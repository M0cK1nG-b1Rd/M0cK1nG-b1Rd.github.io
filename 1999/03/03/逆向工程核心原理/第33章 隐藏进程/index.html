

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="https://picbedddd.oss-cn-beijing.aliyuncs.com/blog/icon/apple-touch-icon.png">
  <link rel="icon" href="https://picbedddd.oss-cn-beijing.aliyuncs.com/blog/icon/favicon.ico">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="何语灵">
  <meta name="keywords" content="">
  
    <meta name="description" content="仅作学习记录，侵删">
<meta property="og:type" content="article">
<meta property="og:title" content="第33章 隐藏进程">
<meta property="og:url" content="https://m0ck1ng-b1rd.github.io/1999/03/03/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC33%E7%AB%A0%20%E9%9A%90%E8%97%8F%E8%BF%9B%E7%A8%8B/index.html">
<meta property="og:site_name" content="M0cK1nG-b1Rd&#39;s site">
<meta property="og:description" content="仅作学习记录，侵删">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC33%E7%AB%A0%20%E9%9A%90%E8%97%8F%E8%BF%9B%E7%A8%8B.assets/image-20220227173930301.png">
<meta property="article:published_time" content="1999-03-03T04:21:06.000Z">
<meta property="article:modified_time" content="2022-05-19T10:47:46.852Z">
<meta property="article:author" content="何语灵">
<meta property="article:tag" content="Binary">
<meta property="article:tag" content="逆向工程核心原理">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC33%E7%AB%A0%20%E9%9A%90%E8%97%8F%E8%BF%9B%E7%A8%8B.assets/image-20220227173930301.png">
  
  
  
  <title>第33章 隐藏进程 - M0cK1nG-b1Rd&#39;s site</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  



  
<link rel="stylesheet" href="//picbedddd.oss-cn-beijing.aliyuncs.com/blog/scripts/scroll.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"m0ck1ng-b1rd.github.io","root":"/","version":"1.9.0","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"https://picbedddd.oss-cn-beijing.aliyuncs.com/blog/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"87rdYWc7BpvmNHtufVgH6hwF-gzGzoHsz","app_key":"FOGIb6hlzKdTWSp4wBpACnWG","server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>

  
<meta name="generator" content="Hexo 6.1.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>M0cK1nG-b1Rd&#39;s site</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('https://picbedddd.oss-cn-beijing.aliyuncs.com/blog/761607.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="第33章 隐藏进程"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="1999-03-03 12:21" pubdate>
          1999年3月3日 中午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          29k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          242 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar category-bar" style="margin-right: -1rem">
    





<div class="category-list">
  
  
    
    
    
    <div class="category row nomargin-x">
      <a class="category-item 
          list-group-item category-item-action col-10 col-md-11 col-xm-11" title="逆向工程核心原理"
        id="heading-3aa8d47104cb3e1c282e0b87fc4ac315" role="tab" data-toggle="collapse" href="#collapse-3aa8d47104cb3e1c282e0b87fc4ac315"
        aria-expanded="true"
      >
        逆向工程核心原理
        <span class="list-group-count">(43)</span>
        <i class="iconfont icon-arrowright"></i>
      </a>
      
      <div class="category-collapse collapse show" id="collapse-3aa8d47104cb3e1c282e0b87fc4ac315"
           role="tabpanel" aria-labelledby="heading-3aa8d47104cb3e1c282e0b87fc4ac315">
        
        
          
  <div class="category-post-list">
    
    
      
      
        <a href="/1999/02/17/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC19%E7%AB%A0%20UPack%E8%B0%83%E8%AF%95%20-%20%E6%9F%A5%E6%89%BEOEP/" title="UPack调试-查找OEP"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">UPack调试-查找OEP</span>
        </a>
      
    
      
      
        <a href="/1999/02/11/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC13%E7%AB%A0%20PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/" title="第13章 PE文件格式"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">第13章 PE文件格式</span>
        </a>
      
    
      
      
        <a href="/1999/02/12/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC14%E7%AB%A0%20%E8%BF%90%E8%A1%8C%E6%97%B6%E5%8E%8B%E7%BC%A9/" title="第14章 运行时压缩"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">第14章 运行时压缩</span>
        </a>
      
    
      
      
        <a href="/1999/02/13/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC15%E7%AB%A0%20%E8%B0%83%E8%AF%95UPX%E5%8E%8B%E7%BC%A9%E7%9A%84notepad%E7%A8%8B%E5%BA%8F/" title="第15章 调试UPX压缩的notepad程序"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">第15章 调试UPX压缩的notepad程序</span>
        </a>
      
    
      
      
        <a href="/1999/02/14/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC16%E7%AB%A0%20%E5%9F%BA%E5%9D%80%E9%87%8D%E5%AE%9A%E4%BD%8D%E8%A1%A8/" title="第16章 基址重定位表"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">第16章 基址重定位表</span>
        </a>
      
    
      
      
        <a href="/1999/02/15/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC17%E7%AB%A0%20%E4%BB%8E%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E4%B8%AD%E5%88%A0%E9%99%A4.reloc%E8%8A%82%E5%8C%BA/" title="第17章 从可执行文件中删除.reloc节区"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">第17章 从可执行文件中删除.reloc节区</span>
        </a>
      
    
      
      
        <a href="/1999/02/16/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC18%E7%AB%A0%20UPack%20PE%E6%96%87%E4%BB%B6%E5%A4%B4%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/" title="第18章 UPack PE文件头详细分析"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">第18章 UPack PE文件头详细分析</span>
        </a>
      
    
      
      
        <a href="/1999/02/18/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC20%E7%AB%A0%20%E2%80%9C%E5%86%85%E5%B5%8C%E8%A1%A5%E4%B8%81%E2%80%9D%E7%BB%83%E4%B9%A0/" title="第20章 “内嵌补丁”练习"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">第20章 “内嵌补丁”练习</span>
        </a>
      
    
      
      
        <a href="/1999/02/20/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC22%E7%AB%A0%20%E6%81%B6%E6%84%8F%E9%94%AE%E7%9B%98%E8%AE%B0%E5%BD%95%E5%99%A8/" title="第22章 恶意键盘记录器"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">第22章 恶意键盘记录器</span>
        </a>
      
    
      
      
        <a href="/1999/02/21/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC23%E7%AB%A0%20DLL%E6%B3%A8%E5%85%A5/" title="第23章 DLL注入"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">第23章 DLL注入</span>
        </a>
      
    
      
      
        <a href="/1999/02/22/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC24%E7%AB%A0%20DLL%E5%8D%B8%E8%BD%BD/" title="第24章 DLL卸载"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">第24章 DLL卸载</span>
        </a>
      
    
      
      
        <a href="/1999/02/23/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC25%E7%AB%A0%20%E9%80%9A%E8%BF%87%E4%BF%AE%E6%94%B9PE%E5%8A%A0%E8%BD%BDDLL/" title="第25章 通过修改PE加载DLL"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">第25章 通过修改PE加载DLL</span>
        </a>
      
    
      
      
        <a href="/1999/02/24/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC26%E7%AB%A0%20PE%20Tools/" title="第26章 PE Tools"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">第26章 PE Tools</span>
        </a>
      
    
      
      
        <a href="/1999/02/25/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC27%E7%AB%A0%20%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/" title="第27章 代码注入"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">第27章 代码注入</span>
        </a>
      
    
      
      
        <a href="/1999/02/26/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC28%E7%AB%A0%20%E4%BD%BF%E7%94%A8%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81/" title="第28章 使用汇编语言编写注入代码"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">第28章 使用汇编语言编写注入代码</span>
        </a>
      
    
      
      
        <a href="/1999/02/27/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC29%E7%AB%A0%20API%E9%92%A9%E5%8F%96%EF%BC%9A%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E4%B9%8B%E2%80%9C%E8%8A%B1%E2%80%9D/" title="第29章 API钩取：逆向分析之“花”"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">第29章 API钩取：逆向分析之“花”</span>
        </a>
      
    
      
      
        <a href="/1999/02/28/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC30%E7%AB%A0%20%E8%AE%B0%E4%BA%8B%E6%9C%ACWriteFile()%20API%E9%92%A9%E5%8F%96/" title="第30章 记事本WriteFile() API钩取"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">第30章 记事本WriteFile() API钩取</span>
        </a>
      
    
      
      
        <a href="/1999/03/01/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC31%E7%AB%A0%20%E5%85%B3%E4%BA%8E%E8%B0%83%E8%AF%95%E5%99%A8/" title="第31章 关于调试器"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">第31章 关于调试器</span>
        </a>
      
    
      
      
        <a href="/1999/03/02/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC32%E7%AB%A0%20%E8%AE%A1%E7%AE%97%E5%99%A8%E6%98%BE%E7%A4%BA%E4%B8%AD%E6%96%87%E6%95%B0%E5%AD%97/" title="第32章 计算器显示中文数字"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">第32章 计算器显示中文数字</span>
        </a>
      
    
      
      
        <a href="/1999/03/03/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC33%E7%AB%A0%20%E9%9A%90%E8%97%8F%E8%BF%9B%E7%A8%8B/" title="第33章 隐藏进程"
           class="list-group-item list-group-item-action
           active">
          <span class="category-post">第33章 隐藏进程</span>
        </a>
      
    
      
      
        <a href="/1999/03/04/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC34%E7%AB%A0%20%E9%AB%98%E7%BA%A7%E5%85%A8%E5%B1%80API%E9%92%A9%E5%8F%96%EF%BC%9AIE%E8%BF%9E%E6%8E%A5%E6%8E%A7%E5%88%B6/" title="第34章 高级全局API钩取：旧连接控制"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">第34章 高级全局API钩取：旧连接控制</span>
        </a>
      
    
      
      
        <a href="/1999/03/05/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC35%E7%AB%A0%20%E4%BC%98%E7%A7%80%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BA%94%E7%A7%8D%E6%A0%87%E5%87%86/" title="第35章 优秀分析工具的五种标准"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">第35章 优秀分析工具的五种标准</span>
        </a>
      
    
      
      
        <a href="/1999/03/06/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC36%E7%AB%A0%2064%E4%BD%8D%E8%AE%A1%E7%AE%97/" title="第36章 64位计算"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">第36章 64位计算</span>
        </a>
      
    
      
      
        <a href="/1999/03/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC37%E7%AB%A0%20x64%E5%A4%84%E7%90%86%E5%99%A8/" title="第37章 x64处理器"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">第37章 x64处理器</span>
        </a>
      
    
      
      
        <a href="/1999/03/08/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC38%E7%AB%A0%20PE32+/" title="第38章 PE32+"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">第38章 PE32+</span>
        </a>
      
    
      
      
        <a href="/1999/03/09/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC39%E7%AB%A0%20WinDbg/" title="第39章 WinDbg"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">第39章 WinDbg</span>
        </a>
      
    
      
      
        <a href="/1999/03/31/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC40%E7%AB%A0%2064%E4%BD%8D%E8%B0%83%E8%AF%95/" title="第40章 64位调试"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">第40章 64位调试</span>
        </a>
      
    
      
      
        <a href="/1999/04/01/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC41%E7%AB%A0%20ASLR/" title="第41章 ASLR"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">第41章 ASLR</span>
        </a>
      
    
      
      
        <a href="/1999/04/02/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC42%E7%AB%A0%20%E5%86%85%E6%A0%B86%E4%B8%AD%E7%9A%84%E4%BC%9A%E8%AF%9D/" title="第42章 内核6中的会话"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">第42章 内核6中的会话</span>
        </a>
      
    
      
      
        <a href="/1999/04/03/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC43%E7%AB%A0%20%E5%86%85%E6%A0%B86%E4%B8%AD%E7%9A%84DLL%E6%B3%A8%E5%85%A5/" title="第43章 内核6中的DLL注入"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">第43章 内核6中的DLL注入</span>
        </a>
      
    
      
      
        <a href="/1999/04/04/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC44%E7%AB%A0%20InjDll.exe%EF%BC%9ADLL%E6%B3%A8%E5%85%A5%E4%B8%93%E7%94%A8%E5%B7%A5%E5%85%B7/" title="第44章 InjDILexe： DLL注入专用工具"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">第44章 InjDILexe： DLL注入专用工具</span>
        </a>
      
    
      
      
        <a href="/1999/04/05/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC45%E7%AB%A0%20TLS%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/" title="第45章 TLS回调函数"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">第45章 TLS回调函数</span>
        </a>
      
    
      
      
        <a href="/1999/04/06/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC46%E7%AB%A0%20TEB/" title="第46章 TEB"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">第46章 TEB</span>
        </a>
      
    
      
      
        <a href="/1999/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC47%E7%AB%A0%20PEB/" title="第47章 PEB"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">第47章 PEB</span>
        </a>
      
    
      
      
        <a href="/1999/04/08/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC48%E7%AB%A0%20SEH/" title="第48章 SEH"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">第48章 SEH</span>
        </a>
      
    
      
      
        <a href="/1999/04/09/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC49%E7%AB%A0%20IA-32%E6%8C%87%E4%BB%A4/" title="第49章 IA-32指令"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">第49章 IA-32指令</span>
        </a>
      
    
      
      
        <a href="/1999/04/30/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC50%E7%AB%A0%20%E5%8F%8D%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF/" title="第50章 反调试技术"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">第50章 反调试技术</span>
        </a>
      
    
      
      
        <a href="/1999/05/01/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC51%E7%AB%A0%20%E9%9D%99%E6%80%81%E5%8F%8D%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF/" title="第51章 静态反调试技术"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">第51章 静态反调试技术</span>
        </a>
      
    
      
      
        <a href="/1999/05/02/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC52%E7%AB%A0%20%E5%8A%A8%E6%80%81%E5%8F%8D%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF/" title="第52章 动态反调试技术"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">第52章 动态反调试技术</span>
        </a>
      
    
      
      
        <a href="/1999/05/03/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC53%E7%AB%A0%20%E9%AB%98%E7%BA%A7%E5%8F%8D%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF/" title="第53章 高级反调试技术"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">第53章 高级反调试技术</span>
        </a>
      
    
      
      
        <a href="/1999/05/04/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC54%E7%AB%A0%20%E8%B0%83%E8%AF%95%E7%BB%83%E4%B9%A01%EF%BC%9A%E6%9C%8D%E5%8A%A1/" title="第54章 调试练习1:服务"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">第54章 调试练习1:服务</span>
        </a>
      
    
      
      
        <a href="/1999/02/19/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC21%E7%AB%A0%20Windows%E6%B6%88%E6%81%AF%E9%92%A9%E5%8F%96/" title="第7章 栈帧"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">第7章 栈帧</span>
        </a>
      
    
      
      
        <a href="/1999/02/10/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC7%E7%AB%A0%20%E6%A0%88%E5%B8%A7/" title="第7章 栈帧"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">第7章 栈帧</span>
        </a>
      
    
  </div>

        
      </div>
    </div>
  
</div>


  </aside>


    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">第33章 隐藏进程</h1>
            
              <p class="note note-info">
                
                  
                    本文最后更新于：2022年5月19日 晚上
                  
                
              </p>
            
            <div class="markdown-body">
              
              <p>第33章隐藏进程<br>本章将讲解通过修改API代码（CodePatch）实现API钩取的技术，还要讲一下有关全局钩取（Global hooking）的内容，它能钩取所有进程。此外，还讲解使用上述方法隐藏（Stealth）特定进程的技术，并通过练习示例帮助大家理解掌握。</p>
<blockquote>
<p>隐藏进程（stealth process）在代码逆向分析领域中的专业术语为Rootkit,它是指 通过修改（hooking）系统内核来隐藏进程、文件、注册表等的一种技术。Rootkit的相关内容不在本章讲解范围内，为便于理解，本书中将统一使用“隐藏进程”这一名称。</p>
</blockquote>
<h1 id="33-1-技术图表"><a href="#33-1-技术图表" class="headerlink" title="33.1 技术图表"></a>33.1 技术图表</h1><p>正式学习前，先看一下图33-1的技术图表。</p>
<p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC33%E7%AB%A0%20%E9%9A%90%E8%97%8F%E8%BF%9B%E7%A8%8B.assets/image-20220227173635529.png" srcset="https://picbedddd.oss-cn-beijing.aliyuncs.com/blog/loading.gif" lazyload alt="图33-1 技术图表"></p>
<p>技术图表标有下划线的部分表示的就是API代码修改技术。库文件被加载到进程内存后，在其目录映像中直接修改要钩取的API代码本身，这就是所谓的API代码修改技术。该技术广泛应用于API钩取，因为可以用它钩取大部分API,使用起来非常灵活。</p>
<p>前面我们讲过IAT钩取技术，如果要钩取的API不在进程的IAT中，那么就无法使用该技术。反之，“API代码修改”技术没有这一限制。</p>
<p>另外，为了灵活使用目标进程的内存空间，我使用了DLL注入技术。</p>
<h1 id="33-2-API代码修改技术的原理"><a href="#33-2-API代码修改技术的原理" class="headerlink" title="33.2 API代码修改技术的原理"></a>33.2 API代码修改技术的原理</h1><p>本节将具体讲解使用API代码修改技术钩取API的工作原理。与前一章学过的IAT钩取技术相比，API代码修改技术更易理解。IAT钩取通过操作进程的特定IAT值来实现API钩取，而API代码修改技术则将API代码的前5个字节修改为JMP XXXXXXXX指令来钩取API。调用执行被钩取的API时，（修改后的）JMP XXXXXXXX指令就会被执行，转而控制hooking函数。后面图33-3描述的是，向 Process Explorer 进程（procexp.exe）注入 stealth.dll 文件后钩取 ntdll.ZwQuerySystemInformation() API的整个过程（ntdll.ZwQuerySystemInformation() API是为了隐藏进程而需要钩取的API）。</p>
<h2 id="33-2-1-钩取之前"><a href="#33-2-1-钩取之前" class="headerlink" title="33.2.1 钩取之前"></a>33.2.1 钩取之前</h2><p>首先看一下钩取之前正常调用API的进程内存。图33-2描述的是（钩取之前）正常调用API的情形。</p>
<p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC33%E7%AB%A0%20%E9%9A%90%E8%97%8F%E8%BF%9B%E7%A8%8B.assets/image-20220227173930301.png" srcset="https://picbedddd.oss-cn-beijing.aliyuncs.com/blog/loading.gif" lazyload alt="图33-2 钩取之前正常调用API"></p>
<p>procexp.exe代码调用ntdll.ZwQuerySystemInformation() API时，程序执行流顺序如下。 </p>
<p>① procexp.exe 的00422CF7地址处的 CALL DWORD PTR DS:[48C69C]指令调用ntdll.ZwQuerySystemlnformation() API （48C69C地址在进程的IAT区域中，其值为7C93D92E，它是ntdll.ZwQuerySystemInformation() API的起始地址）。 </p>
<p>②相应API执行完毕后，返回到调用代码的下一条指令的地址处。</p>
<h2 id="33-2-2-钩取之后"><a href="#33-2-2-钩取之后" class="headerlink" title="33.2.2 钩取之后"></a>33.2.2 钩取之后</h2><p>下面看看钩取指定API后程序执行的过程。先把stealth.dir注入目标进程（procexp.exe）,直接修改ntdll.ZwQuerySystemInformation() API的代码（Code Patch）,如图33-3所示。</p>
<p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC33%E7%AB%A0%20%E9%9A%90%E8%97%8F%E8%BF%9B%E7%A8%8B.assets/image-20220227174100750.png" srcset="https://picbedddd.oss-cn-beijing.aliyuncs.com/blog/loading.gif" lazyload alt="图33-3 钩取之后调用执行API的流程"></p>
<p>图33-3看上去相当复杂，下面逐一分析说明。</p>
<p>首先把stealth.dll注入目标进程，钩取ntdll.ZwQuerySystemInformation() API。ntdll.ZwQuerySystemInformation()API起始地址（7C93D92E）的5个字节代码被修改为JMP 10001120 （仅修改5个字节代码）。10001120是stealth.MyZwQuerySystemInformation()函数的地址。此时，在procexp.exe<br>代码中调用ntdll.ZwQuerySystemInformation()API,程序将按如下顺序执行。 </p>
<p>①在422CF7地址处调用ntdll.ZwQuerySystemlnformation() API （7C93D92E）。 </p>
<p>②位于7C93D92E地址处的（修改后的）JMP 10001120指令将执行流转到10001120地址处（hooking函数）。1000116A地址处的CALL unhook()指令用来将ntdll.ZwQuerySystemInformation() API的起始5个字节恢复原值。 </p>
<p>③位于1000119B地址处的CALL EAX（7C93D92E）指令将调用原来的函数（ntdll.ZwQuerySystemInformation() API）（由于前面已经“脱钩”，所以可以正常调用执行）。 </p>
<p>④ ntdll.ZwQuerySystemInformation()执行完毕后，由7C93D93A地址处的RETN 10指令返回到stealth.dll代码区域（调用自身的位置）。然后10001212地址处的CALL hook()指令再次钩取ntdll.ZwQuerySystemlnformation() API （即将开始的5字节修改为JMP 10001120指令）。 </p>
<p>⑤ stealth.MyZwQuerySystemInformation()函数执行完毕后，由 10001233地址处的RETN 10命 令返回到procexp.exe进程的代码区域，继续执行。</p>
<p>上述过程刚开始看似很难，多看几遍，慢慢就会明白的。</p>
<p>使用API代码修改技术的好处是可以钩取进程中使用的任意API。前面讲过的IAT钩取技术仅适用于可钩取的API,而API代码修改技术无此限制，（虽然代码会更复杂一些）使用起来要自由得多。使用API代码修改技术的唯一限制是，要钩取的API代码长度要大于5个字节，但是由于所有API代码长度都大于5个字节，所以事实上这个限制是不存在的。</p>
<blockquote>
<p>顾名思义，API代码修改就是指直接修改映射到目标进程内存空间的系统DLL的代码。进程的其他线程正在读（read）某个函数时，尝试修改其代码会怎么样呢？这样做会引发非法访问（Access Violation）异常（后面会讲解该问题的解决方法）。</p>
</blockquote>
<p>接下来继续讲解进程隐藏的工作原理。</p>
<h1 id="33-3-进程隐藏"><a href="#33-3-进程隐藏" class="headerlink" title="33.3 进程隐藏"></a>33.3 进程隐藏</h1><p>进程隐藏的相关内容信息已经得到大量公开，其中用户模式下最常用的是ntdll.ZwQuerySystemInformation() API钩取技术，下面对其进行讲解。</p>
<h2 id="33-3-1-进程隐藏工作原理"><a href="#33-3-1-进程隐藏工作原理" class="headerlink" title="33.3.1 进程隐藏工作原理"></a>33.3.1 进程隐藏工作原理</h2><p>隐形战机是为了防止雷达探测追踪而运用各种先进科学技术研制的全新战机（与现有战斗机完全不同）。隐形战斗机的隐形对象就是其本身。®而隐形进程的概念与此恰好相反。为了隐藏某个特定进程，要潜入其他所有进程内存，钩取相关API。也就是说，实现进程隐藏的关键不是进程自身，而是其他进程。仍以战斗机为例子，实现进程隐藏的工作原理大致如下：</p>
<p>普通战斗机起飞升空后，通过某种方法使追踪雷达发生故障（人为操作、破坏）， 这样雷达就无法正常工作，普通战斗机就变为隐形战机。</p>
<p>虽然例子举得有些牵强，但描述的工作原理与隐藏进程是完全一样的。</p>
<h2 id="33-3-2-相关-API"><a href="#33-3-2-相关-API" class="headerlink" title="33.3.2 相关 API"></a>33.3.2 相关 API</h2><p>由于进程是内核对象，所以（用户模式下的程序）只要通过相关API就能检测到它们。用户模式下检测进程的相关API通常分为如下2类（出处：MSDN）。</p>
<ol>
<li>CreateToolhelp32Snapshot() &amp; EnumProcess()</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">HANDLE WINAPI <span class="hljs-title function_">CreateToolhelp32Snapshot</span><span class="hljs-params">(</span><br><span class="hljs-params">    DWORD dwFlags,</span><br><span class="hljs-params">    DWORD th32ProcessID</span><br><span class="hljs-params">)</span>;<br>BOOL <span class="hljs-title function_">EnumProcesses</span><span class="hljs-params">(</span><br><span class="hljs-params">    DWORD* pProcessIds,</span><br><span class="hljs-params">    DWORD cb,</span><br><span class="hljs-params">    DWORD* pBytesReturned</span><br><span class="hljs-params">)</span>;<br></code></pre></td></tr></table></figure>

<p>上面2个API均在其内部调用了ntdll.ZwQuerySystemInformation() API。 </p>
<ol start="2">
<li>ZwQuerySystemlnformation()</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">NTSTATUS WINAPI <span class="hljs-title function_">ZwQuerySystemInformation</span><span class="hljs-params">(</span><br><span class="hljs-params">  _In_      SYSTEM_INFORMATION_CLASS SystemInformationClass,</span><br><span class="hljs-params">  _Inout_   PVOID                    SystemInformation,</span><br><span class="hljs-params">  _In_      ULONG                    SystemInformationLength,</span><br><span class="hljs-params">  _Out_opt_ PULONG                   ReturnLength</span><br><span class="hljs-params">)</span>;<br></code></pre></td></tr></table></figure>



<p>借助ZwQuerySystemInformation() API可以获取运行中的所有进程信息（结构体），形成一个链表（Linkedlist）。操作该链表（从链表中删除）即可隐藏相关进程。所以在用户模式下不需要分别钩取CreateToolhelp32Snapshot()与EnumProcess()，只需钩取ZwQuerySystemInformation() API就可隐藏指定进程。请大家注意，我们要钩取的目标进程不是要隐藏的进程，而是其他进程（操作的不是“飞机”，而是“雷达”）。</p>
<h2 id="33-3-3-隐藏技术的问题"><a href="#33-3-3-隐藏技术的问题" class="headerlink" title="33.3.3 隐藏技术的问题"></a>33.3.3 隐藏技术的问题</h2><p>假如我们要隐藏的进程为test.exe，如果钩取运行中的ProcExp.exe （或者taskmgr.exe）进程的ZwQuerySystemInfoimation()API,那么ProcExp.exe就无法查找到test.exe。</p>
<blockquote>
<p>ProcExp.exe &#x3D;进程查看器<br>taskmgr.exe &#x3D;任务管理器</p>
</blockquote>
<p>使用上述方法后，test.exe就对ProxExp.exe （或者taskmgr.exe）进程隐藏了。但是，这种方法存在以下两个问题。</p>
<p><strong>问题一：要钩取的进程个数</strong></p>
<p>检索进程的实用工具真的只有上面2种吗？不是的，除了上面提到的ProxExp.exe与taskmgr.exe）之外，还有众多其他的进程检索实用工具，甚至包含许多用户自己编写的进程查看工具。要想把某个进程隐藏起来，需要钩取系统中运行的所有进程。</p>
<p><strong>问题二：新创建的进程</strong></p>
<p>如果用户再运行一个ProcExp.exe （或者taskmgr.exe）会怎么样呢？由于第一个ProcExp.exe 进程已经被钩取了，所以它查找不到testexe进程。第二个ProcExp.exe进程由于尚未被钩取，所以仍然能正常查找到test.exe进程。</p>
<p><strong>解决方法：使用全局钩取</strong></p>
<p>为了解决以上2个问题，我们隐藏test.exe进程时需要钩取系统中运行的所有进程的ZwQuerySystemInformation() API，并且对后面将要启动运行的所有进程也做相同的钩取操作（当然操作是自动进行的）。这就是全局钩取的概念。由于需要在整个系统范围内进行钩取操作，所 以才用了 “全局”（Global）这个词。</p>
<blockquote>
<p>全局API钩取相关内容将在本章后半部分与下一章详细讲解。</p>
</blockquote>
<p>下面通过练习示例进一步理解、掌握通过修改API代码的方法钩取API的技术。</p>
<h1 id="33-4-练习-1-（HideProc-exe，stealth-dll）"><a href="#33-4-练习-1-（HideProc-exe，stealth-dll）" class="headerlink" title="33.4 练习 #1 （HideProc.exe，stealth.dll）"></a>33.4 练习 #1 （HideProc.exe，stealth.dll）</h1><p>HideProc.exe负责将stealth.dll文件注入所有运行中的进程。Stealth.dll负责钩取（注入stealth.dll 文件的）进程的ntdll.ZwQuerySystemInformation() API。接下来我们使用上面2个文件隐藏notepad.exe进程。</p>
<blockquote>
<p>上面两个练习文件不能用来解决“全局钩取-新进程”的问题。也就是说，运行HideProc.exe后，新建的进程不会自动钩取，因此这是一种<strong>不完全</strong>隐藏技术。本练习示例在Windows XP SP3 &amp; Windows 7 （32位）环境中通过测试。</p>
</blockquote>
<h2 id="33-4-1-运行-notepad-exe、procexp-exe、taskmgr-exe"><a href="#33-4-1-运行-notepad-exe、procexp-exe、taskmgr-exe" class="headerlink" title="33.4.1 运行 notepad.exe、procexp.exe、taskmgr.exe"></a>33.4.1 运行 notepad.exe、procexp.exe、taskmgr.exe</h2><p>首先分别运行notepad.exe （要隐藏的进程）、procexp.exe （钩取对象1）、taskmgr.exe进程（钩取对象2）。</p>
<h2 id="33-4-2-运行-HideProc-exe"><a href="#33-4-2-运行-HideProc-exe" class="headerlink" title="33.4.2 运行 HideProc.exe"></a>33.4.2 运行 HideProc.exe</h2><p>运行HideProc.exe,将stealth.dll文件注入当前运行的所有进程，如图33-4所示。</p>
<p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC33%E7%AB%A0%20%E9%9A%90%E8%97%8F%E8%BF%9B%E7%A8%8B.assets/image-20220227194252629.png" srcset="https://picbedddd.oss-cn-beijing.aliyuncs.com/blog/loading.gif" lazyload alt="图33-4 运行HideProc.exe （隐藏）"></p>
<blockquote>
<p>后面的参数（dll path） 一定要使用绝对路径</p>
</blockquote>
<p>简要介绍一下HideProc.exe命令的几个参数： </p>
<p>□ -hide&#x2F;-show： -hide用于隐藏，-show用于取消隐藏。 </p>
<p>□ process name:要隐藏的进程名称。 </p>
<p>□ dll path：要注入的DLL文件路径。</p>
<h2 id="33-4-3-确认stealth-dll注入成功"><a href="#33-4-3-确认stealth-dll注入成功" class="headerlink" title="33.4.3 确认stealth.dll注入成功"></a>33.4.3 确认stealth.dll注入成功</h2><p>使用Process Explorer查看所有成功注入stealth.dll文件的进程，如图33-5所示。</p>
<p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC33%E7%AB%A0%20%E9%9A%90%E8%97%8F%E8%BF%9B%E7%A8%8B.assets/image-20220227193210441.png" srcset="https://picbedddd.oss-cn-beijing.aliyuncs.com/blog/loading.gif" lazyload alt="图33-5 向所有运行中的进程注入stealth.dll文件"></p>
<blockquote>
<p>请注意，鉴于系统安全性的考虑，系统进程（PID0&amp;PID4）禁止进行注入操作。</p>
</blockquote>
<h2 id="33-4-4查看notepad-exe进程是否隐藏成功"><a href="#33-4-4查看notepad-exe进程是否隐藏成功" class="headerlink" title="33.4.4查看notepad.exe进程是否隐藏成功"></a>33.4.4查看notepad.exe进程是否隐藏成功</h2><p>在procexp.exe与taskmgr.exe中可以看到，原来存在的notepad.exe进程消失了（参考图33-6、 图33-7）。</p>
<p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC33%E7%AB%A0%20%E9%9A%90%E8%97%8F%E8%BF%9B%E7%A8%8B.assets/image-20220227193303541.png" srcset="https://picbedddd.oss-cn-beijing.aliyuncs.com/blog/loading.gif" lazyload alt="图33-6 procexp.exe中notepad.exe进程消失"></p>
<p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC33%E7%AB%A0%20%E9%9A%90%E8%97%8F%E8%BF%9B%E7%A8%8B.assets/image-20220227193341313.png" srcset="https://picbedddd.oss-cn-beijing.aliyuncs.com/blog/loading.gif" lazyload alt="图33-7 task.exe中notpad.exe进程消失"></p>
<p>虽然notepad.exe进程的确在运行，但procexp.exe与taskmgr.exe中确实看不到notepad.exe进程，如图33-6与图33-7所示。</p>
<blockquote>
<p>由于仍然能看到记事本窗口，所以这种隐藏进程的方法并不算完美。但是请记得，我们的目标只是隐藏线程本身，可以暂时不管程序窗口。</p>
</blockquote>
<h2 id="33-4-5-取消notepad-exe进程隐藏"><a href="#33-4-5-取消notepad-exe进程隐藏" class="headerlink" title="33.4.5 取消notepad.exe进程隐藏"></a>33.4.5 取消notepad.exe进程隐藏</h2><p>以-show模式运行HideProc.exe命令，将stealth.dll文件从所有进程中卸载，如图33-8所示。</p>
<p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC33%E7%AB%A0%20%E9%9A%90%E8%97%8F%E8%BF%9B%E7%A8%8B.assets/image-20220227194443849.png" srcset="https://picbedddd.oss-cn-beijing.aliyuncs.com/blog/loading.gif" lazyload alt="图33-8 运行HideProc.exe （取消隐藏） "></p>
<p>在procexp.exe与taskmgr.exe中查看notepad.exe进程，可以看到它又正常显示。</p>
<blockquote>
<p>这里好像需要重启procexp才能看到正常显示的notepad</p>
</blockquote>
<h1 id="33-5-源代码分析"><a href="#33-5-源代码分析" class="headerlink" title="33.5 源代码分析"></a>33.5 源代码分析</h1><p>下面分析练习示例的源代码，进一步了解通过修改API代码来实现API钩取的技术原理。</p>
<blockquote>
<p>所有源代码均使用VC++2010 Express Edition工具开发而成，并在Widows XP SP3 &amp; Windows 7 （32位）系统环境中通过测试。</p>
</blockquote>
<h2 id="33-5-1-HideProc-cpp"><a href="#33-5-1-HideProc-cpp" class="headerlink" title="33.5.1 HideProc.cpp"></a>33.5.1 HideProc.cpp</h2><p>HideProc.exe程序负责向运行中的所有进程注入&#x2F;卸载指定DLL文件，它在原有InjectDll.exe程序基础上添加了向所有进程注入DLL的功能，可以认为是InjectDll.exe程序的加强版。</p>
<p><strong>lnjectAIIProcess()</strong></p>
<p>InjectAllProcess()是hideproc.exe程序的核心函数，它首先检索运行中的所有进程，然后分别将指定DLL注入各进程或从各进程卸载。下面分析InjectAllProcess()函数，源代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c">BOOL <span class="hljs-title function_">InjectAllProcess</span><span class="hljs-params">(<span class="hljs-type">int</span> nMode, LPCTSTR szDllPath)</span><br>&#123;<br>	DWORD                   dwPID = <span class="hljs-number">0</span>;<br>	HANDLE                  hSnapShot = INVALID_HANDLE_VALUE;<br>	PROCESSENTRY32          pe;<br><br>	<span class="hljs-comment">// 获取系统快照</span><br>	pe.dwSize = <span class="hljs-keyword">sizeof</span>( PROCESSENTRY32 );<br>	hSnapShot = CreateToolhelp32Snapshot( TH32CS_SNAPALL, <span class="hljs-literal">NULL</span> );<br><br>	<span class="hljs-comment">// 查找进程</span><br>	Process32First(hSnapShot, &amp;pe);<br>	<span class="hljs-keyword">do</span><br>	&#123;<br>		dwPID = pe.th32ProcessID;<br><br>        <span class="hljs-comment">// 鉴于系统安全性的考虑，对PID小于100的进程不进行注入操作</span><br>		<span class="hljs-keyword">if</span>( dwPID &lt; <span class="hljs-number">100</span> )<br>			<span class="hljs-keyword">continue</span>;<br><br>        <span class="hljs-keyword">if</span>( nMode == INJECTION_MODE )<br>		    InjectDll(dwPID, szDllPath);<br>        <span class="hljs-keyword">else</span><br>            EjectDll(dwPID, szDllPath);<br>	&#125;<br>	<span class="hljs-keyword">while</span>( Process32Next(hSnapShot, &amp;pe) );<br><br>	CloseHandle(hSnapShot);<br><br>	<span class="hljs-keyword">return</span> TRUE;<br>&#125;<br></code></pre></td></tr></table></figure>



<p>首先使用CreateToolhelp32Snapshot() API获取系统中运行的所有进程的列表，然后使用Process32First()与Process32Next() API将获得的进程信息存放到PROCESSENTRY32结构体变量pe中，进而获取进程的PID。</p>
<p>以下是CreateToolhelp32Snapshot()、Process32First()、Process32Next() API的函数定义（出处：MSDN）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c">HANDLE <span class="hljs-title function_">CreateToolhelp32Snapshot</span><span class="hljs-params">(</span><br><span class="hljs-params">  [in] DWORD dwFlags,</span><br><span class="hljs-params">  [in] DWORD th32ProcessID</span><br><span class="hljs-params">)</span>;<br><br>BOOL <span class="hljs-title function_">Process32First</span><span class="hljs-params">(</span><br><span class="hljs-params">  [in]      HANDLE           hSnapshot,</span><br><span class="hljs-params">  [in, out] LPPROCESSENTRY32 lppe</span><br><span class="hljs-params">)</span>;<br><br>BOOL <span class="hljs-title function_">Process32Next</span><span class="hljs-params">(</span><br><span class="hljs-params">  [in]  HANDLE           hSnapshot,</span><br><span class="hljs-params">  [out] LPPROCESSENTRY32 lppe</span><br><span class="hljs-params">)</span>;<br></code></pre></td></tr></table></figure>



<blockquote>
<p>请注意，只有先提升HideProc.exe进程的权限（特权），才能准确获取所有进程的列表。在 HideProc.cpp 中，main()函数中调用了 SetPrivilege()函数，而 SetPrivilege()函数内部又调用了 AdjustTokenPrivileges() API 为 HideProc.exe 提升权限。</p>
</blockquote>
<p>获取了进程的PID后，要根据所用的命令选项（-show&#x2F;-hide）来选择调用InjectDllO函数还是EjectDll()函数。还需要注意的一点是，某进程的PID小于100时，则忽略它，不进行操作。原因在于，系统进程的PID （PID&#x3D;0, 4,8,…） —般都小于100, 为保证系统安全性，不会对这些进程注入DLL文件（这些PID值来自对Windows XP&#x2F;Vista&#x2F;7 OS的分析使用经验，其他Windows版本中，系统进程的PID值可能不同）。</p>
<h2 id="33-5-2-stealth-cpp"><a href="#33-5-2-stealth-cpp" class="headerlink" title="33.5.2 stealth.cpp"></a>33.5.2 stealth.cpp</h2><p>实际的API钩取操作由Stealth.dll文件负责，下面分析其源代码（Stealth.cpp）。</p>
<p><strong>SetProcName()</strong></p>
<p>首先看导出函数SepProcName()。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// global variable (in sharing memory)</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(linker, <span class="hljs-string">&quot;/SECTION:.SHARE,RWS&quot;</span>)</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> data_seg(<span class="hljs-string">&quot;.SHARE&quot;</span>)</span><br>    TCHAR g_szProcName[MAX_PATH] = &#123;<span class="hljs-number">0</span>,&#125;;<br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> data_seg()</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __cplusplus</span><br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>__declspec(dllexport) <span class="hljs-type">void</span> <span class="hljs-title function_">SetProcName</span><span class="hljs-params">(LPCTSTR szProcName)</span><br>&#123;<br>    _tcscpy_s(g_szProcName, szProcName);<br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __cplusplus</span><br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure>


<p>以上代码先创建名为“.SHARE”的共享内存节区，然后创缓冲区，最后再由导出函数SetProcName()将要隐藏的进程名称保存到（SetProcName()函数在HideProc.exe中被调用执行）。</p>
<blockquote>
<p>在共享内存节区创建g_szProcName缓冲区的好处在于，stealth.dll被注入所有进程时，可以彼此共享隐藏进程的名称（随着程序不断改进，甚至也可以做到动态修改隐藏进程）。</p>
</blockquote>
<p><strong>DIIMain()</strong></p>
<p>下面看DllMain()函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c">BOOL WINAPI <span class="hljs-title function_">DllMain</span><span class="hljs-params">(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)</span><br>&#123;<br>    <span class="hljs-type">char</span>            szCurProc[MAX_PATH] = &#123;<span class="hljs-number">0</span>,&#125;;<br>    <span class="hljs-type">char</span>            *p = <span class="hljs-literal">NULL</span>;<br><br>    <span class="hljs-comment">// #1. 异常处理</span><br>    <span class="hljs-comment">// 若当前进程为HideProc.exe，则终止，不进行钩取操作。</span><br>    GetModuleFileNameA(<span class="hljs-literal">NULL</span>, szCurProc, MAX_PATH);<br>    p = <span class="hljs-built_in">strrchr</span>(szCurProc, <span class="hljs-string">&#x27;\\&#x27;</span>);<br>    <span class="hljs-keyword">if</span>( (p != <span class="hljs-literal">NULL</span>) &amp;&amp; !_stricmp(p+<span class="hljs-number">1</span>, <span class="hljs-string">&quot;HideProc.exe&quot;</span>) )<br>        <span class="hljs-keyword">return</span> TRUE;<br><br>    <span class="hljs-keyword">switch</span>( fdwReason )<br>    &#123;<br>        <span class="hljs-comment">// #2. API Hooking</span><br>        <span class="hljs-keyword">case</span> DLL_PROCESS_ATTACH : <br>        hook_by_code(DEF_NTDLL, DEF_ZWQUERYSYSTEMINFORMATION, <br>                     (PROC)NewZwQuerySystemInformation, g_pOrgBytes);<br>        <span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-comment">// #3. API Unhooking </span><br>        <span class="hljs-keyword">case</span> DLL_PROCESS_DETACH :<br>        unhook_by_code(DEF_NTDLL, DEF_ZWQUERYSYSTEMINFORMATION, <br>                       g_pOrgBytes);<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> TRUE;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如上所见，DllMain()函数的代码非常简单。首先比较字符串，若进程名为“HideProc.exe”，则进行异常处理，不钩取API。发生DLL_PROCESS_ATTACH事件时，调用hook_by_code()函数钩取API；发生DLL_PROCESS_DETACH事件时，调用unhook_by_code()函数取消API钩取。</p>
<p>hook_ by_code()<br>该hook_by_code()函数通过修改代码实现API钩取操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c">BOOL <span class="hljs-title function_">hook_by_code</span><span class="hljs-params">(LPCSTR szDllName, LPCSTR szFuncName, PROC pfnNew, PBYTE pOrgBytes)</span><br>&#123;<br>    FARPROC pfnOrg;<br>    DWORD dwOldProtect, dwAddress;<br>    BYTE pBuf[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">0xE9</span>, <span class="hljs-number">0</span>, &#125;;<br>    PBYTE pByte;<br><br>    <span class="hljs-comment">// 获取要钩取的API地址</span><br>    pfnOrg = (FARPROC)GetProcAddress(GetModuleHandleA(szDllName), szFuncName);<br>    pByte = (PBYTE)pfnOrg;<br><br>    <span class="hljs-comment">// 若已经被钩取，返回FALSE</span><br>    <span class="hljs-keyword">if</span>( pByte[<span class="hljs-number">0</span>] == <span class="hljs-number">0xE9</span> )<br>        <span class="hljs-keyword">return</span> FALSE;<br><br>    <span class="hljs-comment">// 为了修改5个字节，先向内存添加“写”属性</span><br>    VirtualProtect((LPVOID)pfnOrg, <span class="hljs-number">5</span>, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);<br><br>    <span class="hljs-comment">// 备份原有代码（5字节） </span><br>    <span class="hljs-built_in">memcpy</span>(pOrgBytes, pfnOrg, <span class="hljs-number">5</span>);<br><br>    <span class="hljs-comment">// 计算JMP地址（E9 XXXXXXXX）</span><br>    <span class="hljs-comment">// =&gt; XXXX = pfnNew - pfnOrg - 5</span><br>    dwAddress = (DWORD)pfnNew - (DWORD)pfnOrg - <span class="hljs-number">5</span>;<br>    <span class="hljs-built_in">memcpy</span>(&amp;pBuf[<span class="hljs-number">1</span>], &amp;dwAddress, <span class="hljs-number">4</span>);<br><br>    <span class="hljs-comment">// “钩子”：修改5个字节（JMP XXXXXXXX）</span><br>    <span class="hljs-built_in">memcpy</span>(pfnOrg, pBuf, <span class="hljs-number">5</span>);<br><br>    <span class="hljs-comment">// 恢复内存属性</span><br>    VirtualProtect((LPVOID)pfnOrg, <span class="hljs-number">5</span>, dwOldProtect, &amp;dwOldProtect);<br>    <br>    <span class="hljs-keyword">return</span> TRUE;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>hook_by_code()函数参数介绍如下：</p>
<p>LPCTSTR szDllName： [IN]包含要钩取的API的DLL文件名称。<br>LPCTSTR szFuncName： [IN]要钩取的API名称。<br>PROC pfnNew： [IN]用户提供的钩取函数地址。<br>PBYTE pOrgBytes： [OUT]存储原来5个字节的缓冲区-后面“脱钩”时使用。</p>
<p>正如在工作原理中提到的一样，hook_by_code()函数用于将原来API代码的前5个字节更改为“JMP XXXXXXXX”指令。函数源代码比较简单，结合代码注释很容易理解，中间跳转地址的换算部分是代码逆向分析中相当重要的内容，下面仔细看看。根据Intel x86 （IA-32）指令格式，JMP指令对应的操作码为E9，后面跟着4个字节的地址。<br>也就是说，JMP指令的Instruction实际形式为“E9 XXXXXXXX”。需要注意的是，XXXXXXXX 地址值不是要跳转的绝对地址值，而是从当前JMP命令到跳转位置的相对距离。通过下述关系式可求得XXXXXXXX地址值。</p>
<p>XXXXXXXX&#x3D;要跳转的地址-当前指令地址-当前指令长度（5）</p>
<p>最后又减去5个字节是因为JMP指令本身长度就是5个字节。例如，当前JMP指令的地址为402000,若想跳转到401000地址处，写成“E9 00104000” 是不对的，XXXXXXXX地址值要使用上面的等式换算才行。</p>
<p>XXXXXXXX&#x3D;401000-402000-5&#x3D;FFFFEFFB</p>
<p>所以JMP指令的Instruction应为“E9FFFFEFFB”，通过OllyDbg的汇编或编辑功能可以确认这一点，如图33-9所示。</p>
<p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC33%E7%AB%A0%20%E9%9A%90%E8%97%8F%E8%BF%9B%E7%A8%8B.assets/image-20220304125656518.png" srcset="https://picbedddd.oss-cn-beijing.aliyuncs.com/blog/loading.gif" lazyload alt="图33-9 OllyDbg的汇编功能"></p>
<blockquote>
<p>除了 JMP指令外，还有一种short JMP命令，顾名思义，它是用来进行短距离跳转的指令，对应的IA-32指令为“EBXX”（指令长度为2字节）。希望各位在OllyDbg 中自己测试一下EB指令</p>
</blockquote>
<p>像上面这样每次使用JMP指令都要计算相对地址，显得不太方便。当然，也可以 使用其他指令直接用绝对地址跳转，但是这样的指令长度往往较为复杂。 </p>
<blockquote>
<p>例（1） PUSH+RET<br>68 00104000	  PUSH 00401000<br>C3						RETN<br>例（2） MOV+JMP<br>B8 00104000 	MOV EAX, 00401000<br>FFE0 					JMP EAX</p>
</blockquote>
<blockquote>
<p>计算32位地址时，使用Windows的计算器显得有些不方便。推荐大家试试32位 的Calculator v1.7 by cybult,它是一款实用性超强的计算器。</p>
</blockquote>
<blockquote>
<p>关于解析Op代码映射的方法请参考第49章。</p>
</blockquote>
<p>实际的ZwQuerySystemInformation() API钩取操作由hook_by_code()函数完成，下面使用OllyDbg对ZwQuerySystemInformation() API钩取前&#x2F;后进行调试，进一步了解钩取技术原理（相应进程为procexp.exe）。</p>
<p><strong>钩取之前</strong><br>首先看看钩取前的ZwQuerySystemInformation() API代码。ZwQuerySystemInformation()的地址为77F06238，指令代码如图33-10所示。</p>
<p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC33%E7%AB%A0%20%E9%9A%90%E8%97%8F%E8%BF%9B%E7%A8%8B.assets/image-20220305194553363.png" srcset="https://picbedddd.oss-cn-beijing.aliyuncs.com/blog/loading.gif" lazyload alt="图33-10 钩取前的ZwQuerySystemInfomiation()代码"></p>
<p><strong>钩取之后</strong></p>
<p>注入stealth.dll文件，由hook_by_code()函数钩取API后，代码如图33-11所示。</p>
<p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC33%E7%AB%A0%20%E9%9A%90%E8%97%8F%E8%BF%9B%E7%A8%8B.assets/image-20220305194734571.png" srcset="https://picbedddd.oss-cn-beijing.aliyuncs.com/blog/loading.gif" lazyload alt="图33-11 钩取后的ZwQuerySystemInformation()代码"></p>
<p>ZwQuerySystemInformation()函数起始代码做了如下更改（前5个字节）：</p>
<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-number">77</span>F06238	E9 C3AE698B     <span class="hljs-keyword">jmp</span> stealth.NewZwQuerySystemInformation<br></code></pre></td></tr></table></figure>

<p>地址 35A1100就是钩取数stealth.NewZwQuerySystemInformation()的地址。并且E9后面的4个 字节（8B69AEC3）就是使用前面的公式计算得到的（希望各位自己算一算）。</p>
<blockquote>
<p>示例环境中，Stealth.dll加载到ProcExp.exe进程的350000地址。</p>
</blockquote>
<p><strong>unhook_by_code()</strong><br>unhook_by_code()函数是用来取消钩取的函数，如代码33-5所示。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c">BOOL <span class="hljs-title function_">unhook_by_code</span><span class="hljs-params">(LPCSTR szDllName, LPCSTR szFuncName, PBYTE pOrgBytes)</span><br>&#123;<br>    FARPROC pFunc;<br>    DWORD dwOldProtect;<br>    PBYTE pByte;<br><br>    <span class="hljs-comment">// 获取API地址</span><br>    pFunc = GetProcAddress(GetModuleHandleA(szDllName), szFuncName);<br>    pByte = (PBYTE)pFunc;<br><br>    <span class="hljs-comment">// 若已经“脱钩”，則返回FALSE</span><br>    <span class="hljs-keyword">if</span>( pByte[<span class="hljs-number">0</span>] != <span class="hljs-number">0xE9</span> )<br>        <span class="hljs-keyword">return</span> FALSE;<br><br>    <span class="hljs-comment">// 向内存添加”写”属性，为恢复原代码（5个字节）准备</span><br>    VirtualProtect((LPVOID)pFunc, <span class="hljs-number">5</span>, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);<br><br>    <span class="hljs-comment">// Unhook</span><br>    <span class="hljs-built_in">memcpy</span>(pFunc, pOrgBytes, <span class="hljs-number">5</span>);<br><br>    <span class="hljs-comment">// 恢复内存属性</span><br>    VirtualProtect((LPVOID)pFunc, <span class="hljs-number">5</span>, dwOldProtect, &amp;dwOldProtect);<br><br>    <span class="hljs-keyword">return</span> TRUE;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>其实，“脱钩”的工作原理非常简单，就是将函数代码开始的前5个字节恢复原值（代码很简单，请参考注释理解）。</p>
<p><strong>NewZwQuerySystemlnformation()</strong></p>
<p>最后，分析钩取函数NewZwQuerySystemInformation()。在此之前，先看看ntdll.ZwQuerySysteminformation() API。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c">NTSTATUS WINAPI <span class="hljs-title function_">ZwQuerySystemInformation</span><span class="hljs-params">(</span><br><span class="hljs-params">  _In_      SYSTEM_INFORMATION_CLASS SystemInformationClass,</span><br><span class="hljs-params">  _Inout_   PVOID                    SystemInformation,</span><br><span class="hljs-params">  _In_      ULONG                    SystemInformationLength,</span><br><span class="hljs-params">  _Out_opt_ PULONG                   ReturnLength</span><br><span class="hljs-params">)</span>;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">SYSTEM_PROCESS_INFORMATION</span> &#123;</span><br>    ULONG NextEntryOffset;<br>    ULONG NumberOfThreads;<br>    BYTE Reserved1[<span class="hljs-number">48</span>];<br>    UNICODE_STRING ImageName;<br>    KPRIORITY BasePriority;<br>    HANDLE UniqueProcessId;<br>    PVOID Reserved2;<br>    ULONG HandleCount;<br>    ULONG SessionId;<br>    PVOID Reserved3;<br>    SIZE_T PeakVirtualSize;<br>    SIZE_T VirtualSize;<br>    ULONG Reserved4;<br>    SIZE_T PeakWorkingSetSize;<br>    SIZE_T WorkingSetSize;<br>    PVOID Reserved5;<br>    SIZE_T QuotaPagedPoolUsage;<br>    PVOID Reserved6;<br>    SIZE_T QuotaNonPagedPoolUsage;<br>    SIZE_T PagefileUsage;<br>    SIZE_T PeakPagefileUsage;<br>    SIZE_T PrivatePageCount;<br>    LARGE_INTEGER Reserved7[<span class="hljs-number">6</span>];<br>&#125; SYSTEM_PROCESS_INFORMATION;<br></code></pre></td></tr></table></figure>

<p>简单讲解：将 SystemlnformationClass 参数设置为 SystemProcessInformation（即5）后调用<br>ZwQuerySystemInformation() API，Systemlnformation [in&#x2F;out]参数中存储的是SYSTEM_PROCESS_INFORMATION结构体单向链表（single linked list）的起始地址。该结构体链表中存储着运行中的所有进程的信息。所以，隐藏某进程前，先要查找与之对应的链表成员，然后断开其与链表的链接。接下来看看NewZwQuerySystemInformation()函数的代码，了解具体实现方式。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs c">NTSTATUS WINAPI <span class="hljs-title function_">NewZwQuerySystemInformation</span><span class="hljs-params">(</span><br><span class="hljs-params">                SYSTEM_INFORMATION_CLASS SystemInformationClass, </span><br><span class="hljs-params">                PVOID SystemInformation, </span><br><span class="hljs-params">                ULONG SystemInformationLength, </span><br><span class="hljs-params">                PULONG ReturnLength)</span><br>&#123;<br>    NTSTATUS status;<br>    FARPROC pFunc;<br>    PSYSTEM_PROCESS_INFORMATION pCur, pPrev;<br>    <span class="hljs-type">char</span> szProcName[MAX_PATH] = &#123;<span class="hljs-number">0</span>,&#125;;<br>    <br>    <span class="hljs-comment">// 开始前先“脱钩”</span><br>    unhook_by_code(DEF_NTDLL, DEF_ZWQUERYSYSTEMINFORMATION, g_pOrgBytes);<br><br>    <span class="hljs-comment">// 调用原始API</span><br>    pFunc = GetProcAddress(GetModuleHandleA(DEF_NTDLL), <br>                           DEF_ZWQUERYSYSTEMINFORMATION);<br>    status = ((PFZWQUERYSYSTEMINFORMATION)pFunc)<br>              (SystemInformationClass, SystemInformation, <br>              SystemInformationLength, ReturnLength);<br><br>    <span class="hljs-keyword">if</span>( status != STATUS_SUCCESS )<br>        <span class="hljs-keyword">goto</span> __NTQUERYSYSTEMINFORMATION_END;<br><br>    <span class="hljs-comment">// 仅针对SystemProcessInformation操作</span><br>    <span class="hljs-keyword">if</span>( SystemInformationClass == SystemProcessInformation )<br>    &#123;<br>        <span class="hljs-comment">// SYSTEM_PROCESS_INFORMATION 类型转换</span><br>        <span class="hljs-comment">// pCur是单向链表的头</span><br>        pCur = (PSYSTEM_PROCESS_INFORMATION)SystemInformation;<br><br>        <span class="hljs-keyword">while</span>(TRUE)<br>        &#123;<br>            <span class="hljs-comment">// 比较进程名称</span><br>            <span class="hljs-comment">// g_szProcName 为要隐藏的进程名称</span><br>            <span class="hljs-comment">// (=&gt; 在SetProcName()设置)</span><br>            <span class="hljs-keyword">if</span>(pCur-&gt;Reserved2[<span class="hljs-number">1</span>] != <span class="hljs-literal">NULL</span>)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(!_tcsicmp((PWSTR)pCur-&gt;Reserved2[<span class="hljs-number">1</span>], g_szProcName))<br>                &#123;<br>                    <span class="hljs-comment">// 从链表中删除隐藏进程的点</span><br>                    <span class="hljs-keyword">if</span>(pCur-&gt;NextEntryOffset == <span class="hljs-number">0</span>)<br>                        pPrev-&gt;NextEntryOffset = <span class="hljs-number">0</span>;<br>                    <span class="hljs-keyword">else</span><br>                        pPrev-&gt;NextEntryOffset += pCur-&gt;NextEntryOffset;<br>                &#125;<br>                <span class="hljs-keyword">else</span>		<br>                    pPrev = pCur;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span>(pCur-&gt;NextEntryOffset == <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">break</span>;<br><br>            <span class="hljs-comment">// 链表的下一项</span><br>            pCur = (PSYSTEM_PROCESS_INFORMATION)<br>                    ((ULONG)pCur + pCur-&gt;NextEntryOffset);<br>        &#125;<br>    &#125;<br><br>__NTQUERYSYSTEMINFORMATION_END:<br><br>    <span class="hljs-comment">// 函数终止前，再次执行API钩取操作，为下次调用做准备</span><br>    hook_by_code(DEF_NTDLL, DEF_ZWQUERYSYSTEMINFORMATION, <br>                 (PROC)NewZwQuerySystemInformation, g_pOrgBytes);<br><br>    <span class="hljs-keyword">return</span> status;<br>&#125;<br><br></code></pre></td></tr></table></figure>



<p>对NewZwQuerySystemInformation()函数的结构简要说明如下： </p>
<p>□ “脱钩” ZwQuerySystemInformation()函数； </p>
<p>□调用 ZwQuerySystemInformation()； </p>
<p>□检查SYSTEM_PROCESS_INFORMATION结构体链表，查找要隐藏的进程； </p>
<p>□查找到要隐藏的进程后，从链表中移除； </p>
<p>□挂钩（hook） ZwQuerySystemInformation()。</p>
<p>NewZwQuerySystemInformation()函数代码的中间部分有一个while()语句，它用来检PROCESS_INFORMATION结构体链表，比较进程名称（pCur-&gt;Reserved2[1]）（进程名称为Unicode字符串）。如果掌握了函数的工作原理，再结合代码注释，相信大家在理解上应该没什么困难。</p>
<h1 id="33-6-全局API钩取"><a href="#33-6-全局API钩取" class="headerlink" title="33.6 全局API钩取"></a>33.6 全局API钩取</h1><p>本节正式开始讲解全局API钩取的概念及具体实现方法。全局API钩取实质也是一种API钩取技术，它针对的进程为：①当前运行的所有进程；②将来要运行的所有进程。</p>
<p>请注意，前面讲解过的示例程序（HidePmc.exe、stealth.dll）并不是全局API钩取的例子，因为它并不满足全局API钩取定义中的第②个条件。也就是说，虽然运行HideProc.exe将notepad.exe 进程隐藏起来，但是若重新运行新的Process Exploer （或者task manager）, notepad.exe进程在它们之中仍然可见。原因在于，运行HideProc.exe后未对新创建的进程（自动）注入stealth.dll文件。有多种方法可以解决这一问题，全局API钩取就是其中一种，下面讲解该技术的具体实现方法。</p>
<h2 id="33-6-1-Kernel32-CreateProcess-API"><a href="#33-6-1-Kernel32-CreateProcess-API" class="headerlink" title="33.6.1 Kernel32.CreateProcess() API"></a>33.6.1 Kernel32.CreateProcess() API</h2><p>Kernel32.CreateProcess() API用来创建新进程。其他启动运行进程的API （WinExec()、ShellExecute()、system()）在其内部调用的也是该CreateProcess()函数（出处：MSDN）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c">BOOL <span class="hljs-title function_">CreateProcess</span><span class="hljs-params">(</span><br><span class="hljs-params">  [in, optional]      LPCSTR                lpApplicationName,</span><br><span class="hljs-params">  [in, out, optional] LPSTR                 lpCommandLine,</span><br><span class="hljs-params">  [in, optional]      LPSECURITY_ATTRIBUTES lpProcessAttributes,</span><br><span class="hljs-params">  [in, optional]      LPSECURITY_ATTRIBUTES lpThreadAttributes,</span><br><span class="hljs-params">  [in]                BOOL                  bInheritHandles,</span><br><span class="hljs-params">  [in]                DWORD                 dwCreationFlags,</span><br><span class="hljs-params">  [in, optional]      LPVOID                lpEnvironment,</span><br><span class="hljs-params">  [in, optional]      LPCSTR                lpCurrentDirectory,</span><br><span class="hljs-params">  [in]                LPSTARTUPINFOA        lpStartupInfo,</span><br><span class="hljs-params">  [out]               LPPROCESS_INFORMATION lpProcessInformation</span><br><span class="hljs-params">)</span>;<br></code></pre></td></tr></table></figure>



<p>因此，向当前运行的所有进程注入stealth.dll后，如果在stealth.dll中将CreateProcess() API他一起钩取，那么以后运行的进程也会自动注入stealth.dll文件。进一步说明如下：由于所有进程都是由父进程（使用CreateProcess()）创建的，所以，钩取父进程的CreateProcess() API就可以将stealth.dll文件注入所有子进程（父进程通常都是explorer.exe）。怎么样？这个想法不错吧？全局API钩取的 实现方法没有想得那么难，但钩CreateProcess() API时，要充分考虑以下几个方面。</p>
<p>（1） 钩取CreateProcess() API时，还要分别钩取kernel32.CreateProcessA()、kernel32.CreateProcessW()<br>这2个API （ASCII版本与Unicode版本）。 </p>
<p>（2） CreateProcessA()、CreateProcessW()函数内部又分别调用了CreateProcessInternalA()、<br>CreateProcessInternelW()函数。常规编程中会大量使用CreateProcess()函数，但是微软的部分软件<br>产品中会直接调用CreateProcessInternelA&#x2F;W这2个函数。所以具体实现全局API钩取时，为了准确<br>起见，还要同时钩取上面2个函数（若可能，尽量钩取低级API）。</p>
<p> （3） 钩取函数（NewCreateProcess）要钩取调用原函数（CreateProcess）而创建的子进程的API。<br>因此，极短时间内，子进程可能在未钩取的状态下运行。</p>
<p>我们进行全局API钩取时必须解决上面这些问题。幸运的是，很多代码逆向分析高手通过努力发现了比kernel32.CreateProcess()更低级的API,钩取它效果会更好（能够一次性解决上面所有问题）。这个API就是ntdll.ZwResumeThread() API。</p>
<h2 id="33-6-2-Ntdll-ZwResumeThread-API"><a href="#33-6-2-Ntdll-ZwResumeThread-API" class="headerlink" title="33.6.2 Ntdll.ZwResumeThread() API"></a>33.6.2 Ntdll.ZwResumeThread() API</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">ZwResumeThread(<br>    IN	HANDLE	ThreadHandle,<br>    OUT	PULONG	SuspendCount OPTIONAL<br>); <br></code></pre></td></tr></table></figure>

<blockquote>
<p>用户模式下，NtXXX系列与ZwXXX系列仅是名称不同，它们其实是相同的API。</p>
</blockquote>
<p>ZwResumeThread()函数（出处：MSDN）在进程创建后、主线程运行前被调用执行（在CreateProcess()API内部调用执行）。所以只要钩取这个函数，即可在不运行子进程代码的状态下钩取API。但需要注意的是，ZwResumeThread()是一个尚未公开的API，将来的某个时候可能会被改变，这就无法保障安全性。所以，钩取类似ZwResumeThread()的尚未公开API时，要时刻记得，随着OS补丁升级，该API可能更改，这可能使在低版本中正常运行的钩取操作到了新版本中突然无法正常运行。</p>
<h1 id="33-7-练习-2-（HideProc2-exe-Stealth2-dll）"><a href="#33-7-练习-2-（HideProc2-exe-Stealth2-dll）" class="headerlink" title="33.7 练习#2 （HideProc2.exe,Stealth2.dll）"></a>33.7 练习#2 （HideProc2.exe,Stealth2.dll）</h1><blockquote>
<p>stealth2.dll 用来钩取 CreateProcess,钩取 ZwResumeThread 请参考第34章。本练习示例在Windows XP SP3 &amp; Windows 7 （32位）环境下通过测试。</p>
</blockquote>
<p>请注意，为操作简单，本练习中我们将只隐藏notepad.exe。</p>
<h2 id="33-7-1-复制-stealth2-dll-文件到-SYSTEM-文件夹中"><a href="#33-7-1-复制-stealth2-dll-文件到-SYSTEM-文件夹中" class="headerlink" title="33.7.1 复制 stealth2.dll 文件到%SYSTEM%文件夹中"></a>33.7.1 复制 stealth2.dll 文件到%SYSTEM%文件夹中</h2><p>为了把stealth2.dll文件注入所有运行进程，首先要把stealth2.dll文件复制到%SYSTEM%文件夹，所有进程都能识别该路径，如图33-12所示。</p>
<p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC33%E7%AB%A0%20%E9%9A%90%E8%97%8F%E8%BF%9B%E7%A8%8B.assets/image-20220305203320883.png" srcset="https://picbedddd.oss-cn-beijing.aliyuncs.com/blog/loading.gif" lazyload alt="图33-12 复制stealth2.dll"></p>
<h2 id="33-7-2-运行-HideProc2-exe-hide"><a href="#33-7-2-运行-HideProc2-exe-hide" class="headerlink" title="33.7.2 运行 HideProc2.exe -hide"></a>33.7.2 运行 HideProc2.exe -hide</h2><p>与以前的HideProc.exe相比，HideProc2.exe只是运行参数发生了改变。由于要隐藏的进程名<br>称被硬编码为notepad.exe，所以运行隐藏程序时不需要再输入。使用-hide选项运行HideProc2.exe<br>后，全局API钩取就开始了（请各位使用Process Explorer查看c:\windows\system32\stealth2.dll文件<br>是否正常注入运行进程），如图33-13所示。</p>
<p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC33%E7%AB%A0%20%E9%9A%90%E8%97%8F%E8%BF%9B%E7%A8%8B.assets/image-20220305203755162.png" srcset="https://picbedddd.oss-cn-beijing.aliyuncs.com/blog/loading.gif" lazyload alt="图33-13 运行HideProc2.exe（隐藏）"></p>
<h2 id="33-7-3-运行-ProcExp-exe-amp-notepad-exe"><a href="#33-7-3-运行-ProcExp-exe-amp-notepad-exe" class="headerlink" title="33.7.3 运行 ProcExp.exe&amp;notepad.exe"></a>33.7.3 运行 ProcExp.exe&amp;notepad.exe</h2><p>请运行多个Process Explorer （或者任务管理器）与notepad程序，如图33-14所示。</p>
<p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC33%E7%AB%A0%20%E9%9A%90%E8%97%8F%E8%BF%9B%E7%A8%8B.assets/image-20220305203914136.png" srcset="https://picbedddd.oss-cn-beijing.aliyuncs.com/blog/loading.gif" lazyload alt="图33-14 Process Explorer 与 notepad"></p>
<p>从图33-14中可以看到，分别运行了2个ProcExp.exe与notepad.exe进程。但是ProcExp.exe中却看不到notepad.exe进程，它被隐藏起来了。大家可以尝试多运行几个ProcExp.exe，最终结果都是一样的，新创建的ProcExp.exe进程中，notepad.exe进程都被隐藏起来、都是不可见的。这就是全局API钩取要实现的效果。</p>
<h2 id="33-7-4-运行-HideProc2-exe-show"><a href="#33-7-4-运行-HideProc2-exe-show" class="headerlink" title="33.7.4 运行 HideProc2.exe -show"></a>33.7.4 运行 HideProc2.exe -show</h2><p>运行HideProc2.exe-show命令，撤销全局API钩取操作，如图33-15所示。</p>
<p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC33%E7%AB%A0%20%E9%9A%90%E8%97%8F%E8%BF%9B%E7%A8%8B.assets/image-20220305204036369.png" srcset="https://picbedddd.oss-cn-beijing.aliyuncs.com/blog/loading.gif" lazyload alt="图33-15 运行HideProc2.exe（撤销隐藏）"></p>
<p>现在Process Explorer （或者任务管理器）中又能看到notepad.exe进程了。</p>
<h1 id="33-8-源代码分析"><a href="#33-8-源代码分析" class="headerlink" title="33.8 源代码分析"></a>33.8 源代码分析</h1><h2 id="33-8-1-HideProc2-cpp"><a href="#33-8-1-HideProc2-cpp" class="headerlink" title="33.8.1 HideProc2.cpp"></a>33.8.1 HideProc2.cpp</h2><p>与前面的HideProc.cpp相比，HideProc2.cpp只是减少了运行参数的个数，相关讲解请参考前面的内容。</p>
<h2 id="33-8-2-stealth2-cpp"><a href="#33-8-2-stealth2-cpp" class="headerlink" title="33.8.2 stealth2.cpp"></a>33.8.2 stealth2.cpp</h2><p>与前面的stealth.cpp相比，stealth2.cpp的不同之处在于将要隐藏的进程名称硬编码为notepad.exe，并且添加了钩取CreateProcessA()API与CreateProcessW() API的代码，以便实现全局钩取操作。</p>
<p><strong>DIIMain()</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c">BOOL WINAPI <span class="hljs-title function_">DllMain</span><span class="hljs-params">(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)</span><br>&#123;<br>    <span class="hljs-type">char</span>            szCurProc[MAX_PATH] = &#123;<span class="hljs-number">0</span>,&#125;;<br>    <span class="hljs-type">char</span>            *p = <span class="hljs-literal">NULL</span>;<br><br>    <span class="hljs-comment">// 异常处理使注入不会发生在HideProc2.exe进程</span><br>    GetModuleFileNameA(<span class="hljs-literal">NULL</span>, szCurProc, MAX_PATH);<br>    p = <span class="hljs-built_in">strrchr</span>(szCurProc, <span class="hljs-string">&#x27;\\&#x27;</span>);<br>    <span class="hljs-keyword">if</span>( (p != <span class="hljs-literal">NULL</span>) &amp;&amp; !_stricmp(p+<span class="hljs-number">1</span>, <span class="hljs-string">&quot;HideProc2.exe&quot;</span>) )<br>        <span class="hljs-keyword">return</span> TRUE;<br><br>    <span class="hljs-comment">// 改变 privilege</span><br>    SetPrivilege(SE_DEBUG_NAME, TRUE);<br><br>    <span class="hljs-keyword">switch</span>( fdwReason )<br>    &#123;<br>        <span class="hljs-keyword">case</span> DLL_PROCESS_ATTACH : <br>            <span class="hljs-comment">// hook</span><br>            hook_by_code(<span class="hljs-string">&quot;kernel32.dll&quot;</span>, <span class="hljs-string">&quot;CreateProcessA&quot;</span>, <br>                         (PROC)NewCreateProcessA, g_pOrgCPA);<br>            hook_by_code(<span class="hljs-string">&quot;kernel32.dll&quot;</span>, <span class="hljs-string">&quot;CreateProcessW&quot;</span>, <br>                         (PROC)NewCreateProcessW, g_pOrgCPW);<br>            hook_by_code(<span class="hljs-string">&quot;ntdll.dll&quot;</span>, <span class="hljs-string">&quot;ZwQuerySystemInformation&quot;</span>, <br>                         (PROC)NewZwQuerySystemInformation, g_pOrgZwQSI);<br>            <span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-keyword">case</span> DLL_PROCESS_DETACH :<br>            <span class="hljs-comment">// unhook</span><br>            unhook_by_code(<span class="hljs-string">&quot;kernel32.dll&quot;</span>, <span class="hljs-string">&quot;CreateProcessA&quot;</span>, <br>                           g_pOrgCPA);<br>            unhook_by_code(<span class="hljs-string">&quot;kernel32.dll&quot;</span>, <span class="hljs-string">&quot;CreateProcessW&quot;</span>, <br>                           g_pOrgCPW);<br>            unhook_by_code(<span class="hljs-string">&quot;ntdll.dll&quot;</span>, <span class="hljs-string">&quot;ZwQuerySystemInformation&quot;</span>, <br>                           g_pOrgZwQSI);<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> TRUE;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>从以上DIIMain()函数代码中可以看到，新增了对CreateProcessA()、CreateProcessW() API进行钩取&#x2F; “脱钩”的代码。</p>
<p><strong>NewCreateProcessA()</strong><br>下面看看NewCreateProcessA()函数代码，它是钩取CreateProcessA() API的函数（代码与NewCreateProcessW()几乎一样）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c">BOOL WINAPI <span class="hljs-title function_">NewCreateProcessA</span><span class="hljs-params">(</span><br><span class="hljs-params">    LPCTSTR lpApplicationName,</span><br><span class="hljs-params">    LPTSTR lpCommandLine,</span><br><span class="hljs-params">    LPSECURITY_ATTRIBUTES lpProcessAttributes,</span><br><span class="hljs-params">    LPSECURITY_ATTRIBUTES lpThreadAttributes,</span><br><span class="hljs-params">    BOOL bInheritHandles,</span><br><span class="hljs-params">    DWORD dwCreationFlags,</span><br><span class="hljs-params">    LPVOID lpEnvironment,</span><br><span class="hljs-params">    LPCTSTR lpCurrentDirectory,</span><br><span class="hljs-params">    LPSTARTUPINFO lpStartupInfo,</span><br><span class="hljs-params">    LPPROCESS_INFORMATION lpProcessInformation</span><br><span class="hljs-params">)</span><br>&#123;<br>    BOOL bRet;<br>    FARPROC pFunc;<br><br>    <span class="hljs-comment">// unhook</span><br>    unhook_by_code(<span class="hljs-string">&quot;kernel32.dll&quot;</span>, <span class="hljs-string">&quot;CreateProcessA&quot;</span>, g_pOrgCPA);<br><br>    <span class="hljs-comment">// 调用原始API</span><br>    pFunc = GetProcAddress(GetModuleHandleA(<span class="hljs-string">&quot;kernel32.dll&quot;</span>), <span class="hljs-string">&quot;CreateProcessA&quot;</span>);<br>    bRet = ((PFCREATEPROCESSA)pFunc)(lpApplicationName,<br>                                     lpCommandLine,<br>                                     lpProcessAttributes,<br>                                     lpThreadAttributes,<br>                                     bInheritHandles,<br>                                     dwCreationFlags,<br>                                     lpEnvironment,<br>                                     lpCurrentDirectory,<br>                                     lpStartupInfo,<br>                                     lpProcessInformation);<br><br>    <span class="hljs-comment">// 向生成的子进程中注入stealth2.dll</span><br>    <span class="hljs-keyword">if</span>( bRet )<br>        InjectDll2(lpProcessInformation-&gt;hProcess, STR_MODULE_NAME);<br><br>    <span class="hljs-comment">// hook</span><br>    hook_by_code(<span class="hljs-string">&quot;kernel32.dll&quot;</span>, <span class="hljs-string">&quot;CreateProcessA&quot;</span>, <br>                 (PROC)NewCreateProcessA, g_pOrgCPA);<br><br>    <span class="hljs-keyword">return</span> bRet;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>NewCreateProcessA()函数代码比较简单。先执行“脱钩”操作（unhook_by_code），调用执行原函数，再将stealth2.dll注入（InjectDlI2）生成的子进程，最后再钩取（hook_by_code），为下次运行做准备。其中需要注意的是，注入stealth2.dll文件用的函数为InjectDll2()。以前的InjectDll()函数通过PID获取进程句柄进行注入（调用OpenProcess() API），但在上述示例中调用CreateProcessA() API时，能自然而然获得子进程的句柄（lpProcessInformation-&gt;hProcess），请留意这一点。</p>
<p>到此我们学习了有关全局API钩取的内容。由于它是一种钩取系统全部进程的技术，所以有时会引发意料之外的错误。使用这项技术前必须仔细测试。另外，钩取尚未公开的API时，一定要检查它在当前OS版本中能否正常运行。</p>
<h1 id="33-9-利用“热补丁”技术钩取API"><a href="#33-9-利用“热补丁”技术钩取API" class="headerlink" title="33.9 利用“热补丁”技术钩取API"></a>33.9 利用“热补丁”技术钩取API</h1><h2 id="33-9-1-API代码修改技术的问题"><a href="#33-9-1-API代码修改技术的问题" class="headerlink" title="33.9.1 API代码修改技术的问题"></a>33.9.1 API代码修改技术的问题</h2><p>对代码33-8中NewCreateProcessA()函数的结构简单梳理如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c">NewCreateProcessA(...)<br>&#123;<br>    <span class="hljs-comment">//①脱钩</span><br>    <br>    <span class="hljs-comment">//②调用原始API</span><br>    <br>    <span class="hljs-comment">//⑤注入</span><br>    <br>    <span class="hljs-comment">//④挂钩</span><br>&#125;<br></code></pre></td></tr></table></figure>



<p>为正常调用原API，需要先①“脱钩”（若不“脱钩”，调用②原始API就会陷入无限循环）。然后在钩取函数（NewCreateProcessA）返回前再次④挂钩，使之进人钩取状态。</p>
<p>也就是说，每当在程序内部调用CreateProcessA()API时，NewCreateProcessA()就会被调用执行，不断重复“脱钩” &#x2F;挂钩。这种反复进行的“脱钩”准钩操作不仅会造成整体性能低下，更 严重的是在多线程环境下还会产生运行时错误，这是由“脱钩” &#x2F;挂钩操作要对原API的前5个字节进行修改（覆写）引起的。</p>
<p>一个线程尝试运行某段代码时，若另一进程正在对该段代码进行“写”操作，这时就会出现冲突，最终引发运行时错误。所以我们需要一种更安全的API钩取技术。</p>
<p>《Windows核心编程》一书中曾指出，运用代码修改技术钩取API会对系统安全造成威胁。</p>
<h2 id="33-9-2-“热补丁”（修改7个字节代码）"><a href="#33-9-2-“热补丁”（修改7个字节代码）" class="headerlink" title="33.9.2 “热补丁”（修改7个字节代码）"></a>33.9.2 “热补丁”（修改7个字节代码）</h2><p>使用“热补丁”（HotPatch）技术比修改5个字节代码的方法更稳定，本小节将讲解有关“热补丁”技术的内容。</p>
<blockquote>
<p>“热补丁”对应的英文为Hot Patch或Hot Fix,与修改5个字节代码的技术不同，使用“热补丁”技术时将修改7个字节代码，所以该技术又称为7字节代码修改技术。</p>
</blockquote>
<p><strong>普通API起始代码的形态</strong></p>
<p>讲解“热补丁”技术前，先看看常用API的起始代码部分（参考图33-16至图33-19）。</p>
<p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC33%E7%AB%A0%20%E9%9A%90%E8%97%8F%E8%BF%9B%E7%A8%8B.assets/image-20220305211925669.png" srcset="https://picbedddd.oss-cn-beijing.aliyuncs.com/blog/loading.gif" lazyload alt="图33-16 kernel32.CreateProcessA()"></p>
<p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC33%E7%AB%A0%20%E9%9A%90%E8%97%8F%E8%BF%9B%E7%A8%8B.assets/image-20220305212012044.png" srcset="https://picbedddd.oss-cn-beijing.aliyuncs.com/blog/loading.gif" lazyload alt="图33-17 kernel32丄oadLibraryAO"></p>
<p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC33%E7%AB%A0%20%E9%9A%90%E8%97%8F%E8%BF%9B%E7%A8%8B.assets/image-20220305212038993.png" srcset="https://picbedddd.oss-cn-beijing.aliyuncs.com/blog/loading.gif" lazyload alt="图33-18 user32.MessageBoxA()"></p>
<p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC33%E7%AB%A0%20%E9%9A%90%E8%97%8F%E8%BF%9B%E7%A8%8B.assets/image-20220305212332200.png" srcset="https://picbedddd.oss-cn-beijing.aliyuncs.com/blog/loading.gif" lazyload alt="图33-19 gdi32.TextOutW()"></p>
<p>以上列出的API起始代码有如下2个明显的相似点：</p>
<p>（1） API代码以”MOV EDI,EDI”指令开始（IA-32指令： 0x8BFF）。 </p>
<p>（2） API代码上方有5个NOP指令（IA-32指令： 0x90）。</p>
<p>MOV EDI，EDI指令大小为2个字节，用于将EDI寄存器的值再次传送到EDI寄存器，这没有什么实际意义。NOP指令为1个字节大小，不进行任何操作（NOPeration）（该NOP指令存在于函数与函数之间，甚至都不会被执行）。也就是说，API起始代码的MOV指令（2个字节）与其上方的5个NOP指令（5个字节）合起来共7个字节的指令没有任何意义。</p>
<p>很显然，kernel32.dll、user32.dll、gdi32.dll是Windows OS相当重要的库。那么微软到底为什么要使用这种方式来制作系统库呢？原因是为了方便“打热补丁”。“热补丁”由API钩取组成，在进程处于运行状态时临时更改进程内存中的库文件（重启系统时，修改的目标库文件会被完全取代）。</p>
<p><strong>工作原理及特征</strong></p>
<p>要理解“热补丁”钩取方法的核心原理，需要先了解该方法的2种特征。下面使用“热补丁”方法钩取图33-16中的kernel32.CreateProcessA()API，借此理解学习“热补丁”钩取的技术原理。</p>
<p>A.二次跳转</p>
<p>首先将API起始代码之前的5个字节修改为FAR JMP指令（E9 XXXXXXXX），跳转到用户钩取函数处（10001000）。然后将API起始代码的2个字节修改为SHORT JMP指令（EB F9）。该SHORT JMP指令用来跳转到前面的FAR JMP指令处（参考图33-20）。</p>
<p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC33%E7%AB%A0%20%E9%9A%90%E8%97%8F%E8%BF%9B%E7%A8%8B.assets/image-20220305213701444.png" srcset="https://picbedddd.oss-cn-beijing.aliyuncs.com/blog/loading.gif" lazyload alt="图33-20 使用“热补丁”技术钩取CreateProcessA() API"></p>
<p>调用CreateProcessA() API时，遇到API起始地址（7C80236B）处的JMP SHORT 7C802366指 令，就会跳转到紧接在其上方的指令地址（7C802366）。然后遇到JMP 10001000指令，跳转到实际钩取的函数地址（10001000）。像这样经过2次连续跳转，就完成了对指定API的钩取操作（我将这种技术称为“二次跳转”，其优点稍后介绍）。这一过程中需要注意的是，我们修改的7个字节的指令（NOP*5、MOV EDI,EDI）原来都是毫无意义的。</p>
<blockquote>
<p>从图33-20中的7C802366、7C80236B地址可以看到，虽然都是JMP指令，但指 令形态不同。7C802366地址处的指令形式为E9 XXXXXXXX,大小为5个字节，被称 为FAR JMP,用来实现远程跳转（可以跳转到进程内存用户区域中的任意位置）；而 7C80236B地址处的指令形式为EB YY，大小为2个字节，被称为SHORT JMP,它只能以当前EIP为基准，在-128〜127范围内跳转。IA-32指令中有些相同指令拥有不同指令形态，IA-32指令的解析方法请参考第49章。</p>
</blockquote>
<p>B.不需要在钩取函数内部进行“脱钩” &#x2F;挂钩操作</p>
<p>前面讲解过修改代码的前5个字节进行钩取的技术，使用时需要在钩取函数NewCreateProcessA()内部反复“脱钩” &#x2F;挂钩，这可能导致系统稳定性下降。</p>
<p>而使用“热补丁”技术钩取API时，不需要在钩取函数内部进行“脱钩” &#x2F;挂钩操作。在5字节代码修改技术中“脱钩” &#x2F;挂钩是为了 “调用原函数”，而使用“热补丁”技术钩取API时，在API代码遭到修改的状态下也能正常调用原API。这是因为，从API角度看只是修改了其起始代码的<code>MOV EDI,EDI</code>指令（无意义的2个字节），从[API起始地址+2]地址开始，仍然能正常调用原API，且执行的动作也完全一样。 以Kernel32.CreateProcessA()为例，从图33-16所示的原API起始地址（7C80236B）开始执行，与从图33-20中的[API起始地址+2]地址（7C80236B）开始执行，结果完全一样。由于钩取函数中去除了 “脱钩” &#x2F;挂钩操作，在多线程环境下使API钩取变得稳定。这正是二次跳转的优势所在。</p>
<h1 id="33-10-练习-3-stealth3-dll"><a href="#33-10-练习-3-stealth3-dll" class="headerlink" title="33.10 练习 #3: stealth3.dll"></a>33.10 练习 #3: stealth3.dll</h1><p>stealth3.dll文件中使用了 “热补丁” API钩取技术，下面用它练习，如图33-22所示</p>
<p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC33%E7%AB%A0%20%E9%9A%90%E8%97%8F%E8%BF%9B%E7%A8%8B.assets/image-20220305220443798.png" srcset="https://picbedddd.oss-cn-beijing.aliyuncs.com/blog/loading.gif" lazyload alt="图33-22 stealth3.dll练习（隐藏）"></p>
<p>练习方法与stealth2.dll—样。先把stealth3.dll文件复制到％SYSTEM%文件夹，然后在命令行窗口运行HideProc2.exe命令，如图33-22所示（操作步骤与练习2的步骤1-4相同）。由于HideProc2.exe命令未做改动，像之前一样使用就可以了（隐藏notepad.exe进程的行为是相同的）。</p>
<blockquote>
<p>练习示例在Windows XP SP3&amp; Windows 7 （32位）系统环境中通过测试。</p>
</blockquote>
<h1 id="33-11-源代码分析"><a href="#33-11-源代码分析" class="headerlink" title="33.11 源代码分析"></a>33.11 源代码分析</h1><p>下面分析stealth3.cpp源代码，内容大致与stealth2.cpp类似，主要看与实施“热补丁”技术相关的代码。</p>
<p><strong>stealth3.cpp</strong></p>
<p>hook_by_hotpatch()</p>
<p>首先5析hook_by_hotpatch()函数，它运用“热补丁”技术钩取API。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c">BOOL <span class="hljs-title function_">hook_by_hotpatch</span><span class="hljs-params">(LPCSTR szDllName, LPCSTR szFuncName, PROC pfnNew)</span><br>&#123;<br>	FARPROC pFunc;<br>	DWORD dwOldProtect, dwAddress;<br>	BYTE pBuf[<span class="hljs-number">5</span>] = &#123; <span class="hljs-number">0xE9</span>, <span class="hljs-number">0</span>, &#125;;<br>    BYTE pBuf2[<span class="hljs-number">2</span>] = &#123; <span class="hljs-number">0xEB</span>, <span class="hljs-number">0xF9</span> &#125;;<br>	PBYTE pByte;<br><br>	pFunc = (FARPROC)GetProcAddress(GetModuleHandleA(szDllName), szFuncName);<br>	pByte = (PBYTE)pFunc;<br>	<span class="hljs-keyword">if</span>( pByte[<span class="hljs-number">0</span>] == <span class="hljs-number">0xEB</span> )<br>		<span class="hljs-keyword">return</span> FALSE;<br><br>	VirtualProtect((LPVOID)((DWORD)pFunc - <span class="hljs-number">5</span>), <span class="hljs-number">7</span>, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);<br><br>    <span class="hljs-comment">// 1. NOP (0x90)</span><br>	dwAddress = (DWORD)pfnNew - (DWORD)pFunc;<br>	<span class="hljs-built_in">memcpy</span>(&amp;pBuf[<span class="hljs-number">1</span>], &amp;dwAddress, <span class="hljs-number">4</span>);<br>	<span class="hljs-built_in">memcpy</span>((LPVOID)((DWORD)pFunc - <span class="hljs-number">5</span>), pBuf, <span class="hljs-number">5</span>);<br>    <br>    <span class="hljs-comment">// 2. MOV EDI, EDI (0x8BFF)</span><br>    <span class="hljs-built_in">memcpy</span>(pFunc, pBuf2, <span class="hljs-number">2</span>);<br><br>	VirtualProtect((LPVOID)((DWORD)pFunc - <span class="hljs-number">5</span>), <span class="hljs-number">7</span>, dwOldProtect, &amp;dwOldProtect);<br><br>	<span class="hljs-keyword">return</span> TRUE;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>使用“热补丁”技术钩取API时，操作顺序非常重要。首先要将API起始地址上方的NOP*5指令修改为JMP XXXXXXXX。通过下面公式很容易求出XXXXXXXX值（即上述代码中的dwAddress变量），计算公式如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">dwAddress = (DWORD)pfnNew-(DWORD)pFunc;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>上述公式与前面讲解hook_by_code()函数时介绍的地址计算公式实际是一样的。</p>
<p>XXXXXXXX &#x3D;要跳转的地址-当前指令地址-当前指令长度(5)</p>
<p>当前指令(NOP*5)地址&#x3D;pFunc-5,所以上述公式可做如下修改：</p>
<p>XXXXXXXX &#x3D; (DWORD)pfnNew - ((DWORD)pFunc - 5) -5</p>
<p>&#x3D;(DWORD)pfnNew - (DWORD)pFunc </p>
<p>*pfnNew &#x3D;用户钩取函数</p>
<p>*pFunc &#x3D;原 API 地址</p>
</blockquote>
<p>求得XXXXXXXX值后，使用下述代码将NOP *5指令（5个字节大小）替换为JMP XXXXXXXX指令。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">memcpy</span>(&amp;pBuf[<span class="hljs-number">1</span>], &amp;dwAddress, <span class="hljs-number">4</span>);<br><span class="hljs-built_in">memcpy</span>((LPVOID)((DWORD)pFunc - <span class="hljs-number">5</span>), pBuf, <span class="hljs-number">5</span>);<br></code></pre></td></tr></table></figure>

<p>接下来，将位于API起始地址处的MOV EDI,EDI指令（2个字节大小）替换为JMP YY指令。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">memcpy</span>(pFunc, pBuf2, <span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure>



<blockquote>
<p>使用JMP YY指令时，要先计算出YY值，计算公式与前面相同。</p>
<p>YY&#x3D;要跳转的地址-当前指令地址-当前指令长度（2）</p>
<p>要跳转的地址是pFunc - 5,当前指令地址为pFunc, YY值计算如下：</p>
<p>YY &#x3D; （pFunc - 5）- pFunc - 2 &#x3D; -7 &#x3D;0xF9 </p>
<p>“热补丁”技术中，YY值总为0xF9,将其硬编码到源代码就可以了（0xF9是-7 的 “2的补码”形式）。</p>
</blockquote>
<p>unhook_by_hotpatch()</p>
<p>接下来分析unhook_by_hotpatch()函数，它在“热补丁”技术中用来取消API钩取操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c">BOOL <span class="hljs-title function_">unhook_by_hotpatch</span><span class="hljs-params">(LPCSTR szDllName, LPCSTR szFuncName)</span><br>&#123;<br>    FARPROC pFunc;<br>    DWORD dwOldProtect;<br>    PBYTE pByte;<br>    BYTE pBuf[<span class="hljs-number">5</span>] = &#123; <span class="hljs-number">0x90</span>, <span class="hljs-number">0x90</span>, <span class="hljs-number">0x90</span>, <span class="hljs-number">0x90</span>, <span class="hljs-number">0x90</span> &#125;;<br>    BYTE pBuf2[<span class="hljs-number">2</span>] = &#123; <span class="hljs-number">0x8B</span>, <span class="hljs-number">0xFF</span> &#125;;<br><br><br>    pFunc = (FARPROC)GetProcAddress(GetModuleHandleA(szDllName), szFuncName);<br>    pByte = (PBYTE)pFunc;<br>    <span class="hljs-keyword">if</span>( pByte[<span class="hljs-number">0</span>] != <span class="hljs-number">0xEB</span> )<br>        <span class="hljs-keyword">return</span> FALSE;<br><br>    VirtualProtect((LPVOID)pFunc, <span class="hljs-number">5</span>, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);<br><br>    <span class="hljs-comment">// 1. NOP (0x90)</span><br>    <span class="hljs-built_in">memcpy</span>((LPVOID)((DWORD)pFunc - <span class="hljs-number">5</span>), pBuf, <span class="hljs-number">5</span>);<br>    <br>    <span class="hljs-comment">// 2. MOV EDI, EDI (0x8BFF)</span><br>    <span class="hljs-built_in">memcpy</span>(pFunc, pBuf2, <span class="hljs-number">2</span>);<br><br>    VirtualProtect((LPVOID)pFunc, <span class="hljs-number">5</span>, dwOldProtect, &amp;dwOldProtect);<br><br>    <span class="hljs-keyword">return</span> TRUE;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上述代码用来将修改后的指令恢复为原来的NOP *5与<code>MOV EDI，EDI</code>指令。“热补丁”技术中这些指令都是固定不变的，所以可以将它们硬编码到源代码。</p>
<p>NewCreateProcessA()</p>
<p>下面分析用户钩取函数NewCreateProcessA()。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c">BOOL WINAPI <span class="hljs-title function_">NewCreateProcessA</span><span class="hljs-params">(</span><br><span class="hljs-params">    LPCTSTR lpApplicationName,</span><br><span class="hljs-params">    LPTSTR lpCommandLine,</span><br><span class="hljs-params">    LPSECURITY_ATTRIBUTES lpProcessAttributes,</span><br><span class="hljs-params">    LPSECURITY_ATTRIBUTES lpThreadAttributes,</span><br><span class="hljs-params">    BOOL bInheritHandles,</span><br><span class="hljs-params">    DWORD dwCreationFlags,</span><br><span class="hljs-params">    LPVOID lpEnvironment,</span><br><span class="hljs-params">    LPCTSTR lpCurrentDirectory,</span><br><span class="hljs-params">    LPSTARTUPINFO lpStartupInfo,</span><br><span class="hljs-params">    LPPROCESS_INFORMATION lpProcessInformation</span><br><span class="hljs-params">)</span><br>&#123;<br>    BOOL bRet;<br>    FARPROC pFunc;<br><br>    <span class="hljs-comment">// 调用原始API</span><br>    pFunc = GetProcAddress(GetModuleHandleA(<span class="hljs-string">&quot;kernel32.dll&quot;</span>), <span class="hljs-string">&quot;CreateProcessA&quot;</span>);<br>    pFunc = (FARPROC)((DWORD)pFunc + <span class="hljs-number">2</span>);<br>    bRet = ((PFCREATEPROCESSA)pFunc)(lpApplicationName,<br>                                     lpCommandLine,<br>                                     lpProcessAttributes,<br>                                     lpThreadAttributes,<br>                                     bInheritHandles,<br>                                     dwCreationFlags,<br>                                     lpEnvironment,<br>                                     lpCurrentDirectory,<br>                                     lpStartupInfo,<br>                                     lpProcessInformation);<br><br>    <span class="hljs-comment">// 向生成的子进程注入stealth3.dll</span><br>    <span class="hljs-keyword">if</span>( bRet )<br>        InjectDll2(lpProcessInformation-&gt;hProcess, STR_MODULE_NAME);<br><br>    <span class="hljs-keyword">return</span> bRet;<br>&#125;<br></code></pre></td></tr></table></figure>



<p>从上述代码中可以看到，不再调用unhook_by_code()与hook_by_code函数，且与已有函数根本的不同在于添加了计算pFunc的语句，如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">pFunc=(FARPROC)((DWORD)pFunc+<span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure>

<p>该代码语句用于跳过位于API起始地址处的JMP YY指令{ 2个字节，原指令为<code>MOV EDI,EDI</code>），从紧接的下一条指令开始执行，与调用原API的效果一样。</p>
<h1 id="33-12-使用“热补丁”-API钩取技术时需要考虑的问题"><a href="#33-12-使用“热补丁”-API钩取技术时需要考虑的问题" class="headerlink" title="33.12 使用“热补丁” API钩取技术时需要考虑的问题"></a>33.12 使用“热补丁” API钩取技术时需要考虑的问题</h1><p>令人遗憾的是，这么优越的“热补丁” API钩取技术也不是万能的，使用时目标API必须满足它的适用条件（NOP *5指令+<code>MOV EDI,EDI</code>指令），但是有些API却不能满足这些条件（参考图33-23、图33-24）。</p>
<p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC33%E7%AB%A0%20%E9%9A%90%E8%97%8F%E8%BF%9B%E7%A8%8B.assets/image-20220305222144911.png" srcset="https://picbedddd.oss-cn-beijing.aliyuncs.com/blog/loading.gif" lazyload alt="图33-23难以使用“热补丁” API钩取技术：kernel32.GetStartInfoA()"></p>
<p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC33%E7%AB%A0%20%E9%9A%90%E8%97%8F%E8%BF%9B%E7%A8%8B.assets/image-20220305222334989.png" srcset="https://picbedddd.oss-cn-beijing.aliyuncs.com/blog/loading.gif" lazyload alt="图33-24 无法使用“热补丁” API钩取技术：ntdll.dll提供的API"></p>
<p>并非所有API都能使用“热补丁” API钩取技术，所以使用前先确认要钩取的API是否支持它。若不支持，则要使用前面介绍过的5字节代码修改技术。</p>
<blockquote>
<p>ntdll.dll中提供的API代码都较短，钩取这些API时有一种非常好的方法，使用这种方法时先将原API备份到用户内存区域，然后使用5字节代码修改技术修改原API的起始部分。在用户钩取函数内部调用原API时，只需调用备份的API即可，这样实 现的API钩取既简单又稳定。由于ntdll.dll API代码较短，且代码内部地址无依赖性，所以它们非常适合用该技术钩取API。</p>
</blockquote>
<h1 id="33-13-小结"><a href="#33-13-小结" class="headerlink" title="33.13 小结"></a>33.13 小结</h1><p>通过修改API代码钩取API技术的讲解到此结束。讲解技术的核心内容时用的篇幅较多。各位阅读学习时不要死记硬背，要把重点放在对技术原理的理解上。学完本章以及下一章要介绍的全局API钩取内容，就能够完全掌握API钩取技术。</p>
<p>Q.运行hideproc.exe程序0.5秒后自动终止，为什么会这样？ </p>
<p>A. hideproc.exe进程完成所有工作后会自动终止退出，程序就是这样编写的。若任务管理器中看不到notepad.exe进程，就表示执行成功。 </p>
<p>Q.执行HideProc.exe -hide abc.exe d:\stealth.dll命令，结果出现如下注入失败信息:<br>OpenProcess3976 failed!!! OpenProcess4040 failed!!!为什么注入会失败呢？ </p>
<p>A. Windows Vista&#x2F;7中使用了会话隔离技术，这可能导致DLL注入失败。出现这个问题时，不要使用kernel32.CreateRemoteThread()，而使用ntdll.NtCreateThreadEx()就可以了。相关内容请参考Session in Windows 7中的说明。有时开启杀毒软件自身的进程保护功能也会导致DLL注入失败。此外，尝试向PE32+格式的进程注入PE32格式的DLL时，也会失败（反之亦然）。注入时必须保证要注入的DLL文件与目标进程的PE格式一致（PE32+格式是Windows 64位OS使用的可执行文件格式）。</p>
<p>Q.要隐藏的进程在任务管理器的“进程”选项卡中消失了，但在“应用程序”选项卡中仍然可见，且程序窗口也依然可见。如何把程序窗口也一起隐藏起来呢？ </p>
<p>A.是的，若只在进程列表中实现了进程隐藏，则程序窗口仍然可见。若将程序窗口也一起隐藏起来，则在任务管理器的“应用程序”选项卡中也消失不见。正文示例的代码只是为了钩取API,对程序的窗口并未作任何处理（程序窗口确实存在，但是进程却消失不见了，我也有意让各位看看这个现象）。就像隐形战斗机，隐形并不是指用肉眼看不到它，而是仅指用雷达探测不到它。DLL文件注入目标进程后，只要调用与窗口隐藏相关的API即可轻松隐藏程序窗 口（SetWindowPos()，MoveWindow()等）。</p>
<p> Q.除了前面介绍过的5字节修改方法之外，还有其他钩取API的方法吗？在钩取函数中反复进行“脱钩” &#x2F;挂钩操作显得相当麻烦啊！ </p>
<p>A.我介绍的5字节修改方法适用范围较广，一般情况下也运行得非常好。除此之外，还有7字节修改方法，在钩取函数中也不需要进行“脱钩” &#x2F;挂钩操作。但并不适用于所有API, 特别是ntdll.dll提供的原生（native） API就无法使用7字节修改技术。关于7字节“热补丁”技术的内容请参看前面正文。此外还有一种方法是，将API代码全部拷贝到其他地方，但是这需要处理好重定位的问题（该方法非常适用于ntdll的原生API,因为这些API的代码都比较简短）。总之，从应用范围以及简便性方面考虑，5字节修改技术是首选。 </p>
<p>Q.使用全局钩取技术注入dll文件时会不会给系统带来很大负担呢？所有进程在创建的时候都要注入dll,那么内存使用量会大幅飙升吧？ </p>
<p>A.首先，任何钩取操作都会给系统带来一定负担。编写程序时若能巧妙运用一些手法，则可以将这种对系统的影响降到最低，不会有什么问题，但一定要充分考虑好系统稳定性与资源利用问题。向所有进程注入DLL时，内存使用量也会随之增加，但并不是以“DLL尺寸*注入进程的个数增加。Windows中，相同DLL只要加载到内存中1次即可，进程通过映射技术使用它。简言之，通过映射技术将代码映射到相同内存，即代码区对所有进程都是一样的，而数据区则要根据相应进程重新创建。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《逆向工程核心原理》 第33章</p>

              
            </div>
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/Binary/" class="category-chain-item">Binary</a>
  
  
    <span>></span>
    
  <a href="/categories/Binary/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/" class="category-chain-item">逆向工程核心原理</a>
  
  

  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/Binary/">#Binary</a>
      
        <a href="/tags/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/">#逆向工程核心原理</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>第33章 隐藏进程</div>
      <div>https://m0ck1ng-b1rd.github.io/1999/03/03/逆向工程核心原理/第33章 隐藏进程/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>何语灵</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>1999年3月3日</div>
        </div>
      
      
      <div class="license-meta-item">
        <div>许可协议</div>
        <div>
          
            
            
              <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
              <span class="hint--top hint--rounded" aria-label="BY - 署名">
                <i class="iconfont icon-by"></i>
              </span>
              </a>
            
          
        </div>
      </div>
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/1999/03/04/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC34%E7%AB%A0%20%E9%AB%98%E7%BA%A7%E5%85%A8%E5%B1%80API%E9%92%A9%E5%8F%96%EF%BC%9AIE%E8%BF%9E%E6%8E%A5%E6%8E%A7%E5%88%B6/" title="第34章 高级全局API钩取：旧连接控制">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">第34章 高级全局API钩取：旧连接控制</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/1999/03/02/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC32%E7%AB%A0%20%E8%AE%A1%E7%AE%97%E5%99%A8%E6%98%BE%E7%A4%BA%E4%B8%AD%E6%96%87%E6%95%B0%E5%AD%97/" title="第32章 计算器显示中文数字">
                        <span class="hidden-mobile">第32章 计算器显示中文数字</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  <article id="comments" lazyload>
    
  <script type="text/javascript">
    Fluid.utils.loadComments('#comments', function() {
      var light = 'github-light';
      var dark = 'github-dark';
      var schema = document.documentElement.getAttribute('data-user-color-scheme');
      if (schema === 'dark') {
        schema = dark;
      } else {
        schema = light;
      }
      window.UtterancesThemeLight = light;
      window.UtterancesThemeDark = dark;
      var s = document.createElement('script');
      s.setAttribute('src', 'https://utteranc.es/client.js');
      s.setAttribute('repo', 'M0cK1nG-b1Rd/blog-comments');
      s.setAttribute('issue-term', 'title');
      
      s.setAttribute('label', 'utterances');
      
      s.setAttribute('theme', schema);
      s.setAttribute('crossorigin', 'anonymous');
      document.getElementById('comments').appendChild(s);
    })
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


  </article>


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  






    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://M0cK1nG-b1Rd.github.io" target="_blank" rel="nofollow noopener"><span>M0cK1nG-b1Rd</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Powered by Hexo&Fluid</span></a> <div>Per aspera ad astra</div> <div> <span id="timeDate">载入天数...</span> <span id="times">载入时分秒...</span> <script src="/js/duration.js"></script> </div> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="leancloud-site-pv-container" style="display: none">
        总访问量 
        <span id="leancloud-site-pv"></span>
         次
      </span>
    
    
      <span id="leancloud-site-uv-container" style="display: none">
        总访客数 
        <span id="leancloud-site-uv"></span>
         人
      </span>
    
    

  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  

  

  

  

  

  

  
    
  




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.0/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script>
  (function() {
    var enableLang = CONFIG.code_language.enable && CONFIG.code_language.default;
    var enableCopy = CONFIG.copy_btn;
    if (!enableLang && !enableCopy) {
      return;
    }

    function getBgClass(ele) {
      return Fluid.utils.getBackgroundLightness(ele) >= 0 ? 'code-widget-light' : 'code-widget-dark';
    }

    var copyTmpl = '';
    copyTmpl += '<div class="code-widget">';
    copyTmpl += 'LANG';
    copyTmpl += '</div>';
    jQuery('.markdown-body pre').each(function() {
      var $pre = jQuery(this);
      if ($pre.find('code.mermaid').length > 0) {
        return;
      }
      if ($pre.find('span.line').length > 0) {
        return;
      }

      var lang = '';

      if (enableLang) {
        lang = CONFIG.code_language.default;
        if ($pre[0].children.length > 0 && $pre[0].children[0].classList.length >= 2 && $pre.children().hasClass('hljs')) {
          lang = $pre[0].children[0].classList[1];
        } else if ($pre[0].getAttribute('data-language')) {
          lang = $pre[0].getAttribute('data-language');
        } else if ($pre.parent().hasClass('sourceCode') && $pre[0].children.length > 0 && $pre[0].children[0].classList.length >= 2) {
          lang = $pre[0].children[0].classList[1];
          $pre.parent().addClass('code-wrapper');
        } else if ($pre.parent().hasClass('markdown-body') && $pre[0].classList.length === 0) {
          $pre.wrap('<div class="code-wrapper"></div>');
        }
        lang = lang.toUpperCase().replace('NONE', CONFIG.code_language.default);
      }
      $pre.append(copyTmpl.replace('LANG', lang).replace('code-widget">',
        getBgClass($pre[0]) + (enableCopy ? ' code-widget copy-btn" data-clipboard-snippet><i class="iconfont icon-copy"></i>' : ' code-widget">')));

      if (enableCopy) {
        Fluid.utils.createScript('https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js', function() {
          var clipboard = new window.ClipboardJS('.copy-btn', {
            target: function(trigger) {
              var nodes = trigger.parentNode.childNodes;
              for (var i = 0; i < nodes.length; i++) {
                if (nodes[i].tagName === 'CODE') {
                  return nodes[i];
                }
              }
            }
          });
          clipboard.on('success', function(e) {
            e.clearSelection();
            e.trigger.innerHTML = e.trigger.innerHTML.replace('icon-copy', 'icon-success');
            setTimeout(function() {
              e.trigger.innerHTML = e.trigger.innerHTML.replace('icon-success', 'icon-copy');
            }, 2000);
          });
        });
      }
    });
  })();
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="/js/leancloud.js" ></script>




  
<script src="//picbedddd.oss-cn-beijing.aliyuncs.com/blog/scripts/DynamicRibbon.min.js"></script>
<script src="//picbedddd.oss-cn-beijing.aliyuncs.com/blog/scripts/star.min.js"></script>



<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"left","width":250,"height":500,"hOffset":-30,"vOffset":-150},"mobile":{"show":true,"scale":0.5},"log":false});</script></body>
</html>
