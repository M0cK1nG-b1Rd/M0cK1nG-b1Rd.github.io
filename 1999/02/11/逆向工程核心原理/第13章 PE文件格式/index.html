

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="https://picbedddd.oss-cn-beijing.aliyuncs.com/blog/icon/apple-touch-icon.png">
  <link rel="icon" href="https://picbedddd.oss-cn-beijing.aliyuncs.com/blog/icon/favicon.ico">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="何语灵">
  <meta name="keywords" content="">
  
    <meta name="description" content="仅作学习记录，侵删">
<meta property="og:type" content="article">
<meta property="og:title" content="第13章 PE文件格式">
<meta property="og:url" content="https://m0ck1ng-b1rd.github.io/1999/02/11/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC13%E7%AB%A0%20PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/index.html">
<meta property="og:site_name" content="M0cK1nG-b1Rd&#39;s site">
<meta property="og:description" content="仅作学习记录，侵删">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC13%E7%AB%A0%20PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F.assets/image-20211203222319938.png">
<meta property="article:published_time" content="1999-02-11T04:21:06.000Z">
<meta property="article:modified_time" content="2022-05-19T10:47:05.117Z">
<meta property="article:author" content="何语灵">
<meta property="article:tag" content="Binary">
<meta property="article:tag" content="逆向工程核心原理">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC13%E7%AB%A0%20PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F.assets/image-20211203222319938.png">
  
  
  
  <title>第13章 PE文件格式 - M0cK1nG-b1Rd&#39;s site</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  



  
<link rel="stylesheet" href="//picbedddd.oss-cn-beijing.aliyuncs.com/blog/scripts/scroll.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"m0ck1ng-b1rd.github.io","root":"/","version":"1.9.0","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"https://picbedddd.oss-cn-beijing.aliyuncs.com/blog/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"87rdYWc7BpvmNHtufVgH6hwF-gzGzoHsz","app_key":"FOGIb6hlzKdTWSp4wBpACnWG","server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>

  
<meta name="generator" content="Hexo 6.1.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>M0cK1nG-b1Rd&#39;s site</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('https://picbedddd.oss-cn-beijing.aliyuncs.com/blog/761607.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="第13章 PE文件格式"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="1999-02-11 12:21" pubdate>
          1999年2月11日 中午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          39k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          323 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar category-bar" style="margin-right: -1rem">
    





<div class="category-list">
  
  
    
    
    
    <div class="category row nomargin-x">
      <a class="category-item 
          list-group-item category-item-action col-10 col-md-11 col-xm-11" title="逆向工程核心原理"
        id="heading-3aa8d47104cb3e1c282e0b87fc4ac315" role="tab" data-toggle="collapse" href="#collapse-3aa8d47104cb3e1c282e0b87fc4ac315"
        aria-expanded="true"
      >
        逆向工程核心原理
        <span class="list-group-count">(22)</span>
        <i class="iconfont icon-arrowright"></i>
      </a>
      
      <div class="category-collapse collapse show" id="collapse-3aa8d47104cb3e1c282e0b87fc4ac315"
           role="tabpanel" aria-labelledby="heading-3aa8d47104cb3e1c282e0b87fc4ac315">
        
        
          
  <div class="category-post-list">
    
    
      
      
        <a href="/1999/02/17/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC19%E7%AB%A0%20UPack%E8%B0%83%E8%AF%95%20-%20%E6%9F%A5%E6%89%BEOEP/" title="UPack调试-查找OEP"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">UPack调试-查找OEP</span>
        </a>
      
    
      
      
        <a href="/1999/02/11/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC13%E7%AB%A0%20PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/" title="第13章 PE文件格式"
           class="list-group-item list-group-item-action
           active">
          <span class="category-post">第13章 PE文件格式</span>
        </a>
      
    
      
      
        <a href="/1999/02/12/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC14%E7%AB%A0%20%E8%BF%90%E8%A1%8C%E6%97%B6%E5%8E%8B%E7%BC%A9/" title="第14章 运行时压缩"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">第14章 运行时压缩</span>
        </a>
      
    
      
      
        <a href="/1999/02/13/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC15%E7%AB%A0%20%E8%B0%83%E8%AF%95UPX%E5%8E%8B%E7%BC%A9%E7%9A%84notepad%E7%A8%8B%E5%BA%8F/" title="第15章 调试UPX压缩的notepad程序"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">第15章 调试UPX压缩的notepad程序</span>
        </a>
      
    
      
      
        <a href="/1999/02/14/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC16%E7%AB%A0%20%E5%9F%BA%E5%9D%80%E9%87%8D%E5%AE%9A%E4%BD%8D%E8%A1%A8/" title="第16章 基址重定位表"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">第16章 基址重定位表</span>
        </a>
      
    
      
      
        <a href="/1999/02/15/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC17%E7%AB%A0%20%E4%BB%8E%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E4%B8%AD%E5%88%A0%E9%99%A4.reloc%E8%8A%82%E5%8C%BA/" title="第17章 从可执行文件中删除.reloc节区"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">第17章 从可执行文件中删除.reloc节区</span>
        </a>
      
    
      
      
        <a href="/1999/02/16/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC18%E7%AB%A0%20UPack%20PE%E6%96%87%E4%BB%B6%E5%A4%B4%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/" title="第18章 UPack PE文件头详细分析"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">第18章 UPack PE文件头详细分析</span>
        </a>
      
    
      
      
        <a href="/1999/02/18/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC20%E7%AB%A0%20%E2%80%9C%E5%86%85%E5%B5%8C%E8%A1%A5%E4%B8%81%E2%80%9D%E7%BB%83%E4%B9%A0/" title="第20章 “内嵌补丁”练习"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">第20章 “内嵌补丁”练习</span>
        </a>
      
    
      
      
        <a href="/1999/02/20/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC22%E7%AB%A0%20%E6%81%B6%E6%84%8F%E9%94%AE%E7%9B%98%E8%AE%B0%E5%BD%95%E5%99%A8/" title="第22章 恶意键盘记录器"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">第22章 恶意键盘记录器</span>
        </a>
      
    
      
      
        <a href="/1999/02/21/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC23%E7%AB%A0%20DLL%E6%B3%A8%E5%85%A5/" title="第23章 DLL注入"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">第23章 DLL注入</span>
        </a>
      
    
      
      
        <a href="/1999/02/22/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC24%E7%AB%A0%20DLL%E5%8D%B8%E8%BD%BD/" title="第24章 DLL卸载"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">第24章 DLL卸载</span>
        </a>
      
    
      
      
        <a href="/1999/02/23/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC25%E7%AB%A0%20%E9%80%9A%E8%BF%87%E4%BF%AE%E6%94%B9PE%E5%8A%A0%E8%BD%BDDLL/" title="第25章 通过修改PE加载DLL"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">第25章 通过修改PE加载DLL</span>
        </a>
      
    
      
      
        <a href="/1999/02/24/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC26%E7%AB%A0%20PE%20Tools/" title="第26章 PE Tools"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">第26章 PE Tools</span>
        </a>
      
    
      
      
        <a href="/1999/02/25/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC27%E7%AB%A0%20%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/" title="第27章 代码注入"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">第27章 代码注入</span>
        </a>
      
    
      
      
        <a href="/1999/02/26/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC28%E7%AB%A0%20%E4%BD%BF%E7%94%A8%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81/" title="第28章 使用汇编语言编写注入代码"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">第28章 使用汇编语言编写注入代码</span>
        </a>
      
    
      
      
        <a href="/1999/02/27/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC29%E7%AB%A0%20API%E9%92%A9%E5%8F%96%EF%BC%9A%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E4%B9%8B%E2%80%9C%E8%8A%B1%E2%80%9D/" title="第29章 API钩取：逆向分析之“花”"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">第29章 API钩取：逆向分析之“花”</span>
        </a>
      
    
      
      
        <a href="/1999/02/28/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC30%E7%AB%A0%20%E8%AE%B0%E4%BA%8B%E6%9C%ACWriteFile()%20API%E9%92%A9%E5%8F%96/" title="第30章 记事本WriteFile() API钩取"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">第30章 记事本WriteFile() API钩取</span>
        </a>
      
    
      
      
        <a href="/1999/03/01/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC31%E7%AB%A0%20%E5%85%B3%E4%BA%8E%E8%B0%83%E8%AF%95%E5%99%A8/" title="第31章 关于调试器"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">第31章 关于调试器</span>
        </a>
      
    
      
      
        <a href="/1999/03/02/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC32%E7%AB%A0%20%E8%AE%A1%E7%AE%97%E5%99%A8%E6%98%BE%E7%A4%BA%E4%B8%AD%E6%96%87%E6%95%B0%E5%AD%97/" title="第32章 计算器显示中文数字"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">第32章 计算器显示中文数字</span>
        </a>
      
    
      
      
        <a href="/1999/03/03/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC33%E7%AB%A0%20%E9%9A%90%E8%97%8F%E8%BF%9B%E7%A8%8B/" title="第33章 隐藏进程"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">第33章 隐藏进程</span>
        </a>
      
    
      
      
        <a href="/1999/02/19/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC21%E7%AB%A0%20Windows%E6%B6%88%E6%81%AF%E9%92%A9%E5%8F%96/" title="第7章 栈帧"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">第7章 栈帧</span>
        </a>
      
    
      
      
        <a href="/1999/02/10/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC7%E7%AB%A0%20%E6%A0%88%E5%B8%A7/" title="第7章 栈帧"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">第7章 栈帧</span>
        </a>
      
    
  </div>

        
      </div>
    </div>
  
</div>


  </aside>


    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">第13章 PE文件格式</h1>
            
              <p class="note note-info">
                
                  
                    本文最后更新于：2022年5月19日 晚上
                  
                
              </p>
            
            <div class="markdown-body">
              
              <p>本章将详细讲解Windows操作系统的PE（Portable Executable）文件格式相关知识。学习PE文件格式的过程中，也一起整理一下有关进程、内存、DLL等的内容，它们是Windows操作系统最核心的部分。</p>
<h1 id="13-1-介绍"><a href="#13-1-介绍" class="headerlink" title="13.1 介绍"></a>13.1 介绍</h1><p>PE文件是Windows操作系统下使用的可执行文件格式。它是微软在UNIX平台的COFF（Common Object File Format，通用对象文件格式）基础上制作而成的。最初（正如Portable这个单词所代表的那样）设计用来提高程序在不同操作系统上的移植性，但实际上这种文件格式仅用在Windows系列的操作系统下。</p>
<p>PE文件是指32位的可执行文件，也称为PE32。64位的可执行文件称为PE+或PE32+，是PE（PE32）文件的一种扩展形式（请注意不是PE64 ）。</p>
<h1 id="13-2-PE文件格式"><a href="#13-2-PE文件格式" class="headerlink" title="13.2 PE文件格式"></a>13.2 PE文件格式</h1><p>PE文件种类如下表所示。</p>
<table>
<thead>
<tr>
<th>种类</th>
<th>主拓展名</th>
</tr>
</thead>
<tbody><tr>
<td>可执行系列</td>
<td>EXE、SCR</td>
</tr>
<tr>
<td>库系列</td>
<td>DLL、OCX、CPL、DRV</td>
</tr>
<tr>
<td>驱动程序系列</td>
<td>SYS、VXD</td>
</tr>
<tr>
<td>对象文件系列</td>
<td>OBJ</td>
</tr>
</tbody></table>
<p>严格地说，OBJ （对象）文件之外的所有文件都是可执行的。DLL、SYS文件等虽然不能直接在Shell （Explorer.exe）中运行，但可以使用其他方法（调试器、服务等）执行。</p>
<blockquote>
<p>根据PE正式规范，编译结果OBJ文件也视为PE文件。但是OBJ文件本身不能以任何形式执行，在代码逆向分析中几乎不需要关注它。</p>
</blockquote>
<p>下面以记事本（notepad.exe）程序进行简单说明，首先使用Hex Editor打开记事本程序。 </p>
<p>下图是notepad.exe文件的起始部分，也是PE文件的头部分（PE header）。notepad.exe文件运行需要的所有信息就存储在这个PE头中。如何加载到内存、从何处开始运行、运行中需要的DLL有哪些、需要多大的栈&#x2F;堆内存等，大量信息以结构体形式存储在PE头中。换言之，学习PE文件格式就是学习PE头中的结构体。</p>
<p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC13%E7%AB%A0%20PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F.assets/image-20211203222319938.png" srcset="https://picbedddd.oss-cn-beijing.aliyuncs.com/blog/loading.gif" lazyload alt="image-20211203222319938"></p>
<p>书中将以Windows XP SP3的notepad.exe为例进行说明，与其他版本Windows下 的notepad.exe文件结构类似，但是地址不同。在我的随书实验过程中，我使用的是32位win7的文件夹底下的notepad进行实验。</p>
<h2 id="13-2-1-基本结构"><a href="#13-2-1-基本结构" class="headerlink" title="13.2.1 基本结构"></a>13.2.1 基本结构</h2><p>notepad.exe具有普通PE文件的基本结构。下图描述了notepad.exe文件加载到内存时的情形。<br>其中包含了许多内容，下面逐一学习。</p>
<p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC13%E7%AB%A0%20PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F.assets/image-20211203222351309.png" srcset="https://picbedddd.oss-cn-beijing.aliyuncs.com/blog/loading.gif" lazyload alt="image-20211203222351309"></p>
<p>从DOS头（DOS header）到节区头（Section header）是PE头部分，其下的节区合称PE体。文件中使用偏移（offset），内存中使用VA （Virtual Address，虚拟地址）来表示位置。文件加载到内存时，情况就会发生变化（节区的大小、位置等）。文件的内容一般可分为代码（.text）、数据（.data ）、资源（.rsrc ）节，分别保存。</p>
<blockquote>
<p>根据所用的不同开发工具（VB&#x2F;VC++&#x2F;Delphi&#x2F;etc）与编译选项，节区的名称、大小、<br>个数、存储的内容等都是不同的。最重要的是它们按照不同的用途分类保存到不同的节中。</p>
</blockquote>
<p>各节区头定义了各节区在文件或内存中的大小、位置、属性等。</p>
<p>PE头与各节区的尾部存在一个区域，称为NULL填充（NULL padding）。计算机中，为了提高处理文件、内存、网络包的效率，使用“最小基本单位”这一概念，PE文件中也类似。文件&#x2F;内存中节区的起始位置应该在各文件&#x2F;内存最小单位的倍数位置上，空白区域将用NULL填充（看上图，可以看到各节区起始地址的截断都遵循一定规则）。</p>
<h2 id="13-2-2-VA-amp-RVA-amp-FOA-RAW"><a href="#13-2-2-VA-amp-RVA-amp-FOA-RAW" class="headerlink" title="13.2.2 VA&amp;RVA&amp;FOA(RAW)"></a>13.2.2 VA&amp;RVA&amp;FOA(RAW)</h2><p>VA指的是进程虚拟内存的绝对地址，RVA ( Relative Virtual Address,相对虚拟地址）指从某个基准位置(ImageBase )开始的相对地址。</p>
<p>VA与RVA满足的换算关系为<code>RVA+ImageBase=VA</code></p>
<p>PE头内部信息大多以RVA形式存在。原因在于，PE文件（主要是DLL)加载到进程虚拟内存的特定位置时，该位置可能已经加载了其他PE文件（DLL )。此时必须通过重定位（Relocation )将其加载到其他空白的位置，若PE头信息使用的是VA，则无法正常访问。因此使用RVA来定位信息，即使发生了重定位，只要相对于基准位置的相对地址没有变化，就能正常访问到指定信息，不会出现任何问题</p>
<p>至于FOV的话就比较简单，它是文件中的偏移地址</p>
<blockquote>
<p>32位Windows OS中，各进程分配有4GB的虚拟内存，因此进程中VA值的范围是00000000〜FFFFFFFF。</p>
</blockquote>
<h1 id="13-3-PE头"><a href="#13-3-PE头" class="headerlink" title="13.3 PE头"></a>13.3 PE头</h1><p>PE头由许多结构体组成，现在开始逐一学习各结构体。此外还会详细讲解在代码逆向分析中起着重要作用的结构体成员。</p>
<h2 id="13-3-1-DOS-头"><a href="#13-3-1-DOS-头" class="headerlink" title="13.3.1 DOS 头"></a>13.3.1 DOS 头</h2><p>微软创建PE文件格式时，入们正广泛使用DOS文件，所以微软充分考虑了PE文件对DOS文件的兼容性。其结果是在PE头的最前面添加了一个IMAGE_DOS_HEADER结构体，用来扩展已有的DOS EXE头。</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs awk">IMAGE_DOS_HEADER STRUCT<br>&#123;<br>+<span class="hljs-number">0</span>h 	WORD e_magic    	<span class="hljs-regexp">//</span> Magic DOS signature MZ(<span class="hljs-number">4</span>Dh <span class="hljs-number">5</span>Ah)		DOS可执行文件标记<br>+<span class="hljs-number">2</span>h 	WORD e_cblp    		<span class="hljs-regexp">//</span> Bytes on last page of file<br>+<span class="hljs-number">4</span>h 	WORD e_cp    		<span class="hljs-regexp">//</span> Pages <span class="hljs-keyword">in</span> file<br>+<span class="hljs-number">6</span>h 	WORD e_crlc    		<span class="hljs-regexp">//</span> Relocations<br>+<span class="hljs-number">8</span>h 	WORD e_cparhdr   	<span class="hljs-regexp">//</span> Size of header <span class="hljs-keyword">in</span> paragraphs<br>+<span class="hljs-number">0</span>ah 	WORD e_minalloc   	<span class="hljs-regexp">//</span> Minimun extra paragraphs needs<br>+<span class="hljs-number">0</span>ch 	WORD e_maxalloc  	<span class="hljs-regexp">//</span> Maximun extra paragraphs needs<br>+<span class="hljs-number">0</span>eh 	WORD e_ss           <span class="hljs-regexp">//</span> intial(relative)SS value        		DOS代码的初始化堆栈SS<br>+<span class="hljs-number">10</span>h 	WORD e_sp     		<span class="hljs-regexp">//</span> intial SP value                      DOS代码的初始化堆栈指针SP<br>+<span class="hljs-number">12</span>h 	WORD e_csum     	<span class="hljs-regexp">//</span> Checksum<br>+<span class="hljs-number">14</span>h 	WORD e_ip     		<span class="hljs-regexp">//</span> intial IP value               		DOS代码的初始化指令入口[指针IP]<br>+<span class="hljs-number">16</span>h 	WORD e_cs     		<span class="hljs-regexp">//</span> intial(relative)CS value         	DOS代码的初始堆栈入口<br>+<span class="hljs-number">18</span>h 	WORD e_lfarlc     	<span class="hljs-regexp">//</span> File Address of relocation table<br>+<span class="hljs-number">1</span>ah 	WORD e_ovno         <span class="hljs-regexp">//</span> Overlay number<br>+<span class="hljs-number">1</span>ch 	WORD e_res[<span class="hljs-number">4</span>]      	<span class="hljs-regexp">//</span> Reserved words<br>+<span class="hljs-number">24</span>h 	WORD e_oemid      	<span class="hljs-regexp">//</span> OEM identifier(<span class="hljs-keyword">for</span> e_oeminfo)<br>+<span class="hljs-number">26</span>h 	WORD e_oeminfo   	<span class="hljs-regexp">//</span> OEM information;e_oemid specific<br>+<span class="hljs-number">29</span>h 	WORD e_res2[<span class="hljs-number">10</span>]   	<span class="hljs-regexp">//</span> Reserved words<br>+<span class="hljs-number">3</span>ch 	DWORD e_lfanew     	<span class="hljs-regexp">//</span>  Offset to start of PE header      	指向PE文件头<br>&#125; IMAGE_DOS_HEADER ENDS<br></code></pre></td></tr></table></figure>



<h3 id="自实现代码解析"><a href="#自实现代码解析" class="headerlink" title="自实现代码解析"></a>自实现代码解析</h3><p>IMAGE_DOS_HEADER结构体的大小为40个字节。在其中最重要的两个字段如下：</p>
<p>e_magic：一个WORD类型，值是一个常数0x4D5A，用文本编辑器查看该值位‘MZ’，可执行文件必须都是’MZ’开头。<br>e_lfanew：为32位可执行文件扩展的域，用来表示DOS头之后的NT头相对文件起始地址的偏移。</p>
<p>使用Hex Editor打开notepad.exe，查看IMAGE_DOS_HEADERS结构体，可以看上面打开的图。根据PE规范，文件开始的2个字节为4D5A，e_lfanew值为000000E0（不是E0000000）。</p>
<blockquote>
<p>Intel系列的CPU以逆序存储数据，这称为小端序标识法。</p>
</blockquote>
<p>自己写代码可以加深对PE头的理解，接下来手写代码解析MS-DOS头：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;Windows.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    FILE *pFile = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-type">char</span> *buffer;<br>    <span class="hljs-type">int</span> nFileLength = <span class="hljs-number">0</span>;<br>    pFile = fopen(<span class="hljs-string">&quot;C:\\Users\\shinelon\\Desktop\\notepad.exe&quot;</span>, <span class="hljs-string">&quot;rb&quot;</span>);<br>    fseek(pFile, <span class="hljs-number">0</span>, SEEK_END); <span class="hljs-comment">// 将文件位置指针定位到文件结尾，从SEEK_END开始，偏移0个字节</span><br>    nFileLength = ftell(pFile); <span class="hljs-comment">//返回当前文件位置指针相对于文件开始的距离，在这里就是文件的大小</span><br>    rewind(pFile); <span class="hljs-comment">//将文件位置指针倒回文件开始</span><br>    <span class="hljs-type">int</span> imageLength = nFileLength * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">char</span>) + <span class="hljs-number">1</span>;<br>    buffer = (<span class="hljs-type">char</span> *) <span class="hljs-built_in">malloc</span>(imageLength);<br>    <span class="hljs-built_in">memset</span>(buffer, <span class="hljs-number">0</span>, imageLength);<br>    fread(buffer, <span class="hljs-number">1</span>, imageLength, pFile);<br><br>    PIMAGE_DOS_HEADER dosHeader = (PIMAGE_DOS_HEADER)buffer;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%x&quot;</span>, dosHeader-&gt;e_magic);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%x&quot;</span>, dosHeader-&gt;e_lfanew);<br><br>    <span class="hljs-built_in">free</span>(buffer);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="13-3-2-DOS存根"><a href="#13-3-2-DOS存根" class="headerlink" title="13.3.2 DOS存根"></a>13.3.2 DOS存根</h2><p>DOS存根（stub）在DOS头下方，是个可选项，且大小不固定（即使没有DOS存根，文件也能正常运行）。DOS存根由代码与数据混合而成，下图显示的就是notepad.exe的DOS存根。</p>
<p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC13%E7%AB%A0%20PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F.assets/image-20211203225009480.png" srcset="https://picbedddd.oss-cn-beijing.aliyuncs.com/blog/loading.gif" lazyload alt="image-20211203225009480"></p>
<p>上图中，文件偏移40~4D区域为16位的汇编指令。32位的Windows OS中不会运行该命令（由于被识别为PE文件，所以完全忽视该代码）。在DOS环境中运行Notepad.exe文件，或者使用DOS调试器（debug.exe）运行它，可使其执行该代码（不认识PE文件格式，所以被识别为DOS EXE文件）。</p>
<p>打开命令行窗口（cmd.exe），输入如下命令（仅适用于Windows XP环境）。</p>
<p>debug C:\Windows\notepad.exe</p>
<p>在出现的光标位置上输入“u”指令（Unassemble），将会岀现16位的汇编指令，如下所示。</p>
<p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC13%E7%AB%A0%20PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F.assets/image-20211203224614355.png" srcset="https://picbedddd.oss-cn-beijing.aliyuncs.com/blog/loading.gif" lazyload alt="image-20211203224614355"></p>
<p>对汇编代码的解释参考书：</p>
<p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC13%E7%AB%A0%20PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F.assets/image-20211203224855360.png" srcset="https://picbedddd.oss-cn-beijing.aliyuncs.com/blog/loading.gif" lazyload alt="image-20211203224855360"></p>
<p>代码非常简单，在画面中输岀字符串“This program cannot be run in DOS mode”后就退出。<br>换言之，notepad.exe文件虽然是32位的PE文件，但是带有MS-DOS兼容模式，可以在DOS环境中运行，执行DOS EXE代码，输出“This program cannot be run in DOS mode”后终止。灵活使用该特性可以在一个可执行文件（EXE）中创建岀另一个文件，它在DOS与Windows中都能运行（在DOS环境中运行16位DOS代码，在Windows环境中运行32位Windows代码）。</p>
<p>如前所述，DOS存根是可选项，开发工具应该支持它（VB、VC++、Delphi等默认支持DOS存根）</p>
<h2 id="13-3-3-NT头"><a href="#13-3-3-NT头" class="headerlink" title="13.3.3 NT头"></a>13.3.3 NT头</h2><p>NT头结构体如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IMAGE_NT_HEADERS</span> &#123;</span><br>    DWORD Signature;<br>    IMAGE_FILE_HEADER FileHeader;<br>    IMAGE_OPTIONAL_HEADER32 OptionalHeader;<br>&#125; IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32;<br></code></pre></td></tr></table></figure>



<p>IMAGE_NT_HEADERS结构体由3个成员组成，第一个成员为签名（Signature ）结构体，其值为50450000h（ “PE” 00 ）。另外两个成员分别为文件头（File Header）与可选头（ Optional Header）结构体。使用Hex Editor打开notepad.exe，查看IMAGE_NT_HEADERS，如下图所示。</p>
<p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC13%E7%AB%A0%20PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F.assets/image-20211204094323666.png" srcset="https://picbedddd.oss-cn-beijing.aliyuncs.com/blog/loading.gif" lazyload alt="image-20211204094323666"></p>
<p>IMAGE_NT_HEADERS结构体的大小为F8，相当大。下面分别讲解文件头与可选头结构体。</p>
<h2 id="13-3-4-NT头：文件头"><a href="#13-3-4-NT头：文件头" class="headerlink" title="13.3.4 NT头：文件头"></a>13.3.4 NT头：文件头</h2><h3 id="IMAGE-FILE-HEADER"><a href="#IMAGE-FILE-HEADER" class="headerlink" title="IMAGE_FILE_HEADER"></a>IMAGE_FILE_HEADER</h3><p>文件头是表现文件大致属性的结构体。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IMAGE_FILE_HEADER</span> &#123;</span><br>    WORD    Machine;<br>    WORD    NumberOfSections;<br>    DWORD   TimeDateStamp;<br>    DWORD   PointerToSymbolTable;<br>    DWORD   NumberOfSymbols;<br>    WORD    SizeOfOptionalHeader;<br>    WORD    Characteristics;<br>&#125; IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;<br></code></pre></td></tr></table></figure>

<p>IMAGE_FILE_HEADERS结构体中有如下4种重要成员（若它们设置不正确，将导致文件无法正常运行）。</p>
<h4 id="Machine"><a href="#Machine" class="headerlink" title="Machine"></a>Machine</h4><p>每个CPU都拥有唯一的Machine码，兼容32位Intel x86芯片的Machine码为14C。以下是定义在winnt.h文件中的Machine码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_FILE_MACHINE_UNKNOWN           0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_FILE_MACHINE_TARGET_HOST       0x0001  <span class="hljs-comment">// Useful for indicating we want to interact with the host and not a WoW guest.</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_FILE_MACHINE_I386              0x014c  <span class="hljs-comment">// Intel 386.</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_FILE_MACHINE_R3000             0x0162  <span class="hljs-comment">// MIPS little-endian, 0x160 big-endian</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_FILE_MACHINE_R4000             0x0166  <span class="hljs-comment">// MIPS little-endian</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_FILE_MACHINE_R10000            0x0168  <span class="hljs-comment">// MIPS little-endian</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_FILE_MACHINE_WCEMIPSV2         0x0169  <span class="hljs-comment">// MIPS little-endian WCE v2</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_FILE_MACHINE_ALPHA             0x0184  <span class="hljs-comment">// Alpha_AXP</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_FILE_MACHINE_SH3               0x01a2  <span class="hljs-comment">// SH3 little-endian</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_FILE_MACHINE_SH3DSP            0x01a3</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_FILE_MACHINE_SH3E              0x01a4  <span class="hljs-comment">// SH3E little-endian</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_FILE_MACHINE_SH4               0x01a6  <span class="hljs-comment">// SH4 little-endian</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_FILE_MACHINE_SH5               0x01a8  <span class="hljs-comment">// SH5</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_FILE_MACHINE_ARM               0x01c0  <span class="hljs-comment">// ARM Little-Endian</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_FILE_MACHINE_THUMB             0x01c2  <span class="hljs-comment">// ARM Thumb/Thumb-2 Little-Endian</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_FILE_MACHINE_ARMNT             0x01c4  <span class="hljs-comment">// ARM Thumb-2 Little-Endian</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_FILE_MACHINE_AM33              0x01d3</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_FILE_MACHINE_POWERPC           0x01F0  <span class="hljs-comment">// IBM PowerPC Little-Endian</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_FILE_MACHINE_POWERPCFP         0x01f1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_FILE_MACHINE_IA64              0x0200  <span class="hljs-comment">// Intel 64</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_FILE_MACHINE_MIPS16            0x0266  <span class="hljs-comment">// MIPS</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_FILE_MACHINE_ALPHA64           0x0284  <span class="hljs-comment">// ALPHA64</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_FILE_MACHINE_MIPSFPU           0x0366  <span class="hljs-comment">// MIPS</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_FILE_MACHINE_MIPSFPU16         0x0466  <span class="hljs-comment">// MIPS</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_FILE_MACHINE_AXP64             IMAGE_FILE_MACHINE_ALPHA64</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_FILE_MACHINE_TRICORE           0x0520  <span class="hljs-comment">// Infineon</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_FILE_MACHINE_CEF               0x0CEF</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_FILE_MACHINE_EBC               0x0EBC  <span class="hljs-comment">// EFI Byte Code</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_FILE_MACHINE_AMD64             0x8664  <span class="hljs-comment">// AMD64 (K8)</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_FILE_MACHINE_M32R              0x9041  <span class="hljs-comment">// M32R little-endian</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_FILE_MACHINE_ARM64             0xAA64  <span class="hljs-comment">// ARM64 Little-Endian</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_FILE_MACHINE_CEE               0xC0EE</span><br></code></pre></td></tr></table></figure>



<h4 id="NumberOfSections"><a href="#NumberOfSections" class="headerlink" title="NumberOfSections"></a>NumberOfSections</h4><p>​	前面提到过，PE文件把代码、数据、资源等依据属性分类到各节区中存储。<br>​	<code>NumberOfSections</code>用来指出文件中存在的节区数量。该值一定要大于0，且当定义的节区数量与实际节区不同时，将发生运行错误。</p>
<h4 id="TimeDateStamp"><a href="#TimeDateStamp" class="headerlink" title="TimeDateStamp"></a>TimeDateStamp</h4><p>​	该PE文件生成的时间。该成员的值不影响文件运行，用 来记录编译器创建此文件的时间。但是有些开发工具（VB、VC++)提供了设置该值的工具，而有些开发工具（Delphi)则未提供（且随所用选项的不同而不同）。</p>
<h4 id="PointerToSymbolTable"><a href="#PointerToSymbolTable" class="headerlink" title="PointerToSymbolTable"></a>PointerToSymbolTable</h4><p>这个已经逐渐弃用了，这里不再介绍。</p>
<h4 id="NumberOfSymbols"><a href="#NumberOfSymbols" class="headerlink" title="NumberOfSymbols"></a>NumberOfSymbols</h4><p>这个已经逐渐弃用了，这里不再介绍。</p>
<h4 id="SizeOfOptionalHeader"><a href="#SizeOfOptionalHeader" class="headerlink" title="SizeOfOptionalHeader"></a>SizeOfOptionalHeader</h4><p>​	<code>IMAGE_NT_HEADER</code>结构体的最后一个成员为<code>IMAGE_OPTIONAL_HEADER32</code>结构体。<code>SizeOfOptionalHeader</code>成员用来指岀 <code>IMAGE_OPTIONAL_HEADER32</code>结构体的长度。<code>IMAGE_OPTIONAL_HJEADER32</code>结构体由C语言编写而成，故其大小已经确定。但是Windows的PE装载器需要查看<code>IMAGE_FILE_HEADER</code>的<code>SizeOfOptionalHeader</code>值，从而识别出<code>MAGE_OPTIONAL_HEADER32</code>结构体的大小。</p>
<p>​	PE32+格式的文件中使用的是<code>IMAGE_OPTIONAL_HEADER64</code>结构体，而不是<code>IMAGE_OPTIONAL_HEADER32</code>结构体。2个结构体的尺寸是不同的，所以需要在<code>SizeOfOptionaUieader</code>成员中明确指出结构体的大小。</p>
<blockquote>
<p>借助 IMAGE_DOS_HEADER 的 ejfanew 成员与 IMAGE_FILE_HEADER 的SizeOfOptionalHeader成员，可以创建出一种脱离常规的PE文件（PE Patch )(也有入称之为“麻花” PE文件）。</p>
</blockquote>
<h4 id="Characteristics"><a href="#Characteristics" class="headerlink" title="Characteristics"></a>Characteristics</h4><p>​	该字段用于标识文件的属性，文件是否是可运行的形态、是否为DLL文件等信息，以bit OR形式组合起来。以下是定义在winnt.h文件中的（请记住0002h与2000h这两个值)。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_FILE_RELOCS_STRIPPED           0x0001  <span class="hljs-comment">// Relocation info stripped from file.</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_FILE_EXECUTABLE_IMAGE          0x0002  <span class="hljs-comment">// File is executable  (i.e. no unresolved external references).</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_FILE_LINE_NUMS_STRIPPED        0x0004  <span class="hljs-comment">// Line nunbers stripped from file.</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_FILE_LOCAL_SYMS_STRIPPED       0x0008  <span class="hljs-comment">// Local symbols stripped from file.</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_FILE_AGGRESIVE_WS_TRIM         0x0010  <span class="hljs-comment">// Aggressively trim working set</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_FILE_LARGE_ADDRESS_AWARE       0x0020  <span class="hljs-comment">// App can handle &gt;2gb addresses</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_FILE_BYTES_REVERSED_LO         0x0080  <span class="hljs-comment">// Bytes of machine word are reversed.</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_FILE_32BIT_MACHINE             0x0100  <span class="hljs-comment">// 32 bit word machine.</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_FILE_DEBUG_STRIPPED            0x0200  <span class="hljs-comment">// Debugging info stripped from file in .DBG file</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_FILE_REMOVABLE_RUN_FROM_SWAP   0x0400  <span class="hljs-comment">// If Image is on removable media, copy and run from the swap file.</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_FILE_NET_RUN_FROM_SWAP         0x0800  <span class="hljs-comment">// If Image is on Net, copy and run from the swap file.</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_FILE_SYSTEM                    0x1000  <span class="hljs-comment">// System File.</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_FILE_DLL                       0x2000  <span class="hljs-comment">// File is a DLL.</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_FILE_UP_SYSTEM_ONLY            0x4000  <span class="hljs-comment">// File should only be run on a UP machine</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_FILE_BYTES_REVERSED_HI         0x8000  <span class="hljs-comment">// Bytes of machine word are reversed.</span></span><br></code></pre></td></tr></table></figure>



<p>​	另外，PE文件中Characteristics的值有可能不是0002h吗（不可执行）？是的，确实存在这种情况。比如类似*.obj的object文件及resource DLL文件等。</p>
<h3 id="自实现代码解析-1"><a href="#自实现代码解析-1" class="headerlink" title="自实现代码解析"></a>自实现代码解析</h3><p>编写如下代码对PE文件的FileHeader进行分析：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;Windows.h&gt;</span></span><br><br><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    FILE* pFile = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-type">char</span>* buffer;<br>    <span class="hljs-type">int</span> nFileLength = <span class="hljs-number">0</span>;<br>    pFile = fopen(<span class="hljs-string">&quot;C:\\Users\\shinelon\\Desktop\\Caesium.exe&quot;</span>, <span class="hljs-string">&quot;rb&quot;</span>);<br>    fseek(pFile, <span class="hljs-number">0</span>, SEEK_END); <span class="hljs-comment">// 将文件位置指针定位到文件结尾，从SEEK_END开始，偏移0个字节</span><br>    nFileLength = ftell(pFile); <span class="hljs-comment">//返回当前文件位置指针相对于文件开始的距离，在这里就是文件的大小</span><br>    rewind(pFile); <span class="hljs-comment">//将文件位置指针倒回文件开始</span><br>    <span class="hljs-type">int</span> imageLength = nFileLength * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">char</span>) + <span class="hljs-number">1</span>;<br>    buffer = (<span class="hljs-type">char</span>*)<span class="hljs-built_in">malloc</span>(imageLength);<br>    <span class="hljs-built_in">memset</span>(buffer, <span class="hljs-number">0</span>, imageLength);<br>    fread(buffer, <span class="hljs-number">1</span>, imageLength, pFile);<br><br>    PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)buffer;<br>    PIMAGE_NT_HEADERS  pNtHeaders = (PIMAGE_NT_HEADERS)(buffer + pDosHeader-&gt;e_lfanew);<br>    PIMAGE_FILE_HEADER pfileHeader = &amp;(pNtHeaders-&gt;FileHeader);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%x&quot;</span>, pfileHeader-&gt;Machine);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%x&quot;</span>, pfileHeader-&gt;NumberOfSections);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%x&quot;</span>, pfileHeader-&gt;Characteristics);<br><br><br>    <span class="hljs-built_in">free</span>(buffer);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure>







<h2 id="13-3-5-NT头：可选头"><a href="#13-3-5-NT头：可选头" class="headerlink" title="13.3.5 NT头：可选头"></a>13.3.5 NT头：可选头</h2><p>表面上有的头是Optional的，实际上它是最大也是最为重要的一个PE结构。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//</span><br><span class="hljs-comment">// Directory format.</span><br><span class="hljs-comment">//</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IMAGE_DATA_DIRECTORY</span> &#123;</span><br>    DWORD   VirtualAddress;<br>    DWORD   Size;<br>&#125; IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_NUMBEROF_DIRECTORY_ENTRIES    16</span><br><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Optional header format.</span><br><span class="hljs-comment">//</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IMAGE_OPTIONAL_HEADER</span> &#123;</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// Standard fields.</span><br>    <span class="hljs-comment">//</span><br><br>    WORD    Magic;<br>    BYTE    MajorLinkerVersion;<br>    BYTE    MinorLinkerVersion;<br>    DWORD   SizeOfCode;<br>    DWORD   SizeOfInitializedData;<br>    DWORD   SizeOfUninitializedData;<br>    DWORD   AddressOfEntryPoint;<br>    DWORD   BaseOfCode;<br>    DWORD   BaseOfData;<br><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// NT additional fields.</span><br>    <span class="hljs-comment">//</span><br><br>    DWORD   ImageBase;<br>    DWORD   SectionAlignment;<br>    DWORD   FileAlignment;<br>    WORD    MajorOperatingSystemVersion;<br>    WORD    MinorOperatingSystemVersion;<br>    WORD    MajorImageVersion;<br>    WORD    MinorImageVersion;<br>    WORD    MajorSubsystemVersion;<br>    WORD    MinorSubsystemVersion;<br>    DWORD   Win32VersionValue;<br>    DWORD   SizeOfImage;<br>    DWORD   SizeOfHeaders;<br>    DWORD   CheckSum;<br>    WORD    Subsystem;<br>    WORD    DllCharacteristics;<br>    DWORD   SizeOfStackReserve;<br>    DWORD   SizeOfStackCommit;<br>    DWORD   SizeOfHeapReserve;<br>    DWORD   SizeOfHeapCommit;<br>    DWORD   LoaderFlags;<br>    DWORD   NumberOfRvaAndSizes;<br>    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];<br>&#125; IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;<br></code></pre></td></tr></table></figure>



<p>在IMAGE_OPTIONAL_HEADER32结构体中需要关注下列成员。这些值是文件运行必需的，设置错误将导致文件无法正常运行。</p>
<ol>
<li><p>Magic<br>为IMAGE_OPTIONAL_HEADER32结构体时，Magic码为 10B ;为 IMAGE_OPTIONAL_HEADER64结构体时，Magic码为20B。</p>
</li>
<li><p>AddressOfEntryPoint<br>AddressOffEntryPoint持有EP的RVA值。该值指出程序最先执行的代码起始地址，相当重要。</p>
</li>
<li><p>ImageBase<br>进程虚拟内存的范围是0〜FFFFFFFF （32位系统）。PE文件被加载到如此大的内存中时，ImageBase指出文件的优先装入地址。EXE、DLL文件被装载到用户内存的0〜7FFFFFFF中，SYS文件被载入内核内存的80000000〜FFFFFFFF中。一般而言，使用开发工具（VB&#x2F;VO+&#x2F;Delphi）创建好EXE文件后，其ImageBase的值为00400000, DLL文件的ImageBase值为10000000 (当然也可以指定为其他值）。执行PE文件时，PE装载器先创建进程，再将文件载入内存，然后把EIP寄存器的值设置为ImageBase+AddressOfEntryPoint。</p>
</li>
<li><p>SectionAlignment,FileAlignment<br>PE文件的Body部分划分为若干节区，这些节存储着不同类别的数据。FileAlignment指定了节区在磁盘文件中的最小单位，而SectionAlignment则指定了节区在内存中的最小单位（一个文件中，FileAlignment与SectionAlignment的值可能相同，也可能不同）。磁盘文件或内存的节区大小必定为FileAlignment或SectionAlignment值的整数倍。</p>
</li>
<li><p>SizeOfImage<br>加载PE文件到内存时，SizeOfImage指定了PE Image在虚拟内存中所#占空间的大小。一般而言，文件的大小与加载到内存中的大小是不同的（节区头中定义了各节装载的位置与占有内存的大小，后面会讲到）。 </p>
</li>
<li><p>SizeOfHeader<br>SizeOfHeader用来指出整个PE头的大小。该值也必须是FileAlignment的整数倍。第一节区所在位置与SizeOfHeader距文件开始偏移的量相同。</p>
</li>
<li><p>Subsystem<br>该Subsystem值用来区分系统驱动文件（*.sys )与普通的可执行文件（*.exe, *.dll）。 Subsystem成员可拥有的值如表13-2所示（部分）。</p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_SUBSYSTEM_UNKNOWN              0   <span class="hljs-comment">// Unknown subsystem.</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_SUBSYSTEM_NATIVE               1   <span class="hljs-comment">// Image doesn&#x27;t require a subsystem. 通常为驱动文件</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_SUBSYSTEM_WINDOWS_GUI          2   <span class="hljs-comment">// Image runs in the Windows GUI subsystem. 窗口应用程序</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_SUBSYSTEM_WINDOWS_CUI          3   <span class="hljs-comment">// Image runs in the Windows character subsystem. 控制台应用程序</span></span><br></code></pre></td></tr></table></figure>



<ol start="8">
<li><p>NumberOfRvaAndSizes<br>NumberOfRvaAndSizes 用来指定DataDirectory（IMAGE_OPTIONAL_HEADER32结构体的最后一个成员）数组的个数。虽然结构体定义中明确指出了数组个数为IMAGE_NUMBEROF_DIRECTORY_ENTRIES(16),但是PE装载器通过查看NumberOfRvaAndSizes值来识别数组大小，换言之，数组大小也可能不是16。</p>
</li>
<li><p>DataDirectory<br>DataDirectory是由IMAGE_DATA_DIRECTORY结构体组成的数组，数组的每项都有被定义的值。如下列出了各数组项</p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Directory Entries</span><br><span class="hljs-comment">// 标*的是我们重点需要关注的内容，其他的了解一下即可</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_DIRECTORY_ENTRY_EXPORT          0   <span class="hljs-comment">// Export Directory				*  </span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_DIRECTORY_ENTRY_IMPORT          1   <span class="hljs-comment">// Import Directory				*</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_DIRECTORY_ENTRY_RESOURCE        2   <span class="hljs-comment">// Resource Directory				*</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_DIRECTORY_ENTRY_EXCEPTION       3   <span class="hljs-comment">// Exception Directory</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_DIRECTORY_ENTRY_SECURITY        4   <span class="hljs-comment">// Security Directory</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_DIRECTORY_ENTRY_BASERELOC       5   <span class="hljs-comment">// Base Relocation Table</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_DIRECTORY_ENTRY_DEBUG           6   <span class="hljs-comment">// Debug Directory</span></span><br><span class="hljs-comment">//      IMAGE_DIRECTORY_ENTRY_COPYRIGHT       7   // (X86 usage)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_DIRECTORY_ENTRY_ARCHITECTURE    7   <span class="hljs-comment">// Architecture Specific Data</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_DIRECTORY_ENTRY_GLOBALPTR       8   <span class="hljs-comment">// RVA of GP</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_DIRECTORY_ENTRY_TLS             9   <span class="hljs-comment">// TLS Directory					*</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG    10   <span class="hljs-comment">// Load Configuration Directory</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT   11   <span class="hljs-comment">// Bound Import Directory in headers</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_DIRECTORY_ENTRY_IAT            12   <span class="hljs-comment">// Import Address Table</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT   13   <span class="hljs-comment">// Delay Load Import Descriptors</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR 14   <span class="hljs-comment">// COM Runtime descriptor</span></span><br></code></pre></td></tr></table></figure>



<p>如下是notepad.exe的IMAGE_OPTIONAL_HEADER结构体。</p>
<p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC13%E7%AB%A0%20PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F.assets/image-20211204095701399.png" srcset="https://picbedddd.oss-cn-beijing.aliyuncs.com/blog/loading.gif" lazyload alt="image-20211204095701399"></p>
<h2 id="13-3-6-节区头"><a href="#13-3-6-节区头" class="headerlink" title="13.3.6 节区头"></a>13.3.6 节区头</h2><p>​	节区头中定义了各节区属性。看节区头之前先思考一下：前面提到过，PE文件中的code (代码）、data (数据）、resource (资源）等按照属性分类存储在不同节区，设计PE文件格式的工程师们之所以这样做，一定有着某些好处。</p>
<p>​	我认为把PE文件创建成多个节区结构的好处是，这样可以保证程序的安全性。若把code与data放在一个节区中相互纠缠（实际上完全可以这样做）很容易引发安全问题，即使忽略过程的烦琐。	<br>​	假如向字符串data写数据时，由于某个原因导致溢出（输入超过缓冲区大小时），那么其下的code (指令）就会被覆盖，应用程序就会崩溃。因此，PE文件格式的设计者们决定把具有相似属性的数据统一保存在一个被称为“节区”的地方，然后需要把各节区属性记录在节区头中（节区属性中有文件&#x2F;内存的起始位置、大小、访问权限等)。</p>
<p>​	换言之，需要为每个code&#x2F;data&#x2F;resource分别设置不同的特性、访问权限等，如下表。</p>
<table>
<thead>
<tr>
<th>节名</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>. text&#x2F;.code</td>
<td>.exe或DLL文件的代码</td>
</tr>
<tr>
<td>. data</td>
<td>已经初始化的数据</td>
</tr>
<tr>
<td>. edata</td>
<td>输出文件名表</td>
</tr>
<tr>
<td>. idata</td>
<td>输入文件名表</td>
</tr>
<tr>
<td>. rdata</td>
<td>运行期只读数据</td>
</tr>
<tr>
<td>. reloc</td>
<td>重定位表信息</td>
</tr>
<tr>
<td>. rsrc</td>
<td>资源</td>
</tr>
<tr>
<td>. bss</td>
<td>未经初始化的数据</td>
</tr>
<tr>
<td>. crt</td>
<td>C运行期只读数据</td>
</tr>
<tr>
<td>. debug</td>
<td>调试信息</td>
</tr>
<tr>
<td>. didata</td>
<td>延迟输入文件名表</td>
</tr>
<tr>
<td>. tls</td>
<td>线程的本地存储器</td>
</tr>
<tr>
<td>. xdata</td>
<td>异常处理表</td>
</tr>
</tbody></table>
<p>​	至此，大家应当对节区头的作用有了大致了解。</p>
<h3 id="IMAGE-SECTION-HEADER"><a href="#IMAGE-SECTION-HEADER" class="headerlink" title="IMAGE_SECTION_HEADER"></a>IMAGE_SECTION_HEADER</h3><p>节区头是由IMAGE_SECTION_HEADER结构体组成的数组，每个结构体对应一个节区。下面代码给出节区头的结构体定义。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IMAGE_SECTION_HEADER</span> &#123;</span><br>    BYTE    Name[IMAGE_SIZEOF_SHORT_NAME];<br>    <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>            DWORD   PhysicalAddress;<br>            DWORD   VirtualSize; <span class="hljs-comment">//内存中所占节区所占大小（内存对齐前的长度）</span><br>    &#125; Misc;<br>    DWORD   VirtualAddress; <span class="hljs-comment">//内存中节区起始地址(RVA)</span><br>    DWORD   SizeOfRawData; <span class="hljs-comment">//磁盘文件中节区所占大小（文件对齐后的长度）</span><br>    DWORD   PointerToRawData; <span class="hljs-comment">//磁盘文件中节区起始位置</span><br>    DWORD   PointerToRelocations;<br>    DWORD   PointerToLinenumbers;<br>    WORD    NumberOfRelocations;<br>    WORD    NumberOfLinenumbers;<br>    DWORD   Characteristics; <span class="hljs-comment">//节区属性(bit OR)</span><br>&#125; IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;<br></code></pre></td></tr></table></figure>


<p>​	这里需要说明的是，VirtualAddress与PointerToRawData不带有任何值，分别由（定义在IMAGE_OPTIONAL_HEADER32中的）SectionAlignment与FileAlignment确定。</p>
<p>​	VirtualSize与SizeOfRawData—般具有不同的值，即磁盘文件中节区的大小与加载到内存中的节区大小是不同的。</p>
<p>​	Characteristics由下面代码中中显示的值组合（bit OR)而成。这里只展示了部分重要的节区属性。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_SCN_CNT_CODE                   0x00000020  <span class="hljs-comment">// Section contains code.</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_SCN_CNT_INITIALIZED_DATA       0x00000040  <span class="hljs-comment">// Section contains initialized data.</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_SCN_CNT_UNINITIALIZED_DATA     0x00000080  <span class="hljs-comment">// Section contains uninitialized data.</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_SCN_MEM_EXECUTE                0x20000000  <span class="hljs-comment">// Section is executable.</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_SCN_MEM_READ                   0x40000000  <span class="hljs-comment">// Section is readable.</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_SCN_MEM_WRITE                  0x80000000  <span class="hljs-comment">// Section is writeable.</span></span><br></code></pre></td></tr></table></figure>



<p>​	最后谈谈Name字段。Name成员不像C语言中的字符串一样以NULL结束，并且没有“必须使用ASCII值”的限制。PE规范未明确规定节区的Name,所以可以向其中放入任何值，甚至可以填充NULL值。所以节区的Name仅供参考，不能保证其百分之百地被用作某种信息（数据节区的名称也可叫做.code )。</p>
<blockquote>
<p>​	讲解PE文件时经常出现“映像”（Image）这一术语，希望各位牢记。PE文件加 栽到内存时，文件不会原封不动地加载，而要根据节区头中定义的节区起始地址、节区大小等加载。因此，磁盘文件中的PE与内存中的PE具有不同形态。将装载到内存中的形态称为“映像”以示区别，使用这一术语能够很好地区分二者</p>
</blockquote>
<h3 id="自实现代码解析-2"><a href="#自实现代码解析-2" class="headerlink" title="自实现代码解析"></a>自实现代码解析</h3><p>编写如下代码可以帮助我们分析节表：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;Windows.h&gt;</span></span><br><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    FILE *pFile = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-type">char</span> *buffer;<br>    <span class="hljs-type">int</span> nFileLength = <span class="hljs-number">0</span>;<br>    pFile = fopen(<span class="hljs-string">&quot;C:\\Users\\shinelon\\Desktop\\Caesium.exe&quot;</span>, <span class="hljs-string">&quot;rb&quot;</span>);<br>    fseek(pFile, <span class="hljs-number">0</span>, SEEK_END); <span class="hljs-comment">// 将文件位置指针定位到文件结尾，从SEEK_END开始，偏移0个字节</span><br>    nFileLength = ftell(pFile); <span class="hljs-comment">//返回当前文件位置指针相对于文件开始的距离，在这里就是文件的大小</span><br>    rewind(pFile); <span class="hljs-comment">//将文件位置指针倒回文件开始</span><br>    <span class="hljs-type">int</span> imageLength = nFileLength * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">char</span>) + <span class="hljs-number">1</span>;<br>    buffer = (<span class="hljs-type">char</span> *) <span class="hljs-built_in">malloc</span>(imageLength);<br>    <span class="hljs-built_in">memset</span>(buffer, <span class="hljs-number">0</span>, imageLength);<br>    fread(buffer, <span class="hljs-number">1</span>, imageLength, pFile);<br><br>    PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER) buffer;<br>    PIMAGE_NT_HEADERS pNtHeaders = (PIMAGE_NT_HEADERS) (buffer + pDosHeader-&gt;e_lfanew);<br>    PIMAGE_FILE_HEADER pFileHeader = &amp;(pNtHeaders-&gt;FileHeader);<br><br><br>    PIMAGE_SECTION_HEADER pSectionHeader = IMAGE_FIRST_SECTION(pNtHeaders);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; pFileHeader-&gt;NumberOfSections; i++) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Name(区段名称):%s\n&quot;</span>, pSectionHeader[i].Name);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;VOffset(起始的相对虚拟地址): %08X\n&quot;</span>, pSectionHeader[i].VirtualAddress);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;VSize(区段大小):%08X\n&quot;</span>, pSectionHeader[i].SizeOfRawData);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ROffset(文件偏移):%08X\n&quot;</span>, pSectionHeader[i].PointerToRawData);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;RSize(文件中区段大小): %08X\n&quot;</span>, pSectionHeader[i].Misc.VirtualSize);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;标记(区段的属性):%08X\n\n&quot;</span>, pSectionHeader[i].Characteristics);<br>    &#125;<br>        <span class="hljs-built_in">free</span>(buffer);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>其中IMAGE_FIRST_SECTION是内置的宏定义，摘抄如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_FIRST_SECTION( ntheader ) ((PIMAGE_SECTION_HEADER)        \</span><br><span class="hljs-meta">    ((ULONG_PTR)(ntheader) +                                            \</span><br><span class="hljs-meta">     FIELD_OFFSET( IMAGE_NT_HEADERS, OptionalHeader ) +                 \</span><br><span class="hljs-meta">     ((ntheader))-&gt;FileHeader.SizeOfOptionalHeader   \</span><br><span class="hljs-meta">    ))</span><br></code></pre></td></tr></table></figure>





<h1 id="13-4-RVAtoRAW"><a href="#13-4-RVAtoRAW" class="headerlink" title="13.4 RVAtoRAW"></a>13.4 RVAtoRAW</h1><p>理解了节区头后，下面继续讲解有关PE文件从磁盘到内存映射的内容。PE文件加载到内存时，每个节区都要能准确完成内存地址与文件偏移间的映射。这种映射一般称为RVA to RAW，方法如下。</p>
<p>(1)查找RVA所在节区。</p>
<p>(2)使用简单的公式计算文件偏移（RAW）。根据IMAGE_SECTION_HEADER结构体，换算公式如下：</p>
<p>RAW - PointerToRawData &#x3D; RVA - VirtualAddress<br>RAW &#x3D; RVA - VirtualAddress + PointerToRawData</p>
<p>为了便于说明，给出之前的notepad.exe在磁盘中和在内存中的拉伸对比图：</p>
<p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC13%E7%AB%A0%20PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F.assets/image-20211130142449550.png" srcset="https://picbedddd.oss-cn-beijing.aliyuncs.com/blog/loading.gif" lazyload alt="image-20211130142449550"></p>
<p>​	这里补充一些东西，一方面我们可以看到这个文件中节区的大小和内存中的是不一样的。这是因为磁盘文件对齐的字节数和内存中的不一样。这里大概可以看出磁盘中对齐字节数是100h，而内存中是4h。</p>
<p>​	另一方面就是书上的Quiz3，题目、答案与解释如下：</p>
<p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC13%E7%AB%A0%20PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F.assets/image-20211130143406915.png" srcset="https://picbedddd.oss-cn-beijing.aliyuncs.com/blog/loading.gif" lazyload alt="image-20211130143406915"></p>
<p>像Q3—样，PE文件节区中因VirtualSize与SizeOfRawData值彼此不同而引起的奇怪、有趣的事还有很多（后面会陆续讲到）。</p>
<blockquote>
<p>RVA与RAW (文件偏移）间的相互变换是PE头的最基本的内容，各位一定要熟悉并掌握它们之间的转换关系。</p>
</blockquote>
<h2 id="自实现代码解析-3"><a href="#自实现代码解析-3" class="headerlink" title="自实现代码解析"></a>自实现代码解析</h2><p>我们也可以根据如上方法论编写地址转换函数，从代码也不难看出此代码也存在Q3类似的问题。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c">DWORD <span class="hljs-title function_">RVAtoFOA</span><span class="hljs-params">(IN LPVOID pFileBuffer, IN DWORD dwRVA)</span> &#123;<br>    PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER) pFileBuffer;<br>    PIMAGE_FILE_HEADER pPEHeader = (PIMAGE_FILE_HEADER) (pDosHeader-&gt;e_lfanew + (DWORD) pFileBuffer + <span class="hljs-number">4</span>);<br>    PIMAGE_OPTIONAL_HEADER32 pOptionHeader = (PIMAGE_OPTIONAL_HEADER32) ((DWORD) pPEHeader + IMAGE_SIZEOF_FILE_HEADER);<br>    PIMAGE_SECTION_HEADER pSectionHeader = (PIMAGE_SECTION_HEADER) ((DWORD) pOptionHeader + pPEHeader-&gt;SizeOfOptionalHeader);<br><br>    <span class="hljs-comment">// RVA在文件头中时，RVA==FOA √</span><br>    <span class="hljs-comment">// 或者文件对齐==内存对齐时，RVA==FOA  × （比如当 Misc&gt;SizeOfRawData）</span><br>    <span class="hljs-keyword">if</span> (dwRVA &lt; pOptionHeader-&gt;SizeOfHeaders) &#123;<br>        <span class="hljs-keyword">return</span> dwRVA;<br>    &#125;<br><br>    <span class="hljs-comment">// 遍历节表，确定偏移属于哪一个节</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; pPEHeader-&gt;NumberOfSections; i++) &#123;<br>        <span class="hljs-keyword">if</span> (dwRVA &gt;= pSectionHeader[i].VirtualAddress &amp;&amp; dwRVA &lt; pSectionHeader[i].VirtualAddress + pSectionHeader[i].Misc.VirtualSize) &#123;<br>            <span class="hljs-type">int</span> offset = dwRVA - pSectionHeader[i].VirtualAddress;<br>            <span class="hljs-keyword">return</span> pSectionHeader[i].PointerToRawData + offset;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;找不到RVA %x 对应的 FOA，转换失败\n&quot;</span>, dwRVA);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>







<h1 id="13-5-IAT"><a href="#13-5-IAT" class="headerlink" title="13.5 IAT"></a>13.5 IAT</h1><p>   刚开始学习PE头时，最难过的一关就是IAT (Import Address Table,导入地址表)。IAT保存的内容与Windows操作系统的核心进程、内存、DLL结构等有关。换句话说，只要理解了IAT，就掌握了Windows操作系统的根基。简言之，IAT是一种表格，用来记录程序正在使用哪些库中的哪些函数。</p>
<h2 id="13-5-1-DLL"><a href="#13-5-1-DLL" class="headerlink" title="13.5.1 DLL"></a>13.5.1 DLL</h2><p>​	讲解IAT前先学习一下有关DLL ( Dynamic Linked Library )的知识（知其所以然，才更易理解），它支撑起了整座Windows OS大厦。DLL翻译成中文为“动态链接库”，为何这样称呼呢？16位的DOS时代不存在DLL这一概念，只有“库”（Library )—说。比如在C语言中使用printf()函数时，编译器会先从C库中读取相应函数的二进制代码，然后插入（包含到）应用程序。也就是说，可执行文件中包含着printf()函数的二进制代码。Windows OS支持多任务，若仍采用这种包含库的方式，会非常没有效率。Windows操作系统使用了数量庞大的库函数（进程、内存、窗口、消息等）来支持32位的Windows环境。同时运行多个程序时，若仍像以前一样每个程序运行时都包含相同的库，将造成严重的内存浪费（当然磁盘空间的浪费也不容小觑)。因此，WindowsOS设计者们根据需要引入了DLL这一概念，描述如下。</p>
<ul>
<li>不要把库包含到程序中，单独组成DLL文件，需要时调用即可。 </li>
<li>内存映射技术使加载后的DLL代码、资源在多个进程中实现共享。</li>
<li>更新库时只要替换相关DLL文件即可，简便易行。加载DLL的方式实际有两种：一种是“显式链接”（ExplicitLinking)，程序使用DLL时加载，使用完毕后释放内存；另一种是“隐式链接” (Implicit Linking ),程序开始时即一同加载DLL,程序终止时再释放占用的内存。IAT提供的机制即与隐式链接有关。下面使用OllyDbg打开notepad.exe来查看IAT。图13-10是调用CreateFileW()函数的代码，该函数位于kernel32.dll中。</li>
</ul>
<p>​	调用CreateFileW()函数时并非直接调用，而是通过获取01001104地址处的值来实现（所有API调用均采用这种方式)。地址01001104是notepad.exe中.text节区的内存区域（更确切地说是IAT内存区域）。01001104地址的值为7C8107F0，而7C8107F0地址即是加载到notepad.exe进程内存中的CreateFileW()函数（位于kernel32.dll库中）的地址。</p>
<p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC13%E7%AB%A0%20PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F.assets/image-20211201114904108.png" srcset="https://picbedddd.oss-cn-beijing.aliyuncs.com/blog/loading.gif" lazyload alt="image-20211201114904108"></p>
<p>​	此处产生一个疑问。</p>
<p>​	“直接使用CALL 7C8107F0指令调用函数不是更好、更方便吗？”</p>
<p>​	甚至还会有入问：“编译器直接写CALL 77E2CC56不是更准确、更好吗？”这是前面说过的DOS时代的方式。事实上，notepad.exe程序的制作者编译（生成）程序时，并不知道该notepad.exe程序要运行在哪种Windows ( 9X、2K、XP、Vista、7 )、哪种语言（ENG、JPN、KOR等）、哪种服务包（ServicePack)下。上面列举出的所有环境中，kernel32.dll的版本各不相同，CreateFileW()函数的位置（地 址）也不相同。为了确保在所有环境中都能正常调用CreateFileW()函数，编译器准备了要保存CreateFileW()函数实际地址的位置（ 10001124)，并仅记下CALL DWORD PTR DS:[10001124]形式的指令。执行文件时，PE装载器将CreateFileWO函数的地址写到10001124位置。</p>
<p>​	编译器不使用CALL 77E2CC56语句的另一个原因在于DLL重定位。DLL文件的ImageBase值一般为10000000。比如某个程序使用a.dll与b.dll时，PE装载器先把a.dll装载到内存的10000000(ImageBase)处，然后尝试把b.dll也装载到该处。但是由于该地址处已经装载了a.dll，所以PE装载器查找其他空白的内存空间（ex:3E000000 )，然后将b.dll装载进去。</p>
<p>​	这就是所谓的DLL重定位，它使我们无法对实际地址硬编码。另一个原因在于，PE头中表示地址时不使用VA，而是RVA。</p>
<blockquote>
<p>实际操作中无法保证DLL —定会被加载到PE头内指定的ImageBase处。但是EXE文件（生成进程的主体）却能准确加载到自身的ImageBase中，因为它拥有自己的虚拟空间。</p>
</blockquote>
<p>​	PE头的IAT是代码逆向分析的核心内容。希望各位好好理解它。相信大家现在已经能够掌握IAT的作用了（后面讲解IAT结构为什么如此复杂时，希望各位也能很快了解）。</p>
<h2 id="13-5-2-IMAGE-IMPORT-DESCRIPTOR"><a href="#13-5-2-IMAGE-IMPORT-DESCRIPTOR" class="headerlink" title="13.5.2 IMAGE_IMPORT_DESCRIPTOR"></a>13.5.2 IMAGE_IMPORT_DESCRIPTOR</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//@[comment(&quot;MVI_tracked&quot;)]</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IMAGE_IMPORT_DESCRIPTOR</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>        DWORD   Characteristics;            <span class="hljs-comment">// 0 for terminating null import descriptor</span><br>        DWORD   OriginalFirstThunk;         <span class="hljs-comment">// RVA to original unbound IAT (PIMAGE_THUNK_DATA)</span><br>        									<span class="hljs-comment">// In other words, INT(Import Name Table)</span><br>    &#125; DUMMYUNIONNAME;<br>    DWORD   TimeDateStamp;                  <span class="hljs-comment">// 0 if not bound,</span><br>                                            <span class="hljs-comment">// -1 if bound, and real date\time stamp</span><br>                                            <span class="hljs-comment">//     in IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT (new BIND)</span><br>                                            <span class="hljs-comment">// O.W. date/time stamp of DLL bound to (Old BIND)</span><br><br>    DWORD   ForwarderChain;                 <span class="hljs-comment">// -1 if no forwarders</span><br>    DWORD   Name;<br>    DWORD   FirstThunk;                     <span class="hljs-comment">// RVA to IAT (if bound this IAT has actual addresses)</span><br>    										<span class="hljs-comment">// IAT(Import Address Table)</span><br>&#125; IMAGE_IMPORT_DESCRIPTOR;<br><span class="hljs-keyword">typedef</span> IMAGE_IMPORT_DESCRIPTOR UNALIGNED *PIMAGE_IMPORT_DESCRIPTOR;<br></code></pre></td></tr></table></figure>





<p>​	执行一个普通程序时往往需要导入多个库，导入多少库就存在多少个IMAGE_IMPORT_DESCRIPTOR结构体，这些结构体形成了数组，且结构体数组最后以NULL结构体结束。IMAGE_IMPORT_DESCRIPTOR中的重要成员如表13-5所示（拥有全部RVA值)。</p>
<p>​	其中的重要成员如下所示：</p>
<ul>
<li>OriginalFirstThunk：INT的地址（RVA)</li>
<li>Name：库名称字符串的地址（RVA)</li>
<li>FirstThunk：IAT的地址（RVA)</li>
</ul>
<blockquote>
<p>• PE头中提到的“Table”即指数组。<br>• INT与IAT是长整型（4个字节数据类型）数组，以NULL结束（未另外明确指出<br>大小）。<br>• INT中各元素的值为IMAGE_IMPORT_BY_NAME结构体指针（有时IAT也拥有<br>相同的值)。<br>• INT与IAT的大小应相同。</p>
</blockquote>
<p>下图描述了notepad.exe之kernel32.dll的IMAGE_IMPORT_DESCRIPTOR结构。</p>
<p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC13%E7%AB%A0%20PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F.assets/image-20211201125729065.png" srcset="https://picbedddd.oss-cn-beijing.aliyuncs.com/blog/loading.gif" lazyload alt="image-20211201125729065"></p>
<p>​	上图中，INT与IAT的各元素同时指向相同地址，但也有很多情况下它们是不一致的（后面会陆续接触很多变形的PE文件，到时再逐一讲解)。但至少在我们的notepad分析中，这两者是一致的。<br>​	下面了解一下PE装载器把导入函数输入至IAT的顺序。</p>
<ul>
<li>1.读取IID的Name成员，获取库名称字符串kernel32.dll）。</li>
<li>2.装载相应库。 <ul>
<li>LoadLibrary(“kernel32.dll”）</li>
</ul>
</li>
<li>3.读取IID的OriginalFirstThunk成员，获取INT地址。</li>
<li>4.逐一读取INT中数组的值，获取相应IMAGE_IMPORT_BY_NAME地址（RVA）。</li>
<li>5.使用IMAGE_IMPORT_BY_NAME的Hint (ordinal)或fame项，获取相应函数的起始地址。<ul>
<li>GetProcAddress(“GetCurrentThreadld”)</li>
</ul>
</li>
<li>6.读取IID的FirstThunk (IAT)成员.获得IAT地址。</li>
<li>7.将上面获得的函数地址输入相应IAT数组值。 </li>
<li>8.重复以上步骤4~7,直到INT结束（遇到NULL时）。</li>
</ul>
<h2 id="13-5-3-notepad分析"><a href="#13-5-3-notepad分析" class="headerlink" title="13.5.3 notepad分析"></a>13.5.3 notepad分析</h2><p>​	下面以notepad.exe为对象逐一查看。先提一个问题：IMAGE_IMPORT_DESCRIPTOR结构体数组究竟存在于PE文件的哪个部分呢？</p>
<p>​	它不在PE头而在PE体中（在.idata段里），但查找其位置的信息在PE头中，IMAGE_OPTIONAL_HEADER32.DataDirectory[1].VirtualAddress的值即是IMAGE_IMPORT_DESCRIPTOR结构体数组的起始地址(RVA值)。IMAGE_IMPORT_DESCRIPTOR结构体数组也被称为IMPORT Directory Table (只有了解上述全部称谓，与他入交流时才能没有障碍)。</p>
<p>​	使用010editor对文件进行查看，找到导入表的RVA地址。</p>
<p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC13%E7%AB%A0%20PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F.assets/image-20211201134456381.png" srcset="https://picbedddd.oss-cn-beijing.aliyuncs.com/blog/loading.gif" lazyload alt="image-20211201134456381"></p>
<p>​	使用之前提到的RVAtoFOA函数对地址进行转换，找到导入表实际位置在文件中的偏移起始地址为2367C。由该地址开始引出一条的链，该链上的每一个块对应着一个DLL和通过这个DLL导入的一堆函数，以及一个IMAGE_IMPORT_DESCRIPTOR结构体。</p>
<p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC13%E7%AB%A0%20PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F.assets/image-20211201142440842.png" srcset="https://picbedddd.oss-cn-beijing.aliyuncs.com/blog/loading.gif" lazyload alt="image-20211201142440842"></p>
<p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC13%E7%AB%A0%20PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F.assets/image-20211201165502730.png" srcset="https://picbedddd.oss-cn-beijing.aliyuncs.com/blog/loading.gif" lazyload alt="image-20211201165502730"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//@[comment(&quot;MVI_tracked&quot;)]</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IMAGE_IMPORT_DESCRIPTOR</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>        DWORD   Characteristics;            <span class="hljs-comment">// 0 for terminating null import descriptor</span><br>        DWORD   OriginalFirstThunk;         <span class="hljs-comment">// RVA to original unbound IAT (PIMAGE_THUNK_DATA)</span><br>    &#125; DUMMYUNIONNAME;<br>    DWORD   TimeDateStamp;                  <span class="hljs-comment">// 0 if not bound,</span><br>                                            <span class="hljs-comment">// -1 if bound, and real date\time stamp</span><br>                                            <span class="hljs-comment">//     in IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT (new BIND)</span><br>                                            <span class="hljs-comment">// O.W. date/time stamp of DLL bound to (Old BIND)</span><br><br>    DWORD   ForwarderChain;                 <span class="hljs-comment">// -1 if no forwarders</span><br>    DWORD   Name;<br>    DWORD   FirstThunk;                     <span class="hljs-comment">// RVA to IAT (if bound this IAT has actual addresses)</span><br>&#125; IMAGE_IMPORT_DESCRIPTOR;<br></code></pre></td></tr></table></figure>



<p>​	将几个成员的值提取如下：</p>
<table>
<thead>
<tr>
<th align="center">文件偏移</th>
<th align="center">成员</th>
<th align="center">RVA</th>
<th align="center">FOA（RAW）</th>
</tr>
</thead>
<tbody><tr>
<td align="center">367C</td>
<td align="center">OriginalFirstThunk（INT）</td>
<td align="center">26700</td>
<td align="center">23900</td>
</tr>
<tr>
<td align="center">3680</td>
<td align="center">TimeDateStamp</td>
<td align="center">0</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center">3684</td>
<td align="center">ForwarderChain</td>
<td align="center">0</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center">3688</td>
<td align="center">Name</td>
<td align="center">27110</td>
<td align="center">24310</td>
</tr>
<tr>
<td align="center">368C</td>
<td align="center">FirstThunk（IAT）</td>
<td align="center">26068</td>
<td align="center">23268</td>
</tr>
</tbody></table>
<p>​	依此看看下面的这些文件吧。</p>
<ol>
<li>库名称（Name)</li>
</ol>
<p>​	Name是一个字符串指针，它指向导入函数所属的库文件名称。在下图文件偏移24310(RVA:27110→RAW:24310)处看到字符串KERNEL32.dll了吧？</p>
<p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC13%E7%AB%A0%20PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F.assets/image-20211201185152884.png" srcset="https://picbedddd.oss-cn-beijing.aliyuncs.com/blog/loading.gif" lazyload alt="image-20211201185152884"></p>
<ol start="2">
<li>OriginalFirstThunk - INT</li>
</ol>
<p>​	INT是一个包含导入函数信息(Ordinal, Name)的结构体指针数组。只有获得了这些信息，才能在加载到进程内存的库中准确求得相应函数的起始地址（请参考后面EAT的讲解）。</p>
<p>​	跟踪OriginalFirstThunk成员（RVA:26700→RAW:23900)。 结果如下。</p>
<p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC13%E7%AB%A0%20PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F.assets/image-20211202105556623.png" srcset="https://picbedddd.oss-cn-beijing.aliyuncs.com/blog/loading.gif" lazyload alt="image-20211202105556623"></p>
<p>​	上图实际上就是INT，它由地址数组形式组成（数组尾部以NULL结束）。该地址数组实际上也有一个结构体IMAGE_THUNK_DATA来指代。这里我们使用的是AddressOfData的变量。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//@[comment(&quot;MVI_tracked&quot;)]</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IMAGE_THUNK_DATA32</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>        DWORD ForwarderString;      <span class="hljs-comment">// PBYTE </span><br>        DWORD Function;             <span class="hljs-comment">// PDWORD</span><br>        DWORD Ordinal;<br>        DWORD AddressOfData;        <span class="hljs-comment">// PIMAGE_IMPORT_BY_NAME</span><br>    &#125; u1;<br>&#125; IMAGE_THUNK_DATA32;<br><span class="hljs-keyword">typedef</span> IMAGE_THUNK_DATA32 * PIMAGE_THUNK_DATA32;<br></code></pre></td></tr></table></figure>



<blockquote>
<p>需要说明的是，当 IMAGE_THUNK_DATA 值的最高位为 1时，表示函数以序号方式导入，这时候低 31位被看作一个函数序号。（可以用预定义值IMAGE_ORDINAL_FLAG32或80000000h来对最高位进行测试）。</p>
<p>当 IMAGE_THUNK_DATA 值的最高位为 0时，表示函数以字符串类型的函数名方式导入，这时双字的值是一个 RVA，指向一IMAGE_IMPORT_BY_NAME 结构。</p>
</blockquote>
<p>​	而其中，每个地址值分别指向IMAGE_IMPORT_BY_NAME结构体。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//@[comment(&quot;MVI_tracked&quot;)]</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IMAGE_IMPORT_BY_NAME</span> &#123;</span><br>    WORD    Hint;<br>    CHAR   Name[<span class="hljs-number">1</span>];<br>&#125; IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME;<br></code></pre></td></tr></table></figure>

<p>​	跟踪数组的第一个值26D3C（RVA），其FOA为23F3C：</p>
<p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC13%E7%AB%A0%20PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F.assets/image-20211201185127343.png" srcset="https://picbedddd.oss-cn-beijing.aliyuncs.com/blog/loading.gif" lazyload alt="image-20211201185127343"></p>
<p>​	进入该地址，可以看到导入的API函数的名称字符串。文件偏移23F3C最初的2个字节值（02B0）为Ordinal，在上述结构体中即为那个WORD变量，它是库中函数的固有编号。</p>
<p>​	Ordinal的后面 为函数名称字符串GetProcAddress（同C语言一样，字符串末尾以Terminating NULL[‘\0’ ]结束）。</p>
<p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC13%E7%AB%A0%20PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F.assets/image-20211201175112947.png" srcset="https://picbedddd.oss-cn-beijing.aliyuncs.com/blog/loading.gif" lazyload alt="image-20211201175112947"></p>
<p>​	可以看下之前放的图，对理解有帮助，如下：<br><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC13%E7%AB%A0%20PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F.assets/image-20211201125729065.png" srcset="https://picbedddd.oss-cn-beijing.aliyuncs.com/blog/loading.gif" lazyload alt="image-20211201125729065"></p>
<ol start="3">
<li>FirstThunk - IAT (Import Address Table)</li>
</ol>
<p>​	IAT的RVA:26068即为RAW:23268</p>
<p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC13%E7%AB%A0%20PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F.assets/image-20211201185040061.png" srcset="https://picbedddd.oss-cn-beijing.aliyuncs.com/blog/loading.gif" lazyload alt="image-20211201185040061"></p>
<p>​	图13-17中文件偏移23268~234C0区域即为IAT数组区域，对应于kernel32.dll库。它与INT类似，由结构体指针数组组成，且以NULL结尾。</p>
<p>​	IAT的第一个元素值被硬编码为26D3C，该值无实际意义，notepad.exe文件加载到内存时，PE装载器会使用相应API的起始地址替换该值。替换后的值是准确的。</p>
<blockquote>
<ul>
<li><p>微软在制作服务包过程中重建相关系统文件，此时会硬编入准确地址（普通的 DLL实际地址不会被硬编码到IAT中，通常带有与INT相同的值）。 </p>
</li>
<li><p>另外，普通DLL文件的ImageBase为10000000,所以经常会发生DLL重定位。但是Windows系统DLL文件（kernel32&#x2F;user32&#x2F;gdi32等）拥有自身固有的ImageBase，不会出现DLL重定位。</p>
</li>
</ul>
</blockquote>
<p>下面使用x32dbg查看notepad.exe的IAT，如图13-18所示。</p>
<p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC13%E7%AB%A0%20PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F.assets/image-20211201192123159.png" srcset="https://picbedddd.oss-cn-beijing.aliyuncs.com/blog/loading.gif" lazyload alt="image-20211201192123159"></p>
<p>GetProcAddress函数的IAT地址为836068,其值为769FF550，它是API准确的起始地址值。</p>
<p>若在其他OS ( 2000、Vista 等）或服务包（SP1、SP2 )中运行notepad.exe（这个notepad是从win10的syswow64里复制出来的32位notepad），836068地址中会被设置为其他值（相应OS的kernel32.dll的GetProcAddress地址）。</p>
<p>进入769FF550地址中，如上图所示，可以看到该处即为kernel32.dll的GetProcAddress函数的起始位置。</p>
<p>以上是对IAT的基本讲解，都是一些初学者不易理解的概念。反复阅读前面的讲解，并且实际进入相应地址查看学习，将非常有助于对概念的掌握。IAT是Windows逆向分析中的重要概念，一定要熟练把握。后面学习带有变形IAT的PE Patch文件时，会进一步学习IAT相关知识。</p>
<h2 id="自实现代码解析-4"><a href="#自实现代码解析-4" class="headerlink" title="自实现代码解析"></a>自实现代码解析</h2><p>IAT表分析代码实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c">VOID <span class="hljs-title function_">printImport</span><span class="hljs-params">()</span> &#123;<br>    LPVOID pFileBuffer = <span class="hljs-literal">NULL</span>;<br>    PIMAGE_DOS_HEADER pDosHeader = <span class="hljs-literal">NULL</span>;<br>    PIMAGE_NT_HEADERS pNTHeader = <span class="hljs-literal">NULL</span>;<br>    PIMAGE_FILE_HEADER pPEHeader = <span class="hljs-literal">NULL</span>;<br>    PIMAGE_OPTIONAL_HEADER32 pOptionHeader = <span class="hljs-literal">NULL</span>;<br>    ReadPEFile(FILEPATH_IN, &amp;pFileBuffer);<br>    pDosHeader = (PIMAGE_DOS_HEADER) pFileBuffer;<br>    pNTHeader = (PIMAGE_NT_HEADERS) ((DWORD) pFileBuffer + pDosHeader-&gt;e_lfanew);<br>    pPEHeader = (PIMAGE_FILE_HEADER) (((DWORD) pNTHeader) + <span class="hljs-number">4</span>);<br>    pOptionHeader = (PIMAGE_OPTIONAL_HEADER32) ((DWORD) pPEHeader + IMAGE_SIZEOF_FILE_HEADER);<br>    DWORD import_foa = (DWORD) pFileBuffer + RVAtoFOA(pFileBuffer, pOptionHeader-&gt;DataDirectory[<span class="hljs-number">1</span>].VirtualAddress);<br>    PIMAGE_IMPORT_DESCRIPTOR pImportDescriptor = (PIMAGE_IMPORT_DESCRIPTOR) import_foa;<br>    <span class="hljs-comment">//Traverse the data to find the num of blocks.</span><br>    <span class="hljs-comment">// Check every byte in IMAGE_IMPORT_DESCRIPTOR</span><br>    <span class="hljs-type">int</span> num = <span class="hljs-number">0</span>;<br>    boolean break_flag = FALSE;<br>    PIMAGE_IMPORT_DESCRIPTOR pTemp = pImportDescriptor;<br>    <span class="hljs-keyword">while</span> (pTemp-&gt;Name != <span class="hljs-literal">NULL</span>) &#123;<br>        num++;<br>        pTemp++;<br>    &#125;<br>    <span class="hljs-comment">//Traverse the data to process each block.</span><br>    pTemp = pImportDescriptor;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; num; j++) &#123;<br>        <span class="hljs-type">char</span> *dll_name = (<span class="hljs-type">char</span> *) ((DWORD) pFileBuffer + RVAtoFOA(pFileBuffer, (pTemp + j)-&gt;Name));<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s :\n&quot;</span>, dll_name);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;----------------------------\n&quot;</span>);<br>        <br>        PIMAGE_THUNK_DATA pThunkData = (PIMAGE_THUNK_DATA) ((DWORD) pFileBuffer + RVAtoFOA(pFileBuffer, (pTemp + j)-&gt;OriginalFirstThunk));<br><br>        PIMAGE_IMPORT_BY_NAME pImageImportByName = (PIMAGE_IMPORT_BY_NAME) ((DWORD) pFileBuffer + RVAtoFOA(pFileBuffer, pThunkData-&gt;u1.Ordinal));<br>        <span class="hljs-keyword">while</span> (TRUE) &#123;<br>            <span class="hljs-keyword">if</span> ((pThunkData-&gt;u1.Ordinal &amp; IMAGE_ORDINAL_FLAG) == <span class="hljs-number">0</span>) <span class="hljs-comment">// the highest bit is 0</span><br>            &#123; <span class="hljs-comment">// Fetch function name in each dll</span><br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, pImageImportByName-&gt;Name);<br>                pImageImportByName = (PIMAGE_IMPORT_BY_NAME) ((DWORD) pFileBuffer + RVAtoFOA(pFileBuffer, pThunkData-&gt;u1.Ordinal));<br><br>            &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//The highest bit is 1</span><br>                DWORD ordinal = ((pThunkData-&gt;u1.Ordinal &lt;&lt; <span class="hljs-number">1</span>) &gt;&gt; <span class="hljs-number">1</span>);<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Import by ordinal: %lx\n&quot;</span>, ordinal);<br>            &#125;<br>            pThunkData++;<br>            <span class="hljs-keyword">if</span> (pThunkData-&gt;u1.Ordinal == <span class="hljs-number">0</span>) &#123; <span class="hljs-keyword">break</span>; &#125;<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>





<p>效果截图：</p>
<p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC13%E7%AB%A0%20PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F.assets/image-20211201203347502.png" srcset="https://picbedddd.oss-cn-beijing.aliyuncs.com/blog/loading.gif" lazyload alt="image-20211201203347502"></p>
<h1 id="13-6-EAT"><a href="#13-6-EAT" class="headerlink" title="13.6 EAT"></a>13.6 EAT</h1><p>​	Windows操作系统中，“库”是为了方便其他程序调用而集中包含相关函数的文件（DLL&#x2F;SYS)。Win32 API是最具代表性的库，其中的kernel32.dll文件被称为最核心的库文件。<br>​	EAT是一种核心机制，它使不同的应用程序可以调用库文件中提供的函数。也就是说，只有通过EAT才能准确求得从相应库中导岀函数的起始地址。与前面讲解的IAT—样，PE文件内的特定结构体（IMAGE_EXPORT_DIRECTORY）保存着导出信息，且PE文件中仅有一个用来说明库EAT的IMAGE_EXPORT_DIRECTORY结构体。</p>
<blockquote>
<p>对比之下，用来说明IAT的IMAGE_IMPORT_DESCRIPTOR结构体以数组形式存在，且拥有多个成员。这样是因为PE文件可以同时导入多个库。而我们的IMAGE_EXPORT_DIRECTORY只能有一个。</p>
</blockquote>
<p>​	可以在PE文件的PE头中查找到IMAGE_EXPORT_DIRECTORY结构体的位置。IMAGE_OPTIONAL_HEADER32.DataDirectory[0].VirtualAddress 值即是 IMAGE_EXPORT_DIRECTORY结构体数组的起始地址（也是RVA的值）。</p>
<p>​	下图显示的是kernel32.dll文件的IMAGE_OPTIONAL_HEADER32.DataDirectory[0]（第一个4字节为VirtualAddress，第二个4字节为Size成员）</p>
<p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC13%E7%AB%A0%20PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F.assets/image-20211202205310896.png" srcset="https://picbedddd.oss-cn-beijing.aliyuncs.com/blog/loading.gif" lazyload alt="image-20211202205310896"></p>
<h2 id="13-6-1-IMAGE-EXPORT-DIRECTORY"><a href="#13-6-1-IMAGE-EXPORT-DIRECTORY" class="headerlink" title="13.6.1 IMAGE_EXPORT_DIRECTORY"></a>13.6.1 IMAGE_EXPORT_DIRECTORY</h2><p>IMAGE EXPORT DIRECTORY结构体如下代码所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//@[comment(&quot;MVI_tracked&quot;)]</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IMAGE_EXPORT_DIRECTORY</span> &#123;</span><br>    DWORD	Characteristics;<br>    DWORD	TimeDateStamp;            <span class="hljs-comment">//输出表的创建时间</span><br>    WORD	MajorVersion;                      <span class="hljs-comment">//输出表的主版本号。未使用设置为0</span><br>    WORD	MinorVersion;                      <span class="hljs-comment">//输出表的次版本号。未使用设置为0</span><br>    DWORD	Name;                <span class="hljs-comment">//指向一个与输出函数关联的文件名的RVA </span><br>    DWORD	Base;                <span class="hljs-comment">//到处函数的起始序号</span><br>    DWORD	NumberOfFunctions;        <span class="hljs-comment">//导出函数的总数</span><br>    DWORD	NumberOfNames;            <span class="hljs-comment">//以名称到处的函数总数</span><br>    DWORD	AddressOfFunctions;        <span class="hljs-comment">//指向到处函数地址表的RVA</span><br>    DWORD	AddressOfNames;            <span class="hljs-comment">//指向函数名地址表的AVA</span><br>    DWORD	AddressOfNameOrdinals;            <span class="hljs-comment">//指向函数名序号表的RVA</span><br>&#125; IMAGE_EXPORT_DIRECTORY, *pIMAGE_EXPORT_DIRECTORY<br></code></pre></td></tr></table></figure>



<p>下面讲解其中的重要成员（全部地址均为RVA),如下表所示。</p>
<table>
<thead>
<tr>
<th>项目</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>NumberOfFunctions</td>
<td>实际Export函数的个数</td>
</tr>
<tr>
<td>NumberOfNames</td>
<td>Export函数中具名的函数个数</td>
</tr>
<tr>
<td>AddressOfFunctions</td>
<td>Export函数地址数组（数组元素个数&#x3D;NumberOfFunctions）</td>
</tr>
<tr>
<td>AddressOfNames</td>
<td>函数名称地址数组（数组元素个数&#x3D;NumberOfNames）</td>
</tr>
<tr>
<td>AddressOfNameOrdinals</td>
<td>Ordinal地址数组（数组元素个数&#x3D;NumberOfNames）</td>
</tr>
</tbody></table>
<p>下图描述了kernel32.dll文件的IMAGE_EXPORT_DIRECTORY结构体与整个EAT结构。</p>
<p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC13%E7%AB%A0%20PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F.assets/image-20211202153710240.png" srcset="https://picbedddd.oss-cn-beijing.aliyuncs.com/blog/loading.gif" lazyload alt="image-20211202153710240"></p>
<p>从库中获得函数地址的API为GetProcAddress()函数。该API引用EAT来获取指定API的地址。<br>GetProcAddress() API拥有函数名称，下面讲解它如何获取函数地址。理解了这一过程，就等于征服了EAT。</p>
<p>GetProcAddress()操作原理</p>
<ul>
<li>(1)利用AddressOfNames成员转到“函数名称数组”。</li>
<li>(2) “函数名称数组”中存储着字符串地址。通过比较（strcmp）字符串，查找指定的函数名称（此时数组的索引称为name_index )。</li>
<li>(3)利用 AddressOfNameOrdinals 成员，转到ordinal 数组。 </li>
<li>(4)在ordinal数组中通过name_index查找相应ordinal值。</li>
<li>(5)利用AddressOfFunctions成员转到“函数地址数组”（EAT）。</li>
<li>(6)在“函数地址数组”中将刚刚求得的ordinal用作数组索引，获得指定函数的起始地址。</li>
</ul>
<p>上图描述的是kernel32.dll文件的情形。kernel32.dll中所有导岀函数均有相应名称，<br>AddressOfNameOrdinals数组的值以index&#x3D;ordinal的形式存在。但并不是所有的DLL文件都如此。<br>导出函数中也有一些函数没有名称（仅通过ordinal导岀），AddressOfNameOrdinals数组的值为index!&#x3D;ordinal。所以只有按照上面的顺序才能获得准确的函数地址。</p>
<blockquote>
<p>​	对于没有函数名称的导出函数，可以通过Ordinal查找到它们的地址。从Ordinal值中减去IMAGE_EXPORT_DIRECTORY.Base成员后得到一个值，使用该值作为“函数地址数组”的索引，即可查找到相应函数的地址。</p>
</blockquote>
<h2 id="13-6-2-使用-kernel32-dll-练习"><a href="#13-6-2-使用-kernel32-dll-练习" class="headerlink" title="13.6.2 使用 kernel32.dll 练习"></a>13.6.2 使用 kernel32.dll 练习</h2><p>下面看看如何实际从kernel32.dll文件的EAT中查找AddAtomW函数并获取其函数地址。kernel32.dll的IMAGE_EXPORT_DIRECTORY结构体RVA为92D30，换算成RAW为78D30。</p>
<p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC13%E7%AB%A0%20PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F.assets/image-20211202205340163.png" srcset="https://picbedddd.oss-cn-beijing.aliyuncs.com/blog/loading.gif" lazyload alt="image-20211202205340163"></p>
<p>使用010Editor进入78D30偏移处，如下图所示。</p>
<p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC13%E7%AB%A0%20PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F.assets/image-20211202205619615.png" srcset="https://picbedddd.oss-cn-beijing.aliyuncs.com/blog/loading.gif" lazyload alt="image-20211202205619615"></p>
<p>将几个成员的值抽取出来，如下所示：</p>
<table>
<thead>
<tr>
<th align="center">文件偏移</th>
<th align="center">成员</th>
<th align="center">值</th>
<th align="center">RAW</th>
</tr>
</thead>
<tbody><tr>
<td align="center">98BE0h</td>
<td align="center">DWORD  Characteristics</td>
<td align="center">0</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center">98BE4h</td>
<td align="center">time_t TimeDateStamp</td>
<td align="center">02&#x2F;08&#x2F;2016 21:48:04</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center">98BE8h</td>
<td align="center">WORD MajorVersion</td>
<td align="center">0</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center">98BEAh</td>
<td align="center">WORD MinorVersion</td>
<td align="center">0</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center">98BECh</td>
<td align="center">DWORD Name</td>
<td align="center">96C1Eh</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center">98BF0h</td>
<td align="center">DWORD Base</td>
<td align="center">1</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center">98BF4h</td>
<td align="center">DWORD NumberOfFunctions</td>
<td align="center">1607(647h)</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center">98BF8h</td>
<td align="center">DWORD NumberOfNames</td>
<td align="center">1607(647h)</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center">98BFCh</td>
<td align="center">DWORD AddressOfFunctions</td>
<td align="center">92D58h</td>
<td align="center">.rdata FOA &#x3D;  0x78D58</td>
</tr>
<tr>
<td align="center">98C00h</td>
<td align="center">DWORD AddressOfNames</td>
<td align="center">94674h</td>
<td align="center">.rdata FOA &#x3D; 0x7A674</td>
</tr>
<tr>
<td align="center">98C04h</td>
<td align="center">DWORD  AddressOfNameOrdinals</td>
<td align="center">95F90h</td>
<td align="center">.rdata FOA &#x3D; 0x7BF90</td>
</tr>
</tbody></table>
<p>下面通过模拟GetProcAddress()获取函数地址的方式对各个字段进行讲解。</p>
<ol>
<li>函数名称数组</li>
</ol>
<p>AddressOfNames成员的值为RVA&#x3D;94674,即RAW&#x3D;7A674。使用010Editor查看该地址，如下图</p>
<p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC13%E7%AB%A0%20PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F.assets/image-20211202210107851.png" srcset="https://picbedddd.oss-cn-beijing.aliyuncs.com/blog/loading.gif" lazyload alt="image-20211202210107851"></p>
<p>此处为4字节RVA组成的数组。数组元素个数为NumberOfNames ( 647h）。遍历所有RVA值即可发现函数名称字符串。</p>
<ol start="2">
<li>查找指定函数名称</li>
</ol>
<p>要查找的函数名称字符串为“AddAtomW”，在上图中遍历到第六个元素的值RVA数组的值(RVA:96D23→RAW:7CD23)即可。</p>
<p>进入相应地址就会看到“AddAtomW”字符串，如下图所示。此时“AddAtomW”函数名即是上图数组的第六个元素，数组索引为5。</p>
<p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC13%E7%AB%A0%20PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F.assets/image-20211202210945251.png" srcset="https://picbedddd.oss-cn-beijing.aliyuncs.com/blog/loading.gif" lazyload alt="image-20211202210945251"></p>
<ol start="3">
<li>Ordinal数组</li>
</ol>
<p>下面查找 “AddAtomW” 函数的Ordinal值。AddressOfNameOrdinals成员的值为RVA:95F90→RVA:7BF90。</p>
<p>在下图中可以看到，深色部分是由多个2字节的ordinal组成的数组（ ordinal数组中的各元素大小为2个字节)。</p>
<p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC13%E7%AB%A0%20PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F.assets/image-20211202211136196.png" srcset="https://picbedddd.oss-cn-beijing.aliyuncs.com/blog/loading.gif" lazyload alt="image-20211202211136196"></p>
<ol start="4">
<li>ordinal</li>
</ol>
<p>将2中求得的index值(5)应用到3中的Ordinal数组即可求得Ordinal(8)。<br>AddressOfNameOrdinals[index]&#x3D;ordinal</p>
<p>(index&#x3D;5,ordinal&#x3D;8)</p>
<ol start="5">
<li>函数地址数组-EAT</li>
</ol>
<p>最后查找AddAtomW的实际函数地址。AddressOfFunctions成员的值为RVA:92D58→RVA:78D58。 下图深色部分即为4字节函数地址RVA数组，它就是Export函数的地址。</p>
<p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC13%E7%AB%A0%20PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F.assets/image-20211202211332384.png" srcset="https://picbedddd.oss-cn-beijing.aliyuncs.com/blog/loading.gif" lazyload alt="image-20211202211332384"></p>
<ol start="6">
<li>AddAtomW函数地址</li>
</ol>
<p>图13-26中，为了获取“AddAtomW”函数的地址，将第4步所求的Ordinal用作上图数组的索引，得到RVA&#x3D;1B8D0。</p>
<p>AddressOfFunctions[ordinal]&#x3D;RVA</p>
<p>(ordinal&#x3D;7,RVA&#x3D;195A0)</p>
<p>使用x32dbg进行验证，kernel32.dll的ImageBase&#x3D;7A270000。因此AddAtomW函数的实际地址（VA）为7A2895A0（7A270000+1B8D0&#x3D;7A28B8D0）。如下图所示：</p>
<p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC13%E7%AB%A0%20PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F.assets/image-20211202213955074.png" srcset="https://picbedddd.oss-cn-beijing.aliyuncs.com/blog/loading.gif" lazyload alt="image-20211202213955074"></p>
<p>以上过程是在DLL文件中查找Export函数地址的方法，这与使用GetProcAddress() API获取指定函数地址的方法一致。</p>
<p>最基本、最重要的部分到此就全部讲完了。要理解这些内容并不容易，若有不理解的暂且保留，通过实际操作慢慢理解</p>
<h2 id="自实现代码解析-5"><a href="#自实现代码解析-5" class="headerlink" title="自实现代码解析"></a>自实现代码解析</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c">VOID <span class="hljs-title function_">printExport</span><span class="hljs-params">()</span> &#123;<br>    LPVOID pFileBuffer = <span class="hljs-literal">NULL</span>;<br>    PIMAGE_DOS_HEADER pDosHeader = <span class="hljs-literal">NULL</span>;<br>    PIMAGE_NT_HEADERS pNTHeader = <span class="hljs-literal">NULL</span>;<br>    PIMAGE_FILE_HEADER pPEHeader = <span class="hljs-literal">NULL</span>;<br>    PIMAGE_OPTIONAL_HEADER32 pOptionHeader = <span class="hljs-literal">NULL</span>;<br>    ReadPEFile(FILEPATH_IN, &amp;pFileBuffer);<br>    pDosHeader = (PIMAGE_DOS_HEADER) pFileBuffer;<br>    pNTHeader = (PIMAGE_NT_HEADERS) ((DWORD) pFileBuffer + pDosHeader-&gt;e_lfanew);<br>    pPEHeader = (PIMAGE_FILE_HEADER) (((DWORD) pNTHeader) + <span class="hljs-number">4</span>);<br>    pOptionHeader = (PIMAGE_OPTIONAL_HEADER32) ((DWORD) pPEHeader + IMAGE_SIZEOF_FILE_HEADER);<br>    DWORD export_foa = (DWORD) pFileBuffer + RVAtoFOA(pFileBuffer, pOptionHeader-&gt;DataDirectory[<span class="hljs-number">0</span>].VirtualAddress);<br>    PIMAGE_EXPORT_DIRECTORY pImageExportDirectory = (PIMAGE_EXPORT_DIRECTORY) export_foa; <span class="hljs-comment">// The real export dir</span><br>    <span class="hljs-comment">//Convert the address</span><br>    DWORD aof_in_file =<br>            (DWORD) pFileBuffer + (DWORD) RVAtoFOA(pFileBuffer, pImageExportDirectory-&gt;AddressOfFunctions); <span class="hljs-comment">//All of them are address</span><br>    DWORD aon_in_file = (DWORD) pFileBuffer + (DWORD) RVAtoFOA(pFileBuffer, pImageExportDirectory-&gt;AddressOfNames);<br>    DWORD aono_in_file = (DWORD) pFileBuffer + (DWORD) RVAtoFOA(pFileBuffer, pImageExportDirectory-&gt;AddressOfNameOrdinals);<br><br>    PDWORD begin_aof_foa = (PDWORD) aof_in_file;<br>    <span class="hljs-comment">// Find the index</span><br>    PDWORD temp_aof_foa = begin_aof_foa;<br>    <span class="hljs-type">int</span> aof_index;<br>    DWORD aono_index;<br>    DWORD address;<br>    DWORD num_of_func_by_name = (aono_in_file - aon_in_file) / <span class="hljs-number">4</span>;<br>    <span class="hljs-type">char</span> *func_name;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;------------------------------------------\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Ordinal\t\tRVA\t\tFunction Name\n&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; num_of_func_by_name; i++) &#123;<br>        aof_index = i;<br>        address = *(PDWORD) temp_aof_foa++;<br>        aono_index = valueToIndex(aof_index, (PWORD) aono_in_file, num_of_func_by_name);<br>        <span class="hljs-keyword">if</span> (address != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (aono_index + pImageExportDirectory-&gt;Base &gt;= pImageExportDirectory-&gt;Base) &#123; <br>                <span class="hljs-comment">// Then the aono_index is -1, no name for the function.</span><br>                PDWORD aon_pointer = (PDWORD) aon_in_file;<br>                func_name = (<span class="hljs-type">char</span> *) (RVAtoFOA(pFileBuffer, *(aon_pointer + i)) + (DWORD) pFileBuffer);<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lu\t\t%lx\t\t%s\n&quot;</span>, aof_index + pImageExportDirectory-&gt;Base, address, func_name);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lu\t\t%lx\t\t-\n&quot;</span>, aof_index + pImageExportDirectory-&gt;Base, address);<br>            &#125;<br>        &#125;<br>    &#125;<br><br><br>&#125;<br><br><span class="hljs-comment">//Convert in the AddressOfNameOrdinals table</span><br>DWORD <span class="hljs-title function_">valueToIndex</span><span class="hljs-params">(<span class="hljs-type">int</span> value, PWORD initial_address, DWORD search)</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; search; i++) &#123;<br>        <span class="hljs-keyword">if</span> (value == *initial_address++) &#123;<br>            <span class="hljs-keyword">return</span> i;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>





<h1 id="13-7-高级PE"><a href="#13-7-高级PE" class="headerlink" title="13.7 高级PE"></a>13.7 高级PE</h1><p>前面我们花了相当长时间来学习PE文件格式相关知识。虽然可以根据PE规范逐一学习各结构体成员，但前面的学习中仅抽取与代码逆向分析息息相关的成员进行了说明。其中IAT&#x2F;EAT相关内容是运行时压缩器（Run-timePacker）、反调试、DLL注入、API钩取等多种中高级逆向主题的基础知识。希望各位多训练使用Hex Editor,铅笔、纸张逐一计算IAT&#x2F;EAT的地址，再找到文件&#x2F;内存中的实际地址。虽然要掌握这些内容并不容易，但是由于其在代码逆向分析中占有重要地位，<br>所以只有掌握它们，才能学到高级逆向技术。</p>
<h2 id="13-7-1-PEView-exe"><a href="#13-7-1-PEView-exe" class="headerlink" title="13.7.1 PEView.exe"></a>13.7.1 PEView.exe</h2><p>下面向各位介绍一个简单易用的PE Viewer应用程序（PEView.exe ）(个入编写的免费公开SW ）。</p>
<p><a target="_blank" rel="noopener" href="http://www.magma.ca/~wjr/PEView.zip">http://www.magma.ca/~wjr/PEView.zip</a></p>
<p>下图是PEView.exe的运行界面。</p>
<p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC13%E7%AB%A0%20PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F.assets/image-20211204101345636.png" srcset="https://picbedddd.oss-cn-beijing.aliyuncs.com/blog/loading.gif" lazyload alt="image-20211204101345636"></p>
<p>PEView中，PE头按不同结构体分类组织起来，非常方便查看，也能非常容易地在RVA与文<br>件偏移间转换（与前面讲解的内容与术语略微不同。若二者都能熟练掌握，与他入沟通时会更加顺畅）。</p>
<p>强烈建议各位自己制作一个PE Viewer。我刚开始学习PE头时（为了验证）就制作了一款基于控制台的PE Viewer,使用至今。亲手制作PE Viewer可以学到更多知识，纠正理解上的错误，<br>更有利于进步。</p>
<h2 id="13-7-2-Patched-PE"><a href="#13-7-2-Patched-PE" class="headerlink" title="13.7.2 Patched PE"></a>13.7.2 Patched PE</h2><p>顾名思义，PE规范只是一个建议性质的书面标准，査看各结构体内部会发现，其实有许多成员并未被使用。事实上，只要文件符合PE规范就是PE文件，利用这一点可以制作出一些脱离常识的PE文件。</p>
<p>Patched PE指的就是这样的PE文件，这些PE文件仍然符合PE规范，但附带的PE头非常具有创意（准确地说，PE头纠缠放置到各处）。代码逆向分析中，Patched PE涉及的内容宽泛而有深度，详细讲解须另立主题。</p>
<p>这里只介绍一点，但是足以颠覆前面对PE头的常规理解（但仍未违反PE规范）</p>
<p>在下列网站制作一个名为“tinype”的最小PE文件。</p>
<p><a target="_blank" rel="noopener" href="http://blogs.securiteam.com/index.php/archives/675">http://blogs.securiteam.com/index.php/archives/675</a></p>
<p>它是正常的PE文件，大小只有411个字节。其IMAGE_NT_HEADERS结构体大小只有248个字节，从这一点来看，的确非常小。其他入也不断加入挑战，现在已经出现了304个字节的PE文 件。有入访问上面网站后受到了刺激，制作了一个非常极端、非常荒唐的PE文件，在下列网址中可以看到。</p>
<p><a target="_blank" rel="noopener" href="http://www.phreedom.org/solar/code/tinype/">http://www.phreedom.org/solar/code/tinype/</a></p>
<p>进入网站后可以下载一个97字节的PE文件，它可以在Windows XP中正常运行。并且网站记录了PE头，与tiny pe的制作过程，认真阅读这些内容会有很大帮助（需要具备一点汇编语言的知识）。希望各位全部下载并逐一分析，技术水平必有显著提高。</p>
<h1 id="13-8-小结"><a href="#13-8-小结" class="headerlink" title="13.8 小结"></a>13.8 小结</h1><p>这些Patched PE文件能够帮助打破对PE文件的固有概念，对我、对普通的逆向分析入员都一样。正因如此，逆向分析技术学起来才更有意思。关于PE头需要再次强调的内容整理如下。 </p>
<ul>
<li>PE规范只是一种标准规范而已（有许多内容未使用）。</li>
<li>现在已知关于PE头的认识中有些是错误的（除tinype外，会出现更多操作PE头的创意技巧）。</li>
<li>经常检验掌握的知识，发现不懂的马上补充学习。</li>
</ul>
<p>后面还会有机会详细分析、学习Patched PE文件有关知识，到时再向各位一一介绍有关操作PE头更多有趣而奇特的技巧。</p>
<blockquote>
<p>Q.前面的讲解中提到，执行文件加载到内存时会根据Imagebase确定地址，那么2个notepad程序同时运行时Imagebase都是10000000,它们会侵占彼此的空间区域，不是这样吗？ </p>
<p>A.生成进程（加载到内存）时，OS会单独为它分配4GB大小的虚拟内存。虚拟内存与实际物理内存是不同的。同时运行2个notepad时，各进程分别在自身独有的虚拟内存空间中，<br>所以它们彼此不会重叠。这是由OS来保障的。因此，即使它们的Imagebase—样也完全没问题。 </p>
<p>Q.不怎么理解“填充”（padding）这一概念。 </p>
<p>A.相信会有很多入想了解PE文件的“填充”这一概念，就当它是为了对齐“基本单位”而添加的“饶头”。“基本单位”这个概念在计算机和日常生活中都常见。</p>
<p>比如，保管大量的橘子时并不是单个保管，而是先把它们分别放入一个个箱子中，然后再放入仓库。这些箱子就是“基本单位”。并且，说橘子数量时也很少说几个橘子，而说 几箱橘子，这样称呼会更方便3橘子箱数增加很多时，就要增加保管仓库的数量。此时不会再说几箱橘子，而是说“几仓库的橘子”。事实上，这样保管橘子便于检索，查找时 只要说出“几号仓库的几号箱子的第几个橘子”即可。也就是说，保存大量数据时成“捆”<br>保管，整理与检索都会变得更容易。这种“基本单位”的概念也被融入计算机设计，还被应用到内存、硬盘等。各位一定听说过硬盘是用“扇区”这个单位划分的吧？</p>
<p>同样，“基本单位（大小）”的概念也应用到了PE文件格式的节区。即使编写的代码（编译为机器语言）大小仅有100d字节，若节区的基本单位为1000d（400h）字节，那么代码节区最小也应该为1000d。其中100个字节区域为代码，其余900个字节区域填充着NULL（0）,后者称为NULL填充区域。内存中也使用“基本单位”的概念（其单位的大小比普通文件要略大一些）。那么PE文件中的填充是谁创建的呢？在开发工具（VC++&#x2F;VB等）中生成PE文件时由指定的编译选项确定。 </p>
<p>Q.经常在数字旁边见到字母“h”，它是什么单位？ </p>
<p>A.数字旁边的字母“h”是Hex的首字母，表示前面的数字为十六进制数。另外，十进制数用d （ Decimal ）、八进制数用o （ Octal ）、二进制数用b （ Binary ）标识。 </p>
<p>Q.如何只用Hex Editor识别出DOS存根、IMAGE_FILE_HEADER等部分呢？ </p>
<p>A.根据PE规范，IMAGE_DOS_HEADER的大小为40个字节，DOS存根区域为40〜PE签名区域。紧接在PE签名后的是IMAGE_FILE_HEADER，且该结构体的大小是已知的，所以也可以在Hex Editor中表示出来。也就是说，解析PE规范中定义的结构体及其成员的含义，即可区分出各组成部分（多看几次就熟悉了）。</p>
<p>Q. IMAGE_FILE_HEADER 的 TimeDateStamp 值为0x47918EA2 ,在 PEView 中显示为2008&#x2F;01&#x2F;19,05:46:10 UTC,如何才能这样解析出来呢？</p>
<p> A.使用C语言标准库中提供的ctime（)函数，即可把4个字节的数字转换为实际的日期字符串。 </p>
<p>Q. PE映像是什么？ </p>
<p>A. PE映像这一术语是微软创建PE结构时开始使用的。一般是指PE文件运行时加栽到内存中的形态。PE头信息中有一个SizeOflmage项，该项指出了PE映像所占内存的大小。当然，<br>这个大小与文件的大小不一样。PE文件格式妙处之一就在于，其文件形态与内存形态是不同的。 </p>
<p>Q.不太明白EP这一概念。 </p>
<p>A. EP地址是程序中最早被执行的代码地址。CPU会最先到EP地址处，并从该处开始依次执行指令。 </p>
<p>Q.用PEView打开记事本程序（notepad.exe）后，发现各节区的起始地址、大小等与示例中的不同，为什么会这样呢？ </p>
<p>A. notepad.exe文件随OS版本的不同而不同（其他所有系统文件也如此）。换言之，不同版本的OS下，系统文件的版本也是不同的。微软可能修改了代码、更改了编译选项，重新编译后再发布。 </p>
<p>Q.对图13-9及其下面的Quiz不是很理解。如何知道RVA 5000包含在哪个节区呢？ </p>
<p>A.图13-9是以节区头信息为基础绘制的。图（或节区头信息）中的.text节区是指VA 01001000-01009000区域，转换为RVA形式后对应于RVA 1000〜9000区域（即减去Imagebase值的01000000 ）。由此可知，RVA 5000包含在.text节区中。 </p>
<p>Q.讲解节区头成员VirtualAddress时提到，它是内存中节区头的起始地址（RVA），<br>VirtualAddress不就是VA吗？为什么要叫RVA呢？ </p>
<p>A. “使用RVA值来表示节区头的成员VirtualAddress”，这样理解就可以了。节区头结构体<br>（IMAGE_SECTION_HEADER ）的 VirtualAddress成员与虚拟内存地址（VA , VirtualAddress ）用的术语相同才引起这一混乱。此处“VirtualAddress成员指的是虚拟内存中相应节区的起始地址，它以RVA的形式保存”，如此理解即可。</p>
<p>Q.查看某个文件时，发现其IMAGEJMPORT_DESCRIPTOR结构体的OriginaFirstThunk成员为NULL,跟踪FirstFThunk成员，看到一个实际使用的API的名称字符串数组（INT）。<br>跟踪FirstThunk应该看到的是IAT而不是INT，这是怎么回事呢？ </p>
<p>A. PE装载器无法根据OriginalFirstThunk查找到API名称字符串数组（INT）时，就会尝试用FirstThunk查找。本来FirstThunk含义为IAT，但在实际内存中被实际的API函数地址覆盖 掉了（此时INT与IAT虽然是相同区域，但仍然能够正常工作）。 </p>
<p>Q.使用Windows7的notepad.exe测试，用PEView打开后，IAT起始地址为01001000,而用OllyDbg查看时IAT出现在00831000地址处。请问这是怎么回事呢？ </p>
<p>A.这是由Windows Vista、7中使用的ASLR技术造成的。请参考第41章。 </p>
<p>Q. EAT讲解中提到的Ordinal究竟是什么？不太理解。 </p>
<p>A.把Ordinal想成导出函数的固有编号就可以了。有时候某些函数对外不会公开函数名，仅公开函数的固有编号（Ordinal）。导入并使用这类函数时，要先用Ordinal查找到相应函数 的地址后再调用。比如下面示例（1）通过函数名称来获取函数地址，示例（2）则使用函数的 Ordinal来取得函数地址。<br>示例（1） pFunc&#x3D;GetProcAddress（ “TestFunc”）；<br>示例（2） pFunc&#x3D;GetProcAddress（5）;</p>
</blockquote>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《逆向工程核心原理》 第13章</p>

              
            </div>
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/Binary/" class="category-chain-item">Binary</a>
  
  
    <span>></span>
    
  <a href="/categories/Binary/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/" class="category-chain-item">逆向工程核心原理</a>
  
  

  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/Binary/">#Binary</a>
      
        <a href="/tags/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/">#逆向工程核心原理</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>第13章 PE文件格式</div>
      <div>https://m0ck1ng-b1rd.github.io/1999/02/11/逆向工程核心原理/第13章 PE文件格式/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>何语灵</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>1999年2月11日</div>
        </div>
      
      
      <div class="license-meta-item">
        <div>许可协议</div>
        <div>
          
            
            
              <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
              <span class="hint--top hint--rounded" aria-label="BY - 署名">
                <i class="iconfont icon-by"></i>
              </span>
              </a>
            
          
        </div>
      </div>
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/1999/02/12/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC14%E7%AB%A0%20%E8%BF%90%E8%A1%8C%E6%97%B6%E5%8E%8B%E7%BC%A9/" title="第14章 运行时压缩">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">第14章 运行时压缩</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/1999/02/10/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC7%E7%AB%A0%20%E6%A0%88%E5%B8%A7/" title="第7章 栈帧">
                        <span class="hidden-mobile">第7章 栈帧</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  <article id="comments" lazyload>
    
  <script type="text/javascript">
    Fluid.utils.loadComments('#comments', function() {
      var light = 'github-light';
      var dark = 'github-dark';
      var schema = document.documentElement.getAttribute('data-user-color-scheme');
      if (schema === 'dark') {
        schema = dark;
      } else {
        schema = light;
      }
      window.UtterancesThemeLight = light;
      window.UtterancesThemeDark = dark;
      var s = document.createElement('script');
      s.setAttribute('src', 'https://utteranc.es/client.js');
      s.setAttribute('repo', 'M0cK1nG-b1Rd/blog-comments');
      s.setAttribute('issue-term', 'title');
      
      s.setAttribute('label', 'utterances');
      
      s.setAttribute('theme', schema);
      s.setAttribute('crossorigin', 'anonymous');
      document.getElementById('comments').appendChild(s);
    })
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


  </article>


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  






    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://M0cK1nG-b1Rd.github.io" target="_blank" rel="nofollow noopener"><span>M0cK1nG-b1Rd</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Powered by Hexo&Fluid</span></a> <div> <span id="timeDate">载入天数...</span> <span id="times">载入时分秒...</span> <script src="/js/duration.js"></script> </div> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="leancloud-site-pv-container" style="display: none">
        总访问量 
        <span id="leancloud-site-pv"></span>
         次
      </span>
    
    
      <span id="leancloud-site-uv-container" style="display: none">
        总访客数 
        <span id="leancloud-site-uv"></span>
         人
      </span>
    
    

  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  

  

  

  

  

  

  
    
  




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.0/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script>
  (function() {
    var enableLang = CONFIG.code_language.enable && CONFIG.code_language.default;
    var enableCopy = CONFIG.copy_btn;
    if (!enableLang && !enableCopy) {
      return;
    }

    function getBgClass(ele) {
      return Fluid.utils.getBackgroundLightness(ele) >= 0 ? 'code-widget-light' : 'code-widget-dark';
    }

    var copyTmpl = '';
    copyTmpl += '<div class="code-widget">';
    copyTmpl += 'LANG';
    copyTmpl += '</div>';
    jQuery('.markdown-body pre').each(function() {
      var $pre = jQuery(this);
      if ($pre.find('code.mermaid').length > 0) {
        return;
      }
      if ($pre.find('span.line').length > 0) {
        return;
      }

      var lang = '';

      if (enableLang) {
        lang = CONFIG.code_language.default;
        if ($pre[0].children.length > 0 && $pre[0].children[0].classList.length >= 2 && $pre.children().hasClass('hljs')) {
          lang = $pre[0].children[0].classList[1];
        } else if ($pre[0].getAttribute('data-language')) {
          lang = $pre[0].getAttribute('data-language');
        } else if ($pre.parent().hasClass('sourceCode') && $pre[0].children.length > 0 && $pre[0].children[0].classList.length >= 2) {
          lang = $pre[0].children[0].classList[1];
          $pre.parent().addClass('code-wrapper');
        } else if ($pre.parent().hasClass('markdown-body') && $pre[0].classList.length === 0) {
          $pre.wrap('<div class="code-wrapper"></div>');
        }
        lang = lang.toUpperCase().replace('NONE', CONFIG.code_language.default);
      }
      $pre.append(copyTmpl.replace('LANG', lang).replace('code-widget">',
        getBgClass($pre[0]) + (enableCopy ? ' code-widget copy-btn" data-clipboard-snippet><i class="iconfont icon-copy"></i>' : ' code-widget">')));

      if (enableCopy) {
        Fluid.utils.createScript('https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js', function() {
          var clipboard = new window.ClipboardJS('.copy-btn', {
            target: function(trigger) {
              var nodes = trigger.parentNode.childNodes;
              for (var i = 0; i < nodes.length; i++) {
                if (nodes[i].tagName === 'CODE') {
                  return nodes[i];
                }
              }
            }
          });
          clipboard.on('success', function(e) {
            e.clearSelection();
            e.trigger.innerHTML = e.trigger.innerHTML.replace('icon-copy', 'icon-success');
            setTimeout(function() {
              e.trigger.innerHTML = e.trigger.innerHTML.replace('icon-success', 'icon-copy');
            }, 2000);
          });
        });
      }
    });
  })();
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="/js/leancloud.js" ></script>




  
<script src="//picbedddd.oss-cn-beijing.aliyuncs.com/blog/scripts/DynamicRibbon.min.js"></script>



<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"left","width":250,"height":500,"hOffset":-30,"vOffset":-150},"mobile":{"show":true,"scale":0.5},"log":false});</script></body>
</html>
