

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="https://picbedddd.oss-cn-beijing.aliyuncs.com/blog/icon/apple-touch-icon.png">
  <link rel="icon" href="https://picbedddd.oss-cn-beijing.aliyuncs.com/blog/icon/favicon.ico">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="何语灵">
  <meta name="keywords" content="">
  
    <meta name="description" content="Win32专题整理记录，感谢滴水的老师们">
<meta property="og:type" content="article">
<meta property="og:title" content="滴水初级-Win32笔记">
<meta property="og:url" content="https://m0ck1ng-b1rd.github.io/2022/02/20/%E4%BA%8C%E8%BF%9B%E5%88%B6/Win32/index.html">
<meta property="og:site_name" content="M0cK1nG-b1Rd&#39;s site">
<meta property="og:description" content="Win32专题整理记录，感谢滴水的老师们">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image2021-5-17_1-27-44.png">
<meta property="article:published_time" content="2022-02-20T04:21:06.000Z">
<meta property="article:modified_time" content="2022-04-13T08:21:47.061Z">
<meta property="article:author" content="何语灵">
<meta property="article:tag" content="Binary">
<meta property="article:tag" content="Win32">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image2021-5-17_1-27-44.png">
  
  
  
  <title>滴水初级-Win32笔记 - M0cK1nG-b1Rd&#39;s site</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  



  
<link rel="stylesheet" href="//picbedddd.oss-cn-beijing.aliyuncs.com/blog/scripts/scroll.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"m0ck1ng-b1rd.github.io","root":"/","version":"1.9.0","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"https://picbedddd.oss-cn-beijing.aliyuncs.com/blog/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"87rdYWc7BpvmNHtufVgH6hwF-gzGzoHsz","app_key":"FOGIb6hlzKdTWSp4wBpACnWG","server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>

  
<meta name="generator" content="Hexo 6.1.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>M0cK1nG-b1Rd&#39;s site</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('https://picbedddd.oss-cn-beijing.aliyuncs.com/blog/761607.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="滴水初级-Win32笔记"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-02-20 12:21" pubdate>
          2022年2月20日 中午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          55k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          461 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">滴水初级-Win32笔记</h1>
            
              <p class="note note-info">
                
                  
                    本文最后更新于：2022年4月13日 下午
                  
                
              </p>
            
            <div class="markdown-body">
              
              <h1 id="宽字符"><a href="#宽字符" class="headerlink" title="宽字符"></a>宽字符</h1><h2 id="C语言中的宽字符"><a href="#C语言中的宽字符" class="headerlink" title="C语言中的宽字符"></a>C语言中的宽字符</h2><p>在C语言中如何使用上一章所述的编码格式表示字符串。</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">ASCII码：char strBuff[] <span class="hljs-operator">=</span> <span class="hljs-string">&quot;中国&quot;</span><span class="hljs-comment">;</span><br>Unicode编码（UTF-<span class="hljs-number">16</span>）：wchar_t strBuff[] <span class="hljs-operator">=</span> L<span class="hljs-string">&quot;中国&quot;</span><span class="hljs-comment">; // 这里需要在双引号</span><br></code></pre></td></tr></table></figure>

<p>之前加上L是因为如果你不加的话，编译器会默认使用当前文件的编码格式去存储，所以我们需要加上。（注意使用这个的时候需要包含stdio.h这个头文件）</p>
<p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image2021-5-17_1-27-44.png" srcset="https://picbedddd.oss-cn-beijing.aliyuncs.com/blog/loading.gif" lazyload alt="images/download/attachments/12714992/image2021-5-17_1-27-44.png"></p>
<p><strong>Unicode编码这种表现形式实际上就是宽字符，所以在提起宽字符的时候我们就应该想到这种方式。</strong></p>
<p>ASCII编码和Unicode编码在内存中的存储方式不一样，所以我们使用相关函数的时候也要注意，如下图所示，ASCII编码使用左边的，而Unicode则是右边的：</p>
<p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image2021-5-17_1-12-0.png" srcset="https://picbedddd.oss-cn-beijing.aliyuncs.com/blog/loading.gif" lazyload alt="images/download/attachments/12714992/image2021-5-17_1-12-0.png"></p>
<p>例如我们想要在控制台中打印一个宽字符的字符串：</p>
<p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image2021-5-17_1-18-46.png" srcset="https://picbedddd.oss-cn-beijing.aliyuncs.com/blog/loading.gif" lazyload alt="images/download/attachments/12714992/image2021-5-17_1-18-46.png"></p>
<p>再一个例子就是字符串的长度：</p>
<p>char strBuff[] &#x3D; “China”;</p>
<p>wchar_t strBuff1[] &#x3D; L”China”;</p>
<p>strlen(strBuff); &#x2F;&#x2F;取得多字节字符串中字符长度，不包含 00</p>
<p>wcslen(strBuff1); &#x2F;&#x2F;取得多字节字符串中字符长度，不包含 00 00</p>
<h2 id="Win32-API中的宽字符"><a href="#Win32-API中的宽字符" class="headerlink" title="Win32 API中的宽字符"></a>Win32 API中的宽字符</h2><h3 id="了解什么是Win32-API"><a href="#了解什么是Win32-API" class="headerlink" title="了解什么是Win32 API"></a>了解什么是Win32 API</h3><p>Win32 API就是Windows操作系统提供给我们的函数（应用程序接口），其主要存放在C:\Windows\System32（存储的DLL是64位）、C:\Windows\SysWOW64（存储的DLL是32位）下面的所有DLL文件（几千个）。</p>
<p>重要的DLL文件：</p>
<ol>
<li>Kernel32.dll：最核心的功能模块，例如内存管理、进程线程相关的函数等；</li>
<li>User32.dll：Windows用户界面相关的应用程序接口，例如创建窗口、发送信息等；</li>
<li>GDI32.dll：全称是Graphical Device Interface（图形设备接口），包含用于画图和显示文本的函数。</li>
</ol>
<p>在C语言中我们想要使用Win32 API的话直接在代码中包含windows.h这个头文件即可。</p>
<p>比如我们想要弹出一个提示窗口，Win32 API文档中弹窗API的格式如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">MessageBox</span><span class="hljs-params">(</span><br><span class="hljs-params">    HWND hWnd,          <span class="hljs-comment">// handle to owner window</span></span><br><span class="hljs-params">    LPCTSTR lpText,     <span class="hljs-comment">// text in message box</span></span><br><span class="hljs-params">    LPCTSTR lpCaption,  <span class="hljs-comment">// message box title</span></span><br><span class="hljs-params">    UINT uType          <span class="hljs-comment">// message box style</span></span><br><span class="hljs-params">)</span>;<br></code></pre></td></tr></table></figure>

<p>这个代码可能看起来非常可怕，好像我们都没有接触过，<strong>但实际上其不是什么新的类型，所谓的新的类型无非就是给原有的类型重新起了一个名字，这样做是为了将所有类型统一化，便于读写，如果涉及到跨平台的话将原来的类型修改一下就好了，无需对代码进行重写</strong>。</p>
<p>例如以上代码中的类型LPCTSTR，实际上我们跟进一下代码（选中F12）会发现其本质就是const char *这个类型，只不过是换了一个名字罢了。</p>
<p>常用的数据类型在Win32中都重新起了名字：</p>
<p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image2021-5-17_1-43-48.png" srcset="https://picbedddd.oss-cn-beijing.aliyuncs.com/blog/loading.gif" lazyload alt="images/download/attachments/12714992/image2021-5-17_1-43-48.png"></p>
<h3 id="在Win32中使用字符串"><a href="#在Win32中使用字符串" class="headerlink" title="在Win32中使用字符串"></a>在Win32中使用字符串</h3><p>字符类型：</p>
<p>CHAR strBuff[] &#x3D; “中国”; &#x2F;&#x2F; char</p>
<p>WCHAR strBuff[] &#x3D; L”中国”; &#x2F;&#x2F; wchar_t</p>
<p>TCHAR strBuff[] &#x3D; TEXT(“中国”); &#x2F;&#x2F; TCHAR 根据当前项目的编码自动选择char还是wchar_t，在Win32中推荐使用这种方式</p>
<p>字符串指针:</p>
<p>PSTR strPoint &#x3D; “中国”; &#x2F;&#x2F; char*</p>
<p>PWSTR strPoint &#x3D; L”中国”; &#x2F;&#x2F; wchar_t*</p>
<p>PTSTR strPoint &#x3D; TEXT(“中国”); &#x2F;&#x2F; PTSTR 根据当前项目的编码自动选择如char<em>还是wchar_t</em>，在Win32中推荐使用这种方式</p>
<h3 id="各种版本的MessageBox"><a href="#各种版本的MessageBox" class="headerlink" title="各种版本的MessageBox"></a>各种版本的MessageBox</h3><p>MessageBox，其实际上本质就是MessageBoxW和MessageBoxA：</p>
<p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image2021-5-17_1-51-13-16448896292451.png" srcset="https://picbedddd.oss-cn-beijing.aliyuncs.com/blog/loading.gif" lazyload alt="images/download/attachments/12714992/image2021-5-17_1-51-13.png"></p>
<p>MessageBoxA只接受ASCII编码的参数，而MessageBoxW则只接受Unicode编码的参数。</p>
<p>从本质上来讲，Windows字符串都是宽字符的，所以<strong>使用MessageBoxW这种方式性能会更好一些</strong>，因为当你使用MessageBoxA的时候，在到内核的时候（系统底层）其会转化Unicode，所以性能相对差一些。</p>
<p>弹框调用如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">CHAR strTitle[] = <span class="hljs-string">&quot;Title&quot;</span>;<br>CHAR strContent[] = <span class="hljs-string">&quot;Hello World!&quot;</span>;<br>MessageBoxA(<span class="hljs-number">0</span>, strContent, strTitle, MB_OK);<br></code></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">WCHAR strTitle[] = <span class="hljs-string">L&quot;Title&quot;</span>;<br>WCHAR strContent[] = <span class="hljs-string">L&quot;Hello World!&quot;</span>;<br>MessageBoxW(<span class="hljs-number">0</span>, strContent, strTitle, MB_OK);<br></code></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">TCHAR strTitle[] = TEXT(<span class="hljs-string">&quot;Title&quot;</span>);<br>TCHAR strContent[] = TEXT(<span class="hljs-string">&quot;Hello World!&quot;</span>);<br>MessageBox(<span class="hljs-number">0</span>, strContent, strTitle, MB_OK);<br></code></pre></td></tr></table></figure>



<h1 id="消息机制"><a href="#消息机制" class="headerlink" title="消息机制"></a>消息机制</h1><h2 id="什么是消息"><a href="#什么是消息" class="headerlink" title="什么是消息"></a>什么是消息</h2><p>当我们点击鼠标的时候，或者当我们按下键盘的时候，操作系统都要把这些动作记录下来，封装到一个结构体中，这个<strong>结构体</strong>就是消息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tagMSG</span> &#123;</span><br>  HWND   hwnd;      <span class="hljs-comment">// 所属窗口句柄</span><br>  UINT   message;   <span class="hljs-comment">// 消息类型：编号</span><br>  WPARAM wParam;    <span class="hljs-comment">// 附加数据，进一步描述消息的</span><br>  LPARAM lParam;    <span class="hljs-comment">// 附加数据，进一步描述消息的</span><br>  DWORD  time;      <span class="hljs-comment">// 消息产生的时间</span><br>  POINT  pt;        <span class="hljs-comment">// 在哪里产生的</span><br>&#125; MSG, *PMSG; <br></code></pre></td></tr></table></figure>



<h2 id="消息的产生与处理流程"><a href="#消息的产生与处理流程" class="headerlink" title="消息的产生与处理流程"></a>消息的产生与处理流程</h2><p>从消息发起这个点开始说，假设我们点击了某个窗口时就会产生一个消息，操作系统得到这个消息后先判断当前点击的是哪个窗口，找到对应的窗口对象，再根据窗口对象的里的某一个成员找到对应线程，一旦找到了对应线程，操作系统就会把封装好的消息（这是一个结构体，包含了你鼠标点击的坐标等等消息）存到对应的消息队列里，应用程序就会通过GetMessage不停的从消息队列中取消息。</p>
<p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image2021-6-1_14-46-15.png" srcset="https://picbedddd.oss-cn-beijing.aliyuncs.com/blog/loading.gif" lazyload alt="images/download/attachments/12714992/image2021-6-1_14-46-15.png"></p>
<p>能产生消息的情况有四种情况：<strong>1. 键盘 2. 鼠标 3. 其他应用程序 4. 操作系统内核程序</strong>，有这么多消息要处理，所以操作系统会将所有消息区分类别，每个消息都有独一无二的编号。</p>
<p>消息这个结构体存储的信息也不多，只能知道消息属于哪个窗口，根本不知道对应窗口函数是什么，所以我们不得不在之后对消息进行分发（DispatchMessage函数），而后由内核发起调用来执行窗口函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">LRESULT CALLBACK <span class="hljs-title function_">WindowProc</span><span class="hljs-params">(  </span><br><span class="hljs-params">	IN  HWND hwnd,  </span><br><span class="hljs-params">	IN  UINT uMsg,  </span><br><span class="hljs-params">	IN  WPARAM wParam,  </span><br><span class="hljs-params">	IN  LPARAM lParam  </span><br><span class="hljs-params">	)</span>;  <br></code></pre></td></tr></table></figure>

<p>换而言之，我们这个消息的结构体实际上就是<strong>传递给了窗口函数</strong>，<strong>其四个参数对应着消息结构体的前四个成员</strong>。</p>
<h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><p>每个线程只有一个消息队列。</p>
<p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image2021-5-28_21-47-51.png" srcset="https://picbedddd.oss-cn-beijing.aliyuncs.com/blog/loading.gif" lazyload alt="images/download/attachments/12714992/image2021-5-28_21-47-51.png"></p>
<h2 id="消息类型"><a href="#消息类型" class="headerlink" title="消息类型"></a>消息类型</h2><p>我们想要关注自己想要关注的消息类型，首先可以在窗口函数中打印消息类型来看看都有什么消息类型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 窗口函数定义</span><br>LRESULT CALLBACK <span class="hljs-title function_">WindowProc</span><span class="hljs-params">(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span> &#123;<br>    <span class="hljs-type">char</span> szOutBuff[<span class="hljs-number">0x80</span>];<br>    <span class="hljs-built_in">sprintf</span>(szOutBuff, <span class="hljs-string">&quot;Message: %x - %x \n&quot;</span>, hwnd, uMsg);<br>    OutputDebugString(szOutBuff);<br>    <span class="hljs-comment">// 必须要调用一个默认的消息处理函数，关闭、最小化、最大化都是由默认消息处理函数处理的</span><br>    <span class="hljs-keyword">return</span> DefWindowProc(hwnd, uMsg, wParam, lParam);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image2021-6-1_23-41-40.png" srcset="https://picbedddd.oss-cn-beijing.aliyuncs.com/blog/loading.gif" lazyload alt="images/download/attachments/12714992/image2021-6-1_23-41-40.png"></p>
<p>可以看见这边输出了一个0x1，想要知道这个对应着什么，我们可以在<strong>C:\Program Files\Microsoft Visual Studio\VC98\Include</strong>目录中找到<strong>WINUSER.H</strong>这个文件来查看，搜索0x0001就可以找到：</p>
<p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image2021-6-1_23-46-11.png" srcset="https://picbedddd.oss-cn-beijing.aliyuncs.com/blog/loading.gif" lazyload alt="images/download/attachments/12714992/image2021-6-1_23-46-11.png"></p>
<p>那么我们可以看见对应的宏就是<strong>WM_CREATE</strong>，这个消息的意思就是窗口创建，所以我们有很多消息是不需要关注的，而且消息时刻都在产生，非常非常多。</p>
<h3 id="处理窗口关闭"><a href="#处理窗口关闭" class="headerlink" title="处理窗口关闭"></a>处理窗口关闭</h3><p>在窗口关闭时，实际上进程并不会关闭，所以我们需要在窗口函数中筛选条件，当窗口关闭了就退出进程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 窗口函数定义</span><br>LRESULT CALLBACK <span class="hljs-title function_">WindowProc</span><span class="hljs-params">(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span> &#123;<br>    <span class="hljs-keyword">switch</span>(uMsg) &#123;<br>    <span class="hljs-comment">// 当窗口关闭则退出进程</span><br>    <span class="hljs-keyword">case</span> WM_DESTROY:<br>        &#123;<br>            PostQuitMessage(<span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">    <span class="hljs-comment">// 必须要调用一个默认的消息处理函数，关闭、最小化、最大化都是由默认消息处理函数处理的</span><br>    return <span class="hljs-constructor">DefWindowProc(<span class="hljs-params">hwnd</span>, <span class="hljs-params">uMsg</span>, <span class="hljs-params">wParam</span>, <span class="hljs-params">lParam</span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="处理键盘按下"><a href="#处理键盘按下" class="headerlink" title="处理键盘按下"></a>处理键盘按下</h3><p>我们除了可以处理窗口关闭，处理键盘按下也是没问题的，键盘按下的宏是WM_KEYDOWN，但是我们想要按下a这个键之后才处理该怎么办？首先我们需要查阅一下MSDN Library：</p>
<figure class="highlight hsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs hsp">LRESULT CALLBACK WindowProc(<br>  <span class="hljs-keyword">HWND</span> <span class="hljs-keyword">hwnd</span>,       <span class="hljs-comment">// handle to window</span><br>  UINT uMsg,       <span class="hljs-comment">// WM_KEYDOWN</span><br>  <span class="hljs-keyword">WPARAM</span> <span class="hljs-keyword">wParam</span>,   <span class="hljs-comment">// virtual-key code</span><br>  <span class="hljs-keyword">LPARAM</span> <span class="hljs-keyword">lParam</span>    <span class="hljs-comment">// key data</span><br>)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>

<p>可以很清楚的看见窗口函数的第三个参数就是虚拟键码（键盘上每个键都对应一个虚拟键码），我们可以输出下按下a，其对应虚拟键码是什么：</p>
<figure class="highlight hsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs hsp"><span class="hljs-comment">// 窗口函数定义</span><br>LRESULT CALLBACK WindowProc(<span class="hljs-keyword">HWND</span> <span class="hljs-keyword">hwnd</span>, UINT uMsg, <span class="hljs-keyword">WPARAM</span> <span class="hljs-keyword">wParam</span>, <span class="hljs-keyword">LPARAM</span> <span class="hljs-keyword">lParam</span>) &#123;<br>    <span class="hljs-keyword">switch</span>(uMsg) &#123;<br>    <span class="hljs-comment">// 当键盘按下则处理</span><br>    <span class="hljs-keyword">case</span> WM_KEYDOWN:<br>        &#123;<br>            char szOutBuff[<span class="hljs-number">0</span>x80]<span class="hljs-comment">;</span><br>            sprintf(szOutBuff, <span class="hljs-string">&quot;keycode: %x \n&quot;</span>, <span class="hljs-keyword">wParam</span>)<span class="hljs-comment">;</span><br>            OutputDebugString(szOutBuff)<span class="hljs-comment">;</span><br>            <span class="hljs-keyword">break</span><span class="hljs-comment">;</span><br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">    <span class="hljs-comment">// 必须要调用一个默认的消息处理函数，关闭、最小化、最大化都是由默认消息处理函数处理的</span><br>    return <span class="hljs-constructor">DefWindowProc(<span class="hljs-params">hwnd</span>, <span class="hljs-params">uMsg</span>, <span class="hljs-params">wParam</span>, <span class="hljs-params">lParam</span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image2021-6-2_0-10-19.png" srcset="https://picbedddd.oss-cn-beijing.aliyuncs.com/blog/loading.gif" lazyload alt="images/download/attachments/12714992/image2021-6-2_0-10-19.png"></p>
<p>如上图所示，按下a之后输出的虚拟键码是0x41，所以我们可以根据这个来进行判断。</p>
<h2 id="转换消息"><a href="#转换消息" class="headerlink" title="转换消息"></a>转换消息</h2><p>之前我们举例可以处理键盘按下的消息，但是我们想要直观的看到底输入了什么而不是虚拟键码该怎么办？这时候我们就需要使用WM_CHAR这个宏了，但是在这之前，我们的消息是必须要经过转换的，只有其转换了，我们的虚拟键码才能变成具体的字符。</p>
<p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image2021-6-2_0-17-29.png" srcset="https://picbedddd.oss-cn-beijing.aliyuncs.com/blog/loading.gif" lazyload alt="images/download/attachments/12714992/image2021-6-2_0-17-29.png"></p>
<p>WM_CHAR宏对应的窗口函数参数作用如下：</p>
<figure class="highlight hsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs hsp">LRESULT CALLBACK WindowProc(<br>  <span class="hljs-keyword">HWND</span> <span class="hljs-keyword">hwnd</span>,       <span class="hljs-comment">// handle to window</span><br>  UINT uMsg,       <span class="hljs-comment">// WM_CHAR</span><br>  <span class="hljs-keyword">WPARAM</span> <span class="hljs-keyword">wParam</span>,   <span class="hljs-comment">// character code (TCHAR)</span><br>  <span class="hljs-keyword">LPARAM</span> <span class="hljs-keyword">lParam</span>    <span class="hljs-comment">// key data</span><br>)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>

<p>第三个参数就是字符所以我们直接输出这个即可：</p>
<p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image2021-6-2_0-16-57.png" srcset="https://picbedddd.oss-cn-beijing.aliyuncs.com/blog/loading.gif" lazyload alt="images/download/attachments/12714992/image2021-6-2_0-16-57.png"></p>
<h2 id="窗口与线程"><a href="#窗口与线程" class="headerlink" title="窗口与线程"></a>窗口与线程</h2><p>当我们把鼠标点击左边窗口关闭按钮，为什么它会关闭，这个关闭（坐标、左右键…）操作系统会封装到结构体里（消息），那么这个消息如何精确的传递给对应进程的线程呢？</p>
<p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image2021-5-28_21-52-48.png" srcset="https://picbedddd.oss-cn-beijing.aliyuncs.com/blog/loading.gif" lazyload alt="images/download/attachments/12714992/image2021-5-28_21-52-48.png"></p>
<p>那是因为操作系统可以将坐标之类的作为索引，去找到对应的窗口，窗口在内核中是有窗口对象的，而这个窗口对象就会包含一个成员，这个成员就是线程对象的指针，线程又包含了消息，所以这样一个顺序就很容易理解了。</p>
<p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image2021-5-28_21-57-18.png" srcset="https://picbedddd.oss-cn-beijing.aliyuncs.com/blog/loading.gif" lazyload alt="images/download/attachments/12714992/image2021-5-28_21-57-18.png"></p>
<p>注意：一个线程可以有多个窗口，但是一个窗口只属于一个线程。</p>
<h2 id="消息堆栈"><a href="#消息堆栈" class="headerlink" title="消息堆栈"></a>消息堆栈</h2><p>调用消息处理函数（WinProc）形成的栈帧如下所示，这里假定使用ESP寻址方式：</p>
<p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image-20211230104130403.png" srcset="https://picbedddd.oss-cn-beijing.aliyuncs.com/blog/loading.gif" lazyload alt="image-20211230104130403"></p>
<p>如上可以看到，ESP+8就是我们需要的消息类型参数，基于此可以条件断点（消息断点）便于我们调试。</p>
<h2 id="调试流程"><a href="#调试流程" class="headerlink" title="调试流程"></a>调试流程</h2><h3 id="Win32应用程序入口识别"><a href="#Win32应用程序入口识别" class="headerlink" title="Win32应用程序入口识别"></a>Win32应用程序入口识别</h3><p>还记得WinMain这个入口函数长什么样吗，它的特征是会有四个参数。也就是在反汇编调试的时候会对应着四个PUSH。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> APIENTRY <span class="hljs-title function_">WinMain</span><span class="hljs-params">(HINSTANCE hInstance,</span><br><span class="hljs-params">                     HINSTANCE hPrevInstance,</span><br><span class="hljs-params">                     LPSTR     lpCmdLine,</span><br><span class="hljs-params">                     <span class="hljs-type">int</span>       nCmdShow)</span><br></code></pre></td></tr></table></figure>

<p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image-20211229105030199.png" srcset="https://picbedddd.oss-cn-beijing.aliyuncs.com/blog/loading.gif" lazyload alt="image-20211229105030199"></p>
<p>其中还有一个PUSH是GetModuleHandle函数的返回值（存在EAX）里，这些都是WinMain函数的特征。</p>
<h3 id="窗口回调函数的定位"><a href="#窗口回调函数的定位" class="headerlink" title="窗口回调函数的定位"></a>窗口回调函数的定位</h3><p>在定位到WinMain函数后，我们可以进一步定位到RegisterClass函数：</p>
<p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image-20211229105453841.png" srcset="https://picbedddd.oss-cn-beijing.aliyuncs.com/blog/loading.gif" lazyload alt="image-20211229105453841"></p>
<p>通过该函数我们可以找到我们定义的WNDCLASS结构体，进而拿到消息处理函数的地址：</p>
<p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image-20211229105637846.png" srcset="https://picbedddd.oss-cn-beijing.aliyuncs.com/blog/loading.gif" lazyload alt="image-20211229105637846"></p>
<p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image-20211229105707544.png" srcset="https://picbedddd.oss-cn-beijing.aliyuncs.com/blog/loading.gif" lazyload alt="image-20211229105707544"></p>
<h3 id="具体事件的处理的定位"><a href="#具体事件的处理的定位" class="headerlink" title="具体事件的处理的定位"></a>具体事件的处理的定位</h3><p>Windows的消息是多种多样的，我们需要快速筛选出我们需要关注的消息。这个可以通过条件断点来实现，在401120处打上断点，在断点界面输入相应的条件即可完成筛选：</p>
<p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image-20211229105926271.png" srcset="https://picbedddd.oss-cn-beijing.aliyuncs.com/blog/loading.gif" lazyload alt="image-20211229105926271"></p>
<h3 id="含有子窗口的回调函数的定位"><a href="#含有子窗口的回调函数的定位" class="headerlink" title="含有子窗口的回调函数的定位"></a>含有子窗口的回调函数的定位</h3><p>以按钮为例，按钮是一个特殊的子窗口，它的回调函数是由操作系统提供的。当我们点击按钮时，将按下图所示进行处理：</p>
<pre><code class=" mermaid">graph LR;
	按钮--单击按钮--&gt;Windows提供的WinProc函数
	Windows提供的WinProc函数--转化为WM_COMMAND--&gt;父窗口的WinProc
</code></pre>



<p>一个典型的C语言子窗口事件处理逻辑如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">case</span> WM_COMMAND:								<br>&#123;								<br>	<span class="hljs-keyword">switch</span>(LOWORD(wParam))							<br>	&#123;							<br>		<span class="hljs-keyword">case</span> <span class="hljs-number">1001</span>:						<br>			MessageBox(hwnd,<span class="hljs-string">&quot;Hello Button 1&quot;</span>,<span class="hljs-string">&quot;Demo&quot;</span>,MB_OK);					<br>			<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;					<br>		<span class="hljs-keyword">case</span> <span class="hljs-number">1002</span>:						<br>			MessageBox(hwnd,<span class="hljs-string">&quot;Hello Button 2&quot;</span>,<span class="hljs-string">&quot;Demo&quot;</span>,MB_OK);					<br>			<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;					<br>		<span class="hljs-keyword">case</span> <span class="hljs-number">1003</span>:						<br>			MessageBox(hwnd,<span class="hljs-string">&quot;Hello Button 3&quot;</span>,<span class="hljs-string">&quot;Demo&quot;</span>,MB_OK);					<br>			<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;					<br>	&#125;							<br>	<span class="hljs-keyword">return</span> DefWindowProc(hwnd,uMsg,wParam,lParam);							<br>&#125;								<br></code></pre></td></tr></table></figure>

<p>其中1001-1003是调用创建窗口函数时传入的菜单句柄参数。由上我们可以看到，在转成WM_COMMAND后的菜单句柄参数将放在wParam参数的低字中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c">hwndPushButton = CreateWindow(<br>    TEXT(<span class="hljs-string">&quot;button&quot;</span>),<br>    TEXT(<span class="hljs-string">&quot;普通按钮&quot;</span>),<br>    <span class="hljs-comment">//WS_CHILD | WS_VISIBLE | BS_PUSHBUTTON | BS_DEFPUSHBUTTON,            </span><br>    WS_CHILD | WS_VISIBLE | BS_PUSHBUTTON | BS_DEFPUSHBUTTON,<br>    <span class="hljs-number">10</span>, <span class="hljs-number">10</span>,<br>    <span class="hljs-number">80</span>, <span class="hljs-number">20</span>,<br>    hwnd,<br>    (HMENU)<span class="hljs-number">1001</span>,    <span class="hljs-comment">//子窗口ID                        </span><br>    hAppInstance,<br>    <span class="hljs-literal">NULL</span>);<br></code></pre></td></tr></table></figure>

<p>所以在调试的时候，我们通过条件断点筛选出WM_COMMAND（0x111）再进行处理即可。</p>
<h2 id="复杂程序的回调函数的定位"><a href="#复杂程序的回调函数的定位" class="headerlink" title="复杂程序的回调函数的定位"></a>复杂程序的回调函数的定位</h2><p>当我们要逆向的程序十分复杂，可能无法直接找到消息处理函数的时候，需要通过间接的方式帮助我们找到消息断点。</p>
<p>在Ollydbg的Windows窗口中，可以看到我们需要跟踪的窗口，在上面下消息断点即可。</p>
<p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image-20211230152447454.png" srcset="https://picbedddd.oss-cn-beijing.aliyuncs.com/blog/loading.gif" lazyload alt="image-20211230152447454"></p>
<p>Button在之前介绍过是先调用系统的消息处理函数再转换成WM_COMMAND消息传递给开发者自己编写的消息处理函数。</p>
<p>于是乎，我们可以在用户代码段下一个内存访问断点，当操作系统调用自定义的消息处理函数时就会触发。</p>
<p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image-20211230152804049.png" srcset="https://picbedddd.oss-cn-beijing.aliyuncs.com/blog/loading.gif" lazyload alt="image-20211230152804049"></p>
<p>这里注意有很多个.text段，需要找到自己的PE文件对应的.text段</p>
<p>设置内存访问断点后F9运行，就会断到用用户空间的消息处理函数。</p>
<p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image-20211230153025831.png" srcset="https://picbedddd.oss-cn-beijing.aliyuncs.com/blog/loading.gif" lazyload alt="image-20211230153025831"></p>
<p>这里需要同样注意的是，当我们点击按钮时可能不止产生一种消息，我们还需要通过消息堆栈中的消息类型来判断是否是我们关注的消息类型。在这里我们需要关注的是WM_COMMAND（0x111）。而最初的消息是0x135：</p>
<p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image-20211230153449710.png" srcset="https://picbedddd.oss-cn-beijing.aliyuncs.com/blog/loading.gif" lazyload alt="image-20211230153449710"></p>
<p>这个时候虽然不是我们关注的消息类型，但是我们已经找到了消息处理函数的位置了。我们可将内存访问断点取消并用消息处理函数的第一行代码上下断点代替，之后再次F9运行代码，这里得到的就是我们关注的0x111消息了，之后继续跟进即可。</p>
<p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image-20211230153810345.png" srcset="https://picbedddd.oss-cn-beijing.aliyuncs.com/blog/loading.gif" lazyload alt="image-20211230153810345"></p>
<h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><h2 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a>线程创建</h2><p>举例说明之，在Win32程序中，如果有循环或者其他占用时间较长的代码，主线程的消息处理函数将无法得到正常执行。这个时候需要引入新的线程来完成业务逻辑。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c">HANDLE <span class="hljs-title function_">CreateThread</span><span class="hljs-params">(<span class="hljs-comment">// 返回值：线程句柄			</span></span><br><span class="hljs-params">	LPSECURITY_ATTRIBUTES lpThreadAttributes,	<span class="hljs-comment">// 安全属性 通常为NULL				</span></span><br><span class="hljs-params">	SIZE_T dwStackSize,							<span class="hljs-comment">// 参数用于设定线程可以将多少地址空间用于它自己的堆栈				</span></span><br><span class="hljs-params">												<span class="hljs-comment">// 每个线程拥有它自己的堆栈</span></span><br><span class="hljs-params">	LPTHREAD_START_ROUTINE lpStartAddress,		<span class="hljs-comment">// 参数用于指明想要新线程执行的线程函数的地址				</span></span><br><span class="hljs-params">	LPVOID lpParameter,							<span class="hljs-comment">// 线程函数的参数				</span></span><br><span class="hljs-params">												<span class="hljs-comment">// 在线程启动执行时将该参数传递给线程函数</span></span><br><span class="hljs-params">												<span class="hljs-comment">// 既可以是数字，也可以是指向包含其他信息的一个数据结构的指针</span></span><br><span class="hljs-params">	DWORD dwCreationFlags,						<span class="hljs-comment">// 0 创建完毕立即调度  CREATE_SUSPENDED创建后挂起				</span></span><br><span class="hljs-params">	LPDWORD lpThreadId							<span class="hljs-comment">// 线程ID 				</span></span><br><span class="hljs-params">)</span>;				<br><br></code></pre></td></tr></table></figure>



<h3 id="创建线程时提供参数"><a href="#创建线程时提供参数" class="headerlink" title="创建线程时提供参数"></a>创建线程时提供参数</h3><p>向线程传递参数，如下图所示，我们想要自定义线程执行for循环的次数，将n传递进去，这时候需要注意参数传递到线程参数时在堆栈中存在，并且传递的时候需要强制转换一下：</p>
<p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image2021-5-22_2-12-19.png" srcset="https://picbedddd.oss-cn-beijing.aliyuncs.com/blog/loading.gif" lazyload alt="images/download/attachments/12714992/image2021-5-22_2-12-19.png"></p>
<p>这里有一个坑点是需要考虑参数的生命周期问题，如MyTest()这样的函数在执行完后会销毁堆栈，亦即清空其中的局部变量，当新的线程尝试引用这些变量时将发生错误。</p>
<p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image-20220119125748588.png" srcset="https://picbedddd.oss-cn-beijing.aliyuncs.com/blog/loading.gif" lazyload alt="image-20220119125748588"></p>
<p>解决方法之一是将参数放在全局变量区：</p>
<p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image-20220119125807272.png" srcset="https://picbedddd.oss-cn-beijing.aliyuncs.com/blog/loading.gif" lazyload alt="image-20220119125807272"></p>
<h2 id="线程控制"><a href="#线程控制" class="headerlink" title="线程控制"></a>线程控制</h2><h4 id="Sleep"><a href="#Sleep" class="headerlink" title="Sleep"></a>Sleep</h4><p>Sleep函数是让当前执行到本函数时延迟指定的毫秒之后再向下走，例如：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">for</span>(int i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>    <span class="hljs-built_in">Sleep</span>(<span class="hljs-number">500</span>);<br>    <span class="hljs-built_in">printf</span>(&quot;------ %d \n&quot;, i);<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="线程挂起与恢复"><a href="#线程挂起与恢复" class="headerlink" title="线程挂起与恢复"></a>线程挂起与恢复</h4><p><strong>SuspendThread</strong></p>
<p>SuspendThread函数用于暂停（挂起）某个线程，当暂停后该线程不会占用CPU，其语法格式很简单，只需要传入一个线程句柄即可：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function">DWORD <span class="hljs-title">SuspendThread</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  HANDLE hThread   <span class="hljs-comment">// handle to thread</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br></code></pre></td></tr></table></figure>

<p><strong>ResumeThread</strong></p>
<p>ResumeThread函数用于恢复被暂停（挂起）的线程，其语法格式也很简单，只需要传入一个线程句柄即可：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function">DWORD <span class="hljs-title">ResumeThread</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  HANDLE hThread   <span class="hljs-comment">// handle to thread</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br></code></pre></td></tr></table></figure>

<p>需要注意的是，挂起几次就要恢复几次。</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-constructor">SuspendThread(<span class="hljs-params">hThread</span>)</span>;<br><span class="hljs-constructor">SuspendThread(<span class="hljs-params">hThread</span>)</span>;<br></code></pre></td></tr></table></figure>

<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-constructor">ResumeThread(<span class="hljs-params">hThread</span>)</span>;<br><span class="hljs-constructor">ResumeThread(<span class="hljs-params">hThread</span>)</span>;<br></code></pre></td></tr></table></figure>



<h4 id="线程终止"><a href="#线程终止" class="headerlink" title="线程终止"></a>线程终止</h4><p>线程终止有如下三种方式</p>
<p>①</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">::ExitThread(DWORD dwExitCode);	<br></code></pre></td></tr></table></figure>

<p>②线程函数返回</p>
<p>③</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">::TerminateThread(hThread,<span class="hljs-number">2</span>);		<br>::WaitForSingleObject(hThread,INFINITE);<br></code></pre></td></tr></table></figure>

<p>①和③方式的区别就是①是同步的，③是异步的。</p>
<h4 id="GetExitCodeThread"><a href="#GetExitCodeThread" class="headerlink" title="GetExitCodeThread"></a>GetExitCodeThread</h4><p>线程函数会有一个返回值（DWORD），这个返回值可以根据你的需求进行返回，而我们需要如何获取这个返回结果呢？这时候就可以使用<strong>GetExitCodeThread</strong>函数，其语法格式如下：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function">BOOL <span class="hljs-title">GetExitCodeThread</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  HANDLE hThread,      <span class="hljs-comment">// handle to the thread</span></span></span><br><span class="hljs-params"><span class="hljs-function">  LPDWORD lpExitCode   <span class="hljs-comment">// termination status</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br></code></pre></td></tr></table></figure>

<p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image2021-5-23_15-37-48.png" srcset="https://picbedddd.oss-cn-beijing.aliyuncs.com/blog/loading.gif" lazyload alt="images/download/attachments/12714992/image2021-5-23_15-37-48.png"></p>
<p>根据MSDN Library我们可以知道该函数的参数分别是线程句柄，而另一个则是out类型参数，这种类型则可以理解为GetExitCodeThread函数的返回结果。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">HANDLE hThread;<br>hThread = CreateThread(<span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, ThreadProc, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);<br>WaitForSingleObject(hThread, INFINITE);<br>DWORD exitCode;<br>GetExitCodeThread(hThread, &amp;exitCode);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Exit Code: %d \n&quot;</span>, exitCode);<br></code></pre></td></tr></table></figure>

<p>若ExitCode为STILL_ACTIVE，则表示该线程正在运行。</p>
<p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image2021-5-23_15-44-6.png" srcset="https://picbedddd.oss-cn-beijing.aliyuncs.com/blog/loading.gif" lazyload alt="images/download/attachments/12714992/image2021-5-23_15-44-6.png"></p>
<p>需要注意的是这个函数应该搭配着如上所学的2个等待函数一起使用，不然获取到的值就不会是线程函数返回的值。</p>
<h2 id="设置、获取线程上下文"><a href="#设置、获取线程上下文" class="headerlink" title="设置、获取线程上下文"></a>设置、获取线程上下文</h2><p><strong>线程上下文</strong>是指某一时间点CPU寄存器和程序计数器的内容，如果想要设置、获取线程上下文就需要先将线程<strong>挂起</strong>。</p>
<h3 id="GetThreadContext函数"><a href="#GetThreadContext函数" class="headerlink" title="GetThreadContext函数"></a>GetThreadContext函数</h3><p>GetThreadContext函数用于获取线程上下文，其语法格式如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">BOOL <span class="hljs-title function_">GetThreadContext</span><span class="hljs-params">(</span><br><span class="hljs-params">  HANDLE hThread,       <span class="hljs-comment">// handle to thread with context 句柄</span></span><br><span class="hljs-params">  LPCONTEXT lpContext   <span class="hljs-comment">// context structure</span></span><br><span class="hljs-params">)</span>;<br></code></pre></td></tr></table></figure>

<p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image2021-5-23_15-52-19.png" srcset="https://picbedddd.oss-cn-beijing.aliyuncs.com/blog/loading.gif" lazyload alt="images/download/attachments/12714992/image2021-5-23_15-52-19.png"></p>
<p>第一个参数就是线程句柄，这个很好理解，重点是第二个参数，其是一个CONTEXT结构体，该结构体包含指定线程的上下文，其ContextFlags成员的值指定了要设置线程上下文的哪些部分。</p>
<p>当我们将CONTEXT结构体的ContextFlags成员的值设置为CONTEXT_INTEGER时则可以获取edi、esi、ebx、edx、ecx、eax这些寄存器的值：</p>
<p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image2021-5-23_16-1-25.png" srcset="https://picbedddd.oss-cn-beijing.aliyuncs.com/blog/loading.gif" lazyload alt="images/download/attachments/12714992/image2021-5-23_16-1-25.png"></p>
<p>如下代码尝试获取：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">HANDLE hThread;<br>hThread = CreateThread(<span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, ThreadProc, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);<br>SuspendThread(hThread);<br>CONTEXT c;<br>c.ContextFlags = CONTEXT_INTEGER;<br>GetThreadContext(hThread, &amp;c);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%x %x \n&quot;</span>, c.Eax, c.Ecx);<br></code></pre></td></tr></table></figure>



<p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image2021-5-23_16-1-50.png" srcset="https://picbedddd.oss-cn-beijing.aliyuncs.com/blog/loading.gif" lazyload alt="images/download/attachments/12714992/image2021-5-23_16-1-50.png"></p>
<h3 id="SetThreadContext函数"><a href="#SetThreadContext函数" class="headerlink" title="SetThreadContext函数"></a>SetThreadContext函数</h3><p>GetThreadContext函数是个设置修改线程上下文，其语法格式如下：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">BOOL SetThreadContext(<br>  HANDLE hThread,            <span class="hljs-regexp">//</span> handle to thread<br>  CONST CONTEXT *lpContext   <span class="hljs-regexp">//</span> context structure<br>);<br></code></pre></td></tr></table></figure>

<p>我们可以尝试修改Eax，然后再获取：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c">HANDLE hThread;<br>hThread = CreateThread(<span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, ThreadProc, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);<br>SuspendThread(hThread);<br>CONTEXT c;<br>c.ContextFlags = CONTEXT_INTEGER;<br>c.Eax = <span class="hljs-number">0x123</span>;<br>SetThreadContext(hThread, &amp;c);<br>CONTEXT c1;<br>c1.ContextFlags = CONTEXT_INTEGER;<br>GetThreadContext(hThread, &amp;c1);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%x \n&quot;</span>, c1.Eax);<br></code></pre></td></tr></table></figure>



<p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image2021-5-23_16-9-51.png" srcset="https://picbedddd.oss-cn-beijing.aliyuncs.com/blog/loading.gif" lazyload alt="images/download/attachments/12714992/image2021-5-23_16-9-51.png"></p>
<h2 id="线程互斥与线程同步"><a href="#线程互斥与线程同步" class="headerlink" title="线程互斥与线程同步"></a>线程互斥与线程同步</h2><h3 id="几种相关的结构"><a href="#几种相关的结构" class="headerlink" title="几种相关的结构"></a>几种相关的结构</h3><h4 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h4><h5 id="临界区的实现"><a href="#临界区的实现" class="headerlink" title="临界区的实现"></a>临界区的实现</h5><p>首先会有一个令牌，假设线程1获取了这个令牌，那么这时候令牌则只为线程1所有，然后线程1会执行代码去访问全局变量，最后归还令牌；<strong>如果其他线程想要去访问这个全局变量就需要获取这个令牌，但当令牌已经被取走时则无法访问</strong>。</p>
<p>假设你自己来实现临界区，可能在判断令牌有没有被拿走的时候就又会出现问题，所以自己实现临界区还是有一定的门槛的。</p>
<p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image2021-5-27_15-24-36.png" srcset="https://picbedddd.oss-cn-beijing.aliyuncs.com/blog/loading.gif" lazyload alt="images/download/attachments/12714992/image2021-5-27_15-24-36.png"></p>
<h5 id="线程锁"><a href="#线程锁" class="headerlink" title="线程锁"></a>线程锁</h5><p>线程锁就是临界区的实现方式，通过线程锁我们可以完美解决如上所述的问题，其步骤如下所示：</p>
<ol>
<li>创建全局变量：CRITICAL_SECTION cs;</li>
<li>初始化全局变量：InitializeCriticalSection(&amp;cs);</li>
<li>实现临界区：进入 → EnterCriticalSection(&amp;cs); 离开 → LeaveCriticalSection(&amp;cs);</li>
</ol>
<h5 id="临界区使用"><a href="#临界区使用" class="headerlink" title="临界区使用"></a>临界区使用</h5><p>我们就可以这样改写之前的售卖物品的代码：</p>
<p>在使用全局变量开始前构建并进入临界区，使用完之后离开临界区：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;windows.h&gt;</span></span><br><br>CRITICAL_SECTION cs; <span class="hljs-comment">// 创建全局变量</span><br><span class="hljs-type">int</span> countNumber = <span class="hljs-number">10</span>;<br><br>DWORD WINAPI <span class="hljs-title function_">ThreadProc</span><span class="hljs-params">(LPVOID lpParameter)</span> &#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        EnterCriticalSection(&amp;cs); <span class="hljs-comment">// 构建临界区，获取令牌</span><br>        <span class="hljs-keyword">if</span> (countNumber &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Thread: %d\n&quot;</span>, *((<span class="hljs-type">int</span>*)lpParameter));<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Sell num: %d\n&quot;</span>, countNumber);<br>            <span class="hljs-comment">// 售出-1</span><br>            countNumber--;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Count: %d\n&quot;</span>, countNumber);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            LeaveCriticalSection(&amp;cs); <span class="hljs-comment">// 离开临临界区，归还令牌</span><br>            <span class="hljs-keyword">break</span>;  <br>        &#125;<br>        LeaveCriticalSection(&amp;cs); <span class="hljs-comment">// 离开临临界区，归还令牌</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span><br>&#123;<br><br>    InitializeCriticalSection(&amp;cs); <span class="hljs-comment">// 使用之前进行初始化</span><br>    <br>    <span class="hljs-type">int</span> a = <span class="hljs-number">1</span>;<br>    HANDLE hThread;<br>    hThread = CreateThread(<span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, ThreadProc, (LPVOID)&amp;a, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);<br>    <br>    <span class="hljs-type">int</span> b = <span class="hljs-number">2</span>;<br>    HANDLE hThread1;<br>    hThread1 = CreateThread(<span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, ThreadProc, (LPVOID)&amp;b, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);<br><br>    CloseHandle(hThread);<br><br>    getchar();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image2021-5-27_15-54-0.png" srcset="https://picbedddd.oss-cn-beijing.aliyuncs.com/blog/loading.gif" lazyload alt="images/download/attachments/12714992/image2021-5-27_15-54-0.png"></p>
<h4 id="互斥体"><a href="#互斥体" class="headerlink" title="互斥体"></a>互斥体</h4><p>我们了解了使用线程锁来解决多个线程共用一个全局变量的线程安全问题；<strong>那么假设A进程的B线程和C进程的D线程</strong>，同时使用的是内核级的临界资源（<strong>内核对象：线程、文件、进程…<strong>）该怎么让这个访问是安全的？</strong>使用线程锁的方式明显不行，因为线程锁仅能控制同进程中的多线程</strong>。</p>
<p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image2021-5-27_16-8-12.png" srcset="https://picbedddd.oss-cn-beijing.aliyuncs.com/blog/loading.gif" lazyload alt="images/download/attachments/12714992/image2021-5-27_16-8-12.png"></p>
<p>那么这时候我们就需要一个<strong>能够放在内核中的令牌</strong>来控制，而实现这个作用的，我们称之为<strong>互斥体</strong>。</p>
<p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image2021-5-27_16-10-43.png" srcset="https://picbedddd.oss-cn-beijing.aliyuncs.com/blog/loading.gif" lazyload alt="images/download/attachments/12714992/image2021-5-27_16-10-43.png"></p>
<h5 id="互斥体的使用"><a href="#互斥体的使用" class="headerlink" title="互斥体的使用"></a>互斥体的使用</h5><p>创建互斥体的函数为<strong>CreateMutex</strong>，该函数的语法格式如下：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">HANDLE CreateMutex(<br>  LPSECURITY_ATTRIBUTES lpMutexAttributes,  <span class="hljs-regexp">//</span> SD 安全属性，包含安全描述符<br>  BOOL bInitialOwner,                       <span class="hljs-regexp">//</span> initial owner 是否希望互斥体创建出来就有信号，或者说就可以使用，如果希望的话就为FALSE；官方解释为如果该值为TRUE则表示当前进程拥有该互斥体所有权<br>  LPCTSTR lpName                            <span class="hljs-regexp">//</span> object name 互斥体的名字<br>);<br></code></pre></td></tr></table></figure>

<p>我们可以模拟一下操作资源然后创建：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;windows.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span><br>&#123;<br>    <span class="hljs-comment">// 创建互斥体</span><br>    HANDLE cm = CreateMutex(<span class="hljs-literal">NULL</span>, FALSE, <span class="hljs-string">&quot;XYZ&quot;</span>);<br>    <span class="hljs-comment">// 等待互斥体状态发生变化，也就是有信号或为互斥体拥有者，获取令牌</span><br>    WaitForSingleObject(cm, INFINITE);<br><br>    <span class="hljs-comment">// 操作资源</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Process: A Thread: B -- %d \n&quot;</span>, i);<br>        Sleep(<span class="hljs-number">1000</span>);<br>    &#125;<br>    <span class="hljs-comment">// 释放令牌</span><br>    ReleaseMutex(cm);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们可以运行两个进程来看一下互斥体的作用：</p>
<p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image2021-5-27_16-57-41.png" srcset="https://picbedddd.oss-cn-beijing.aliyuncs.com/blog/loading.gif" lazyload alt="images/download/attachments/12714992/image2021-5-27_16-57-41.png"></p>
<p><strong>互斥体和线程锁的区别</strong></p>
<ol>
<li>线程锁只能用于单个进程间的线程控制</li>
<li>互斥体可以设定等待超时，但线程锁不能</li>
<li>线程意外结束时，互斥体可以避免无限等待</li>
<li>互斥体效率没有线程锁高</li>
</ol>
<h5 id="课外扩展-互斥体防止程序多开"><a href="#课外扩展-互斥体防止程序多开" class="headerlink" title="课外扩展-互斥体防止程序多开"></a>课外扩展-互斥体防止程序多开</h5><p>CreateMutex函数的返回值MSDN Library的介绍是这样的：<strong>如果函数成功，返回值是一个指向mutex对象的句柄；如果命名的mutex对象在函数调用前已经存在，函数返回现有对象的句柄，GetLastError返回ERROR_ALREADY_EXISTS（表示互斥体以及存在）；否则，调用者创建该mutex对象；如果函数失败，返回值为NULL，要获得扩展的错误信息，请调用GetLastError获取</strong>。</p>
<p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image2021-5-27_16-53-41.png" srcset="https://picbedddd.oss-cn-beijing.aliyuncs.com/blog/loading.gif" lazyload alt="images/download/attachments/12714992/image2021-5-27_16-53-41.png"></p>
<p>所以我们可以利用互斥体来防止程序进行多开：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;windows.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span><br>&#123;<br>    <span class="hljs-comment">// 创建互斥体</span><br>    HANDLE cm = CreateMutex(<span class="hljs-literal">NULL</span>, TRUE, <span class="hljs-string">&quot;XYZ&quot;</span>);<br>    <span class="hljs-comment">// 判断互斥体是否创建失败</span><br>    <span class="hljs-keyword">if</span> (cm != <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-comment">// 判断互斥体是否已经存在，如果存在则表示程序被多次打开</span><br>        <span class="hljs-keyword">if</span> (GetLastError() == ERROR_ALREADY_EXISTS) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;该程序已经开启了，请勿再次开启！&quot;</span>);<br>            getchar();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 等待互斥体状态发生变化，也就是有信号或为互斥体拥有者，获取令牌</span><br>            WaitForSingleObject(cm, INFINITE);<br>            <span class="hljs-comment">// 操作资源</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Process: A Thread: B -- %d \n&quot;</span>, i);<br>                Sleep(<span class="hljs-number">1000</span>);<br>            &#125;<br>            <span class="hljs-comment">// 释放令牌</span><br>            ReleaseMutex(cm);<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;CreateMutex 创建失败! 错误代码: %d\n&quot;</span>, GetLastError());<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image2021-5-27_17-7-1.png" srcset="https://picbedddd.oss-cn-beijing.aliyuncs.com/blog/loading.gif" lazyload alt="images/download/attachments/12714992/image2021-5-27_17-7-1.png"></p>
<h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><p>事件本身也是一种内核对象，其也是是用来控制线程的。</p>
<p>创建事件使用函数<strong>CreateEvent</strong>，其语法格式如下：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">HANDLE CreateEvent(<br>  LPSECURITY_ATTRIBUTES lpEventAttributes, // SD 安全属性，包含安全描述符<br>  <span class="hljs-type">BOOL</span> bManualReset,                       // <span class="hljs-keyword">reset</span> <span class="hljs-keyword">type</span> 如果你希望当前事件类型是通知类型则写<span class="hljs-keyword">TRUE</span>，反之<span class="hljs-keyword">FALSE</span><br>  <span class="hljs-type">BOOL</span> bInitialState,                      // initial state 初始状态，决定创建出来时候是否有信号，有为<span class="hljs-keyword">TRUE</span>，没有为<span class="hljs-keyword">FALSE</span><br>  LPCTSTR lpName                           // <span class="hljs-keyword">object</span> <span class="hljs-type">name</span> 事件名字<br>);<br></code></pre></td></tr></table></figure>

<p>控制事件的函数只有一个</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">BOOL <span class="hljs-constructor">SetEvent(HANDLE <span class="hljs-params">hEvent</span>)</span>;				       <span class="hljs-comment">//将对象设置为已通知</span><br></code></pre></td></tr></table></figure>

<p>使用完事件对象要养成关闭句柄的好习惯</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">CloseHandle(hEvent);<br></code></pre></td></tr></table></figure>



<h4 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h4><p>创建信号量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">HANDLE <span class="hljs-title function_">CreateSemaphore</span><span class="hljs-params">(	</span><br><span class="hljs-params">	LPSECURITY_ATTRIBUTES lpSemaphoreAttributes, <span class="hljs-comment">//表示安全控制，一般直接传入NULL。</span></span><br><span class="hljs-params">	</span><br><span class="hljs-params">	LONG lInitialCount, <span class="hljs-comment">//表示初始资源数量。0时不发送信号</span></span><br><span class="hljs-params">	</span><br><span class="hljs-params">	LONG lMaximumCount, <span class="hljs-comment">//表示最大并发数量。lInitialCount&lt;=lMaximumCount</span></span><br><span class="hljs-params">	</span><br><span class="hljs-params">	LPCTSTR lpName <span class="hljs-comment">//表示信号量的名称，传入NULL表示匿名信号量</span></span><br><span class="hljs-params">)</span>;	<br></code></pre></td></tr></table></figure>

<p>打开信号量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c">HANDLE <span class="hljs-title function_">OpenSemaphore</span><span class="hljs-params">(	</span><br><span class="hljs-params"></span><br><span class="hljs-params">  DWORD dwDesiredAccess, <span class="hljs-comment">// 访问权限	</span></span><br><span class="hljs-params">		</span><br><span class="hljs-params">  BOOL bInheritHandle, <span class="hljs-comment">// 句柄继承性</span></span><br><span class="hljs-params">		</span><br><span class="hljs-params">  LPCTSTR lpName <span class="hljs-comment">// 名称，不同进程中的各线程可以通过名称来确保它们访问同一个信号量</span></span><br><span class="hljs-params">		</span><br><span class="hljs-params">)</span>;		<br><br></code></pre></td></tr></table></figure>

<p>增加信号量资源计数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">BOOL <span class="hljs-title function_">ReleaseSemaphore</span><span class="hljs-params">(		</span><br><span class="hljs-params">		</span><br><span class="hljs-params">	HANDLE hSemaphore, <span class="hljs-comment">//信号量的句柄</span></span><br><span class="hljs-params">		</span><br><span class="hljs-params">	LONG lReleaseCount, <span class="hljs-comment">//增加个数，必须大于0且不超过最大资源数量</span></span><br><span class="hljs-params">		</span><br><span class="hljs-params">	LPLONG lpPreviousCount <span class="hljs-comment">//当前资源数量的原始值，设为NULL表示不需要传出</span></span><br><span class="hljs-params">		</span><br><span class="hljs-params">)</span>;	<br></code></pre></td></tr></table></figure>

<p>销毁或清理信号量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">CloseHandle()<br></code></pre></td></tr></table></figure>



<h4 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h4><p><strong>临界区与互斥体</strong></p>
<p>1、临界区只能用于进程内的线程互斥，性能较好.<br>2、互斥体属于内核对象，可以用于进程间的线程互斥，性能较差.<br>3、线程在没有正常退出互斥区而意外终结时，互斥体可以复位，但临界区不行.</p>
<p><strong>事件与信号量</strong></p>
<p>1、都是内核对象，使用完毕后应该关闭句柄.								<br>2、信号量可以用于相当复杂的线程同步控制.	</p>
<h3 id="线程互斥"><a href="#线程互斥" class="headerlink" title="线程互斥"></a>线程互斥</h3><p>线程互斥是指对于共享的进程系统资源，在各单个线程访问时的排它性；当有若干个线程都要使用某一共享资源时，任何时刻最多只允许一个线程去使用，其它要使用该资源的线程必须等待，直到占用资源者释放该资源。</p>
<h4 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h4><p>每个线程都有自己的栈，局部变量是存储在栈中的，这就意味着每个进程都会有一份自己的“句柄变量”（栈），如果线程仅仅使用自己的“局部变量”那就不存在线程安全问题，反之，<strong>如果多个线程共用一个全局变量呢</strong>？那么在什么情况下会有问题呢？<strong>那就是当多线程共用一个全局变量并对其进行修改时则存在安全问题</strong>，如果仅仅是读的话没有问题。</p>
<p>如下所示代码，我们写了一个线程函数，该函数的作用就是使用全局变量，模拟的功能就是售卖物品，全局变量countNumber表示该物品的总是，其值是10，而如果有多个地方（线程）去卖（使用）这个物品（全局变量），则会出现差错：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;windows.h&gt;</span></span><br><br><span class="hljs-type">int</span> countNumber = <span class="hljs-number">10</span>;<br>DWORD WINAPI <span class="hljs-title function_">ThreadProc</span><span class="hljs-params">(LPVOID lpParameter)</span> &#123;<br>    <span class="hljs-keyword">while</span> (countNumber &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Sell num: %d\n&quot;</span>, countNumber);<br>        <span class="hljs-comment">// 售出-1</span><br>        countNumber--;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Count: %d\n&quot;</span>, countNumber);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span><br>&#123;<br>    HANDLE hThread;<br>    hThread = CreateThread(<span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, ThreadProc, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);<br>    <br>    HANDLE hThread1;<br>    hThread1 = CreateThread(<span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, ThreadProc, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);<br><br>    CloseHandle(hThread);<br><br>    getchar();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如图，我们运行了代码，发现会出现重复售卖，并且到最后总数竟变成了-1：</p>
<p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image2021-5-27_15-4-41.png" srcset="https://picbedddd.oss-cn-beijing.aliyuncs.com/blog/loading.gif" lazyload alt="images/download/attachments/12714992/image2021-5-27_15-4-41.png"></p>
<p>出现这样的问题其本质原因是什么呢？<strong>因为多线程在执行的时候是同步进行的，并不是按照顺序来，并且存在着对同一共享资源进行同时写或一读一写的情况，这造成了上面现象的发生</strong>。</p>
<p>想要解决线程安全问题，就需要引伸出一个概念：临界资源，<strong>临界资源表示对该资源的访问一次只能有一个线程；访问临界资源可以有多重形式，其中一种形式是临界区</strong>。</p>
<h3 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h3><p>线程同步是指线程之间所具有的一种制约关系，一个线程的执行依赖另一个线程的消息，当它没有得到另一个线程的消息时应等待，直到消息到达时才被唤醒；同步的前提是互斥，其次就是有序，<strong>互斥并不代表A线程访问临界资源后就一定是B线程再去访问，也有可能是A线程，这就是属于无序的状态</strong>，所以同步就是<strong>互斥加上有序</strong>。</p>
<p>线程同步主要靠WaitForSingleObject和WaitForMultipleObjects两个函数来完成。</p>
<h4 id="WaitForSingleObject-x2F-WaitForMultipleObjects"><a href="#WaitForSingleObject-x2F-WaitForMultipleObjects" class="headerlink" title="WaitForSingleObject&#x2F;WaitForMultipleObjects"></a>WaitForSingleObject&#x2F;WaitForMultipleObjects</h4><p>WaitForSingleObject函数用于等待<strong>一个内核对象（对内核对象的详细说明会在下一章中）</strong>状态发生变更，那也就是执行结束之后，才会继续向下执行，其语法格式如下：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">DWORD WaitForSingleObject(<br>  HANDLE hHandle,        // handle <span class="hljs-keyword">to</span> <span class="hljs-keyword">object</span> 句柄<br>  DWORD dwMilliseconds   // <span class="hljs-type">time</span>-<span class="hljs-keyword">out</span> <span class="hljs-type">interval</span> 等待超时时间（毫秒）<br>);<br></code></pre></td></tr></table></figure>

<p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image2021-5-23_12-34-19.png" srcset="https://picbedddd.oss-cn-beijing.aliyuncs.com/blog/loading.gif" lazyload alt="images/download/attachments/12714992/image2021-5-23_12-34-19.png"></p>
<p>如果你想一直等待的话，可以将第二参数的值设置为<strong>INFINITE</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">HANDLE hThread;<br>hThread = <span class="hljs-built_in">CreateThread</span>(<span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, ThreadProc, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);<br><span class="hljs-built_in">WaitForSingleObject</span>(hThread, INFINITE);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;OK...&quot;</span>);<br></code></pre></td></tr></table></figure>





<p>WaitForMultipleObjects函数与WaitForSingleObject函数<strong>作用是一样</strong>的，只不过它可以等待<strong>多个内核对象的状态</strong>发生变更，其语法格式如下：</p>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs smali">DWORD WaitForMultipleObjects(<br>  DWORD nCount,             // number of handles in<span class="hljs-built_in"> array </span>内核对象的数量<br>  CONST HANDLE *lpHandles,  // object-handle<span class="hljs-built_in"> array </span>内核对象的句柄数组<br>  BOOL bWaitAll,            // wait option 等待模式<br>  DWORD dwMilliseconds      // time-out interval 等待超时时间（毫秒）<br>);<br></code></pre></td></tr></table></figure>

<p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image2021-5-23_15-30-41.png" srcset="https://picbedddd.oss-cn-beijing.aliyuncs.com/blog/loading.gif" lazyload alt="images/download/attachments/12714992/image2021-5-23_15-30-41.png"></p>
<p>等待模式的值是布尔类型，一个是TRUE，一个是FALSE，TRUE就是等待所有对象的所有状态发生变更，FALSE则是等待任意一个对象的状态发生变更。</p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arcade">HANDLE hThread[<span class="hljs-number">2</span>];<br>hThread[<span class="hljs-number">0</span>] = CreateThread(<span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, ThreadProc, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);<br>hThread[<span class="hljs-number">1</span>] = CreateThread(<span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, ThreadProc, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);<br>WaitForMultipleObjects(<span class="hljs-number">2</span>, hThread, <span class="hljs-literal">TRUE</span>, INFINITE);<br></code></pre></td></tr></table></figure>







<h3 id="生产者与消费者问题"><a href="#生产者与消费者问题" class="headerlink" title="生产者与消费者问题"></a>生产者与消费者问题</h3><p>想要证明事件和互斥体最本质的区别，我们可以使用生产者与消费者模型来举例子。</p>
<p>生产者消费者模式就是通过一个容器来解决生产者和消费者的强耦合（依赖性）问题。生产者和消费者彼此之间不直接通讯，而通过阻塞队列来进行通讯，所以生产者生产完数据之后不用等待消费者处理，直接扔给阻塞队列，消费者不找生产者要数据，而是直接从阻塞队列里取，阻塞队列就相当于一个缓冲区，平衡了生产者和消费者的处理能力。</p>
<p>我们就可以理解为生产者生产一个物品，将其放进容器里，然后消费者从容器中取物品进行消费，就这样“按部就班”下去…</p>
<h4 id="互斥体-1"><a href="#互斥体-1" class="headerlink" title="互斥体"></a>互斥体</h4><p>首先我们来写一段互斥体下的生产者与消费者的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdafx.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;windows.h&gt;</span></span><br><br><span class="hljs-comment">// 容器</span><br><span class="hljs-type">int</span> container;<br><span class="hljs-comment">// 次数</span><br><span class="hljs-type">int</span> count = <span class="hljs-number">10</span>;<br><span class="hljs-comment">// 互斥体</span><br>HANDLE hMutex;<br><span class="hljs-comment">// 生产者</span><br>DWORD WINAPI <span class="hljs-title function_">ThreadProc</span><span class="hljs-params">(LPVOID lpParameter)</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; count; i++) &#123;<br>        <span class="hljs-comment">// 等待互斥体，获取令牌</span><br>        WaitForSingleObject(hMutex, INFINITE);<br>        <span class="hljs-comment">// 获取当前进程ID</span><br>        <span class="hljs-type">int</span> threadId = GetCurrentThreadId();<br>        <span class="hljs-comment">// 生产存放进容器</span><br>        container = <span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Thread: %d, Build: %d \n&quot;</span>, threadId, container);<br>        <span class="hljs-comment">// 释放令牌</span><br>        ReleaseMutex(hMutex);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 消费者</span><br>DWORD WINAPI <span class="hljs-title function_">ThreadProcB</span><span class="hljs-params">(LPVOID lpParameter)</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; count; i++) &#123;<br>        <span class="hljs-comment">// 等待互斥体，获取令牌</span><br>        WaitForSingleObject(hMutex, INFINITE);<br>        <span class="hljs-comment">// 获取当前进程ID</span><br>        <span class="hljs-type">int</span> threadId = GetCurrentThreadId();<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Thread: %d, Consume: %d \n&quot;</span>, threadId, container);<br>        <span class="hljs-comment">// 消费</span><br>        container = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 释放令牌</span><br>        ReleaseMutex(hMutex);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span><br>&#123;<br>    <span class="hljs-comment">// 创建互斥体</span><br>    hMutex = CreateMutex(<span class="hljs-literal">NULL</span>, FALSE, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-comment">// 创建2个线程</span><br>    HANDLE hThread[<span class="hljs-number">2</span>];<br>    hThread[<span class="hljs-number">0</span>] = CreateThread(<span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, ThreadProc, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);<br>    hThread[<span class="hljs-number">1</span>] = CreateThread(<span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, ThreadProcB, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);<br>    WaitForMultipleObjects(<span class="hljs-number">2</span>, hThread, TRUE, INFINITE);<br>    CloseHandle(hThread[<span class="hljs-number">0</span>]);<br>    CloseHandle(hThread[<span class="hljs-number">1</span>]);<br>    CloseHandle(hMutex);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>运行结果如下图所示：</p>
<p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image2021-5-28_17-57-34.png" srcset="https://picbedddd.oss-cn-beijing.aliyuncs.com/blog/loading.gif" lazyload alt="images/download/attachments/12714992/image2021-5-28_17-57-34.png"></p>
<p>我们可以清晰的看见结果并不是我们想要的，生产一次消费一次的有序进行，甚至还出现了先消费后生产的情况，这个问题我们可以去修改代码解决：</p>
<p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image2021-5-28_18-3-24.png" srcset="https://picbedddd.oss-cn-beijing.aliyuncs.com/blog/loading.gif" lazyload alt="images/download/attachments/12714992/image2021-5-28_18-3-24.png"></p>
<p>这样虽然看似解决了问题，但是实际上也同样会出现一种问题，那就是for循环执行了不止10次，这样会倒是过分的<strong>占用计算资源</strong>。</p>
<h4 id="事件-1"><a href="#事件-1" class="headerlink" title="事件"></a>事件</h4><p>我们使用事件的方式就可以更加完美的解决这一需求：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;windows.h&gt;</span></span><br><br><span class="hljs-comment">// 容器</span><br><span class="hljs-type">int</span> container = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// 次数</span><br><span class="hljs-type">int</span> count = <span class="hljs-number">10</span>;<br><br><span class="hljs-comment">// 事件</span><br>HANDLE eventA;<br>HANDLE eventB;<br><br><span class="hljs-comment">// 生产者</span><br>DWORD WINAPI <span class="hljs-title function_">ThreadProc</span><span class="hljs-params">(LPVOID lpParameter)</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; count; i++) &#123;<br>        <span class="hljs-comment">// 等待事件，修改事件A状态</span><br>        WaitForSingleObject(eventA, INFINITE);<br>        <span class="hljs-comment">// 获取当前进程ID</span><br>        <span class="hljs-type">int</span> threadId = GetCurrentThreadId();<br>        <span class="hljs-comment">// 生产存放进容器</span><br>        container = <span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Thread: %d, Build: %d \n&quot;</span>, threadId, container);<br>        <span class="hljs-comment">// 给eventB设置信号</span><br>        SetEvent(eventB);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 消费者</span><br>DWORD WINAPI <span class="hljs-title function_">ThreadProcB</span><span class="hljs-params">(LPVOID lpParameter)</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; count; i++) &#123;<br>        <span class="hljs-comment">// 等待事件，修改事件B状态</span><br>        WaitForSingleObject(eventB, INFINITE);<br>        <span class="hljs-comment">// 获取当前进程ID</span><br>        <span class="hljs-type">int</span> threadId = GetCurrentThreadId();<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Thread: %d, Consume: %d \n&quot;</span>, threadId, container);<br>        <span class="hljs-comment">// 消费</span><br>        container = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 给eventA设置信号</span><br>        SetEvent(eventA);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span><br>&#123;<br>    <span class="hljs-comment">// 创建事件</span><br>    <span class="hljs-comment">// 线程同步的前提是互斥</span><br>    <span class="hljs-comment">// 顺序按照先生产后消费，所以事件A设置信号，事件B需要通过生产者线程来设置信号</span><br>    eventA = CreateEvent(<span class="hljs-literal">NULL</span>, FALSE, TRUE, <span class="hljs-literal">NULL</span>);<br>    eventB = CreateEvent(<span class="hljs-literal">NULL</span>, FALSE, FALSE, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-comment">// 创建2个线程</span><br>    HANDLE hThread[<span class="hljs-number">2</span>];<br>    hThread[<span class="hljs-number">0</span>] = CreateThread(<span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, ThreadProc, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);<br>    hThread[<span class="hljs-number">1</span>] = CreateThread(<span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, ThreadProcB, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);<br><br>    WaitForMultipleObjects(<span class="hljs-number">2</span>, hThread, TRUE, INFINITE);<br>    CloseHandle(hThread[<span class="hljs-number">0</span>]);<br>    CloseHandle(hThread[<span class="hljs-number">1</span>]);<br>    <span class="hljs-comment">// 事件类型也是内核对象，所以也需要关闭句柄</span><br>    CloseHandle(eventA);<br>    CloseHandle(eventB);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>运行结果如下图：</p>
<p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image2021-5-28_18-13-7.png" srcset="https://picbedddd.oss-cn-beijing.aliyuncs.com/blog/loading.gif" lazyload alt="images/download/attachments/12714992/image2021-5-28_18-13-7.png"></p>
<h1 id="内核对象"><a href="#内核对象" class="headerlink" title="内核对象"></a>内核对象</h1><p>在铺垫完上面的内容后，我们可以正式引入内核对象这一概念了。</p>
<p>进程、线程、文件、互斥体、事件等等在内核都有一个对应的结构体，这些结构体都由内核负责管理，所以我们都可以称之为内核对象（**当我们创建一个进程，在内核层（高2G）就会创建一个结构体EPROCESS…**）。</p>
<p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image2021-5-20_0-41-40.png" srcset="https://picbedddd.oss-cn-beijing.aliyuncs.com/blog/loading.gif" lazyload alt="images/download/attachments/12714992/image2021-5-20_0-41-40.png"></p>
<p>记不住没关系，我们可以在<strong>MSDN Library中搜索CloseHandle这个函数</strong>，它是用来关闭句柄的，暂时先不用管其原理，我们只要知道它所支持关闭就都是内核对象：</p>
<p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image2021-5-20_0-46-21.png" srcset="https://picbedddd.oss-cn-beijing.aliyuncs.com/blog/loading.gif" lazyload alt="images/download/attachments/12714992/image2021-5-20_0-46-21.png"></p>
<h2 id="管理内核对象"><a href="#管理内核对象" class="headerlink" title="管理内核对象"></a>管理内核对象</h2><p>当我们使用如下图所示的函数创建时，会在内核层创建一个结构体，而我们该如何管理这些结构体呢？或者说如何使用这些结构体呢？一种方式是使用指针，亦即我们可以通过内核结构体地址来管理，但是这样做存在问题：<strong>应用层很有可能操作不当导致修改啦内核结构体的地址</strong>，我们写应用层代码都知道访问到一个不存在的内存地址就会报错，而如果访问到一个内核地址是错误的，微软系统下则直接会蓝屏。</p>
<p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image2021-5-20_0-53-28.png" srcset="https://picbedddd.oss-cn-beijing.aliyuncs.com/blog/loading.gif" lazyload alt="images/download/attachments/12714992/image2021-5-20_0-53-28.png"></p>
<p>微软为了避免这种情况的发生，所以其不会讲内核结构体的地址暴露给应用层，也就是说没法通过这种方式来直接管理。</p>
<h2 id="句柄表"><a href="#句柄表" class="headerlink" title="句柄表"></a>句柄表</h2><p>没法直接管理内核对象，这时候句柄表就诞生了，但是需要注意的是，只有进程才会有句柄表，并且每一个进程都会有一个句柄表。</p>
<p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image2021-5-20_1-1-58.png" srcset="https://picbedddd.oss-cn-beijing.aliyuncs.com/blog/loading.gif" lazyload alt="images/download/attachments/12714992/image2021-5-20_1-1-58.png"></p>
<p>句柄本质上就一个防火墙，将应用层、内核层隔离开来，通过句柄就可以控制进程内核结构体，我们得到所谓句柄的值实际上就是句柄表里的一个索引。</p>
<h2 id="多进程共享内核对象"><a href="#多进程共享内核对象" class="headerlink" title="多进程共享内核对象"></a>多进程共享内核对象</h2><p>如下图所示，A进程通过<strong>CreateProcess函数</strong>创建了一个内核对象；B进程通过<strong>OpenProcess函数</strong>可以打开别人创建好的一个进程，也就是可以操作其的内核对象；A进程想要操作内核对象就通过其对应的句柄表的句柄（索引）来操作；B进程操作这个内核对象也是通过它自己的句柄表的句柄（索引）来操作内核对象。（需要注意的是：句柄表是一个私有的，句柄值就是进程自己句柄表的索引）</p>
<p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image2021-5-21_0-19-38.png" srcset="https://picbedddd.oss-cn-beijing.aliyuncs.com/blog/loading.gif" lazyload alt="images/download/attachments/12714992/image2021-5-21_0-19-38.png"></p>
<p>在之前的例子中我们提到了CloseHandle这个函数是用来关闭进程、线程的，其实它的本质就是释放句柄，但是并不代表执行了这个函数，创建的内核对象就会<strong>彻底消失</strong>；如上图中所示内核对象存在一个计数器，目前是2，它的值是根据调用A的次数来决定的，如果我们只是在A进程中执行了<strong>CloseHandle函数</strong>，内核对象并不会消失，因为进程B还在使用，而只有进程B也执行了<strong>CloseHandle函数</strong>，这个内核对象的计数器为0，就会关闭消失了。</p>
<p><strong>最后</strong>：注意，以上所述特性适合于除了线程以外的所有内核对象，创建进程，同时也会创建线程，如果你想把线程关闭，首先需要<strong>CloseHandle函数</strong>要让其计数器为0，其次需要有人将其关闭，所以假设我们创建了一个IE进程打开了一个网站，如果我们只是在代码中使用了<strong>CloseHandle函数</strong>，这样IE浏览器并不会关闭，需要我们手动点击窗口的关闭按钮才行（<strong>只有线程关闭了，进程才会关闭</strong>）。</p>
<h2 id="句柄是否”可以”被继承"><a href="#句柄是否”可以”被继承" class="headerlink" title="句柄是否”可以”被继承"></a>句柄是否”可以”被继承</h2><p>除了我们上述的方式可以进行共享内核对象以外，Windows还设计了一种方式来提供我们共享内核对象，我们先来了解一下句柄是否”可以”被继承。</p>
<p>如下图所示（<strong>句柄表是有三列的，分别是句柄值、内核结构体地址、句柄是否可以被继承</strong>），比如说我们在A进程（父进程）创建了4个内核对象：</p>
<p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image2021-5-21_0-51-37.png" srcset="https://picbedddd.oss-cn-beijing.aliyuncs.com/blog/loading.gif" lazyload alt="images/download/attachments/12714992/image2021-5-21_0-51-37.png"></p>
<p>这四个函数都有一个参数<strong>LPSECURITY_ATTRIBUTES lpThreadAttributes</strong>，通过这个参数我们可以判断函数是否创建的是内核对象。</p>
<p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image2021-5-21_0-57-16.png" srcset="https://picbedddd.oss-cn-beijing.aliyuncs.com/blog/loading.gif" lazyload alt="images/download/attachments/12714992/image2021-5-21_0-57-16.png"></p>
<p>我们可以跟进看一下这个参数，它就是一个结构体：</p>
<p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image2021-5-21_1-2-23.png" srcset="https://picbedddd.oss-cn-beijing.aliyuncs.com/blog/loading.gif" lazyload alt="images/download/attachments/12714992/image2021-5-21_1-2-23.png"></p>
<p>结构体成员分别是：<strong>1.结构体长度；2.安全描述符；3.句柄是否被继承</strong>。</p>
<p>第一个成员我们见怪不怪了，在Windows设计下都会有这样一个成员；第二个安全描述符，这个对我们来说实际上没有任何意义，一般留空就行，默认它会遵循父进程的来，其主要作用就是<strong>描述谁创建了该对象，谁有访问、使用该对象的权限</strong>。</p>
<p>第三个成员是我们重点需要关注的，因为其决定了句柄是否可以被继承，如下图所示，我们让CreateProcess函数创建的进程、线程句柄可以被继承：</p>
<p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image2021-5-21_1-29-4.png" srcset="https://picbedddd.oss-cn-beijing.aliyuncs.com/blog/loading.gif" lazyload alt="images/download/attachments/12714992/image2021-5-21_1-29-4.png"></p>
<h2 id="句柄是否”允许”被继承"><a href="#句柄是否”允许”被继承" class="headerlink" title="句柄是否”允许”被继承"></a>句柄是否”允许”被继承</h2><p>我们可以让句柄被继承，但也仅仅是可以，要真正完成继承，或者说我们允许子进程继承父进程的句柄，这时候就需要另外一个参数了。</p>
<p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image2021-5-21_1-38-10.png" srcset="https://picbedddd.oss-cn-beijing.aliyuncs.com/blog/loading.gif" lazyload alt="images/download/attachments/12714992/image2021-5-21_1-38-10.png"></p>
<p>我们还是以CreateProcess函数举例，其有一个参数<strong>BOOL bInheritHandles</strong>，这个参数决定了是否允许创建的子进程继承句柄：</p>
<p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image2021-5-21_1-42-32.png" srcset="https://picbedddd.oss-cn-beijing.aliyuncs.com/blog/loading.gif" lazyload alt="images/download/attachments/12714992/image2021-5-21_1-42-32.png"></p>
<p>只有这个参数设置为TRUE时，我们创建的子进程才允许继承父进程的句柄。</p>
<h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>程序所需要的资源（数据、代码…）是由进程提供的；进程是一种空间上的概念，它的责任就是提供资源，至于资源如何使用，与它无关。</p>
<p>每一个进程都有自己的一个4GB大小的虚拟空间，也就是从0x0-0xFFFFFFFF这个范围。</p>
<p>进程内存空间的地址划分如下，每个进程的内核是同一份（高2G），只有其他三个分区是进程独有的（低2G），而只有用户模式区是我们使用的范围：</p>
<p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image2021-5-17_23-53-53.png" srcset="https://picbedddd.oss-cn-beijing.aliyuncs.com/blog/loading.gif" lazyload alt="images/download/attachments/12714992/image2021-5-17_23-53-53.png"></p>
<p>进程也可以理解为是一对模块组成的，我们可以使用OD打开一个进程看一下：</p>
<p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image2021-5-18_0-14-56.png" srcset="https://picbedddd.oss-cn-beijing.aliyuncs.com/blog/loading.gif" lazyload alt="images/download/attachments/12714992/image2021-5-18_0-14-56.png"></p>
<p>这里面有很多的模块，每个模块都是一个可执行文件，它们遵守相同的格式，即PE结构，所以我们也可以理解进程就是一堆PE组合。</p>
<h2 id="进程和线程之间的关系"><a href="#进程和线程之间的关系" class="headerlink" title="进程和线程之间的关系"></a>进程和线程之间的关系</h2><p>一个进程可以包含多个线程，如老师所说（<strong>一个进程至少要包含一个线程，进程是4GB，线程就是EIP</strong>）。</p>
<p>打开任务管理器，可以看到一个进程包含的线程个数</p>
<p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image-20220119124918815.png" srcset="https://picbedddd.oss-cn-beijing.aliyuncs.com/blog/loading.gif" lazyload alt="image-20220119124918815"></p>
<h2 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h2><p>我们需要知道任何进程都是别的进程创建的，当我们在Windows下双击打开一个文件，实际上就是explorer.exe这个进程创建的子进程。我们打开文件的进程，其使用的方法就是CreateProcess()</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c">BOOL <span class="hljs-title function_">CreateProcess</span><span class="hljs-params">(						</span><br><span class="hljs-params">	LPCTSTR lpApplicationName,					<span class="hljs-comment">// name of executable module								</span></span><br><span class="hljs-params">	LPTSTR lpCommandLine,						<span class="hljs-comment">// command line string								</span></span><br><span class="hljs-params">	LPSECURITY_ATTRIBUTES lpProcessAttributes, 	<span class="hljs-comment">// SD								</span></span><br><span class="hljs-params">	LPSECURITY_ATTRIBUTES lpThreadAttributes,	<span class="hljs-comment">// SD								</span></span><br><span class="hljs-params">	BOOL bInheritHandles,						<span class="hljs-comment">// handle inheritance option								</span></span><br><span class="hljs-params">	DWORD dwCreationFlags,						<span class="hljs-comment">// creation flags								</span></span><br><span class="hljs-params">	LPVOID lpEnvironment,						<span class="hljs-comment">// new environment block								</span></span><br><span class="hljs-params">	LPCTSTR lpCurrentDirectory,					<span class="hljs-comment">// current directory name								</span></span><br><span class="hljs-params">	LPSTARTUPINFO lpStartupInfo,				<span class="hljs-comment">// startup information								</span></span><br><span class="hljs-params">	LPPROCESS_INFORMATION lpProcessInformation 	<span class="hljs-comment">// process information								</span></span><br><span class="hljs-params">)</span>;<br></code></pre></td></tr></table></figure>



<p>进程创建的过程也就是<strong>CreateProcess函数</strong>：</p>
<ol>
<li>映射EXE文件（低2G）</li>
<li>创建内核对象EPROCESS（高2G）</li>
<li>映射系统DLL（ntdll.dll）</li>
<li>创建线程内核对象RTHREAD（高2G）</li>
<li>系统启动线程：<ol>
<li>映射DLL（ntdll.LdrInitializeThunk）</li>
<li>线程开始执行</li>
</ol>
</li>
</ol>
<p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image2021-5-18_0-17-35.png" srcset="https://picbedddd.oss-cn-beijing.aliyuncs.com/blog/loading.gif" lazyload alt="images/download/attachments/12714992/image2021-5-18_0-17-35.png"></p>
<p>如上图就是打开A.exe的创建过程图，进程是空间上的概念，只用于提供代码和数据资源等等…而想要使用这些资源的是线程，每个进程至少需要一个线程。</p>
<p>在映射EXE文件时主要做了如下几件事</p>
<ol>
<li>将EXE拉伸，存储到指定的位置</li>
<li>遍历EXE导入表，将需要用到的DLL拉伸存储到指定位置，如果位置被占用就换个地方，并通过DLL的重定位表，修复全局遍历</li>
<li>DLL如果引用了其他的DLL 递归第二步	</li>
<li>修复EXE&#x2F;DLL中的IAT表</li>
</ol>
<h1 id="Win32下的自动化测试"><a href="#Win32下的自动化测试" class="headerlink" title="Win32下的自动化测试"></a>Win32下的自动化测试</h1><p>一个简单又必须掌握的技能</p>
<h2 id="查找窗口与控制窗口"><a href="#查找窗口与控制窗口" class="headerlink" title="查找窗口与控制窗口"></a>查找窗口与控制窗口</h2><p>查找指定窗口</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c">TCHAR szTitle[MAX_PATH] = &#123;<span class="hljs-number">0</span>&#125;;<br>HWND hwnd = ::FindWindow(TEXT(<span class="hljs-string">&quot;#32770&quot;</span>),TEXT(<span class="hljs-string">&quot;飞鸽传书  IP Messenger&quot;</span>));<br><span class="hljs-keyword">if</span>(hwnd != <span class="hljs-literal">NULL</span>)<br>&#123;<br>	<span class="hljs-comment">//修改窗口标题</span><br>	::SetWindowText(hwnd,<span class="hljs-string">&quot;新的窗口标题&quot;</span>);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>	::MessageBox(<span class="hljs-literal">NULL</span>,TEXT(<span class="hljs-string">&quot;窗口没有找到&quot;</span>),TEXT(<span class="hljs-string">&quot;[ERROR]&quot;</span>),MB_OK);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>控制窗口</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c">TCHAR szTitle[MAX_PATH] = &#123;<span class="hljs-number">0</span>&#125;;<br>HWND hwnd = ::FindWindow(TEXT(<span class="hljs-string">&quot;#32770&quot;</span>),TEXT(<span class="hljs-string">&quot;飞鸽传书  IP Messenger&quot;</span>));<br><span class="hljs-keyword">if</span>(hwnd != <span class="hljs-literal">NULL</span>)<br>&#123;<br>	<span class="hljs-keyword">typedef</span> <span class="hljs-title function_">void</span> <span class="hljs-params">(WINAPI *PSWITCHTOTHISWINDOW)</span> <span class="hljs-params">(HWND,BOOL)</span>;<br>	PSWITCHTOTHISWINDOW SwitchToThisWindow;<br>	HMODULE hUser32=LoadLibrary(<span class="hljs-string">&quot;user32.dll&quot;</span>);<br>	SwitchToThisWindow=(PSWITCHTOTHISWINDOW)GetProcAddress(hUser32,<span class="hljs-string">&quot;SwitchToThisWindow&quot;</span>);<br><br>	<span class="hljs-comment">//切换窗口</span><br>	SwitchToThisWindow(hwnd,<span class="hljs-literal">false</span>);<br><br>	Sleep(<span class="hljs-number">3000</span>);<br>	<span class="hljs-comment">//关闭窗口 </span><br>	::SendMessage(hwnd,WM_CLOSE,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>	::MessageBox(<span class="hljs-literal">NULL</span>,TEXT(<span class="hljs-string">&quot;窗口没有找到&quot;</span>),TEXT(<span class="hljs-string">&quot;[ERROR]&quot;</span>),MB_OK);<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h2 id="查找子窗口"><a href="#查找子窗口" class="headerlink" title="查找子窗口"></a>查找子窗口</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c">TCHAR szTitle[MAX_PATH] = &#123;<span class="hljs-number">0</span>&#125;;								<br>HWND hwnd = ::FindWindow(TEXT(<span class="hljs-string">&quot;#32770&quot;</span>),TEXT(<span class="hljs-string">&quot;飞鸽传书  IP Messenger&quot;</span>));								<br><span class="hljs-keyword">if</span>(hwnd != <span class="hljs-literal">NULL</span>)								<br>&#123;								<br>	<span class="hljs-comment">//查找子窗口							</span><br>	HWND hEdit = FindWindowEx(hwnd,<span class="hljs-literal">NULL</span>,<span class="hljs-string">&quot;Edit&quot;</span>,<span class="hljs-string">&quot;&quot;</span>);							<br>	<span class="hljs-comment">//设置标题							</span><br>	::SetWindowText(hEdit,<span class="hljs-string">&quot;文本框新的标题&quot;</span>);							<br>	<span class="hljs-comment">//修改内容							</span><br>	::SendMessage(hEdit,WM_SETTEXT,<span class="hljs-number">0</span>,(LPARAM)<span class="hljs-string">&quot;新的内容&quot;</span>);							<br>&#125;								<br><span class="hljs-keyword">else</span>								<br>&#123;								<br>	::MessageBox(<span class="hljs-literal">NULL</span>,TEXT(<span class="hljs-string">&quot;窗口没有找到&quot;</span>),TEXT(<span class="hljs-string">&quot;[ERROR]&quot;</span>),MB_OK);							<br>&#125;								<br>								<br>								<br>TCHAR szTitle[MAX_PATH] = &#123;<span class="hljs-number">0</span>&#125;;								<br>HWND hwnd = ::FindWindow(TEXT(<span class="hljs-string">&quot;#32770&quot;</span>),TEXT(<span class="hljs-string">&quot;飞鸽传书  IP Messenger&quot;</span>));								<br><span class="hljs-keyword">if</span>(hwnd != <span class="hljs-literal">NULL</span>)								<br>&#123;								<br>	<span class="hljs-comment">//查找子窗口							</span><br>	HWND hEdit =::GetDlgItem(hwnd,<span class="hljs-number">0x3E9</span>);							<br>	<span class="hljs-comment">//获取内容							</span><br>	::SendMessage(hEdit,WM_GETTEXT,MAX_PATH,(LPARAM)szTitle);							<br>	<span class="hljs-comment">//修改内容							</span><br>	::SendMessage(hEdit,WM_SETTEXT,<span class="hljs-number">0</span>,(LPARAM)<span class="hljs-string">&quot;新的内容&quot;</span>);							<br>&#125;								<br><span class="hljs-keyword">else</span>								<br>&#123;								<br>	::MessageBox(<span class="hljs-literal">NULL</span>,TEXT(<span class="hljs-string">&quot;窗口没有找到&quot;</span>),TEXT(<span class="hljs-string">&quot;[ERROR]&quot;</span>),MB_OK);							<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="枚举子窗口控件"><a href="#枚举子窗口控件" class="headerlink" title="枚举子窗口控件"></a>枚举子窗口控件</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c">BOOL CALLBACK <span class="hljs-title function_">EnumChildProc</span><span class="hljs-params">(HWND hWnd,LPARAM lParam)</span>  									<br>&#123;  									<br>    TCHAR szTitle[MAX_PATH] = &#123;<span class="hljs-number">0</span>&#125;;									<br>    ::GetWindowText(hWnd,szTitle,MAX_PATH); 									<br>    MessageBox(<span class="hljs-literal">NULL</span>,szTitle,<span class="hljs-string">&quot;[子窗口]&quot;</span>,MB_OK);  									<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  									<br>&#125;  									<br>									<br>VOID <span class="hljs-title function_">EnumChildWindow</span><span class="hljs-params">()</span>									<br>&#123;									<br>	TCHAR szTitle[MAX_PATH] = &#123;<span class="hljs-number">0</span>&#125;;								<br>	HWND hWnd = ::FindWindow(TEXT(<span class="hljs-string">&quot;#32770&quot;</span>),TEXT(<span class="hljs-string">&quot;飞鸽传书  IP Messenger&quot;</span>));								<br>	<span class="hljs-keyword">if</span>(hWnd != <span class="hljs-literal">NULL</span>)								<br>	&#123;								<br>		::EnumChildWindows(hWnd,EnumChildProc,<span class="hljs-number">0</span>);  							<br>	&#125;								<br>	<span class="hljs-keyword">else</span>								<br>	&#123;								<br>		::MessageBox(<span class="hljs-literal">NULL</span>,TEXT(<span class="hljs-string">&quot;窗口没有找到&quot;</span>),TEXT(<span class="hljs-string">&quot;[ERROR]&quot;</span>),MB_OK);							<br>	&#125;								<br>&#125;									<br></code></pre></td></tr></table></figure>



<h2 id="枚举所有打开窗口"><a href="#枚举所有打开窗口" class="headerlink" title="枚举所有打开窗口"></a>枚举所有打开窗口</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c">BOOL CALLBACK <span class="hljs-title function_">EnumOpenWindowProc</span><span class="hljs-params">(HWND hWnd,LPARAM lParam)</span>  						<br>&#123;  						<br>    TCHAR szTitle[MAX_PATH] = &#123;<span class="hljs-number">0</span>&#125;;						<br>    ::GetWindowText(hWnd,szTitle,MAX_PATH); 						<br>    MessageBox(<span class="hljs-literal">NULL</span>,szTitle,<span class="hljs-string">&quot;[窗口]&quot;</span>,MB_OK);  						<br>    	<span class="hljs-keyword">if</span>(<span class="hljs-built_in">strcmp</span>(szTitle,<span class="hljs-string">&quot;飞鸽传书  IP Messenger&quot;</span>) == <span class="hljs-number">0</span>)					<br>	&#123;					<br>		MessageBox(<span class="hljs-literal">NULL</span>,szTitle,<span class="hljs-string">&quot;[窗口]&quot;</span>,MB_OK);  				<br>		<span class="hljs-keyword">return</span> FALSE;				<br>	&#125;					<br>    <span class="hljs-keyword">return</span> TRUE;  						<br>&#125;  						<br>VOID <span class="hljs-title function_">EnumOpenWindows</span><span class="hljs-params">()</span>						<br>&#123;						<br>	EnumWindows(EnumOpenWindowProc,<span class="hljs-literal">NULL</span>);					<br>&#125;						<br><br></code></pre></td></tr></table></figure>

<h2 id="模拟鼠标单击"><a href="#模拟鼠标单击" class="headerlink" title="模拟鼠标单击"></a>模拟鼠标单击</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c">TCHAR szTitle[MAX_PATH] = &#123;<span class="hljs-number">0</span>&#125;;	<br>RECT r;	<br>HWND hwnd = ::FindWindow(TEXT(<span class="hljs-string">&quot;#32770&quot;</span>),TEXT(<span class="hljs-string">&quot;飞鸽传书  IP Messenger&quot;</span>));	<br><span class="hljs-keyword">if</span>(hwnd != <span class="hljs-literal">NULL</span>)	<br>&#123;	<br>	HWND hButton = FindWindowEx(hwnd,<span class="hljs-literal">NULL</span>,<span class="hljs-string">&quot;Button&quot;</span>,<span class="hljs-string">&quot;刷新(&amp;R)&quot;</span>);<br>	<br>	<span class="hljs-comment">//获取窗口坐标</span><br>	::GetWindowRect(hButton,&amp;r);<br>	<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>,r.left,r.top);<br>	<br>	<span class="hljs-comment">//设置鼠标的位置</span><br>	::SetCursorPos(r.left+<span class="hljs-number">10</span>,r.top+<span class="hljs-number">10</span>);<br>	Sleep(<span class="hljs-number">2000</span>);<br>	<span class="hljs-comment">//鼠标左键单击</span><br>	mouse_event(MOUSEEVENTF_LEFTDOWN,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<span class="hljs-comment">//点下左键 </span><br>	mouse_event(MOUSEEVENTF_LEFTUP,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<span class="hljs-comment">//松开左键</span><br>&#125;	<br><span class="hljs-keyword">else</span>	<br>&#123;	<br>	::MessageBox(<span class="hljs-literal">NULL</span>,TEXT(<span class="hljs-string">&quot;窗口没有找到&quot;</span>),TEXT(<span class="hljs-string">&quot;[ERROR]&quot;</span>),MB_OK);<br>&#125;	<br><br></code></pre></td></tr></table></figure>

<h2 id="模拟键盘"><a href="#模拟键盘" class="headerlink" title="模拟键盘"></a>模拟键盘</h2><p>这里模拟键盘点击需要自行搜索键盘键与虚拟键码对照表（不是不是ASCII码！！）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c">TCHAR szTitle[MAX_PATH] = &#123;<span class="hljs-number">0</span>&#125;;	<br>RECT r;	<br>HWND hwnd = ::FindWindow(TEXT(<span class="hljs-string">&quot;#32770&quot;</span>),TEXT(<span class="hljs-string">&quot;飞鸽传书  IP Messenger&quot;</span>));	<br><span class="hljs-keyword">if</span>(hwnd != <span class="hljs-literal">NULL</span>)	<br>&#123;	<br>	<span class="hljs-comment">//HWND hButton = FindWindowEx(hwnd,NULL,&quot;Button&quot;,&quot;刷新(&amp;R)&quot;);</span><br>	HWND hEdit =::GetDlgItem(hwnd,<span class="hljs-number">0x3E9</span>);<br>	<br>	<span class="hljs-comment">//获取窗口坐标</span><br>	::GetWindowRect(hEdit,&amp;r);<br>	<br>	<span class="hljs-comment">//设置鼠标的位置</span><br>	::SetCursorPos(r.left+<span class="hljs-number">1</span>,r.top+<span class="hljs-number">1</span>);<br>	Sleep(<span class="hljs-number">1000</span>);<br>	<br>	<span class="hljs-comment">//鼠标左键单击</span><br>	mouse_event(MOUSEEVENTF_LEFTDOWN,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<span class="hljs-comment">//点下左键 </span><br>	mouse_event(MOUSEEVENTF_LEFTUP,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<span class="hljs-comment">//松开左键</span><br>	<br>	<span class="hljs-comment">//模拟键盘</span><br>	keybd_event(<span class="hljs-number">97</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>	keybd_event(<span class="hljs-number">97</span>,<span class="hljs-number">0</span>,KEYEVENTF_KEYUP,<span class="hljs-number">0</span>);<br>	Sleep(<span class="hljs-number">1000</span>);<br>	keybd_event(<span class="hljs-number">66</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>	keybd_event(<span class="hljs-number">66</span>,<span class="hljs-number">0</span>,KEYEVENTF_KEYUP,<span class="hljs-number">0</span>);<br>	Sleep(<span class="hljs-number">1000</span>);<br>	keybd_event(<span class="hljs-number">16</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>	keybd_event(<span class="hljs-number">67</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>	keybd_event(<span class="hljs-number">67</span>,<span class="hljs-number">0</span>,KEYEVENTF_KEYUP,<span class="hljs-number">0</span>);<br>	keybd_event(<span class="hljs-number">16</span>,<span class="hljs-number">0</span>,KEYEVENTF_KEYUP,<span class="hljs-number">0</span>);<br>	<br>&#125;	<br><span class="hljs-keyword">else</span>	<br>&#123;	<br>	::MessageBox(<span class="hljs-literal">NULL</span>,TEXT(<span class="hljs-string">&quot;窗口没有找到&quot;</span>),TEXT(<span class="hljs-string">&quot;[ERROR]&quot;</span>),MB_OK);<br>&#125;	<br><br></code></pre></td></tr></table></figure>



<h2 id="练习：模拟QQ登录"><a href="#练习：模拟QQ登录" class="headerlink" title="练习：模拟QQ登录"></a>练习：模拟QQ登录</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// qq_autologin.cpp : 定义控制台应用程序的入口点。</span><br><span class="hljs-comment">//</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdafx.h&quot;</span></span><br><br>TCHAR path[MAX_PATH]=_T(<span class="hljs-string">&quot;C:\\Program Files\\Tencent\\QQ\\Bin\\QQScLauncher.exe&quot;</span>);<br>BOOL bFindFlag;<br><br>BOOL CALLBACK <span class="hljs-title function_">EnumOpenWindowProc</span><span class="hljs-params">(HWND hWnd,LPARAM lParam)</span>  						<br>&#123;  						<br>	TCHAR szTitle[MAX_PATH] = &#123;<span class="hljs-number">0</span>&#125;;	<br>	RECT r;<br>	::GetWindowText(hWnd,szTitle,MAX_PATH); 						 						<br>	<span class="hljs-keyword">if</span>(lstrcmp(szTitle,_T(<span class="hljs-string">&quot;QQ&quot;</span>)) == <span class="hljs-number">0</span>)				<br>	&#123;					<br>		<span class="hljs-comment">// 找到了 </span><br>		bFindFlag = TRUE;<br>		SwitchToThisWindow(hWnd,<span class="hljs-literal">false</span>);<br>		<span class="hljs-comment">// 获取对话框左上角位置</span><br>		::GetWindowRect(hWnd,&amp;r);<br><br>		<span class="hljs-comment">//设置鼠标的位置</span><br>		::SetCursorPos(r.left+<span class="hljs-number">250</span>,r.top+<span class="hljs-number">120</span>);<br>		<span class="hljs-comment">//鼠标左键单击</span><br>		mouse_event(MOUSEEVENTF_LEFTDOWN,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<span class="hljs-comment">//点下左键 </span><br>		mouse_event(MOUSEEVENTF_LEFTUP,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<span class="hljs-comment">//松开左键</span><br>		<span class="hljs-comment">//模拟键盘 输入账号</span><br>		keybd_event(<span class="hljs-number">97</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>		keybd_event(<span class="hljs-number">97</span>,<span class="hljs-number">0</span>,KEYEVENTF_KEYUP,<span class="hljs-number">0</span>);<br><br>		keybd_event(<span class="hljs-number">66</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>		keybd_event(<span class="hljs-number">66</span>,<span class="hljs-number">0</span>,KEYEVENTF_KEYUP,<span class="hljs-number">0</span>);<br><br>		keybd_event(<span class="hljs-number">16</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>		keybd_event(<span class="hljs-number">67</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>		keybd_event(<span class="hljs-number">67</span>,<span class="hljs-number">0</span>,KEYEVENTF_KEYUP,<span class="hljs-number">0</span>);<br>		keybd_event(<span class="hljs-number">16</span>,<span class="hljs-number">0</span>,KEYEVENTF_KEYUP,<span class="hljs-number">0</span>);<br><br><br><br>		Sleep(<span class="hljs-number">1000</span>);<br>		<span class="hljs-comment">// 按tab</span><br>		keybd_event(<span class="hljs-number">9</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>		keybd_event(<span class="hljs-number">9</span>,<span class="hljs-number">0</span>,KEYEVENTF_KEYUP,<span class="hljs-number">0</span>);<br>		<span class="hljs-comment">//模拟键盘 输入密码</span><br>		keybd_event(<span class="hljs-number">97</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>		keybd_event(<span class="hljs-number">97</span>,<span class="hljs-number">0</span>,KEYEVENTF_KEYUP,<span class="hljs-number">0</span>);<br><br>		keybd_event(<span class="hljs-number">66</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>		keybd_event(<span class="hljs-number">66</span>,<span class="hljs-number">0</span>,KEYEVENTF_KEYUP,<span class="hljs-number">0</span>);<br><br>		keybd_event(<span class="hljs-number">16</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>		keybd_event(<span class="hljs-number">67</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>		keybd_event(<span class="hljs-number">67</span>,<span class="hljs-number">0</span>,KEYEVENTF_KEYUP,<span class="hljs-number">0</span>);<br>		keybd_event(<span class="hljs-number">16</span>,<span class="hljs-number">0</span>,KEYEVENTF_KEYUP,<span class="hljs-number">0</span>);<br><br><br><br>		<span class="hljs-comment">// Enter登录</span><br>		keybd_event(<span class="hljs-number">13</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>		keybd_event(<span class="hljs-number">13</span>,<span class="hljs-number">0</span>,KEYEVENTF_KEYUP,<span class="hljs-number">0</span>);<br><br>		<span class="hljs-keyword">return</span> FALSE;				<br>	&#125;					<br>	<span class="hljs-keyword">return</span> TRUE;  						<br>&#125;  		<br><br>VOID <span class="hljs-title function_">EnumOpenWindows</span><span class="hljs-params">()</span>						<br>&#123;<br>	<span class="hljs-keyword">while</span> (!bFindFlag)<br>	&#123;<br>		EnumWindows(EnumOpenWindowProc,<span class="hljs-literal">NULL</span>);<br>		Sleep(<span class="hljs-number">5000</span>);<br>	&#125;<br>	<br>&#125;						<br><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, _TCHAR* argv[])</span><br>&#123;<br>	STARTUPINFO si = &#123;<span class="hljs-number">0</span>&#125;;<br>	si.cb = <span class="hljs-keyword">sizeof</span>(si);<br>	PROCESS_INFORMATION pi;<br>	CreateProcess(path,<span class="hljs-literal">NULL</span>,<span class="hljs-literal">NULL</span>,<span class="hljs-literal">NULL</span>,FALSE,CREATE_NEW_CONSOLE,<span class="hljs-literal">NULL</span>,<span class="hljs-literal">NULL</span>,&amp;si,&amp;pi);<br>	EnumOpenWindows();<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<h1 id="远程线程注入"><a href="#远程线程注入" class="headerlink" title="远程线程注入"></a>远程线程注入</h1><p>之前我们是远程创建线程，调用的也是人家自己的线程函数，而如果我们想要创建远程线程调用自己定义的线程函数就需要使用<strong>远程线程注入</strong>技术。</p>
<h2 id="什么是注入"><a href="#什么是注入" class="headerlink" title="什么是注入"></a>什么是注入</h2><p>所谓注入就是在第三方进程不知道或者不允许的情况下将模块或者代码写入对方进程空间，并设法执行的技术。</p>
<p>在安全领域，“注入”是非常重要的一种技术手段，注入与反注入也一直处于不断变化的，而且也愈来愈激烈的对抗当中。</p>
<p><strong>已知的注入方式：</strong></p>
<p>远程线程注入、APC注入、消息钩子注入、注册表注入、导入表注入、输入法注入等等。</p>
<h2 id="远程线程注入的流程"><a href="#远程线程注入的流程" class="headerlink" title="远程线程注入的流程"></a>远程线程注入的流程</h2><p>远程线程注入的思路就是在进程A中创建线程，<strong>将线程函数指向LoadLibrary函数</strong>。</p>
<p>那么为什么可以这样呢？这是因为我们执行远程线程函数满足返回值是4字节，一个参数是4字节即可（ThreadProc就是这样的条件）：</p>
<p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image2021-6-3_15-6-49.png" srcset="https://picbedddd.oss-cn-beijing.aliyuncs.com/blog/loading.gif" lazyload alt="images/download/attachments/12714992/image2021-6-3_15-6-49.png"></p>
<p>我们再来看一下<strong>LoadLibrary函数的语法格式</strong>：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs fortran">HMODULE LoadLibrary(<br>  LPCTSTR lpFileName   // <span class="hljs-keyword">file</span> <span class="hljs-keyword">name</span> of <span class="hljs-keyword">module</span><br>);<br></code></pre></td></tr></table></figure>

<p>我们可以跟进（F12）一下<strong>HMODULE和LPCTSTR这两个宏的定义，就会发现其实都是4字节宽度</strong>。</p>
<p>具体实现步骤如下图所示：</p>
<p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image2021-6-3_15-11-55.png" srcset="https://picbedddd.oss-cn-beijing.aliyuncs.com/blog/loading.gif" lazyload alt="images/download/attachments/12714992/image2021-6-3_15-11-55.png"></p>
<h2 id="如何执行代码"><a href="#如何执行代码" class="headerlink" title="如何执行代码"></a>如何执行代码</h2><p>DLL文件，在DLL文件入口函数判断并创建线程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// B.cpp : Defines the entry point for the DLL application.</span><br><span class="hljs-comment">//</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdafx.h&quot;</span></span><br><br>DWORD WINAPI <span class="hljs-title function_">ThreadProc</span><span class="hljs-params">(LPVOID lpParaneter)</span> &#123;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        Sleep(<span class="hljs-number">1000</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;DLL RUNNING...&quot;</span>);<br>    &#125;<br>&#125;<br><br>BOOL APIENTRY <span class="hljs-title function_">DllMain</span><span class="hljs-params">( HANDLE hModule, </span><br><span class="hljs-params">                       DWORD  ul_reason_for_call, </span><br><span class="hljs-params">                       LPVOID lpReserved</span><br><span class="hljs-params">                     )</span><br>&#123;   <span class="hljs-comment">// 当进程执行LoadLibrary时创建一个线程，执行ThreadProc线程</span><br>    <span class="hljs-keyword">switch</span> (ul_reason_for_call) &#123;<br>    <span class="hljs-keyword">case</span> DLL_PROCESS_ATTACH:<br>        CreateThread(<span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, ThreadProc, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> TRUE;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>文件我们用如下写的Test.exe即可，将编译好的DLL和Test.exe放在同一个目录并打开Test1.exe。</p>
<p>注入实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Test.cpp : Defines the entry point for the console application.</span><br><span class="hljs-comment">//</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;StdAfx.h&quot;</span></span><br><br><span class="hljs-comment">// LoadDll需要两个参数一个参数是进程ID，一个是DLL文件的路径</span><br>BOOL <span class="hljs-title function_">LoadDll</span><span class="hljs-params">(DWORD dwProcessID, <span class="hljs-type">char</span>* szDllPathName)</span> &#123;<br>    <br>    HANDLE hProcess;<br>    HANDLE hThread;<br>    DWORD dwLength;<br>    DWORD dwLoadAddr;<br>    LPVOID lpAllocAddr;<br>    DWORD dwThreadID;<br>    HMODULE hModule;<br>    <br>    bRet = <span class="hljs-number">0</span>;<br>    dwLoadAddr = <span class="hljs-number">0</span>;<br>    hProcess = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-comment">// 1. 获取进程句柄</span><br>    hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwProcessID); <br>    <span class="hljs-comment">// 2. 获取DLL文件路径的长度，并在最后+1，因为要加上0结尾的长度</span><br>    dwLength = <span class="hljs-built_in">strlen</span>(szDllPathName) + <span class="hljs-number">1</span>;    <br>    <span class="hljs-comment">// 3. 在目标进程分配内存</span><br>    lpAllocAddr = VirtualAllocEx(hProcess, <span class="hljs-literal">NULL</span>, dwLength, MEM_COMMIT, PAGE_READWRITE);<br>    <span class="hljs-comment">// 4. 拷贝DLL路径名字到目标进程的内存</span><br>    WriteProcessMemory(hProcess, lpAllocAddr, szDllPathName, dwLength, <span class="hljs-literal">NULL</span>);  <br>    <span class="hljs-comment">// 5. 获取模块句柄</span><br>    <span class="hljs-comment">// LoadLibrary这个函数是在kernel32.dll这个模块中的，所以需要现货区kernel32.dll这个模块的句柄</span><br>    hModule = GetModuleHandle(<span class="hljs-string">&quot;kernel32.dll&quot;</span>); <br>    <span class="hljs-comment">// 6. 获取LoadLibraryA函数地址</span><br>    dwLoadAddr = (DWORD)GetProcAddress(hModule, <span class="hljs-string">&quot;LoadLibraryA&quot;</span>); <br>    <span class="hljs-comment">// 7. 创建远程线程，加载DLL</span><br>    hThread = CreateRemoteThread(hProcess, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, (LPTHREAD_START_ROUTINE)dwLoadAddr, lpAllocAddr, <span class="hljs-number">0</span>, &amp;dwThreadID); <br>    <span class="hljs-comment">// 8. 关闭进程句柄</span><br>    CloseHandle(hThread);<br>    CloseHandle(hProcess);<br>    <br>    <span class="hljs-keyword">return</span> TRUE;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span> &#123;<br>    LoadDll(<span class="hljs-number">384</span>, <span class="hljs-string">&quot;C:\\Documents and Settings\\Administrator\\桌面\\test\\B.dll&quot;</span>);<br>    getchar();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>注入成功：</p>
<p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image2021-6-3_15-38-24.png" srcset="https://picbedddd.oss-cn-beijing.aliyuncs.com/blog/loading.gif" lazyload alt="images/download/attachments/12714992/image2021-6-3_15-38-24.png"></p>
<h1 id="模块隐藏的基本方式"><a href="#模块隐藏的基本方式" class="headerlink" title="模块隐藏的基本方式"></a>模块隐藏的基本方式</h1><h2 id="加载进程"><a href="#加载进程" class="headerlink" title="加载进程"></a>加载进程</h2><p>加载进程的步骤如下：</p>
<p>1、将自己进程的ImageBase设置一个较大的值，让自己的程序在高空运行.</p>
<p>2、将要执行的进程读取进来，按照进程的ImageBase和SizeOfImage分配空间</p>
<p>3、拉伸进程</p>
<p>4、修复IAT表</p>
<p>5、跳转到入口执行</p>
<p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image-20220215110459007.png" srcset="https://picbedddd.oss-cn-beijing.aliyuncs.com/blog/loading.gif" lazyload alt="加载进程示意图"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdafx.h&quot;</span></span><br><br><span class="hljs-type">int</span> _tmain(<span class="hljs-type">int</span> argc, _TCHAR* argv[])<br>&#123;<br>	LPVOID pFileBuffer;<br>	LPVOID pImageBuffer;<br>	DWORD dwImageSize;<br>	HANDLE hCurrentProcess;<br>	LPVOID lpAllocAddr;<br><br>	PIMAGE_DOS_HEADER pDosHeader = <span class="hljs-literal">NULL</span>;<br>    PIMAGE_NT_HEADERS pNTHeader = <span class="hljs-literal">NULL</span>;<br>    PIMAGE_FILE_HEADER pPEHeader = <span class="hljs-literal">NULL</span>;<br>    PIMAGE_OPTIONAL_HEADER pOptionHeader = <span class="hljs-literal">NULL</span>;<br>	LPVOID pImportDir;<br>	LPVOID pImportAddressDir;<br><br><br>	DWORD dwImageBase;<br>	DWORD dwLastError;<br>	<span class="hljs-comment">// 读取A.exe，拉伸到0x400000中</span><br>	ReadPEFile(<span class="hljs-string">&quot;C:\\Users\\admin\\Desktop\\injected_exe.exe&quot;</span>, &amp;pFileBuffer);<br>	dwImageSize = CopyFileBufferToImageBuffer(pFileBuffer, &amp;pImageBuffer);<br>	<br>	<span class="hljs-comment">//更新PE文件信息</span><br>	pDosHeader = (PIMAGE_DOS_HEADER) pFileBuffer;<br>	pNTHeader = (PIMAGE_NT_HEADERS) ((DWORD) pFileBuffer + pDosHeader-&gt;e_lfanew);<br>    pPEHeader = (PIMAGE_FILE_HEADER) (((DWORD) pNTHeader) + <span class="hljs-number">4</span>);<br>    pOptionHeader = (PIMAGE_OPTIONAL_HEADER) ((DWORD) pPEHeader + IMAGE_SIZEOF_FILE_HEADER);<br><br>	dwImageBase = pOptionHeader-&gt;ImageBase;<br>	pImportAddressDir = (LPVOID)(pOptionHeader-&gt;DataDirectory[<span class="hljs-number">12</span>].VirtualAddress + dwImageBase);<br><br>	<span class="hljs-comment">// 获取进程自身句柄</span><br>	hCurrentProcess = GetCurrentProcess();<br>	<span class="hljs-comment">// 在进程中申请空间，需要以A.exe的基址来申请</span><br>	VirtualAllocEx(hCurrentProcess, (LPVOID)dwImageBase, dwImageSize, MEM_RESET, PAGE_READWRITE);<br>	lpAllocAddr = VirtualAllocEx(hCurrentProcess, (LPVOID)dwImageBase, dwImageSize, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);<br>	<br>	<span class="hljs-keyword">if</span> (lpAllocAddr == <span class="hljs-literal">NULL</span> )<br>	&#123;<br>		dwLastError = GetLastError();<br>		OutputDebugString(<span class="hljs-string">&quot;VirtualAllocEx failed!&quot;</span>);<br>		CloseHandle(hCurrentProcess);<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>	&#125;<br><br>	<span class="hljs-keyword">if</span> (lpAllocAddr != (LPVOID)dwImageBase )<br>	&#123;<br>		dwLastError = GetLastError();<br>		OutputDebugString(<span class="hljs-string">&quot;VirtualAllocEx address inconsist!&quot;</span>);<br>		CloseHandle(hCurrentProcess);<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>	&#125;<br>	<span class="hljs-comment">// 在进程中写入ImageBuffer</span><br>	WriteProcessMemory(hCurrentProcess, lpAllocAddr, pImageBuffer, dwImageSize, <span class="hljs-literal">NULL</span>);<br><br><br>	<span class="hljs-comment">// 根据A.exe的导入表，修复IAT表</span><br><br>	pImportDir = (LPVOID)(pOptionHeader-&gt;DataDirectory[<span class="hljs-number">1</span>].VirtualAddress + dwImageBase);<br><br>	<span class="hljs-comment">// 解析导入表</span><br>	PIMAGE_IMPORT_DESCRIPTOR pImportDescriptor = (PIMAGE_IMPORT_DESCRIPTOR) pImportDir;<br>	<span class="hljs-comment">//遍历数据并找到 IMAGE_IMPORT_DESCRIPTOR 的数目</span><br>	<span class="hljs-comment">// 检查每一个字节</span><br>	<span class="hljs-type">int</span> num = <span class="hljs-number">0</span>;<br>	BOOL break_flag = FALSE;<br>	PIMAGE_IMPORT_DESCRIPTOR pTemp = pImportDescriptor;<br>	DWORD procAddress;<br>	<span class="hljs-keyword">while</span> (pTemp-&gt;Name != <span class="hljs-literal">NULL</span>) &#123;<br>		num++;<br>		pTemp++;<br>	&#125;<br>	<span class="hljs-comment">// 遍历并处理每一块</span><br>	pTemp = pImportDescriptor;<br><br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; num; j++) &#123;<br>		<span class="hljs-comment">// DLL的名字</span><br>		<span class="hljs-type">char</span> *dll_name = (<span class="hljs-type">char</span> *) (dwImageBase + (pTemp + j)-&gt;Name);<br>		<span class="hljs-comment">//printf(&quot;%s :\n&quot;, dll_name);</span><br>		<span class="hljs-comment">//printf(&quot;----------------------------\n&quot;);</span><br><br>		<span class="hljs-comment">// INT表</span><br>		PIMAGE_THUNK_DATA pThunkName = (PIMAGE_THUNK_DATA) (dwImageBase + (pTemp + j)-&gt;OriginalFirstThunk);<br>		<span class="hljs-comment">// IAT表</span><br>		PIMAGE_THUNK_DATA pThunkProcAddress = (PIMAGE_THUNK_DATA) (dwImageBase + (pTemp + j)-&gt;FirstThunk);<br><br>		PIMAGE_IMPORT_BY_NAME pImageImportByName = (PIMAGE_IMPORT_BY_NAME) (dwImageBase + pThunkName-&gt;u1.Ordinal);<br>		<span class="hljs-comment">// 获取该DLL的函数名或者序号名</span><br>		<span class="hljs-keyword">while</span> (TRUE) &#123;<br>			<span class="hljs-keyword">if</span> ((pThunkName-&gt;u1.Ordinal &amp; IMAGE_ORDINAL_FLAG) == <span class="hljs-number">0</span>) <span class="hljs-comment">// the highest bit is 0</span><br>			&#123; <span class="hljs-comment">// 此时是名称导入方式，需要获取导入DLL中的函数名</span><br>				pImageImportByName = (PIMAGE_IMPORT_BY_NAME) (dwImageBase +  pThunkName-&gt;u1.Ordinal);<br>				<span class="hljs-comment">//printf(&quot;%s\n&quot;, pImageImportByName-&gt;Name);	</span><br>				<span class="hljs-comment">// 得到地址</span><br>				procAddress =  (DWORD)GetProcAddress(LoadLibrary(dll_name),pImageImportByName-&gt;Name);<br>				<br>				<span class="hljs-comment">// 修复</span><br>				pThunkProcAddress-&gt;u1.Ordinal = procAddress;<br>			&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//The highest bit is 1</span><br>				 <span class="hljs-comment">// 此时是序号导入方式，需要获取导入DLL中的序号</span><br>				DWORD dwOrdinal = ((pThunkName-&gt;u1.Ordinal &lt;&lt; <span class="hljs-number">1</span>) &gt;&gt; <span class="hljs-number">1</span>);<br>				<span class="hljs-comment">//printf(&quot;Import by ordinal: %lx\n&quot;, dwOrdinal);</span><br>				procAddress = (DWORD)GetProcAddress(LoadLibrary(dll_name),(LPCSTR)dwOrdinal);<br><br>				<span class="hljs-comment">// 修复</span><br>				pThunkProcAddress-&gt;u1.Ordinal = procAddress;<br>			&#125;<br>			pThunkName++;<br>			pThunkProcAddress++;<br>			<span class="hljs-keyword">if</span> (pThunkName-&gt;u1.Ordinal == <span class="hljs-number">0</span>) &#123; <span class="hljs-keyword">break</span>; &#125;<br>		&#125;<br>	&#125;<br><br><br><br>	<span class="hljs-comment">// 跳转到A的入口处执行</span><br>	DWORD dwOEPAddr = pOptionHeader-&gt;ImageBase + pOptionHeader-&gt;AddressOfEntryPoint;<br>	HANDLE hThread = CreateThread(<span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, (PTHREAD_START_ROUTINE)dwOEPAddr,<span class="hljs-literal">NULL</span> , <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello World\nBelow are the loaded exe:\n&quot;</span>);<br>	WaitForSingleObject(hThread, INFINITE);<br><br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="内存写入"><a href="#内存写入" class="headerlink" title="内存写入"></a>内存写入</h2><p>内存写入的思路如下：</p>
<p>1、获取自身句柄</p>
<p>2、得到ImageSize的大小,得到模块的ImageBuffer</p>
<p>3、在当前空间申请空间存放自身代码</p>
<p>4、拷贝自身到缓存</p>
<p>5、打开要注入的进程</p>
<p>6、在远程进程申请空间</p>
<p>7、对模块中的代码进行重定位</p>
<p>8、得到模块中要运行的函数的地址</p>
<p>9、将模块在进程中的地址作为参数传递给入口函数</p>
<p>10、将修正后的模块 通过WriteProcessMemory写入远程进程的内存空间中</p>
<p>11、通过CreateRemoteThread启动刚写入的代码</p>
<p>12、释放内存</p>
<p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image-20220215112345125.png" srcset="https://picbedddd.oss-cn-beijing.aliyuncs.com/blog/loading.gif" lazyload alt="内存写入示意图"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdafx.h&quot;</span></span><br><br>LPTSTR lpszCurrentModuleName;<br>LPVOID pFileBuffer;<br>LPVOID pImageBuffer;<br><br>DWORD <span class="hljs-type">static</span> WINAPI <span class="hljs-title function_">Entry</span><span class="hljs-params">(LPVOID pImageBuffer)</span><br>&#123;<br>	PIMAGE_DOS_HEADER pImageDosHeader = (PIMAGE_DOS_HEADER)pImageBuffer;<br>	PIMAGE_NT_HEADERS pImageNTHeader = (PIMAGE_NT_HEADERS) ((DWORD) pImageBuffer + pImageDosHeader-&gt;e_lfanew);<br>	PIMAGE_FILE_HEADER pImagePEHeader = (PIMAGE_FILE_HEADER) (((DWORD) pImageNTHeader) + <span class="hljs-number">4</span>);<br>	PIMAGE_OPTIONAL_HEADER pImageOptionHeader = (PIMAGE_OPTIONAL_HEADER) ((DWORD) pImagePEHeader + IMAGE_SIZEOF_FILE_HEADER);<br>	<span class="hljs-comment">// 修复IAT表</span><br><br><br>	<span class="hljs-comment">// 根据注入的EXE的导入表和当前被注入的EXE的环境，修复IAT表</span><br>	DWORD dwImageBase = pImageOptionHeader-&gt;ImageBase;<br>	LPVOID pImportDir = (LPVOID)(pImageOptionHeader-&gt;DataDirectory[<span class="hljs-number">1</span>].VirtualAddress + pImageOptionHeader-&gt;ImageBase);<br><br>	<span class="hljs-comment">// 解析导入表</span><br>	PIMAGE_IMPORT_DESCRIPTOR pImportDescriptor = (PIMAGE_IMPORT_DESCRIPTOR) pImportDir;<br>	<span class="hljs-comment">//遍历数据并找到 IMAGE_IMPORT_DESCRIPTOR 的数目</span><br>	<span class="hljs-comment">// 检查每一个字节</span><br>	<span class="hljs-type">int</span> num = <span class="hljs-number">0</span>;<br>	BOOL break_flag = FALSE;<br>	PIMAGE_IMPORT_DESCRIPTOR pTemp = pImportDescriptor;<br>	DWORD procAddress;<br>	<span class="hljs-keyword">while</span> (pTemp-&gt;Name != <span class="hljs-literal">NULL</span>) &#123;<br>		num++;<br>		pTemp++;<br>	&#125;<br>	<span class="hljs-comment">// 遍历并处理每一块</span><br>	pTemp = pImportDescriptor;<br><br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; num; j++) &#123;<br>		<span class="hljs-comment">// DLL的名字</span><br>		<span class="hljs-type">char</span> *dll_name = (<span class="hljs-type">char</span> *) (dwImageBase + (pTemp + j)-&gt;Name);<br>		<span class="hljs-comment">//printf(&quot;%s :\n&quot;, dll_name);</span><br>		<span class="hljs-comment">//printf(&quot;----------------------------\n&quot;);</span><br><br>		<span class="hljs-comment">// INT表</span><br>		PIMAGE_THUNK_DATA pThunkName = (PIMAGE_THUNK_DATA) (dwImageBase + (pTemp + j)-&gt;OriginalFirstThunk);<br>		<span class="hljs-comment">// IAT表</span><br>		PIMAGE_THUNK_DATA pThunkProcAddress = (PIMAGE_THUNK_DATA) (dwImageBase + (pTemp + j)-&gt;FirstThunk);<br><br>		PIMAGE_IMPORT_BY_NAME pImageImportByName = (PIMAGE_IMPORT_BY_NAME) (dwImageBase + pThunkName-&gt;u1.Ordinal);<br>		<span class="hljs-comment">// 获取该DLL的函数名或者序号名</span><br>		<span class="hljs-keyword">while</span> (TRUE) &#123;<br>			<span class="hljs-keyword">if</span> ((pThunkName-&gt;u1.Ordinal &amp; IMAGE_ORDINAL_FLAG) == <span class="hljs-number">0</span>) <span class="hljs-comment">// the highest bit is 0</span><br>			&#123; <span class="hljs-comment">// 此时是名称导入方式，需要获取导入DLL中的函数名</span><br>				pImageImportByName = (PIMAGE_IMPORT_BY_NAME) (dwImageBase +  pThunkName-&gt;u1.Ordinal);<br>				<span class="hljs-comment">//printf(&quot;%s\n&quot;, pImageImportByName-&gt;Name);	</span><br>				<span class="hljs-comment">// 得到地址</span><br>				procAddress =  (DWORD)GetProcAddress(LoadLibrary(dll_name),pImageImportByName-&gt;Name);<br><br>				<span class="hljs-comment">// 修复</span><br>				pThunkProcAddress-&gt;u1.Ordinal = procAddress;<br>			&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//The highest bit is 1</span><br>				<span class="hljs-comment">// 此时是序号导入方式，需要获取导入DLL中的序号</span><br>				DWORD dwOrdinal = ((pThunkName-&gt;u1.Ordinal &lt;&lt; <span class="hljs-number">1</span>) &gt;&gt; <span class="hljs-number">1</span>);<br>				<span class="hljs-comment">//printf(&quot;Import by ordinal: %lx\n&quot;, dwOrdinal);</span><br>				procAddress = (DWORD)GetProcAddress(LoadLibrary(dll_name),(LPCSTR)dwOrdinal);<br><br>				<span class="hljs-comment">// 修复</span><br>				pThunkProcAddress-&gt;u1.Ordinal = procAddress;<br>			&#125;<br>			pThunkName++;<br>			pThunkProcAddress++;<br>			<span class="hljs-keyword">if</span> (pThunkName-&gt;u1.Ordinal == <span class="hljs-number">0</span>) &#123; <span class="hljs-keyword">break</span>; &#125;<br>		&#125;<br>	&#125;<br><br><br><br>	<span class="hljs-comment">// 跳转到A的入口处执行</span><br>	DWORD dwOEPAddr = pImageOptionHeader-&gt;ImageBase + pImageOptionHeader-&gt;AddressOfEntryPoint;<br>	HANDLE hThread = CreateThread(<span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, (PTHREAD_START_ROUTINE)dwOEPAddr,<span class="hljs-literal">NULL</span> , <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;AnotherThread running...\n&quot;</span>);<br>	WaitForSingleObject(hThread, INFINITE);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 需要注入的进程ID</span><br>DWORD dwInjectedPid = <span class="hljs-number">880</span>;<br><span class="hljs-type">int</span> _tmain(<span class="hljs-type">int</span> argc, _TCHAR* argv[])<br>&#123;<br>	DWORD dwCurrentPid = GetCurrentProcessId();<br>	<span class="hljs-comment">// 正确注入，执行代码</span><br>	<span class="hljs-keyword">if</span> (dwCurrentPid == dwInjectedPid )<br>	&#123;<br>		TestSuccess();<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>	&#125;<br><br><br><br>	<span class="hljs-comment">//1、获取自身句柄			</span><br>	DWORD dwImageAddr = (DWORD)::GetModuleHandle(<span class="hljs-literal">NULL</span>);<br><br>	<span class="hljs-comment">// 2、获得自身的ImageBase/SizeOfImage</span><br>	PIMAGE_DOS_HEADER pSelfDosHeader  = (PIMAGE_DOS_HEADER)dwImageAddr;<br>	PIMAGE_NT_HEADERS pSelfNTHeader = (PIMAGE_NT_HEADERS) (dwImageAddr + pSelfDosHeader-&gt;e_lfanew);;<br>	PIMAGE_FILE_HEADER pSelfPEHeader = (PIMAGE_FILE_HEADER) (((DWORD) pSelfNTHeader) + <span class="hljs-number">4</span>);;<br>	PIMAGE_OPTIONAL_HEADER pSelfOptionHeader = (PIMAGE_OPTIONAL_HEADER) ((DWORD) pSelfPEHeader + IMAGE_SIZEOF_FILE_HEADER);<br><br>	DWORD dwSelfImageBase = pSelfOptionHeader-&gt;ImageBase;<br>	DWORD dwSelfImageSize = pSelfOptionHeader-&gt;SizeOfImage;<br><br>	<span class="hljs-comment">//3、创建一个新的缓冲区，将自己复制进去	</span><br>	pImageBuffer = <span class="hljs-built_in">calloc</span>(<span class="hljs-number">1</span>,dwSelfImageSize);<br>	ReadProcessMemory(GetCurrentProcess(),(LPCVOID)dwSelfImageBase,pImageBuffer,dwSelfImageSize,<span class="hljs-literal">NULL</span>);<br>	<span class="hljs-comment">//4、打开要注入的A进程			</span><br>	HANDLE hInjectProcess = OpenProcess(PROCESS_ALL_ACCESS,FALSE,dwInjectedPid);<br>	<span class="hljs-keyword">if</span> (hInjectProcess == <span class="hljs-literal">NULL</span>)<br>	&#123;<br>		OutputDebugString(<span class="hljs-string">&quot;进程不存在！&quot;</span>);<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>	&#125;<br><br>	<span class="hljs-comment">//5、在A进程中申请内存，大小就是SizeOfImage		</span><br>	LPVOID lpAllocAddr = VirtualAllocEx(hInjectProcess, <span class="hljs-literal">NULL</span>, dwSelfImageSize, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);<br><br>	<span class="hljs-comment">//6、根据B的重定位表修复值</span><br><br>	<span class="hljs-comment">// 改掉ImageBase</span><br>	PIMAGE_DOS_HEADER pSelfImageDosHeader = (PIMAGE_DOS_HEADER)pImageBuffer;<br>	PIMAGE_NT_HEADERS pSelfImageNTHeader = (PIMAGE_NT_HEADERS) ((DWORD) pImageBuffer + pSelfImageDosHeader-&gt;e_lfanew);<br>	PIMAGE_FILE_HEADER pSelfImagePEHeader = (PIMAGE_FILE_HEADER) (((DWORD) pSelfImageNTHeader) + <span class="hljs-number">4</span>);<br>	PIMAGE_OPTIONAL_HEADER pSelfImageOptionHeader = (PIMAGE_OPTIONAL_HEADER) ((DWORD) pSelfImagePEHeader + IMAGE_SIZEOF_FILE_HEADER);<br>	DWORD dwOriginalImageBase = pSelfImageOptionHeader-&gt;ImageBase;<br>	pSelfImageOptionHeader-&gt;ImageBase =(DWORD)lpAllocAddr;<br><br><br>	PIMAGE_BASE_RELOCATION pReloc = (PIMAGE_BASE_RELOCATION)((DWORD)pImageBuffer + pSelfImageOptionHeader-&gt;DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress);<br><br>	<span class="hljs-comment">// 计算delta</span><br>	DWORD dwDelta;<br>	dwDelta = (DWORD)lpAllocAddr - dwOriginalImageBase;<span class="hljs-comment">//实际的imageBase减去pe文件里面标识的imagebase得到“移动的距离”</span><br>	<span class="hljs-comment">//判断是否有重定位表</span><br>	<span class="hljs-keyword">if</span> ((<span class="hljs-type">char</span>*)pReloc != (<span class="hljs-type">char</span>*)pImageBuffer)<br>	&#123;<br>		<span class="hljs-keyword">while</span> ((pReloc-&gt;VirtualAddress + pReloc-&gt;SizeOfBlock) != <span class="hljs-number">0</span>) <span class="hljs-comment">//开始扫描重定位表</span><br>		&#123;<br>			WORD* pLocData = (WORD*)((PBYTE)pReloc + <span class="hljs-keyword">sizeof</span>(IMAGE_BASE_RELOCATION));<br>			<span class="hljs-comment">//计算需要修正的重定位项（地址）的数目</span><br>			<span class="hljs-type">int</span> nNumberOfReloc = (pReloc-&gt;SizeOfBlock - <span class="hljs-keyword">sizeof</span>(IMAGE_BASE_RELOCATION)) / <span class="hljs-keyword">sizeof</span>(WORD);<br><br>			DWORD* pAddress;<br>			<br>			<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nNumberOfReloc; i++)<br>			&#123;<br><br>				<span class="hljs-keyword">if</span> ((DWORD)(pLocData[i] &amp; <span class="hljs-number">0x0000F000</span>) == <span class="hljs-number">0x00003000</span>) <span class="hljs-comment">//这是一个需要修正的地址</span><br>				&#123;<br>					pAddress = (DWORD*)((PBYTE)pImageBuffer + pReloc-&gt;VirtualAddress + (pLocData[i] &amp; <span class="hljs-number">0x0FFF</span>));<br>					*pAddress += dwDelta;<span class="hljs-comment">//把移动的距离在原地址加上去</span><br>				&#125;<br>			&#125;<br><br>			<span class="hljs-comment">//转移到下一个节进行处理</span><br>			pReloc = (PIMAGE_BASE_RELOCATION)((PBYTE)pReloc + pReloc-&gt;SizeOfBlock);<br>		&#125;<br>	&#125;<br><br><br>	<span class="hljs-comment">//7、将修复后的数据，复制到A的内存中			</span><br>	WriteProcessMemory(hInjectProcess, lpAllocAddr, pImageBuffer, dwSelfImageSize, <span class="hljs-literal">NULL</span>);<br>	<span class="hljs-comment">//8、创建一个远程线程，执行Entry	</span><br>	DWORD dwFixedEntry = (DWORD)Entry + dwDelta;<br>	HANDLE hThread = CreateRemoteThread(hInjectProcess, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, (LPTHREAD_START_ROUTINE)dwFixedEntry, lpAllocAddr, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);<br>	WaitForSingleObject(hThread, INFINITE);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<h1 id="基本HOOK方式（3环HOOK）"><a href="#基本HOOK方式（3环HOOK）" class="headerlink" title="基本HOOK方式（3环HOOK）"></a>基本HOOK方式（3环HOOK）</h1><blockquote>
<p>Hook技术被广泛应用于安全的多个领域，比如杀毒软件的主动防御功能，涉及到对一些敏感API的监控，就需要对这些API进行Hook；窃取密码的木马病毒，为了接收键盘的输入，需要Hook键盘消息；甚至是Windows系统及一些应用程序，在打补丁时也需要用到Hook技术</p>
</blockquote>
<h2 id="IAT-HOOK"><a href="#IAT-HOOK" class="headerlink" title="IAT HOOK"></a>IAT HOOK</h2><p>我们都知道几乎所有的PE文件都需要外部模块提供的函数，这些函数的信息存储在导入表IAT中，将IAT表中的信息修改为指定函数的地址即可达到HOOK的效果。</p>
<p>IAT HOOK的代码十分地精简，主要函数如下，它的功能是修改IAT表中的值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs c">HMODULE hModule = GetModuleHandle(_T(<span class="hljs-string">&quot;user32.dll&quot;</span>));<br>DWORD dwOldProcAddr = (DWORD)GetProcAddress(hModule, _T(<span class="hljs-string">&quot;MessageBoxA&quot;</span>));<br><br><br><span class="hljs-comment">// 传入参数为IAT表中原先的值和需要修改的值</span><br>BOOL <span class="hljs-title function_">SetIATHook</span><span class="hljs-params">(DWORD dwOldAddr, DWORD dwNewAddr)</span>&#123;<br>	init();<br>	PIMAGE_IMPORT_DESCRIPTOR pImportDescriptor = (PIMAGE_IMPORT_DESCRIPTOR) pImportDir;<br>	<span class="hljs-keyword">while</span> (pImportDescriptor-&gt;FirstThunk != <span class="hljs-number">0</span> &amp;&amp; g_bIATHookFlag != <span class="hljs-number">1</span>) &#123;<br>		pFuncAddr = (PDWORD) (dwImageAddr + pImportDescriptor-&gt;FirstThunk);<br>		<span class="hljs-keyword">while</span> (*pFuncAddr)&#123;<br>			<span class="hljs-keyword">if</span> (*pFuncAddr == dwOldAddr) &#123;<br>				*pFuncAddr = dwNewAddr;<br>				g_bIATHookFlag = TRUE;<br>				<span class="hljs-keyword">return</span> TRUE;<br>			&#125;<br>			pFuncAddr ++ ;<br>		&#125;<br>		pImportDescriptor ++ ;<br>	&#125;<br>	<span class="hljs-keyword">return</span> FALSE;<br>&#125;<br><br>BOOL <span class="hljs-title function_">UnsetIATHook</span><span class="hljs-params">(DWORD dwOldAddr)</span><br>&#123;<br>	*pFuncAddr = dwOldAddr;<br>	<span class="hljs-keyword">return</span> TRUE;<br>&#125;<br><br>DWORD <span class="hljs-title function_">GetFuncAddr</span><span class="hljs-params">(DWORD dwFuncAddr)</span>&#123;<br>	DWORD dwOffset = *(PDWORD)((PBYTE)dwFuncAddr + <span class="hljs-number">1</span>);<br>	<span class="hljs-keyword">return</span> dwFuncAddr + <span class="hljs-number">5</span> + dwOffset;<br>&#125;<br><br><br><span class="hljs-comment">// 0x411810</span><br>DWORD WINAPI <span class="hljs-title function_">MyMessageBox</span><span class="hljs-params">(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType)</span>&#123;<br>	<span class="hljs-comment">// 定义MessageBox 函数指针</span><br><br>	<span class="hljs-keyword">typedef</span> <span class="hljs-title function_">DWORD</span> <span class="hljs-params">(WINAPI *pfnMessageBox)</span><span class="hljs-params">(HWND _hWnd, LPCSTR _lpText, LPCSTR _lpCaption, UINT _uType)</span>;<br><br>	<span class="hljs-comment">// 获取参数</span><br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;参数： %x %s %s %x\n&quot;</span>,hWnd, lpText, lpCaption, uType);<br>	<span class="hljs-comment">// 执行真正的函数</span><br>	<span class="hljs-type">int</span> ret = ((pfnMessageBox)dwOldProcAddr)(hWnd, lpText, lpCaption, uType);<br>	<span class="hljs-comment">// 获取返回值</span><br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;返回值： %x\n&quot;</span>,ret);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br>VOID <span class="hljs-title function_">TestIATHook</span><span class="hljs-params">()</span>&#123;<br>	<span class="hljs-comment">//安装IAT Hook</span><br>	BOOL bSuccess = SetIATHook(dwOldProcAddr,GetFuncAddr((DWORD)MyMessageBox));<br><br>	<span class="hljs-keyword">if</span> (bSuccess)&#123;<br>		MessageBox(<span class="hljs-literal">NULL</span>,_T(<span class="hljs-string">&quot;测试IAT Hook&quot;</span>), _T(<span class="hljs-string">&quot;IAT Hook&quot;</span>), MB_OK);<br><br>		<span class="hljs-comment">//卸载IAT Hook</span><br>		UnsetIATHook(dwOldProcAddr);<br>	&#125;<br>	<br>&#125;<br><br><span class="hljs-type">int</span> _tmain(<span class="hljs-type">int</span> argc, _TCHAR* argv[])&#123;<br><br>	TestIATHook();<br>	<span class="hljs-comment">//TestInlineHook();</span><br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<p>这里的GetFuncAddr函数是为了获得函数的地址。虽然也可以通过直接反汇编看函数的代码来看，但是这种方式重新编译后就可能会发生变化，比较不方便。</p>
<p>简单地将函数名转成DWORD也是不行的，原因如下图，有个jmp：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">BOOL bSuccess = SetIATHook(dwOldProcAddr,(DWORD)MyMessageBox); <span class="hljs-comment">// 不行</span><br></code></pre></td></tr></table></figure>

<p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image-20220215162358338.png" srcset="https://picbedddd.oss-cn-beijing.aliyuncs.com/blog/loading.gif" lazyload alt="image-20220215162358338"></p>
<p>运行结果：</p>
<p>简单地打印了一下参数和返回值</p>
<p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image-20220215225404864.png" srcset="https://picbedddd.oss-cn-beijing.aliyuncs.com/blog/loading.gif" lazyload alt="image-20220215225404864"></p>
<h2 id="Inline-HOOK"><a href="#Inline-HOOK" class="headerlink" title="Inline HOOK"></a>Inline HOOK</h2><p>Inline HOOK更将简单粗暴一些，通过直接修改硬编码达到函数跳转的效果。</p>
<p>Inline HOOK实现的关键是如何保存原来线程的CONTEXT环境，以及被覆盖的硬编码的保存与执行问题。</p>
<p>对于第一个问题，我们可以定义一个Register类来保存原来线程的CONTEXT环境：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">REGISTER</span>&#123;</span><br>	DWORD Eax;<br>	DWORD Ebx;<br>	DWORD Ecx;<br>	DWORD Edx;<br>	DWORD Esi;<br>	DWORD Edi;<br>	DWORD Esp;<br>	DWORD Ebp;<br>&#125;Register;<br></code></pre></td></tr></table></figure>

<p>同时在我们的HOOK函数中用相应的汇编代码保存现场：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> __declspec(naked) <span class="hljs-type">void</span> <span class="hljs-title function_">HookProc</span><span class="hljs-params">()</span>&#123;<br>	<span class="hljs-comment">// 保存寄存器</span><br>	_asm<br>	&#123;<br>		pushad<br>		pushfd<br>	&#125;<br><br>	<span class="hljs-comment">// 获取数据</span><br>	_asm<br>	&#123;<br>		mov reg.Eax, eax<br>		mov reg.Ebx, ebx<br>		mov reg.Ecx, ecx<br>		mov reg.Edx, edx<br>		mov reg.Esi, esi<br>		mov reg.Edi, edi<br>		mov reg.Esp, esp<br>		mov reg.Ebp, ebp<br>	&#125;<br><br>    <br>    <span class="hljs-comment">//要做的事代码写这</span><br><br>    <br>	<span class="hljs-comment">// 恢复寄存器</span><br>	_asm<br>	&#123;<br>		popfd<br>		popad<br>	&#125;<br><br>	<span class="hljs-comment">// 跳到存储的CodePatch处</span><br>	_asm<br>	&#123;<br>		jmp g_pOldProcAddr;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>对于第二个问题，这里直接给出代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs c">BOOL g_bHookSuccessFlag = FALSE;<br>PBYTE g_pCodePatch;<br><br><span class="hljs-comment">// dwHookAddr : 安装Hook的地址</span><br><span class="hljs-comment">// dwProcAddr ：真正需要执行的函数地址</span><br>BOOL <span class="hljs-title function_">SetInlineHook</span><span class="hljs-params">(DWORD dwHookAddr, DWORD dwProcAddr, DWORD dwLength, PBYTE* pOldCode)</span>&#123;<br>	BOOL bRet;<br>	<br>	DWORD dwJmpCode;<br>	<span class="hljs-comment">// 参数校验</span><br>	<span class="hljs-keyword">if</span> (dwHookAddr == <span class="hljs-literal">NULL</span> || dwProcAddr == <span class="hljs-literal">NULL</span>)&#123;<br>		OutputDebugString(<span class="hljs-string">&quot;SetInlineHook函数执行失败：Hook地址/函数地址填写有误！&quot;</span>);<br>		<span class="hljs-keyword">return</span> FALSE;<br>	&#125;<br>	<span class="hljs-comment">// 长度不能小于5</span><br>	<span class="hljs-keyword">if</span> (dwLength &lt; <span class="hljs-number">5</span>)&#123;<br>		OutputDebugString(<span class="hljs-string">&quot;SetInlineHook函数执行失败：修改的硬编码长度不能小于5！&quot;</span>);<br>		<span class="hljs-keyword">return</span> FALSE;<br>	&#125;<br>	<span class="hljs-comment">// 将要Hook的内存修改为可写</span><br>	DWORD dwOldProtectionFlag;<br>	bRet = VirtualProtectEx(::GetCurrentProcess(),(LPVOID)dwHookAddr,dwLength,PAGE_EXECUTE_READWRITE,&amp;dwOldProtectionFlag);<br>	<span class="hljs-keyword">if</span> (!bRet)&#123;<br>		OutputDebugString(<span class="hljs-string">&quot;SetInlineHook函数执行失败：修改内存属性失败！&quot;</span>);<br>		<span class="hljs-keyword">return</span> FALSE;<br>	&#125;<br>	<span class="hljs-comment">// 申请一块有执行权限的虚拟内存，存储原来的硬编码</span><br>	<span class="hljs-comment">// +5 是为了预留空间嵌入机器码跳回原来的地址</span><br>	LPVOID pAllocAddr = VirtualAllocEx(::GetCurrentProcess(),<span class="hljs-literal">NULL</span>,dwLength + <span class="hljs-number">5</span>, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);<br>	<span class="hljs-built_in">memcpy</span>(pAllocAddr,(LPVOID)dwHookAddr,dwLength);<br>	<span class="hljs-comment">// 设置跳回并执行原来的地址</span><br>	*(PBYTE)((DWORD)pAllocAddr + dwLength) = <span class="hljs-number">0xE9</span>;<br>	<span class="hljs-comment">// 要跳转到的地址 = E9的地址 + 5 + E9后面的值</span><br>	<span class="hljs-comment">// --&gt; E9后面的值 = 要跳转到的地址 - 5 - E9的地址</span><br>	*(PDWORD)((DWORD)pAllocAddr + dwLength +<span class="hljs-number">1</span>) = dwHookAddr + dwLength - ((DWORD)pAllocAddr + dwLength) - <span class="hljs-number">5</span>;<br>	<span class="hljs-comment">// 将pAllocAddr的地址传递出去，它将会在HookProc函数的最后得到使用</span><br>	*pOldCode = (PBYTE)pAllocAddr;<br><br>	<span class="hljs-comment">// 跳转到dwProcAddr</span><br>	<span class="hljs-comment">// 要跳转到的地址 = E9的地址 + 5 + E9后面的值</span><br>	<span class="hljs-comment">// --&gt; E9后面的值 = 要跳转到的地址 - 5 - E9的地址</span><br>	dwJmpCode = dwProcAddr - dwHookAddr - <span class="hljs-number">5</span>;<br><br>	<span class="hljs-comment">// 将要Hook的内存首先全部设置为NOP</span><br>	<span class="hljs-built_in">memset</span>((PBYTE)dwHookAddr,<span class="hljs-number">0x90</span>,dwLength);<br><br>	<span class="hljs-comment">// 修改要Hook的内存的硬编码</span><br>	*(PBYTE)dwHookAddr = <span class="hljs-number">0xE9</span>;<br>	*(PDWORD)((PBYTE)dwHookAddr + <span class="hljs-number">1</span>) = dwJmpCode;<br>	<br>	<span class="hljs-comment">// 修改被Hook的状态</span><br>	g_bHookSuccessFlag = TRUE;<br><br>	<span class="hljs-keyword">return</span> TRUE;<br>&#125;<br><br>BOOL <span class="hljs-title function_">UnsetInlineHook</span><span class="hljs-params">(DWORD dwHookAddr, DWORD dwPatchAddr, DWORD dwLength)</span>&#123;<br>	<span class="hljs-keyword">if</span> (g_bHookSuccessFlag)&#123;<br>		<span class="hljs-built_in">memcpy</span>((LPVOID)dwHookAddr,(LPVOID)dwPatchAddr,dwLength);<br>		<span class="hljs-keyword">return</span> TRUE;<br>	&#125;<span class="hljs-keyword">else</span>&#123;<br>		OutputDebugString(<span class="hljs-string">&quot;没有Hook成功，无需恢复！&quot;</span>);<br>		<span class="hljs-keyword">return</span> FALSE;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在安装InlineHook后，函数的执行流程变成了下面这种方式：</p>
<p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image-20220215224714071.png" srcset="https://picbedddd.oss-cn-beijing.aliyuncs.com/blog/loading.gif" lazyload alt="image-20220215224714071"></p>
<p>运行结果：</p>
<p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image-20220218161715304.png" srcset="https://picbedddd.oss-cn-beijing.aliyuncs.com/blog/loading.gif" lazyload alt="image-20220218161715304"></p>
<p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image-20220218161725298.png" srcset="https://picbedddd.oss-cn-beijing.aliyuncs.com/blog/loading.gif" lazyload alt="image-20220218161725298"></p>
<h1 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h1><p>进程通信的方式有很多，包括文件读写、自定义消息、文件映射、共享内存、管道（匿名&#x2F;命名）等。</p>
<p>我们之前提到的信号量等进程同步机制也同样可以用于进程间的通信。</p>
<p>下面给出几种进程通信的Demo。</p>
<h2 id="自定义消息"><a href="#自定义消息" class="headerlink" title="自定义消息"></a>自定义消息</h2><p>在Windows的消息机制中，消息的种类是有限的。最后一种消息是<code>wm_user</code>（0x0400），这意味着往后就是Windows未使用的消息编号，我们可以使用其来传递消息。</p>
<h3 id="发送端代码"><a href="#发送端代码" class="headerlink" title="发送端代码"></a>发送端代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c">HWND hwnd = ::FindWindow(<span class="hljs-literal">NULL</span>,TEXT(<span class="hljs-string">&quot;接收端窗口名&quot;</span>));<br><span class="hljs-keyword">if</span>(hwnd == <span class="hljs-literal">NULL</span>)<br>&#123;<br>	MessageBox(<span class="hljs-number">0</span>,TEXT(<span class="hljs-string">&quot;没找到窗口&quot;</span>),TEXT(<span class="hljs-string">&quot;ERROR&quot;</span>),MB_OK);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>	<span class="hljs-comment">// 发送消息  </span><br>	<span class="hljs-comment">//SendMessage(hwnd,WM_USER+0x1,NULL, (LPARAM)100); </span><br>	PostMessage(hwnd,WM_USER+<span class="hljs-number">0x1</span>, <span class="hljs-literal">NULL</span>, (LPARAM)<span class="hljs-number">100</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="接收端代码"><a href="#接收端代码" class="headerlink" title="接收端代码"></a>接收端代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">switch</span>(uMsg)<br>&#123;<br>    <span class="hljs-keyword">case</span> WM_CLOSE:<br>    &#123;<br>    	EndDialog(hDlg,<span class="hljs-number">0</span>);<br>    	<span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">case</span> WM_USER+<span class="hljs-number">0x1</span>:<br>    &#123;<br>    	DWORD x = wParam;<br>    	DWORD y = lParam;<br><br>    	MessageBox(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>    	<span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">case</span> WM_COMMAND:<br>    &#123;<br>    	<span class="hljs-keyword">switch</span> (LOWORD (wParam))<br>    	&#123;<br>            <span class="hljs-keyword">case</span> IDC_BUTTON_RECV:<br>            &#123;<br>                <span class="hljs-keyword">return</span> TRUE;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">break</span> ;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h2><p>Win32 API中共享内存(Shared Memory)是文件映射的一种特殊情况。进程在创建文件映射对象时用0xFFFFFFFF来代替文件句柄(HANDLE)，就表示了对应的文件映射对象是从操作系统页面文件访问内存，其它进程打开该文件映射对象就可以访问该内存块。</p>
<blockquote>
<p>补充：关于文件映射</p>
<p>文件映射(Memory-Mapped Files)能使进程把文件内容当作进程地址区间一块内存那样来对待。因此，进程不必使用文件I&#x2F;O操作，只需简单的指针操作就可读取和修改文件的内容。</p>
<p>Win32 API允许多个进程访问同一文件映射对象，各个进程在它自己的地址空间里接收内存的指针。通过使用这些指针，不同进程就可以读或修改文件的内容，实现了对文件中数据的共享。</p>
</blockquote>
<h3 id="发送端代码-1"><a href="#发送端代码-1" class="headerlink" title="发送端代码"></a>发送端代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> _tmain(<span class="hljs-type">int</span> argc, _TCHAR* argv[])<br>&#123;<br>	HANDLE hMapObject;<br>	HANDLE hMapView;<br><br>	<span class="hljs-comment">//创建FileMapping对象</span><br>	hMapObject = CreateFileMapping((HANDLE)<span class="hljs-number">0xFFFFFFFF</span>,<span class="hljs-literal">NULL</span>,PAGE_READWRITE,<span class="hljs-number">0</span>,<span class="hljs-number">0x1000</span>,TEXT(<span class="hljs-string">&quot;shared&quot;</span>));<br>	<span class="hljs-keyword">if</span>(!hMapObject)<br>	&#123;<br>		MessageBox(<span class="hljs-literal">NULL</span>,TEXT(<span class="hljs-string">&quot;共享内存失败&quot;</span>),TEXT(<span class="hljs-string">&quot;Error&quot;</span>),MB_OK);<br>		<span class="hljs-keyword">return</span> FALSE;<br>	&#125;<br>	<span class="hljs-comment">//将FileMapping对象映射到自己的进程</span><br>	hMapView = MapViewOfFile(hMapObject,FILE_MAP_WRITE,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>	<span class="hljs-keyword">if</span>(!hMapView)<br>	&#123;<br>		MessageBox(<span class="hljs-literal">NULL</span>,TEXT(<span class="hljs-string">&quot;内存映射失败&quot;</span>),TEXT(<span class="hljs-string">&quot;Error&quot;</span>),MB_OK);<br>		<span class="hljs-keyword">return</span> FALSE;<br>	&#125;<br>	<span class="hljs-comment">//向共享内存写入数据</span><br>	<span class="hljs-built_in">strcpy</span>((<span class="hljs-type">char</span>*)hMapView,<span class="hljs-string">&quot;Test Shared Memery&quot;</span>);<br>	getchar();<br><br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="接收端代码-1"><a href="#接收端代码-1" class="headerlink" title="接收端代码"></a>接收端代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// shared_memory_receive.cpp : 定义控制台应用程序的入口点。</span><br><span class="hljs-comment">//</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdafx.h&quot;</span></span><br><br><br><span class="hljs-type">int</span> _tmain(<span class="hljs-type">int</span> argc, _TCHAR* argv[])<br>&#123;<br>	HANDLE hMapObject;<br>	HANDLE hMapView;<br><br>	<span class="hljs-comment">//创建FileMapping对象</span><br>	hMapObject = CreateFileMapping((HANDLE)<span class="hljs-number">0xFFFFFFFF</span>,<span class="hljs-literal">NULL</span>,PAGE_READWRITE,<span class="hljs-number">0</span>,<span class="hljs-number">0x1000</span>,TEXT(<span class="hljs-string">&quot;shared&quot;</span>));<br>	<span class="hljs-keyword">if</span>(!hMapObject)<br>	&#123;<br>		MessageBox(<span class="hljs-literal">NULL</span>,TEXT(<span class="hljs-string">&quot;共享内存失败&quot;</span>),TEXT(<span class="hljs-string">&quot;Error&quot;</span>),MB_OK);<br>		<span class="hljs-keyword">return</span> FALSE;<br>	&#125;<br>	<span class="hljs-comment">//将FileMapping对象映射到自己的进程</span><br>	hMapView = MapViewOfFile(hMapObject,FILE_MAP_WRITE,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>	<span class="hljs-keyword">if</span>(!hMapView)<br>	&#123;<br>		MessageBox(<span class="hljs-literal">NULL</span>,TEXT(<span class="hljs-string">&quot;内存映射失败&quot;</span>),TEXT(<span class="hljs-string">&quot;Error&quot;</span>),MB_OK);<br>		<span class="hljs-keyword">return</span> FALSE;<br>	&#125;<br>	<span class="hljs-comment">//从共享内存读取数据</span><br>	TCHAR szBuffer[<span class="hljs-number">0x1000</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>	<span class="hljs-built_in">memcpy</span>(szBuffer,hMapView,<span class="hljs-number">10</span>);<br>	MessageBox(<span class="hljs-literal">NULL</span>,szBuffer,TEXT(<span class="hljs-string">&quot;从发送端接收到数据&quot;</span>),MB_OK);<br>	getchar();<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h3><p>同时运行发送端和接收端代码，结果如下：</p>
<p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image-20220220110439582.png" srcset="https://picbedddd.oss-cn-beijing.aliyuncs.com/blog/loading.gif" lazyload alt="image-20220220110439582"></p>
<h2 id="匿名管道"><a href="#匿名管道" class="headerlink" title="匿名管道"></a>匿名管道</h2><p>匿名管道不需要知道创建对象管道的名字。它是通过内核对象的可继承性进行的，也就是说匿名管道只能作用于父子进程之间，在父进程创建子进程的时候通过对CreateProcess函数中传参，即可让子进程获得父进程的内核对象句柄。</p>
<p>匿名管道是单机上实现子进程标准I&#x2F;O重定向的有效方法，它不能在网上使用，也不能用于两个不相关的进程之间。</p>
<p>具体实现细节，请参考《Windows核心编程》内核对象一章。</p>
<blockquote>
<p>补充：关于<strong>命</strong>名管道</p>
<p>命名管道(Named Pipe)是服务器进程和一个或多个客户进程之间通信的单向或双向管道。不同于匿名管道的是命名管道可以在不相关的进程之间和不同计算机之间使用，服务器建立命名管道时给它指定一个名字，任何进程都可以通过该名字打开管道的另一端，根据给定的权限和服务器进程通信。</p>
</blockquote>
<h3 id="父进程代码"><a href="#父进程代码" class="headerlink" title="父进程代码"></a>父进程代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// anonymous_pipe_parent.cpp : 定义控制台应用程序的入口点。</span><br><span class="hljs-comment">//</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdafx.h&quot;</span></span><br><br><br><span class="hljs-type">int</span> _tmain(<span class="hljs-type">int</span> argc, _TCHAR* argv[])<br>&#123;<br>	HANDLE hParentRead;<br>	HANDLE hParentWrite;<br>	HANDLE hChildRead;<br>	HANDLE hChildWrite;<br><br>	SECURITY_ATTRIBUTES sa;<br><br>	sa.bInheritHandle = TRUE;<br>	sa.lpSecurityDescriptor = <span class="hljs-literal">NULL</span>;<br>	sa.nLength = <span class="hljs-keyword">sizeof</span>(SECURITY_ATTRIBUTES);<br><br>	<span class="hljs-keyword">if</span>(!CreatePipe(&amp;hParentRead,&amp;hChildWrite,&amp;sa,<span class="hljs-number">0</span>))<br>	&#123;<br>		MessageBox(<span class="hljs-number">0</span>,TEXT(<span class="hljs-string">&quot;创建匿名管道失败!&quot;</span>),TEXT(<span class="hljs-string">&quot;Error&quot;</span>),MB_OK);<br>	&#125;<br>	<span class="hljs-keyword">if</span>(!CreatePipe(&amp;hChildRead,&amp;hParentWrite,&amp;sa,<span class="hljs-number">0</span>))<br>	&#123;<br>		MessageBox(<span class="hljs-number">0</span>,TEXT(<span class="hljs-string">&quot;创建匿名管道失败!&quot;</span>),TEXT(<span class="hljs-string">&quot;Error&quot;</span>),MB_OK);<br>	&#125;<br><br>	STARTUPINFO si;<br>	PROCESS_INFORMATION pi;<br><br>	ZeroMemory(&amp;si,<span class="hljs-keyword">sizeof</span>(STARTUPINFO));<br><br>	si.cb = <span class="hljs-keyword">sizeof</span>(STARTUPINFO);<br>	si.dwFlags = STARTF_USESTDHANDLES;<br>	si.hStdInput = hChildRead;<br>	si.hStdOutput = hChildWrite;<br>	si.hStdError = GetStdHandle(STD_ERROR_HANDLE);<br><br>	LPTSTR szFileName = <span class="hljs-string">&quot;C:\\Users\\admin\\Documents\\visual studio 2012\\Projects\\anonymous_pipe_child\\Debug\\anonymous_pipe_child.exe&quot;</span>;<br>	<span class="hljs-keyword">if</span>(!CreateProcess(szFileName,<span class="hljs-string">&quot;child&quot;</span>,<span class="hljs-literal">NULL</span>,<span class="hljs-literal">NULL</span>,TRUE,CREATE_NEW_CONSOLE,<span class="hljs-literal">NULL</span>,<span class="hljs-literal">NULL</span>,&amp;si,&amp;pi))<br>	&#123;<br>		CloseHandle(hParentRead);<br>		CloseHandle(hParentWrite);<br>		hParentRead = <span class="hljs-literal">NULL</span>;<br>		hParentWrite = <span class="hljs-literal">NULL</span>;<br><br>		CloseHandle(hChildRead);<br>		CloseHandle(hChildWrite);<br>		hChildRead = <span class="hljs-literal">NULL</span>;<br>		hChildWrite = <span class="hljs-literal">NULL</span>;<br>		MessageBox(<span class="hljs-number">0</span>,TEXT(<span class="hljs-string">&quot;创建子进程失败!&quot;</span>),TEXT(<span class="hljs-string">&quot;Error&quot;</span>),MB_OK);<br>	&#125;<br>	<span class="hljs-keyword">else</span><br>	&#123;<br>		CloseHandle(pi.hProcess);<br>		CloseHandle(pi.hThread);<br>	&#125;<br><br><br><br>	<span class="hljs-comment">//写数据</span><br>	TCHAR szWriteBuffer[] = <span class="hljs-string">&quot;父进程：http:\\www.dtdebug.com&quot;</span>;<br>	DWORD dwWrite;<br>	<span class="hljs-keyword">if</span>(!WriteFile(hParentWrite,szWriteBuffer,<span class="hljs-built_in">strlen</span>(szWriteBuffer)+<span class="hljs-number">1</span>,&amp;dwWrite,<span class="hljs-literal">NULL</span>))<br>	&#123;<br>		MessageBox(<span class="hljs-number">0</span>,TEXT(<span class="hljs-string">&quot;父进程写数据失败!&quot;</span>),TEXT(<span class="hljs-string">&quot;Error&quot;</span>),MB_OK);<br>	&#125;<br><br>	Sleep(<span class="hljs-number">5000</span>);<br><br>	<span class="hljs-comment">//读数据</span><br>	TCHAR szReadBuffer[<span class="hljs-number">100</span>];<br>	DWORD dwRead;<br>	<span class="hljs-keyword">if</span>(!ReadFile(hParentRead,szReadBuffer,<span class="hljs-number">100</span>,&amp;dwRead,<span class="hljs-literal">NULL</span>))<br>	&#123;<br>		MessageBox(<span class="hljs-literal">NULL</span>,TEXT(<span class="hljs-string">&quot;父进程读取数据失败!&quot;</span>),TEXT(<span class="hljs-string">&quot;Error&quot;</span>),MB_OK);<br>	&#125;<br>	<span class="hljs-keyword">else</span><br>	&#123;<br>		MessageBox(<span class="hljs-literal">NULL</span>,szReadBuffer,TEXT(<span class="hljs-string">&quot;[父进程读取数据]&quot;</span>),MB_OK);<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br></code></pre></td></tr></table></figure>

<h3 id="子进程代码"><a href="#子进程代码" class="headerlink" title="子进程代码"></a>子进程代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// anonymous_pipe_child.cpp : 定义控制台应用程序的入口点。</span><br><span class="hljs-comment">//</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdafx.h&quot;</span></span><br><br><br><span class="hljs-type">int</span> _tmain(<span class="hljs-type">int</span> argc, _TCHAR* argv[])<br>&#123;<br>	Sleep(<span class="hljs-number">1000</span>);<br>	<span class="hljs-comment">//初始化</span><br>	HANDLE hRead = GetStdHandle(STD_INPUT_HANDLE);<br>	HANDLE hWrite = GetStdHandle(STD_OUTPUT_HANDLE);  <br><br>	<span class="hljs-comment">//读数据</span><br>	TCHAR szReadBuffer[<span class="hljs-number">100</span>];<br>	DWORD dwRead;<br>	<span class="hljs-keyword">if</span>(!ReadFile(hRead,szReadBuffer,<span class="hljs-number">100</span>,&amp;dwRead,<span class="hljs-literal">NULL</span>))<br>	&#123;<br>		MessageBox(<span class="hljs-literal">NULL</span>,TEXT(<span class="hljs-string">&quot;子进程读取数据失败!&quot;</span>),TEXT(<span class="hljs-string">&quot;Error&quot;</span>),MB_OK);<br>	&#125;<br>	<span class="hljs-keyword">else</span><br>	&#123;<br>		MessageBox(<span class="hljs-literal">NULL</span>,szReadBuffer,TEXT(<span class="hljs-string">&quot;[子进程读取数据]&quot;</span>),MB_OK);<br>	&#125;<br><br>	Sleep(<span class="hljs-number">3000</span>);<br><br>	<span class="hljs-comment">//写数据</span><br>	TCHAR szWriteBuffer[<span class="hljs-number">100</span>] = <span class="hljs-string">&quot;子进程：匿名管道&quot;</span>;<br>	DWORD dwWrite;<br>	<span class="hljs-keyword">if</span>(!WriteFile(hWrite,szWriteBuffer,<span class="hljs-built_in">strlen</span>(szWriteBuffer)+<span class="hljs-number">1</span>,&amp;dwWrite,<span class="hljs-literal">NULL</span>))<br>	&#123;<br>		MessageBox(<span class="hljs-literal">NULL</span>,TEXT(<span class="hljs-string">&quot;子进程写入数据失败!&quot;</span>),TEXT(<span class="hljs-string">&quot;Error&quot;</span>),MB_OK);<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br></code></pre></td></tr></table></figure>

<h3 id="运行结果-1"><a href="#运行结果-1" class="headerlink" title="运行结果"></a>运行结果</h3><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image-20220220110717042.png" srcset="https://picbedddd.oss-cn-beijing.aliyuncs.com/blog/loading.gif" lazyload alt="image-20220220110717042"></p>
<h2 id="DLL共享节"><a href="#DLL共享节" class="headerlink" title="DLL共享节"></a>DLL共享节</h2><p>DLL共享节技术可以让使用同一个DLL的多个进程共享一块内存（共享节）。</p>
<blockquote>
<p>我的理解是DLL共享节和共享内存技术有异曲同工之妙。它们的技术思想都是相同的，不同的是DLL共享节使用的是低2G的内存（DLL中），而共享内存使用的是高2G的内存。</p>
</blockquote>
<h3 id="控制侧代码"><a href="#控制侧代码" class="headerlink" title="控制侧代码"></a>控制侧代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdafx.h&quot;</span></span><br><br><span class="hljs-comment">// 远程线程注入</span><br>BOOL <span class="hljs-title function_">InjectDLL</span><span class="hljs-params">()</span><br>&#123;<br>	<span class="hljs-comment">// 提权(win10)</span><br>	EnableDebugPrivilege();<br>	<span class="hljs-comment">// 根据窗口名获取进程句柄</span><br>	HWND hWnd = FindWindow(<span class="hljs-literal">NULL</span>, <span class="hljs-string">&quot;扫雷&quot;</span>);<br>	<span class="hljs-keyword">if</span> (hWnd == <span class="hljs-literal">NULL</span>)<br>	&#123;<br>		OutputDebugString(<span class="hljs-string">&quot;获取窗口句柄失败\n&quot;</span>);<br>		<span class="hljs-keyword">return</span> FALSE;<br>	&#125;<br>	DWORD dwPid = <span class="hljs-number">-1</span>;<br>	GetWindowThreadProcessId(hWnd, &amp;dwPid);<br>	HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPid);<br>	<span class="hljs-keyword">if</span> (hProcess == INVALID_HANDLE_VALUE)<br>	&#123;<br>		OutputDebugString(<span class="hljs-string">&quot;打开进程失败\n&quot;</span>);<br>		<span class="hljs-keyword">return</span> FALSE;<br>	&#125;<br>	<span class="hljs-comment">// 在要注入的进程中申请一块内存，作为LoadLibrary的参数</span><br>	<span class="hljs-type">char</span> szDllName[MAX_PATH] = <span class="hljs-string">&quot;DLLShareSection-DLL.dll&quot;</span>;<br>	LPVOID pAddress = VirtualAllocEx(hProcess, <span class="hljs-literal">NULL</span>, MAX_PATH, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);<br>	WriteProcessMemory(hProcess, pAddress, szDllName, <span class="hljs-built_in">strlen</span>(szDllName), <span class="hljs-literal">NULL</span>);<br>	<span class="hljs-comment">// 创建远程线程，线程入口设置为LoadLibrary，这样就可以自动加载dll</span><br>	HANDLE hThread = CreateRemoteThread(hProcess, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, (LPTHREAD_START_ROUTINE)LoadLibrary, pAddress, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);	<br>	<span class="hljs-comment">//VirtualFreeEx(hProcess, pAddress, 0, MEM_RELEASE);</span><br>	CloseHandle(hProcess);<br>	<span class="hljs-keyword">return</span> TRUE;<br>&#125;<br><br><span class="hljs-comment">// 提权函数：提升为DEBUG权限</span><br>BOOL <span class="hljs-title function_">EnableDebugPrivilege</span><span class="hljs-params">()</span><br>&#123;<br>	HANDLE hToken;<br>	BOOL fOk = FALSE;<br>	<span class="hljs-keyword">if</span> (OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES, &amp;hToken))<br>	&#123;<br>		TOKEN_PRIVILEGES tp;<br>		tp.PrivilegeCount = <span class="hljs-number">1</span>;<br>		LookupPrivilegeValue(<span class="hljs-literal">NULL</span>, SE_DEBUG_NAME, &amp;tp.Privileges[<span class="hljs-number">0</span>].Luid);<br><br>		tp.Privileges[<span class="hljs-number">0</span>].Attributes = SE_PRIVILEGE_ENABLED;<br>		AdjustTokenPrivileges(hToken, FALSE, &amp;tp, <span class="hljs-keyword">sizeof</span>(tp), <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);<br><br>		fOk = (GetLastError() == ERROR_SUCCESS);<br>		CloseHandle(hToken);<br>	&#125;<br>	<span class="hljs-keyword">return</span> fOk;<br>&#125;<br><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>	<span class="hljs-keyword">if</span> (FALSE == InjectDLL())<br>	&#123;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;注入DLL失败\n&quot;</span>);<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>	&#125;<br>	<span class="hljs-keyword">else</span><br>	&#123;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;注入DLL成功\n&quot;</span>);<br>	&#125;<br><br>	HMODULE hModule = LoadLibrary(<span class="hljs-string">&quot;DLLShareSection-DLL.dll&quot;</span>);<br>	<span class="hljs-keyword">if</span> (hModule == <span class="hljs-literal">NULL</span>)<br>	&#123;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;获取DLL句柄失败\n&quot;</span>);<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>	&#125;<br>	<span class="hljs-keyword">typedef</span> <span class="hljs-title function_">void</span> <span class="hljs-params">(*PFNSETDATA)</span><span class="hljs-params">(<span class="hljs-type">char</span> *, DWORD)</span>;<br>	<span class="hljs-keyword">typedef</span> <span class="hljs-title function_">void</span> <span class="hljs-params">(*PFNGETDATA)</span><span class="hljs-params">(<span class="hljs-type">char</span> *)</span>;<br>	PFNSETDATA pFnSetData = (PFNSETDATA)GetProcAddress(hModule, <span class="hljs-string">&quot;SetData&quot;</span>);<br>	PFNGETDATA pFnGetData = (PFNGETDATA)GetProcAddress(hModule, <span class="hljs-string">&quot;GetData&quot;</span>);<br>	<span class="hljs-type">char</span> szBuffer[<span class="hljs-number">0x1000</span>];	<br>	<span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>	&#123;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;输入要发送的数据: &quot;</span>);<br>		ZeroMemory(szBuffer, <span class="hljs-number">0x1000</span>);<br>		<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, szBuffer);<br>		pFnSetData(szBuffer, <span class="hljs-built_in">strlen</span>(szBuffer));<br>		<span class="hljs-comment">//pFnGetData(szBuffer);</span><br>		<span class="hljs-comment">//printf(&quot;修改数据成功，当前数据: %s\n&quot;, szBuffer);</span><br>		<span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(szBuffer, <span class="hljs-string">&quot;quit&quot;</span>) == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>	&#125;<br><br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br></code></pre></td></tr></table></figure>



<h3 id="DLL侧代码"><a href="#DLL侧代码" class="headerlink" title="DLL侧代码"></a>DLL侧代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// dllmain.cpp : 定义 DLL 应用程序的入口点。</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdafx.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> data_seg(<span class="hljs-string">&quot;Shared&quot;</span>)</span><br><br><span class="hljs-type">char</span> g_buffer[<span class="hljs-number">0x1000</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> data_seg()</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(linker,<span class="hljs-string">&quot;/section:Shared,rws&quot;</span>)</span><br><br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span>  __declspec(dllexport) <span class="hljs-type">void</span> <span class="hljs-title function_">SetData</span><span class="hljs-params">(<span class="hljs-type">char</span> *buf, DWORD dwDataLen)</span><br>&#123;<br>	ZeroMemory(g_buffer, <span class="hljs-number">0x1000</span>);<br>	<span class="hljs-built_in">memcpy</span>(g_buffer, buf, dwDataLen);<br>&#125;<br><br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span>  __declspec(dllexport) <span class="hljs-type">void</span> <span class="hljs-title function_">GetData</span><span class="hljs-params">(<span class="hljs-type">char</span> *buf)</span><br>&#123;    <br>	<span class="hljs-built_in">memcpy</span>(buf, g_buffer, <span class="hljs-number">0x1000</span>);<br>&#125;<br><br>BOOL APIENTRY <span class="hljs-title function_">DllMain</span><span class="hljs-params">( HMODULE hModule,</span><br><span class="hljs-params">					  DWORD  ul_reason_for_call,</span><br><span class="hljs-params">					  LPVOID lpReserved</span><br><span class="hljs-params">					  )</span><br>&#123;<br>	<span class="hljs-keyword">switch</span> (ul_reason_for_call)<br>	&#123;<br>	<span class="hljs-keyword">case</span> DLL_PROCESS_ATTACH:<br>		&#123;<br>			<span class="hljs-comment">// 区分是目标进程（游戏）还是控制进程（WG）</span><br>			<span class="hljs-comment">// 如果是扫雷进程(winmine.exe)则开始接收数据</span><br>			<span class="hljs-type">char</span> szModule[MAX_PATH] = &#123; <span class="hljs-number">0</span> &#125;;<br>			GetModuleFileNameA(<span class="hljs-literal">NULL</span>, szModule, MAX_PATH);<br>			<span class="hljs-keyword">if</span> (<span class="hljs-built_in">strstr</span>(szModule, <span class="hljs-string">&quot;winmine&quot;</span>) != <span class="hljs-literal">NULL</span>)<br>			&#123;            <br>				MessageBoxA(<span class="hljs-literal">NULL</span>, <span class="hljs-string">&quot;扫雷程序注入DLL成功&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, MB_OK);<br>				<span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>				&#123;<br>					<span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(g_buffer, <span class="hljs-string">&quot;quit&quot;</span>) == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 控制程序给的退出信号</span><br>					MessageBoxA(<span class="hljs-literal">NULL</span>, g_buffer, szModule, MB_OK);<br>				&#125;<br>			&#125;<br>			<span class="hljs-keyword">break</span>;<br>		&#125;<br>	<span class="hljs-keyword">case</span> DLL_THREAD_ATTACH:<br>	<span class="hljs-keyword">case</span> DLL_THREAD_DETACH:<br>	<span class="hljs-keyword">case</span> DLL_PROCESS_DETACH:<br>		<span class="hljs-keyword">break</span>;<br>	&#125;<br>	<span class="hljs-keyword">return</span> TRUE;<br>&#125;<br><br></code></pre></td></tr></table></figure>





<p>使用前需要将扫雷、DLL、控制端EXE放在同一个目录下。</p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>这是滴水三期初级班的过程，这篇文章前后参考了课件、网上的各种帖子和Github上gh0stkey师傅的<a target="_blank" rel="noopener" href="https://github.com/gh0stkey/Binary-Learning">项目</a>，万分感谢。</p>
<p>挂一漏万，发现自己的内容被搬运的师傅请联系我补上。</p>

              
            </div>
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/Binary/" class="category-chain-item">Binary</a>
  
  
    <span>></span>
    
  <a href="/categories/Binary/%E6%BB%B4%E6%B0%B4%E5%AD%A6%E4%B9%A0/" class="category-chain-item">滴水学习</a>
  
  
    <span>></span>
    
  <a href="/categories/Binary/%E6%BB%B4%E6%B0%B4%E5%AD%A6%E4%B9%A0/%E7%AC%94%E8%AE%B0/" class="category-chain-item">笔记</a>
  
  

  

  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/Binary/">#Binary</a>
      
        <a href="/tags/Win32/">#Win32</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>滴水初级-Win32笔记</div>
      <div>https://m0ck1ng-b1rd.github.io/2022/02/20/二进制/Win32/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>何语灵</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2022年2月20日</div>
        </div>
      
      
      <div class="license-meta-item">
        <div>许可协议</div>
        <div>
          
            
            
              <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
              <span class="hint--top hint--rounded" aria-label="BY - 署名">
                <i class="iconfont icon-by"></i>
              </span>
              </a>
            
          
        </div>
      </div>
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/02/20/%E4%BA%8C%E8%BF%9B%E5%88%B6/PE%20Tool%20%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0%203%20-%20Directory%E8%A7%A3%E6%9E%90/" title="PETOOL开发日记3 - Directory解析">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">PETOOL开发日记3 - Directory解析</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/02/01/%E5%86%85%E7%BD%91%E6%8F%90%E6%9D%83-Linux/" title="Linux提权一文通">
                        <span class="hidden-mobile">Linux提权一文通</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  <article id="comments" lazyload>
    
  <script type="text/javascript">
    Fluid.utils.loadComments('#comments', function() {
      var light = 'github-light';
      var dark = 'github-dark';
      var schema = document.documentElement.getAttribute('data-user-color-scheme');
      if (schema === 'dark') {
        schema = dark;
      } else {
        schema = light;
      }
      window.UtterancesThemeLight = light;
      window.UtterancesThemeDark = dark;
      var s = document.createElement('script');
      s.setAttribute('src', 'https://utteranc.es/client.js');
      s.setAttribute('repo', 'M0cK1nG-b1Rd/blog-comments');
      s.setAttribute('issue-term', 'title');
      
      s.setAttribute('label', 'utterances');
      
      s.setAttribute('theme', schema);
      s.setAttribute('crossorigin', 'anonymous');
      document.getElementById('comments').appendChild(s);
    })
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


  </article>


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  






    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://M0cK1nG-b1Rd.github.io" target="_blank" rel="nofollow noopener"><span>M0cK1nG-b1Rd</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Powered by Hexo&Fluid</span></a> <div>Per aspera ad astra</div> <div> <span id="timeDate">载入天数...</span> <span id="times">载入时分秒...</span> <script src="/js/duration.js"></script> </div> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="leancloud-site-pv-container" style="display: none">
        总访问量 
        <span id="leancloud-site-pv"></span>
         次
      </span>
    
    
      <span id="leancloud-site-uv-container" style="display: none">
        总访客数 
        <span id="leancloud-site-uv"></span>
         人
      </span>
    
    

  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  

  

  

  

  

  

  
    
  




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.0/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script>
  (function() {
    var enableLang = CONFIG.code_language.enable && CONFIG.code_language.default;
    var enableCopy = CONFIG.copy_btn;
    if (!enableLang && !enableCopy) {
      return;
    }

    function getBgClass(ele) {
      return Fluid.utils.getBackgroundLightness(ele) >= 0 ? 'code-widget-light' : 'code-widget-dark';
    }

    var copyTmpl = '';
    copyTmpl += '<div class="code-widget">';
    copyTmpl += 'LANG';
    copyTmpl += '</div>';
    jQuery('.markdown-body pre').each(function() {
      var $pre = jQuery(this);
      if ($pre.find('code.mermaid').length > 0) {
        return;
      }
      if ($pre.find('span.line').length > 0) {
        return;
      }

      var lang = '';

      if (enableLang) {
        lang = CONFIG.code_language.default;
        if ($pre[0].children.length > 0 && $pre[0].children[0].classList.length >= 2 && $pre.children().hasClass('hljs')) {
          lang = $pre[0].children[0].classList[1];
        } else if ($pre[0].getAttribute('data-language')) {
          lang = $pre[0].getAttribute('data-language');
        } else if ($pre.parent().hasClass('sourceCode') && $pre[0].children.length > 0 && $pre[0].children[0].classList.length >= 2) {
          lang = $pre[0].children[0].classList[1];
          $pre.parent().addClass('code-wrapper');
        } else if ($pre.parent().hasClass('markdown-body') && $pre[0].classList.length === 0) {
          $pre.wrap('<div class="code-wrapper"></div>');
        }
        lang = lang.toUpperCase().replace('NONE', CONFIG.code_language.default);
      }
      $pre.append(copyTmpl.replace('LANG', lang).replace('code-widget">',
        getBgClass($pre[0]) + (enableCopy ? ' code-widget copy-btn" data-clipboard-snippet><i class="iconfont icon-copy"></i>' : ' code-widget">')));

      if (enableCopy) {
        Fluid.utils.createScript('https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js', function() {
          var clipboard = new window.ClipboardJS('.copy-btn', {
            target: function(trigger) {
              var nodes = trigger.parentNode.childNodes;
              for (var i = 0; i < nodes.length; i++) {
                if (nodes[i].tagName === 'CODE') {
                  return nodes[i];
                }
              }
            }
          });
          clipboard.on('success', function(e) {
            e.clearSelection();
            e.trigger.innerHTML = e.trigger.innerHTML.replace('icon-copy', 'icon-success');
            setTimeout(function() {
              e.trigger.innerHTML = e.trigger.innerHTML.replace('icon-success', 'icon-copy');
            }, 2000);
          });
        });
      }
    });
  })();
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="/js/leancloud.js" ></script>




  
<script src="//picbedddd.oss-cn-beijing.aliyuncs.com/blog/scripts/DynamicRibbon.min.js"></script>
<script src="//picbedddd.oss-cn-beijing.aliyuncs.com/blog/scripts/star.min.js"></script>



<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"left","width":250,"height":500,"hOffset":-30,"vOffset":-150},"mobile":{"show":true,"scale":0.5},"log":false});</script></body>
</html>
